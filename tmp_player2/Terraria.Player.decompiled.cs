using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Security.Cryptography;
using System.Text;
using Microsoft.Xna.Framework;
using ReLogic.Utilities;
using Terraria.Audio;
using Terraria.Chat;
using Terraria.DataStructures;
using Terraria.Enums;
using Terraria.GameContent;
using Terraria.GameContent.Achievements;
using Terraria.GameContent.Creative;
using Terraria.GameContent.Drawing;
using Terraria.GameContent.Events;
using Terraria.GameContent.Golf;
using Terraria.GameContent.ItemDropRules;
using Terraria.GameContent.Items;
using Terraria.GameContent.ObjectInteractions;
using Terraria.GameContent.Tile_Entities;
using Terraria.GameContent.UI;
using Terraria.GameInput;
using Terraria.Graphics;
using Terraria.Graphics.Capture;
using Terraria.Graphics.Effects;
using Terraria.Graphics.Shaders;
using Terraria.ID;
using Terraria.IO;
using Terraria.Localization;
using Terraria.ModLoader;
using Terraria.ModLoader.Default;
using Terraria.ModLoader.Exceptions;
using Terraria.ModLoader.IO;
using Terraria.ModLoader.UI;
using Terraria.ObjectData;
using Terraria.Social;
using Terraria.Social.Steam;
using Terraria.UI;
using Terraria.UI.Chat;
using Terraria.UI.Gamepad;
using Terraria.Utilities;
using Terraria.WorldBuilding;

namespace Terraria;

public class Player : Entity, IFixLoadedData, IEntityWithInstances<ModPlayer>
{
	public static class BuilderAccToggleIDs
	{
		public const int RulerLine = 0;

		public const int RulerGrid = 1;

		public const int AutoActuate = 2;

		public const int AutoPaint = 3;

		public const int WireVisibility_Red = 4;

		public const int WireVisibility_Green = 5;

		public const int WireVisibility_Blue = 6;

		public const int WireVisibility_Yellow = 7;

		public const int HideAllWires = 8;

		public const int WireVisibility_Actuators = 9;

		public const int BlockSwap = 10;

		public const int TorchBiome = 11;

		public static readonly int Count = 12;
	}

	public struct DirectionalInputSyncCache
	{
		public bool controlLeft;

		public bool controlRight;

		public bool controlUp;

		public bool controlDown;

		public DirectionalInputSyncCache(Player player)
		{
			controlLeft = player.controlLeft;
			controlRight = player.controlRight;
			controlUp = player.controlUp;
			controlDown = player.controlDown;
		}

		public void ApplyTo(Player player)
		{
			player.controlLeft = controlLeft;
			player.controlRight = controlRight;
			player.controlUp = controlUp;
			player.controlDown = controlDown;
		}
	}

	private struct ChannelCancelKey
	{
		public int ProjectileTypeExpected;

		public int ProjectileIndexExpected;

		public bool Matches(Projectile projectile)
		{
			if (ProjectileTypeExpected == projectile.type)
			{
				return ProjectileIndexExpected == projectile.whoAmI;
			}
			return false;
		}

		public void TryTracking(Projectile projectile)
		{
			if (ProjectileTypeExpected == projectile.type)
			{
				ProjectileIndexExpected = projectile.whoAmI;
			}
		}
	}

	public struct RabbitOrderFrameHelper
	{
		public int DisplayFrame;

		private int _frameCounter;

		private int _aiState;

		private const int AIState_Idle = 0;

		private const int AIState_LookingAtCamera = 1;

		private const int AIState_Resting = 2;

		private const int AIState_EatingCarrot = 3;

		public void Update()
		{
			switch (_aiState)
			{
			case 0:
				UpdateFrame(0, 0, Main.rand.Next(1, 4), Main.rand.Next(180, 3600));
				break;
			case 1:
				UpdateFrame(7, 9, 0, 20);
				break;
			case 2:
			{
				int gameFramesPerDisplayFrame = 8;
				if (DisplayFrame == 13)
				{
					gameFramesPerDisplayFrame = 120;
				}
				UpdateFrame(10, 16, 0, gameFramesPerDisplayFrame);
				break;
			}
			case 3:
				UpdateFrame(17, 26, 0, 4);
				break;
			}
		}

		public void Reset()
		{
			ChangeToAIState(0);
		}

		private void ChangeToAIState(int aiState)
		{
			_aiState = aiState;
			_frameCounter = 0;
			Update();
		}

		private void UpdateFrame(int displayFrameMin, int displayFrameMax, int exitAIState, int gameFramesPerDisplayFrame)
		{
			DisplayFrame = Utils.Clamp(DisplayFrame, displayFrameMin, displayFrameMax);
			if (_frameCounter++ >= gameFramesPerDisplayFrame)
			{
				_frameCounter = 0;
				if (DisplayFrame++ >= displayFrameMax)
				{
					ChangeToAIState(exitAIState);
				}
			}
		}
	}

	public enum CompositeArmStretchAmount
	{
		Full,
		None,
		Quarter,
		ThreeQuarters
	}

	public struct CompositeArmData
	{
		public bool enabled;

		public CompositeArmStretchAmount stretch;

		public float rotation;

		public CompositeArmData(bool enabled, CompositeArmStretchAmount intendedStrech, float rotation)
		{
			this.enabled = enabled;
			stretch = intendedStrech;
			this.rotation = rotation;
		}
	}

	public delegate void DashStartAction(int dashDirection);

	public struct SetMatchRequest
	{
		public int Head;

		public int Body;

		public int Legs;

		public int ArmorSlotRequested;

		public bool Male;
	}

	public struct ItemSpaceStatus
	{
		public readonly bool CanTakeItem;

		public readonly bool ItemIsGoingToVoidVault;

		public bool CanTakeItemToPersonalInventory
		{
			get
			{
				if (CanTakeItem)
				{
					return !ItemIsGoingToVoidVault;
				}
				return false;
			}
		}

		public ItemSpaceStatus(bool CanTakeItem, bool ItemIsGoingToVoidVault = false)
		{
			this.CanTakeItem = CanTakeItem;
			this.ItemIsGoingToVoidVault = ItemIsGoingToVoidVault;
		}
	}

	public struct ItemCheckContext
	{
		public bool SkipItemConsumption;
	}

	private struct SpecialToolUsageSettings
	{
		public delegate bool CanUseToolCondition(Player user, Item item, int targetX, int targetY);

		public delegate void UseToolAction(Player user, Item item, int targetX, int targetY);

		public bool IsAValidTool;

		public CanUseToolCondition UsageCondition;

		public UseToolAction UsageAction;
	}

	public class SavedPlayerDataWithAnnoyingRules
	{
		public bool godmodePowerEnabled;

		public bool farPlacementRangePowerEnabled;

		public float spawnRatePowerSliderValue;
	}

	public class RandomTeleportationAttemptSettings
	{
		public bool mostlySolidFloor;

		public bool avoidLava;

		public bool avoidAnyLiquid;

		public bool avoidHurtTiles;

		public bool avoidWalls;

		public int attemptsBeforeGivingUp;

		public int maximumFallDistanceFromOrignalPoint;
	}

	public static class Hooks
	{
		public static event Action<Player> OnEnterWorld;

		public static void PlayerConnect(int playerIndex)
		{
			PressurePlateHelper.ResetPlayer(playerIndex);
			PlayerLoader.PlayerConnect(playerIndex);
		}

		public static void PlayerDisconnect(int playerIndex)
		{
			PressurePlateHelper.ResetPlayer(playerIndex);
			PlayerLoader.PlayerDisconnect(playerIndex);
		}

		public static void EnterWorld(int playerIndex)
		{
			Logging.Terraria.InfoFormat("Entering world with player: {0}, IsCloud={1}, Width: {2}, Height: {3}, Evil: {4}, GameMode: {5}", new object[6]
			{
				Main.ActivePlayerFileData.Name,
				Main.ActivePlayerFileData.IsCloudSave,
				Main.maxTilesX,
				Main.maxTilesY,
				WorldGen.crimson.ToInt(),
				Main.GameMode
			});
			Interface.ResetData();
			if (Hooks.OnEnterWorld != null)
			{
				Hooks.OnEnterWorld(Main.player[playerIndex]);
			}
			PlayerLoader.OnEnterWorld(playerIndex);
			if (playerIndex == Main.myPlayer)
			{
				Main.ToggleGameplayUpdates(state: true);
				SteamedWraps.BeginPlaytimeTracking();
			}
		}
	}

	public class SmartCursorSettings
	{
		public static bool SmartBlocksEnabled;

		public static bool SmartAxeAfterPickaxe;

		public static bool SmartCursorHoldCanReleaseMidUse;
	}

	public class Settings
	{
		public enum HoverControlMode
		{
			Hold,
			Click
		}

		public static HoverControlMode HoverControl;

		public static void CycleHoverControl()
		{
			switch (HoverControl)
			{
			case HoverControlMode.Hold:
				HoverControl = HoverControlMode.Click;
				break;
			case HoverControlMode.Click:
				HoverControl = HoverControlMode.Hold;
				break;
			}
		}
	}

	public class SelectionRadial
	{
		public enum SelectionMode
		{
			Dpad4,
			RadialCircular,
			RadialQuicks
		}

		private int _SelectedBinding = -1;

		public int RadialCount;

		public int[] Bindings;

		public SelectionMode Mode;

		public int SelectedBinding => _SelectedBinding;

		public int SelectedItem
		{
			get
			{
				if (_SelectedBinding == -1)
				{
					return -1;
				}
				return Bindings[_SelectedBinding];
			}
		}

		public SelectionRadial(SelectionMode mode = SelectionMode.Dpad4)
		{
			Mode = mode;
			int radialCount = 0;
			switch (mode)
			{
			case SelectionMode.Dpad4:
				radialCount = 4;
				break;
			case SelectionMode.RadialCircular:
				radialCount = 10;
				break;
			case SelectionMode.RadialQuicks:
				radialCount = 4;
				break;
			}
			RadialCount = radialCount;
			Bindings = new int[RadialCount];
			for (int i = 0; i < RadialCount; i++)
			{
				Bindings[i] = -1;
			}
		}

		public void Update()
		{
			//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
			//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
			//IL_0102: Unknown result type (might be due to invalid IL or missing references)
			//IL_0104: Unknown result type (might be due to invalid IL or missing references)
			//IL_0109: Unknown result type (might be due to invalid IL or missing references)
			//IL_0118: Unknown result type (might be due to invalid IL or missing references)
			//IL_0127: Unknown result type (might be due to invalid IL or missing references)
			//IL_012d: Unknown result type (might be due to invalid IL or missing references)
			//IL_012f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0134: Unknown result type (might be due to invalid IL or missing references)
			//IL_0146: Unknown result type (might be due to invalid IL or missing references)
			//IL_018f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0190: Unknown result type (might be due to invalid IL or missing references)
			switch (Mode)
			{
			case SelectionMode.Dpad4:
				if (PlayerInput.Triggers.JustPressed.DpadRadial1)
				{
					ChangeSelection(0);
				}
				if (PlayerInput.Triggers.JustPressed.DpadRadial2)
				{
					ChangeSelection(1);
				}
				if (PlayerInput.Triggers.JustPressed.DpadRadial3)
				{
					ChangeSelection(2);
				}
				if (PlayerInput.Triggers.JustPressed.DpadRadial4)
				{
					ChangeSelection(3);
				}
				break;
			case SelectionMode.RadialCircular:
			case SelectionMode.RadialQuicks:
			{
				for (int i = 0; i < RadialCount; i++)
				{
					Bindings[i] = i;
				}
				if ((Mode != SelectionMode.RadialCircular || !PlayerInput.Triggers.Current.RadialHotbar) && (Mode != SelectionMode.RadialQuicks || !PlayerInput.Triggers.Current.RadialQuickbar))
				{
					break;
				}
				bool flag = Mode == SelectionMode.RadialCircular;
				float num = (float)Math.PI * 2f / (float)RadialCount / 2f;
				Vector2 val = PlayerInput.GamepadThumbstickRight.RotatedBy(-(float)Math.PI / 2f + num);
				if (((Vector2)(ref val)).Length() == 0f)
				{
					val = PlayerInput.GamepadThumbstickLeft.RotatedBy(-(float)Math.PI / 2f + num);
				}
				int num2 = -1;
				if (((Vector2)(ref val)).Length() > 0.3f)
				{
					num2 = (int)((val.ToRotation() + (float)Math.PI) / ((float)Math.PI * 2f / (float)RadialCount));
					if (num2 >= RadialCount)
					{
						num2 -= RadialCount;
					}
				}
				if ((num2 != -1 || !flag) && _SelectedBinding != num2 && (num2 != -1 || !(val != Vector2.Zero)))
				{
					ChangeSelection(num2);
				}
				break;
			}
			}
		}

		public void ChangeBinding(int itemSlot)
		{
			if (itemSlot >= 0 && itemSlot < 50 && Mode == SelectionMode.Dpad4)
			{
				if (PlayerInput.Triggers.JustPressed.DpadRadial1)
				{
					Bind(itemSlot, 0);
				}
				if (PlayerInput.Triggers.JustPressed.DpadRadial2)
				{
					Bind(itemSlot, 1);
				}
				if (PlayerInput.Triggers.JustPressed.DpadRadial3)
				{
					Bind(itemSlot, 2);
				}
				if (PlayerInput.Triggers.JustPressed.DpadRadial4)
				{
					Bind(itemSlot, 3);
				}
			}
		}

		public void ChangeSelection(int to)
		{
			if (_SelectedBinding == to)
			{
				_SelectedBinding = -1;
			}
			else
			{
				_SelectedBinding = to;
			}
		}

		private void Bind(int itemslot, int radialslot)
		{
			ChangeSelection(-1);
			if (Bindings[radialslot] == itemslot)
			{
				Bindings[radialslot] = -1;
				return;
			}
			for (int i = 0; i < RadialCount; i++)
			{
				if (Bindings[i] == itemslot)
				{
					Bindings[i] = -1;
				}
			}
			Bindings[radialslot] = itemslot;
		}

		public int GetDrawMode(int itemslot)
		{
			if (SelectedBinding != -1 && Bindings[SelectedBinding] == itemslot)
			{
				return 2;
			}
			for (int i = 0; i < RadialCount; i++)
			{
				if (Bindings[i] == itemslot)
				{
					return 1;
				}
			}
			return 0;
		}

		public void CopyTo(SelectionRadial that)
		{
			that._SelectedBinding = _SelectedBinding;
			that.Mode = Mode;
			that.RadialCount = RadialCount;
			Array.Resize(ref that.Bindings, RadialCount);
			for (int i = 0; i < RadialCount; i++)
			{
				that.Bindings[i] = Bindings[i];
			}
		}
	}

	public struct OverheadMessage
	{
		public string chatText;

		public TextSnippet[] snippets;

		public Vector2 messageSize;

		public int timeLeft;

		public Color color;

		public void NewMessage(string message, int displayTime)
		{
			//IL_000e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0033: Unknown result type (might be due to invalid IL or missing references)
			//IL_003d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0042: Unknown result type (might be due to invalid IL or missing references)
			chatText = message;
			snippets = ChatManager.ParseMessage(chatText, Color.White).ToArray();
			messageSize = ChatManager.GetStringSize(FontAssets.MouseText.Value, snippets, Vector2.One);
			timeLeft = displayTime;
		}
	}

	/// <summary>
	/// Represents a damage calculation in the process of being calculated for damage to be applied to a Player. The final damage calculation will be present in the resulting <see cref="T:Terraria.Player.HurtInfo" /> provided to various hooks.
	/// </summary>
	public struct HurtModifiers
	{
		public delegate void HurtInfoModifier(ref HurtInfo info);

		/// <summary>
		/// Use this to enhance or scale the base damage of the NPC/projectile/hit. <br />
		/// <br />
		/// Not used by vanilla due to lack of proper pvp support. <br />
		/// Use cases are similar to <see cref="F:Terraria.NPC.HitModifiers.SourceDamage" /> <br />
		/// </summary>
		public StatModifier SourceDamage;

		/// <summary>
		/// Use this to reduce damage from certain sources before applying defense. <br />
		/// Used by vanilla for coldResist and banner damage reduction.
		/// </summary>
		public MultipliableFloat IncomingDamageMultiplier;

		/// <summary>
		/// Applied to the final damage result. <br />
		/// Used by <see cref="F:Terraria.Player.endurance" /> to reduce overall incoming damage. <br />
		/// <br />
		/// Multiply to grant damage reduction buffs (eg *0.9f for -10% damage taken). <br />
		/// Add to <see cref="F:Terraria.ModLoader.StatModifier.Base" /> to deal damage which ignores armor, but still respects scaling damage reduction like endurance or paladins shield. <br />
		/// Adding to <see cref="F:Terraria.ModLoader.StatModifier.Flat" /> will ignore all reductions or increases to deal unconditional damage. Not recommended due to potential compatibility issues with accessories like paladin's shield, use <see cref="F:Terraria.ModLoader.StatModifier.Base" /> instead.
		/// </summary>
		public StatModifier FinalDamage;

		/// <summary>
		/// Flat defense reduction. Applies after <see cref="F:Terraria.Player.HurtModifiers.ScalingArmorPenetration" />. <br />
		/// <br />
		/// Consider supplying armorPenetration as an argument to <see cref="M:Terraria.Player.Hurt(Terraria.DataStructures.PlayerDeathReason,System.Int32,System.Int32,System.Boolean,System.Boolean,System.Int32,System.Boolean,System.Single,System.Single,System.Single)" /> instead if possible.<br />
		/// </summary>
		public AddableFloat ArmorPenetration;

		/// <summary>
		/// Used to ignore a fraction of player defense. Applies before flat <see cref="F:Terraria.Player.HurtModifiers.ArmorPenetration" />. <br />
		/// <br />
		/// At 1f, the attack will completely ignore all defense.
		/// </summary>
		public AddableFloat ScalingArmorPenetration;

		private int _damageLimit;

		/// <summary>
		/// Modifiers to apply to the knockback.
		/// Add to <see cref="F:Terraria.ModLoader.StatModifier.Base" /> to increase the knockback of the strike.
		/// Multiply to decrease or increase overall knockback susceptibility.
		/// </summary>
		public StatModifier Knockback;

		/// <summary>
		/// Use this to reduce the effectiveness of <see cref="F:Terraria.Player.noKnockback" /> (cobalt shield accessory). <br />
		/// Eg, *0.8f to reduce knockback to 20% when cobalt shield is equipped. <br />
		/// Defaults to 1f (knockback immunity is 100% effective by default). <br />
		/// Used by vanilla for the ogre's launching attack. <br />
		/// </summary>
		public MultipliableFloat KnockbackImmunityEffectiveness;

		private bool _cancelled;

		private bool _dustDisabled;

		private bool _soundDisabled;

		/// <summary>
		/// The source of the strike. <br />
		/// Use <see cref="M:Terraria.DataStructures.PlayerDeathReason.TryGetCausingEntity(Terraria.Entity@)" /> to get the source of the strike (only safe to do when the target is the local player).
		/// </summary>
		public PlayerDeathReason DamageSource { get; init; }

		/// <summary>
		/// Whether or not this strike came from another player. <br />
		/// Note that PvP support in Terraria is rudimentary and inconsistent, so careful research and testing may be required.
		/// </summary>
		public bool PvP { get; init; }

		/// <summary>
		/// The <see cref="T:Terraria.ID.ImmunityCooldownID" /> of the strike
		/// </summary>
		public int CooldownCounter { get; init; }

		/// <summary>
		/// Whether or not this strike was dodgeable.
		/// </summary>
		public bool Dodgeable { get; init; }

		/// <summary>
		/// The direction to apply knockback. If 0, no knockback will be applied. <br />
		/// Could potentially be used for directional resistances. <br />
		/// Can be overridden by <see cref="P:Terraria.Player.HurtModifiers.HitDirectionOverride" />
		/// </summary>
		public int HitDirection { get; init; }

		/// <summary>
		/// Overrides the direction to apply knockback. <br />
		/// Will not affect <see cref="P:Terraria.Player.HurtModifiers.HitDirection" />, only the final <see cref="F:Terraria.Player.HurtInfo.HitDirection" /><br />
		/// If set by multiple mods, only the last override will apply. <br />
		/// Intended for use by attacks which want to hit the player towards the source of the attack.
		/// </summary>
		public int? HitDirectionOverride { private get; set; }

		/// <summary>
		/// Use with caution and consider other alternatives first.<br />
		/// Can be used to register a callback to freely modify the <see cref="T:Terraria.Player.HurtInfo" /> produced by <see cref="M:Terraria.Player.HurtModifiers.ToHurtInfo(System.Int32,System.Int32,System.Single,System.Single,System.Boolean)" /> before it is returned<br />
		/// If multiple mods register different callbacks which modify the hurt info in different ways the results could be a mess!
		/// </summary>
		public event HurtInfoModifier ModifyHurtInfo;

		/// <summary>
		/// Sets an inclusive upper bound on the final damage of the hit. <br />
		/// Can be set by multiple mods, in which case the lowest limit will be used. <br />
		/// Cannot be set to less than 1
		/// </summary>
		public void SetMaxDamage(int limit)
		{
			_damageLimit = Math.Min(_damageLimit, Math.Max(limit, 1));
		}

		/// <summary>
		/// Cancels the Hurt. Further hooks like <see cref="M:Terraria.ModLoader.ModPlayer.FreeDodge(Terraria.Player.HurtInfo)" /> and <see cref="M:Terraria.ModLoader.ModPlayer.OnHurt(Terraria.Player.HurtInfo)" /> will not be called. <br />
		/// Does not automatically apply immune frames, so the player can get hit again next frame. 
		/// </summary>
		public void Cancel()
		{
			_cancelled = true;
		}

		/// <summary>
		/// Prevents dust from spawning
		/// </summary>
		public void DisableDust()
		{
			_dustDisabled = true;
		}

		/// <summary>
		/// Prevents the hurt sound from playing
		/// </summary>
		public void DisableSound()
		{
			_soundDisabled = true;
		}

		public HurtModifiers()
		{
			DamageSource = null;
			PvP = false;
			CooldownCounter = -1;
			Dodgeable = true;
			HitDirection = 0;
			SourceDamage = new StatModifier();
			IncomingDamageMultiplier = new MultipliableFloat();
			FinalDamage = new StatModifier();
			ArmorPenetration = default(AddableFloat);
			ScalingArmorPenetration = default(AddableFloat);
			_damageLimit = int.MaxValue;
			Knockback = new StatModifier();
			HitDirectionOverride = null;
			KnockbackImmunityEffectiveness = new MultipliableFloat();
			_cancelled = false;
			_dustDisabled = false;
			_soundDisabled = false;
			this.ModifyHurtInfo = null;
		}

		public float GetDamage(float baseDamage, float defense, float defenseEffectiveness)
		{
			float num = SourceDamage.ApplyTo(baseDamage) * IncomingDamageMultiplier.Value;
			float num2 = defense * Math.Clamp(ScalingArmorPenetration.Value, 0f, 1f) + ArmorPenetration.Value;
			defense = Math.Max(defense - num2, 0f);
			float num3 = defense * defenseEffectiveness;
			num = Math.Max(num - num3, 1f);
			return Math.Clamp((int)FinalDamage.ApplyTo(num), 1, _damageLimit);
		}

		public float GetKnockback(float baseKnockback, bool knockbackImmune)
		{
			float num = Math.Max(Knockback.ApplyTo(baseKnockback), 0f);
			if (knockbackImmune)
			{
				num *= 1f - Math.Clamp(KnockbackImmunityEffectiveness.Value, 0f, 1f);
			}
			return num;
		}

		public HurtInfo ToHurtInfo(int damage, int defense, float defenseEffectiveness, float knockback, bool knockbackImmune)
		{
			HurtInfo hurtInfo = new HurtInfo();
			hurtInfo.DamageSource = DamageSource;
			hurtInfo.PvP = PvP;
			hurtInfo.CooldownCounter = CooldownCounter;
			hurtInfo.Dodgeable = Dodgeable;
			hurtInfo.HitDirection = HitDirectionOverride ?? HitDirection;
			hurtInfo.SourceDamage = (int)SourceDamage.ApplyTo(damage);
			hurtInfo.Damage = (int)GetDamage(damage, defense, defenseEffectiveness);
			hurtInfo.Knockback = GetKnockback(knockback, knockbackImmune);
			hurtInfo.Cancelled = _cancelled;
			hurtInfo.DustDisabled = _dustDisabled;
			hurtInfo.SoundDisabled = _soundDisabled;
			HurtInfo info = hurtInfo;
			this.ModifyHurtInfo?.Invoke(ref info);
			this.ModifyHurtInfo = null;
			return info;
		}
	}

	/// <summary>
	/// Represents a finalized damage calculation for damage about to be applied to a Player. This is the result of all modifications done previously in a <see cref="T:Terraria.Player.HurtModifiers" /> provided to various hooks.
	/// </summary>
	public struct HurtInfo
	{
		/// <summary>
		/// <inheritdoc cref="P:Terraria.Player.HurtModifiers.DamageSource" />
		/// </summary>
		public PlayerDeathReason DamageSource;

		/// <summary>
		/// <inheritdoc cref="P:Terraria.Player.HurtModifiers.PvP" />
		/// </summary>
		public bool PvP;

		/// <summary>
		/// <inheritdoc cref="P:Terraria.Player.HurtModifiers.CooldownCounter" />
		/// </summary>
		public int CooldownCounter;

		/// <summary>
		/// <inheritdoc cref="P:Terraria.Player.HurtModifiers.Dodgeable" />
		/// </summary>
		public bool Dodgeable;

		private int _sourceDamage;

		private int _damage;

		/// <summary>
		/// <inheritdoc cref="P:Terraria.Player.HurtModifiers.HitDirection" />
		/// </summary>
		public int HitDirection;

		/// <summary>
		/// The amount of knockback to apply. Should always be &gt;= 0.
		/// </summary>
		public float Knockback;

		/// <summary>
		/// <inheritdoc cref="M:Terraria.Player.HurtModifiers.Cancel" />
		/// </summary>
		public bool Cancelled;

		/// <summary>
		/// If true, dust will not spawn
		/// </summary>
		public bool DustDisabled;

		/// <summary>
		/// If true, sound will not play
		/// </summary>
		public bool SoundDisabled;

		/// <summary>
		/// The amount of damage 'dealt' to the player, before incoming damage multipliers, armor, damage reduction.<br />
		/// Use this to trigger effects which scale based on how 'hard' the player was hit rather than how much life was lost.<br />
		/// Cannot be set to less than 1.<br />
		/// <br />
		/// Using this instead of <see cref="P:Terraria.Player.HurtInfo.Damage" /> can prevent diminishing returns damage mitigation, when adding beneficial effects like retaliatory damage.
		/// </summary>
		public int SourceDamage
		{
			readonly get
			{
				return _sourceDamage;
			}
			set
			{
				_sourceDamage = Math.Max(value, 1);
			}
		}

		/// <summary>
		/// The amount of damage received by the player. How much life the player will lose. <br />
		/// Is NOT capped at the player's current life.<br />
		/// Cannot be set to less than 1.
		/// </summary>
		public int Damage
		{
			readonly get
			{
				return _damage;
			}
			set
			{
				_damage = Math.Max(value, 1);
			}
		}

		public HurtInfo()
		{
			DamageSource = null;
			PvP = false;
			CooldownCounter = -1;
			Dodgeable = true;
			_sourceDamage = 1;
			_damage = 1;
			HitDirection = 0;
			Knockback = 0f;
			Cancelled = false;
			DustDisabled = false;
			SoundDisabled = false;
		}
	}

	public struct DefenseStat
	{
		public static DefenseStat Default = new DefenseStat();

		public AddableFloat AdditiveBonus;

		public MultipliableFloat FinalMultiplier;

		public int Positive { get; private set; }

		public int Negative { get; private set; }

		public DefenseStat()
		{
			Positive = 0;
			Negative = 0;
			AdditiveBonus = default(AddableFloat);
			FinalMultiplier = new MultipliableFloat();
		}

		public static DefenseStat operator +(DefenseStat stat, int add)
		{
			if (add >= 0)
			{
				DefenseStat result = stat;
				result.Positive = stat.Positive + add;
				return result;
			}
			return stat - -add;
		}

		public static DefenseStat operator -(DefenseStat stat, int sub)
		{
			if (sub >= 0)
			{
				DefenseStat result = stat;
				result.Negative = stat.Negative + sub;
				return result;
			}
			return stat + -sub;
		}

		public static DefenseStat operator ++(DefenseStat stat)
		{
			return stat + 1;
		}

		public static DefenseStat operator --(DefenseStat stat)
		{
			return stat - 1;
		}

		public static DefenseStat operator *(DefenseStat stat, float mult)
		{
			DefenseStat result = stat;
			result.FinalMultiplier = stat.FinalMultiplier * mult;
			return result;
		}

		public static DefenseStat operator /(DefenseStat stat, float div)
		{
			DefenseStat result = stat;
			result.FinalMultiplier = stat.FinalMultiplier / div;
			return result;
		}

		public static implicit operator int(DefenseStat stat)
		{
			return Math.Max((int)Math.Round(((float)stat.Positive * (1f + stat.AdditiveBonus.Value) - (float)stat.Negative) * stat.FinalMultiplier.Value), 0);
		}

		public override string ToString()
		{
			return ((int)this).ToString();
		}
	}

	public int emoteTime;

	public CreativeUnlocksTracker creativeTracker;

	internal static byte[] ENCRYPTION_KEY = new UnicodeEncoding().GetBytes("h3y_gUyZ");

	public OverheadMessage chatOverhead;

	public SelectionRadial DpadRadial = new SelectionRadial();

	public SelectionRadial CircularRadial = new SelectionRadial(SelectionRadial.SelectionMode.RadialCircular);

	public SelectionRadial QuicksRadial = new SelectionRadial(SelectionRadial.SelectionMode.RadialQuicks);

	public bool alchemyTable;

	public int HotbarOffset;

	public bool GoingDownWithGrapple;

	public byte spelunkerTimer;

	public bool[] hideInfo = new bool[InfoDisplayLoader.InfoDisplayCount];

	public int[] builderAccStatus = new int[BuilderToggleLoader.BuilderToggleCount];

	public long lostCoins;

	public string lostCoinString = "";

	public int soulDrain;

	public float drainBoost;

	public bool dd2Accessory;

	private static bool disabledBlizzardGraphic = false;

	private static bool disabledBlizzardSound = false;

	private static float _blizzardSoundVolume;

	private static SlotId _strongBlizzardSound = SlotId.Invalid;

	private static SlotId _insideBlizzardSound = SlotId.Invalid;

	/// <summary>
	/// This player's displayed name.
	/// <br /> Usually capped at 20 characters.
	/// </summary>
	public string name = "";

	public int taxMoney;

	public double taxTimer;

	public static double taxRate = 3600.0;

	public int numberOfDeathsPVE;

	public int numberOfDeathsPVP;

	public static int crystalLeafDamage = 100;

	public static int crystalLeafKB = 10;

	public float basiliskCharge;

	public Vector2 lastDeathPostion;

	public DateTime lastDeathTime;

	public bool showLastDeath;

	public bool usedAegisCrystal;

	public bool usedAegisFruit;

	public bool usedArcaneCrystal;

	public bool usedGalaxyPearl;

	public bool usedGummyWorm;

	public bool usedAmbrosia;

	public int extraAccessorySlots = 2;

	public bool extraAccessory;

	private bool dontConsumeWand;

	public int tankPet = -1;

	public bool tankPetReset;

	public int stringColor;

	public int counterWeight;

	public bool yoyoString;

	public bool yoyoGlove;

	public int beetleOrbs;

	public float beetleCounter;

	public int beetleCountdown;

	public bool beetleDefense;

	public bool beetleOffense;

	public bool beetleBuff;

	public int solarShields;

	public int solarCounter;

	public const int maxSolarShields = 3;

	public Vector2[] solarShieldPos = (Vector2[])(object)new Vector2[3];

	public Vector2[] solarShieldVel = (Vector2[])(object)new Vector2[3];

	public bool solarDashing;

	public bool solarDashConsumedFlare;

	public const int nebulaMaxLevel = 3;

	public int nebulaLevelLife;

	public int nebulaLevelMana;

	public int nebulaManaCounter;

	public int nebulaLevelDamage;

	public bool manaMagnet;

	public bool lifeMagnet;

	public bool treasureMagnet;

	public bool chiselSpeed;

	public bool lifeForce;

	public bool calmed;

	public bool inferno;

	public float flameRingRot;

	public float flameRingScale = 1f;

	public byte flameRingFrame;

	public byte flameRingAlpha;

	public int netManaTime;

	public int netLifeTime;

	public bool netMana;

	public bool netLife;

	public Vector2[] beetlePos = (Vector2[])(object)new Vector2[3];

	public Vector2[] beetleVel = (Vector2[])(object)new Vector2[3];

	public int beetleFrame;

	public int beetleFrameCounter;

	public static int manaSickTime = 300;

	public static int manaSickTimeMax = 600;

	public static float manaSickLessDmg = 0.25f;

	public float manaSickReduction;

	public bool manaSick;

	public int afkCounter;

	public bool stairFall;

	/// <summary> 0: Success <br /> 1: Future version <br /> 2: Read error </summary>;
	public int loadStatus;

	public Vector2[] itemFlamePos = (Vector2[])(object)new Vector2[7];

	public int itemFlameCount;

	public bool outOfRange;

	public float lifeSteal = 99999f;

	public float ghostDmg;

	public bool teleporting;

	public float teleportTime;

	public int teleportStyle;

	public bool sloping;

	public bool chilled;

	public bool dazed;

	public bool frozen;

	public bool stoned;

	public bool lastStoned;

	public bool ichor;

	public bool webbed;

	public bool tipsy;

	public bool noBuilding;

	public int ropeCount;

	public int manaRegenBonus;

	public float manaRegenDelayBonus;

	/// <summary>
	/// The current vanilla dash that the player is using.<br />
	/// The following values correspond to vanilla dashes:<br />
	/// 1 =&gt; Tabi / Master Ninja Gear<br />
	/// 2 =&gt; Shield of Cthulhu<br />
	/// 3 =&gt; Solar Flare armor set bonus<br />
	/// 4 =&gt; Unused, though a dash for this value DOES exist<br />
	/// 5 =&gt; Crystal Assassin set bonus<br />
	/// </summary>
	public int dashType;

	/// <summary>
	/// The current vanilla dash that the player is VISIBLY using.<br />
	/// Unlike <see cref="F:Terraria.Player.dashType" />, this does not update if a dash cannot currently be input.<br />
	/// </summary>
	public int dash;

	/// <summary>
	/// The amount of time this player has left, in ticks, to input the second keystroke of a standard dash input (double-tap left/right).<br />
	/// For vanilla dashes, this window is 15 ticks, or a quarter of a second, in total.<br />
	/// </summary>
	public int dashTime;

	/// <summary>
	/// The amount of time that has passed, in ticks, since this player last performed a dash.
	/// </summary>
	public int timeSinceLastDashStarted;

	/// <summary>
	/// The amount of time that has to pass, in ticks, before a new dash input will be registered.<br />
	/// For the first frame of any given dash, this is set to -1. After that frame has passed, it is set to 20 ticks, or 1/3 of a second.<br />
	/// For the Tabi dash, and when dashing into an enemy with the Shield of Cthulhu, this is set to 30 ticks, or 1/2 of a second, instead.<br />
	/// </summary>
	public int dashDelay;

	public int eocDash;

	public int eocHit;

	/// <summary>
	/// Similar to <see cref="F:Terraria.Player.maxRunSpeed" />, except this is usually set to a specific value for the active shoe accessory. If accRunSpeed ends up larger than maxRunSpeed, then sprint dust will spawn at high speeds. Basically, this exists to differentiate between sprinting ("run super fast") and running.
	/// <para /> Defaults to 3f. Accessories set this to specific values, resulting in the last equipped accessories to dictate the final value. Vanilla shoe accessories set this to <c>6f</c> (<see cref="F:Terraria.ID.ItemID.HermesBoots" />) or <c>6.75</c> (<see cref="F:Terraria.ID.ItemID.LightningBoots" />). This assignment should happen in <see cref="M:Terraria.ModLoader.ModItem.UpdateEquip(Terraria.Player)" />.
	/// <para /> This value is later multiplied by other effects in the same manner as <see cref="F:Terraria.Player.maxRunSpeed" />. They are usually modified in tandem, but not always depending on the desired result. For example, asphalt triples maxRunSpeed but does not affect accRunSpeed, whereas Shadow Armor affects both equally.
	/// <para /> These multiplicative adjustments should only be done in <see cref="M:Terraria.ModLoader.ModPlayer.PostUpdateRunSpeeds" /> or <see cref="M:Terraria.ModLoader.ModItem.HorizontalWingSpeeds(Terraria.Player,System.Single@,System.Single@)" /> to correctly function.
	/// <para /> When on a mount, all other modifiers are ignored and it is set to <see cref="P:Terraria.Mount.DashSpeed" />
	/// </summary>
	public float accRunSpeed;

	public bool cordage;

	public int gem = -1;

	public int gemCount;

	public BitsByte ownedLargeGems;

	/// <summary>
	/// The vanilla flask effect which the player currently has active; these affect all melee weapons and whips.<br />
	/// Defaults to 0, which denotes that the player does not currently have a flask active.<br />
	/// The following values correspond to vanilla flasks:<br />
	/// 1 =&gt; Flask of Venom (affected weapons proc Acid Venom on hit)<br />
	/// 2 =&gt; Flask of Cursed Flames (affected weapons proc Cursed Inferno on hit)<br />
	/// 3 =&gt; Flask of Fire (affected weapons proc On Fire! on hit)<br />
	/// 4 =&gt; Flask of Gold (affected weapons proc Midas on hit)<br />
	/// 5 =&gt; Flask of Ichor (affected weapons proc Ichor on hit)<br />
	/// 6 =&gt; Flask of Nanites (affected weapons proc Confused on hit)<br />
	/// 7 =&gt; Flask of Party (affected weapons sometimes release confetti explosions on hit)<br />
	/// 8 =&gt; Flask of Poison (affected weapons proc Poisoned on hit)<br />
	/// </summary>
	public byte meleeEnchant;

	/// <summary>
	/// While attached to a rope or similar tile (<see cref="F:Terraria.Player.pulley" />), this value represents the how close to the rope the player is. A value of 1 means the player is centered on the rope, while a value of 2 represents that the player has nudged away from the rope but is still attached. <see cref="F:Terraria.Entity.direction" /> is used still for the players direction.
	/// </summary>
	public byte pulleyDir;

	/// <summary>
	/// If true, the player is attached to a rope or similar tile.
	/// </summary>
	public bool pulley;

	public int pulleyFrame;

	public float pulleyFrameCounter;

	public bool blackBelt;

	public bool sliding;

	public int slideDir;

	public int snowBallLauncherInteractionCooldown;

	/// <summary> Grant the player improved speed on ice and not breaking thin ice when falling onto it </summary>
	public bool iceSkate;

	public bool carpet;

	/// <summary>
	/// Used by the Shoe Spikes and Climbing Claws to allow for holding onto walls (of tiles, not to be confused with actual walls).<br />
	/// Defaults to 0. Any value higher than 0 allows the player to wall-jump.<br />
	/// A value of 1 causes the player to slowly slide down them while holding onto them.<br />
	/// A value of 2 or more doesn't give this limitation, allowing the player to stay holding onto a wall indefinitely.
	/// </summary>
	public int spikedBoots;

	public int carpetFrame = -1;

	public float carpetFrameCounter;

	public bool canCarpet;

	public int carpetTime;

	/// <summary>
	/// Counts updates from 0 up to 299 and then resets back to 0. Can be used to drive visuals and other player effects. The <see href="https://github.com/tModLoader/tModLoader/wiki/Time-and-Timers#modulo-timer">Modulo Timer section of the Time and Timers wiki page</see> has more details about how to use a counter like this.
	/// </summary>
	public int miscCounter;

	public int infernoCounter;

	public int insanityShadowCooldown;

	public int starCloakCooldown;

	private bool _sandStormLogicEnabled;

	public bool crimsonRegen;

	public bool ghostHeal;

	public bool ghostHurt;

	/// <summary> Player is on <see cref="F:Terraria.ID.TileID.HoneyBlock" />. Affects movement parameters. </summary>
	public bool sticky;

	/// <summary> Player is on a <see cref="F:Terraria.ID.TileID.Sets.IceSkateSlippery" /> tile. Affects movement parameters. </summary>
	public bool slippy;

	/// <summary> Player is on <see cref="F:Terraria.ID.TileID.FrozenSlimeBlock" />. Affects movement parameters. </summary>
	public bool slippy2;

	/// <summary> Player is on <see cref="F:Terraria.ID.TileID.Asphalt" />. Affects movement parameters. </summary>
	public bool powerrun;

	public bool runningOnSand;

	public bool flapSound;

	public bool iceBarrier;

	public bool dangerSense;

	public byte luckPotion;

	public byte oldLuckPotion;

	/// <summary>
	/// The percent of damage this player should resist.
	/// <br /> Has a soft cap of <c>1f</c>. Cannot reduce taken damage below <c>1</c>.
	/// </summary>
	public float endurance;

	public float whipRangeMultiplier;

	public bool loveStruck;

	public bool stinky;

	/// <summary>
	/// If <see langword="true" />, this player will take 30% less damage from any NPC with <see cref="F:Terraria.NPC.coldDamage" /> set and any projectile with <see cref="F:Terraria.Projectile.coldDamage" /> set.
	/// </summary>
	public bool resistCold;

	public bool electrified;

	public bool dryadWard;

	public bool panic;

	public Item brainOfConfusionItem;

	public int brainOfConfusionDodgeAnimationCounter;

	public byte iceBarrierFrame;

	public byte iceBarrierFrameCounter;

	public bool shadowDodge;

	public float shadowDodgeCount;

	public bool palladiumRegen;

	public bool onHitDodge;

	public bool onHitRegen;

	public bool onHitPetal;

	public bool onHitTitaniumStorm;

	public int titaniumStormCooldown;

	public bool hasTitaniumStormBuff;

	public int petalTimer;

	public int shadowDodgeTimer;

	public int boneGloveTimer;

	public int phantomPhoneixCounter;

	public int fishingSkill;

	public bool cratePotion;

	public bool sonarPotion;

	/// <summary>
	/// If <see langword="true" />, this player's fishing line will never break.
	/// </summary>
	public bool accFishingLine;

	public bool accFishingBobber;

	public bool accTackleBox;

	public bool accLavaFishing;

	/// <summary>
	/// The maximum value of minions this player can have summoned at once.
	/// <br /> A minion's value is stored as <see cref="F:Terraria.Projectile.minionSlots" />.
	/// </summary>
	public int maxMinions = 1;

	/// <summary>
	/// The current number of minions this player has summoned. Note that <see cref="F:Terraria.Player.slotsMinions" /> is how the minion limit is tracked, not this.
	/// </summary>
	public int numMinions;

	/// <summary>
	/// The current total value of minions this player has summoned. Used to limit active minions to <see cref="F:Terraria.Player.maxMinions" />
	/// <br /> A minion's value is stored as <see cref="F:Terraria.Projectile.minionSlots" />.
	/// </summary>
	public float slotsMinions;

	public bool pygmy;

	public bool raven;

	public bool slime;

	public bool hornetMinion;

	public bool impMinion;

	public bool twinsMinion;

	public bool spiderMinion;

	public int nextCycledSpiderMinionType;

	public bool pirateMinion;

	public bool sharknadoMinion;

	public bool UFOMinion;

	public bool DeadlySphereMinion;

	public bool stardustMinion;

	public bool stardustGuardian;

	public bool stardustDragon;

	public bool batsOfLight;

	public bool babyBird;

	public bool vampireFrog;

	public bool stormTiger;

	public int highestStormTigerGemOriginalDamage;

	public bool smolstar;

	public bool empressBlade;

	public bool flinxMinion;

	public bool abigailMinion;

	public int highestAbigailCounterOriginalDamage;

	public float wingTime;

	public int wings;

	public int wingsLogic;

	public int wingTimeMax;

	public int wingFrame;

	public int wingFrameCounter;

	public int skinVariant;

	public bool ghost;

	public int ghostFrame;

	public int ghostFrameCounter;

	public int miscTimer;

	public int environmentBuffImmunityTimer;

	public int _framesLeftEligibleForDeadmansChestDeathAchievement;

	public bool pvpDeath;

	public BitsByte zone1 = (byte)0;

	public BitsByte zone2 = (byte)0;

	public BitsByte zone3 = (byte)0;

	public BitsByte zone4 = (byte)0;

	public BitsByte zone5 = (byte)0;

	private bool _wasInShimmerZone;

	public bool boneArmor;

	public bool frostArmor;

	public bool honey;

	public bool crystalLeaf;

	public int crystalLeafCooldown;

	public PortableStoolUsage portableStoolInfo;

	public bool preventAllItemPickups;

	public bool dontHurtCritters;

	public bool hasLucyTheAxe;

	public bool dontHurtNature;

	/// <summary>
	/// Used to count time between repeated directional movement key presses. When a directional key is pressed it is set to a value of 15. The value will count down each update until it reaches 0. If the key is pressed again before it reaches 0 it will trigger <see cref="M:Terraria.Player.KeyDoubleTap(System.Int32)" />, which will call <see cref="M:Terraria.ModLoader.ModPlayer.ArmorSetBonusActivated" /> if the armor set bonus direction key has been pressed. Updated immediately before <see cref="M:Terraria.ModLoader.ModPlayer.SetControls" />.
	/// <CardinalDirections>
	/// 		<para /> The index values are as follows: <br /> 0: Down <br /> 1: Up <br /> 2: Right <br /> 3: Left
	/// 	</CardinalDirections>
	/// </summary>
	public int[] doubleTapCardinalTimer = new int[4];

	/// <summary>
	/// Counts how long (in ticks) the player has been holding directional movement keys. Updated immediately before <see cref="M:Terraria.ModLoader.ModPlayer.SetControls" />.
	/// <CardinalDirections>
	/// 		<para /> The index values are as follows: <br /> 0: Down <br /> 1: Up <br /> 2: Right <br /> 3: Left
	/// 	</CardinalDirections>
	/// </summary>
	public int[] holdDownCardinalTimer = new int[4];

	public bool defendedByPaladin;

	public bool hasPaladinShield;

	public float[] speedSlice = new float[60];

	/// <summary>
	/// The sum of the <see cref="F:Terraria.NPC.npcSlots" /> of all town NPCs near this player.
	/// <br /> If <c><see cref="F:Terraria.Player.townNPCs" /> &gt; 2f</c>, then this player is in a town.
	/// </summary>
	public float townNPCs;

	public double headFrameCounter;

	public double bodyFrameCounter;

	public double legFrameCounter;

	public int netSkip;

	public int oldSelectItem;

	public bool immune;

	public bool immuneNoBlink;

	public int immuneTime;

	public int immuneAlphaDirection;

	public int immuneAlpha;

	public int team;

	private int _timeSinceLastImmuneGet;

	private int _immuneStrikes;

	public bool hbLocked;

	public static int nameLen = 20;

	public float maxRegenDelay;

	public int sign = -1;

	public bool editedChestName;

	/// <summary>
	/// How long the player will be unable to use any item after the currently active item usage completes. Derived from <see cref="F:Terraria.Item.reuseDelay" />.
	/// <PlayerItemUseAnimation>
	/// 		<br /><br /> The <see href="https://github.com/tModLoader/tModLoader/wiki/Player-Item-Animation">Player Item Animation wiki page</see> goes into detail about how this and other player item use and animation fields work together and provides a useful overview on this topic.
	/// 	</PlayerItemUseAnimation>
	/// </summary>
	public int reuseDelay;

	public int aggro;

	/// <summary>
	/// The sum of the <see cref="F:Terraria.NPC.npcSlots" /> values of NPC within the active range of this Player. Used to set NPC spawn rates.
	/// </summary>
	public float nearbyActiveNPCs;

	public bool creativeInterface;

	/// <summary>
	/// If true, the mouse is currently overlapping with a user interface so any mouse interaction should be not be interpreted as gameplay input, such as using items.
	/// <para /> UIElements that should block user interaction typically check <c>ContainsPoint(Main.MouseScreen)</c> in the Update method to determine if mouseInterface should be set to true.
	/// </summary>
	public bool mouseInterface;

	public bool lastMouseInterface;

	public int noThrow;

	public int changeItem = -1;

	/// <summary> The index of the <see cref="T:Terraria.Item" /> within the <see cref="F:Terraria.Player.inventory" /> currently selected by the player. To access the <see cref="T:Terraria.Item" /> directly use <see cref="P:Terraria.Player.HeldItem" /> instead. </summary>
	public int selectedItem;

	public const int SupportedSlotsArmor = 3;

	public const int SupportedSlotsAccs = 7;

	public const int SupportedSlotSets = 10;

	public const int InitialAccSlotCount = 5;

	public const int miscSlotPet = 0;

	public const int miscSlotLight = 1;

	public const int miscSlotCart = 2;

	public const int miscSlotMount = 3;

	public const int miscSlotHook = 4;

	public const int SupportedMiscSlotCount = 5;

	/// <summary>
	/// The player's armor and accessories. Indexes 0-2 hold head, chest, and legs armor while 10-12 hold the respective social armor items. Indexes 3-9 hold the accessories and 13-19 hold the social accessory items. Modded accessory slots are stored separately.<br /><br />
	/// Generally speaking, modders <b>should not be accessing this array</b> to check for specific accessories, that is not how Terraria is designed and is not scalable, especially since modded accessory slots exist and each can have special logic. Modders should be using <see cref="M:Terraria.ModLoader.ModItem.UpdateAccessory(Terraria.Player,System.Boolean)" /> to set fields in a <see cref="T:Terraria.ModLoader.ModPlayer" /> class, then use those values for gameplay effects. <see href="https://github.com/tModLoader/tModLoader/blob/stable/ExampleMod/Common/Players/SimpleModPlayer.cs">SimpleModPlayer.cs</see> shows the proper approach and explains this pattern.<br /><br />
	/// The corresponding dye items are found in <see cref="F:Terraria.Player.dye" />. The player's inventory is <see cref="F:Terraria.Player.inventory" />. For equipment, see <see cref="F:Terraria.Player.miscEquips" /> and <see cref="F:Terraria.Player.miscDyes" />. <see cref="F:Terraria.Player.trashItem" /> is the trash slot.<br /><br />
	/// </summary>
	public Item[] armor = new Item[20];

	/// <summary> The dye items corresponding to the <see cref="F:Terraria.Player.armor" /> items. </summary>
	public Item[] dye = new Item[10];

	/// <summary>
	/// The player's equipment items. From indexes 0-4: Pet, Light Pet, Minecart, Mount, and Hook.
	/// </summary>
	public Item[] miscEquips = new Item[5];

	/// <summary> The dye items corresponding to the <see cref="F:Terraria.Player.miscEquips" /> items. </summary>
	public Item[] miscDyes = new Item[5];

	public Item trashItem = new Item();

	public float itemRotation;

	public int itemWidth;

	public int itemHeight;

	public Vector2 itemLocation;

	public bool poundRelease;

	public float ghostFade;

	public float ghostDir = 1f;

	/// <summary>
	/// The <see cref="T:Terraria.ID.BuffID" />s of all buffs this player has active.
	/// <br /> A value of <c>0</c> means that buff slot is empty.
	/// <br /> Buff times are stored with the same index in <see cref="F:Terraria.Player.buffTime" />.
	/// <br /> <see cref="M:Terraria.Player.AddBuff(System.Int32,System.Int32,System.Boolean,System.Boolean)" />, <see cref="M:Terraria.Player.ClearBuff(System.Int32)" />, and <see cref="M:Terraria.Player.DelBuff(System.Int32)" /> should be used to manipulate player buffs.
	/// </summary>
	public int[] buffType = new int[maxBuffs];

	/// <summary>
	/// The remaining durations in ticks of all buffs this player has active.
	/// <br /> A value of <c>0</c> means that buff slot is empty.
	/// <br /> Buff types are stored with the same index in <see cref="F:Terraria.Player.buffType" />.
	/// <br /> <see cref="M:Terraria.Player.AddBuff(System.Int32,System.Int32,System.Boolean,System.Boolean)" />, <see cref="M:Terraria.Player.ClearBuff(System.Int32)" />, and <see cref="M:Terraria.Player.DelBuff(System.Int32)" /> should be used to manipulate player buffs.
	/// </summary>
	public int[] buffTime = new int[maxBuffs];

	/// <summary>
	/// Indexed by <see cref="T:Terraria.ID.BuffID" />. If <see langword="true" /> for a given <see cref="T:Terraria.ID.BuffID" />, then this player cannot be inflicted with that buff.
	/// <br /> Additionally, if the player is inflicted with that buff and becomes immune to it, the buff will be cleared.
	/// <br /> Defaults to <see langword="false" />.
	/// </summary>
	public bool[] buffImmune = new bool[BuffID.Count];

	/// <summary>
	/// The index of the projectile (<see cref="F:Terraria.Entity.whoAmI" />) currently being "held" by the player as if it were an item. Set during projectile AI. Held projectiles will be drawn during player rendering over the player's arms.
	/// <para /> When making a held projectile, make sure to test holding the projectile while moving up or down a single block obstacles and adjust <see cref="M:Terraria.Player.RotatedRelativePoint(Microsoft.Xna.Framework.Vector2,System.Boolean,System.Boolean)" />, <see cref="F:Terraria.Player.gfxOffY" /> or <see cref="F:Terraria.ID.ProjectileID.Sets.HeldProjDoesNotUsePlayerGfxOffY" /> accordingly if the draw location is incorrect.
	/// <para /> Defaults to -1.
	/// </summary>
	public int heldProj = -1;

	/// <summary> A countdown timer for <see cref="F:Terraria.Player.breath" />. Ticks up every frame the player is holding their breath underwater. Once it reaches <see cref="P:Terraria.Player.breathCDMax" />, resets back to 0 and breath is reduced by 1. </summary>
	public int breathCD;

	/// <summary> The max value of <see cref="F:Terraria.Player.breath" />. Defaults to 200. The total ticks before starting to drown is <c>breathMax * breathCDMax</c>. <para /> Effects like Breathing Reed and Diving Gear affect <see cref="F:Terraria.Player.breathEffectiveness" /> rather than edit this value. </summary>
	public int breathMax = 200;

	/// <summary> The current amount of breath the player has (<see href="https://terraria.wiki.gg/wiki/Breath_meter">Breath info on the wiki</see>). <see cref="F:Terraria.Player.breathCD" /> controls how often the value decreases. Once 0, the player will start to take drowning damage. When out of liquid increases by 3 each tick. </summary>
	public int breath = 200;

	public int lavaCD;

	/// <summary> The max amount of lava immunity time (in ticks) the player can have. <see cref="F:Terraria.ID.ItemID.LavaCharm" /> and many other accessories add 420 do this, or 7 seconds. </summary>
	public int lavaMax;

	/// <summary> The remaining amount of lava immunity time (in ticks) the player has. </summary>
	public int lavaTime;

	public bool ignoreWater;

	public bool armorEffectDrawShadow;

	public bool armorEffectDrawShadowSubtle;

	public bool armorEffectDrawOutlines;

	public bool armorEffectDrawShadowLokis;

	public bool armorEffectDrawShadowBasilisk;

	public bool armorEffectDrawOutlinesForbidden;

	public bool armorEffectDrawShadowEOCShield;

	public bool socialShadowRocketBoots;

	public bool socialGhost;

	public bool shroomiteStealth;

	public bool ashWoodBonus;

	public bool socialIgnoreLight;

	public int stealthTimer;

	public float stealth = 1f;

	public int beardGrowthTimer;

	public bool isDisplayDollOrInanimate;

	public bool isFullbright;

	public bool isHatRackDoll;

	public bool isFirstFractalAfterImage;

	public float firstFractalAfterImageOpacity;

	/// <summary>
	/// The text that is shown on armor (<see cref="F:Terraria.Item.wornArmor" />) with an active set bonus.
	/// </summary>
	public string setBonus = "";

	/// <summary>
	/// The player's normal inventory. Indexes 0-9 hold the hotbar items, 10-49 the rest of the main inventory, 50-53 are coin slots, 54-57 are ammo slots. Index 58 is used to store the mouse item in some situations.<br />
	/// Additional inventories are found in <see cref="F:Terraria.Player.bank" /> (Piggy Bank), <see cref="F:Terraria.Player.bank2" /> (Safe), <see cref="F:Terraria.Player.bank3" /> (Defender's Forge), and <see cref="F:Terraria.Player.bank4" /> (Void Vault).
	/// For armor and accessories, see <see cref="F:Terraria.Player.armor" /> and <see cref="F:Terraria.Player.dye" />. For equipment, see <see cref="F:Terraria.Player.miscEquips" /> and <see cref="F:Terraria.Player.miscDyes" />. <see cref="F:Terraria.Player.trashItem" /> is the trash slot.<br />
	/// </summary>
	public Item[] inventory = new Item[59];

	public bool[] inventoryChestStack = new bool[59];

	public Item lastVisualizedSelectedItem;

	/// <summary> Piggy Bank items </summary>
	public Chest bank = new Chest(bank: true);

	/// <summary> Safe items </summary>
	public Chest bank2 = new Chest(bank: true);

	/// <summary> Defender's Forge items </summary>
	public Chest bank3 = new Chest(bank: true);

	/// <summary> Void Vault items </summary>
	public Chest bank4 = new Chest(bank: true);

	public BitsByte voidVaultInfo;

	public float headRotation;

	public float bodyRotation;

	public float legRotation;

	public Vector2 headPosition;

	public Vector2 bodyPosition;

	public Vector2 legPosition;

	public Vector2 headVelocity;

	public Vector2 bodyVelocity;

	public Vector2 legVelocity;

	public float fullRotation;

	public Vector2 fullRotationOrigin = Vector2.Zero;

	public int fartKartCloudDelay;

	public const int fartKartCloudDelayMax = 20;

	public int nonTorch = -1;

	/// <summary>
	/// An offset from the actual position of the player that will be added to the draw position. Used to fake the effect of the player smoothly traveling up single block obstacles.
	/// </summary>
	public float gfxOffY;

	/// <summary>
	/// Has nothing to do with the speed that this player travels, that is dictated by <see cref="F:Terraria.Player.moveSpeed" /> and related fields. This affects how quickly <see cref="F:Terraria.Player.gfxOffY" /> is adjusted.
	/// </summary>
	public float stepSpeed = 1f;

	public static bool deadForGood = false;

	/// <summary> Indicates if this player is dead </summary>
	public bool dead;

	/// <summary> The amount of time in ticks before this player respawns after death. Most suitably modified in <see cref="M:Terraria.ModLoader.ModPlayer.Kill(System.Double,System.Int32,System.Boolean,Terraria.DataStructures.PlayerDeathReason)" /> </summary>
	public int respawnTimer;

	public const int respawnTimerMax = 3600;

	public long lastTimePlayerWasSaved;

	public int attackCD;

	/// <summary>
	/// The potion sickness delay, in ticks. This value mirrors the remaining time for the <see cref="F:Terraria.ID.BuffID.PotionSickness" /> buff.
	/// </summary>
	public int potionDelay;

	/// <summary>
	/// The <see href="https://terraria.wiki.gg/wiki/Difficulty">player difficulty</see>. Valid values are found in <see cref="T:Terraria.ID.PlayerDifficultyID" />. 
	/// </summary>
	public byte difficulty;

	public byte wetSlime;

	public HitTile hitTile;

	public HitTile hitReplace;

	public int jump;

	/// <summary>
	/// The visible head equipment slot (<see cref="T:Terraria.ID.ArmorIDs.Head" />). Usually corresponds to the <see cref="F:Terraria.Item.headSlot" /> of the visible head ("helmet") armor or vanity item.
	/// <br /><br /> Defaults to -1.
	/// </summary>
	public int head = -1;

	/// <summary>
	/// The visible body equipment slot (<see cref="T:Terraria.ID.ArmorIDs.Body" />). Usually corresponds to the <see cref="F:Terraria.Item.bodySlot" /> of the visible body ("shirt") armor or vanity item.
	/// <br /><br /> Defaults to -1.
	/// </summary>
	public int body = -1;

	/// <summary>
	/// The visible legs equipment slot (<see cref="T:Terraria.ID.ArmorIDs.Legs" />). Usually corresponds to the <see cref="F:Terraria.Item.legSlot" /> of the visible legs ("pants") armor or vanity item.
	/// <br /><br /> Defaults to -1.
	/// </summary>
	public int legs = -1;

	public int handon = -1;

	public int handoff = -1;

	public int back = -1;

	public int front = -1;

	public int shoe = -1;

	public int waist = -1;

	public int shield = -1;

	public int neck = -1;

	public int face = -1;

	public int balloon = -1;

	public int backpack = -1;

	public int tail = -1;

	public int faceHead = -1;

	public int faceFlower = -1;

	public int balloonFront = -1;

	public int beard = -1;

	/// <summary>
	/// Indicates if the corresponding <see cref="F:Terraria.Player.armor" /> accessory is set to be hidden or not. 
	/// </summary>
	public bool[] hideVisibleAccessory = new bool[10];

	public BitsByte hideMisc = (byte)0;

	public Rectangle headFrame;

	public Rectangle bodyFrame;

	public Rectangle legFrame;

	public Rectangle hairFrame;

	public DirectionalInputSyncCache LocalInputCache;

	public bool controlLeft;

	public bool controlRight;

	public bool controlUp;

	public bool controlDown;

	public bool controlJump;

	/// <summary> Player is attempting to use an item, set mainly by pressing the "Use Item" keybind (Typically left mouse button). </summary>
	public bool controlUseItem;

	public bool controlUseTile;

	public bool controlThrow;

	public bool controlInv;

	public bool controlHook;

	public bool controlTorch;

	public bool controlMap;

	public bool controlSmart;

	public bool controlMount;

	public bool releaseJump;

	public bool releaseUp;

	public bool releaseUseItem;

	public bool releaseUseTile;

	public bool releaseInventory;

	public bool releaseHook;

	public bool releaseThrow;

	public bool releaseQuickMana;

	public bool releaseQuickHeal;

	public bool releaseLeft;

	public bool releaseRight;

	public bool releaseSmart;

	public bool releaseMount;

	public bool releaseDown;

	public bool controlQuickMana;

	public bool controlQuickHeal;

	public bool controlCreativeMenu;

	public bool releaseCreativeMenu;

	public bool tileInteractionHappened;

	public bool tileInteractAttempted;

	/// <summary> True when the player has been holding <see cref="F:Terraria.Player.controlDown" /> for at least 45 ticks. Used by <see cref="F:Terraria.ID.ItemID.ShimmerCloak" />. See also <see cref="F:Terraria.Player.holdDownCardinalTimer" />. </summary>
	public bool controlDownHold;

	public bool isOperatingAnotherEntity;

	public bool autoReuseAllWeapons;

	public bool isControlledByFilm;

	public bool tryKeepingHoveringDown;

	public bool tryKeepingHoveringUp;

	public int altFunctionUse;

	public bool mapZoomIn;

	public bool mapZoomOut;

	public bool mapAlphaUp;

	public bool mapAlphaDown;

	public bool mapFullScreen;

	public bool mapStyle;

	public bool releaseMapFullscreen;

	public bool releaseMapStyle;

	public int leftTimer;

	public int rightTimer;

	public bool delayUseItem;

	public const int defaultWidth = 20;

	public const int defaultHeight = 42;

	/// <summary>
	/// If true, an item will be drawn on the cursor. This is usually set along with <see cref="F:Terraria.Player.cursorItemIconID" /> and/or <see cref="F:Terraria.Player.cursorItemIconText" />.
	/// </summary>
	public bool cursorItemIconEnabled;

	/// <summary>
	/// If true, the item drawn on the cursor will be flipped horizontally.
	/// </summary>
	public bool cursorItemIconReversed;

	/// <summary>
	/// The Item type to draw on the cursor when <see cref="F:Terraria.Player.cursorItemIconEnabled" /> is true.
	/// <br /><br /> Defaults to 0. Set to -1 to prevent the selected item from being drawn on the cursor, which is the default behavior if in tool/tile placement range of the selected item.
	/// </summary>
	public int cursorItemIconID;

	/// <summary>
	/// When drawing an item on the cursor (<see cref="F:Terraria.Player.cursorItemIconEnabled" />), the item will be offset in both the X and Y directions by this many pixels. Used by Clentaminator solutions (10) and fishing bait (6) so the icons don't overlap the cursor as much as usual.
	/// </summary>
	public int cursorItemIconPush;

	/// <summary>
	/// Text to be drawn on the cursor when <see cref="F:Terraria.Player.cursorItemIconEnabled" /> is true. 
	/// </summary>
	public string cursorItemIconText = "";

	public int runSoundDelay;

	public float opacityForAnimation = 1f;

	public const int shadowMax = 3;

	/// <summary>
	/// Contains the player positioning data for the last 3 frames. Used by <see cref="F:Terraria.Player.armorEffectDrawShadow" /> and other similar effects.
	/// <br /><br /> See <see cref="M:Terraria.Player.GetAdvancedShadow(System.Int32)" /> for a more flexible approach. 
	/// </summary>
	public Vector2[] shadowPos = (Vector2[])(object)new Vector2[3];

	/// <inheritdoc cref="F:Terraria.Player.shadowPos" />
	public float[] shadowRotation = new float[3];

	/// <inheritdoc cref="F:Terraria.Player.shadowPos" />
	public Vector2[] shadowOrigin = (Vector2[])(object)new Vector2[3];

	/// <inheritdoc cref="F:Terraria.Player.shadowPos" />
	public int[] shadowDirection = new int[3];

	public int shadowCount;

	/// <summary>
	/// The percent of mana actually used when mana is consumed.
	/// <br /> Cannot reduce an item's mana cost below <c>0</c>.
	/// </summary>
	public float manaCost = 1f;

	/// <summary> Grants the player immunity from <see cref="F:Terraria.ID.TileID.Sets.TouchDamageHot" /> applying the <see cref="F:Terraria.ID.BuffID.Burning" /> buff. Given by <see cref="F:Terraria.ID.ItemID.ObsidianSkull" /> and many other items. </summary>
	public bool fireWalk;

	public bool channel;

	public int step = -1;

	private ChannelCancelKey _channelShotCache;

	public bool skipAnimatingValuesInPlayerFrame;

	public RabbitOrderFrameHelper rabbitOrderFrame;

	public bool creativeGodMode;

	private const int MaxAdvancedShadows = 60;

	/// <summary>
	/// The number of frames of previous positioning data available for use with <see cref="M:Terraria.Player.GetAdvancedShadow(System.Int32)" />. This will max at 60. Teleporting and mounting are some ways the previous positioning data will be cleared.
	/// </summary>
	public int availableAdvancedShadowsCount;

	private EntityShadowInfo[] _advancedShadows = new EntityShadowInfo[60];

	private int _lastAddedAvancedShadow;

	public CompositeArmData compositeFrontArm;

	public CompositeArmData compositeBackArm;

	public int anglerQuestsFinished;

	public int golferScoreAccumulated;

	public int bartenderQuestLog;

	public bool downedDD2EventAnyDifficulty;

	/// <summary>
	/// The defense value of this player.<br />
	/// The <see href="https://terraria.wiki.gg/wiki/Defense#Players">Defense wiki page</see> teaches how player defense affects incoming damage alongside <see cref="F:Terraria.Player.DefenseEffectiveness" />.<br />
	/// The value resets to 0 during <see cref="M:Terraria.Player.ResetEffects" /> and is manipulated throughout <see cref="M:Terraria.Player.Update(System.Int32)" />.<br />
	/// If the final value is needed, <see cref="M:Terraria.ModLoader.ModPlayer.PostUpdate" /> or anytime later is the best place. As such it is not recommended to manipulate the value during PostUpdate or at any time later for compatibility. Failure to follow this guideline will result in inconsistent behavior.<br />
	/// Due to this field being a <see cref="T:Terraria.Player.DefenseStat" />, modders can freely add, subtract, multiply, and divide the value. The final result will properly account for all modifications applied.<br />
	/// </summary>
	public DefenseStat statDefense;

	/// <summary>
	/// Determines how effective the player's <see cref="F:Terraria.Player.statDefense" /> is at reducing incoming damage.<br />
	/// The <see href="https://terraria.wiki.gg/wiki/Defense#Players">Defense wiki page</see> explains the effect, shown in the wiki as "factor".<br />
	/// </summary>
	public MultipliableFloat DefenseEffectiveness;

	/// <summary>
	/// The maximum health this player can have without adjustment.
	/// <br /> You should <strong>not</strong> modify this value. If you need to increase max health for equipment, modify <see cref="F:Terraria.Player.statLifeMax2" />. If you need to increase max health for a permanent stat boost, use <see cref="M:Terraria.ModLoader.ModPlayer.ModifyMaxStats(Terraria.ModLoader.StatModifier@,Terraria.ModLoader.StatModifier@)" />.
	/// </summary>
	public int statLifeMax = 100;

	/// <summary>
	/// The maximum health this player can have, adjusted by buffs and equipment.
	/// </summary>
	public int statLifeMax2 = 100;

	/// <summary>
	/// The current health of this player. Capped at <see cref="F:Terraria.Player.statLifeMax2" />.
	/// <br /> If you increase this value, be sure to respect the cap.
	/// </summary>
	/// <remarks>
	/// If you want to heal the player with the green text effect, use <see cref="M:Terraria.Player.Heal(System.Int32)" />.
	/// <br /> If you want to hurt the player, use <see cref="M:Terraria.Player.Hurt(Terraria.DataStructures.PlayerDeathReason,System.Int32,System.Int32,System.Boolean,System.Boolean,System.Int32,System.Boolean,System.Single,System.Single,System.Single)" />.
	/// </remarks>
	public int statLife = 100;

	/// <summary>
	/// The current mana of this player. Capped at <see cref="F:Terraria.Player.statManaMax2" />.
	/// <br /> If you increase this value, be sure to respect the cap.
	/// </summary>
	/// <remarks>
	/// If you want to use mana, use <see cref="M:Terraria.Player.CheckMana(Terraria.Item,System.Int32,System.Boolean,System.Boolean)" /> or its overload.
	/// </remarks>
	public int statMana;

	/// <summary>
	/// The maximum mana this player can have without adjustment.
	/// <br /> You should <strong>not</strong> modify this value. If you need to increase max mana for equipment, modify <see cref="F:Terraria.Player.statManaMax2" />. If you need to increase max mana for a permanent stat boost, use <see cref="M:Terraria.ModLoader.ModPlayer.ModifyMaxStats(Terraria.ModLoader.StatModifier@,Terraria.ModLoader.StatModifier@)" />.
	/// </summary>
	public int statManaMax;

	/// <summary>
	/// The maximum mana this player can have, adjusted by buffs and equipment.
	/// </summary>
	public int statManaMax2;

	/// <summary>
	/// The rate of this player's life regeneration in health per tick, divided by <c>120</c>. To put it another way, it is health regeneration every 2 seconds. Used to implement the damage over time of debuffs and life regeneration accessories such as <see cref="F:Terraria.ID.ItemID.BandofRegeneration" />.
	/// <br /> For example, adding <c>10</c> to this value regenerates <c>10 / 120</c> = <c>1/6</c> health per tick, or 5 health per second.
	/// <br /> Life regeneration is accumulated every tick in <see cref="F:Terraria.Player.lifeRegenCount" />.
	/// <br /> This value should be subtracted from in <see cref="M:Terraria.ModLoader.ModPlayer.UpdateBadLifeRegen" /> and added to in <see cref="M:Terraria.ModLoader.ModPlayer.UpdateLifeRegen" />.
	/// </summary>
	public int lifeRegen;

	/// <summary>
	/// This player's accumulated life regeneration.
	/// <br /> If this value reaches or exceeds <c>120</c>, the player gains <c><see cref="F:Terraria.Player.lifeRegenCount" /> / 120</c> health and this value decreases until it no longer exceeds <c>120</c>.
	/// <br /> If this value reaches or exceeds <c>-120</c>, the player loses health in the same way.
	/// <br /> In either case, text will appear above the player indicating the life regeneration or life loss.
	/// </summary>
	public int lifeRegenCount;

	/// <summary>
	/// How effective this player's natural life regeneration should be. Resets whenever the player is hurt, increases over time.
	/// <br /> Certain effects increase this value to increase
	/// </summary>
	/// <remarks>
	/// Use <see cref="M:Terraria.ModLoader.ModPlayer.NaturalLifeRegen(System.Single@)" /> to directly modify natural life regeneration.
	/// </remarks>
	public float lifeRegenTime;

	public int manaRegen;

	public int manaRegenCount;

	public float manaRegenDelay;

	public bool manaRegenBuff;

	public bool noKnockback;

	public bool shimmerImmune;

	public bool spaceGun;

	/// <summary> The players gravity direction. <b>1</b> if normal, <b>-1</b> if reversed. <para /> Defaults to <b>1</b>.</summary>
	public float gravDir = 1f;

	/// <summary> Applies the "20% chance to save ammo" effect (20% ammo conservation) specific to Chlorophyte Helmet. <AmmoConservation>
	/// 		<br /><br /> Ammo conservation effects stack, each is treated as an independent event (random chance decision). See the <see href="https://terraria.wiki.gg/wiki/Ammo_conservation">Ammo conservation wiki page</see> for more information.
	/// 		<br /><br /> Using existing effect bools like <see cref="F:Terraria.Player.ammoCost75" />, <see cref="F:Terraria.Player.ammoCost80" />, <see cref="F:Terraria.Player.chloroAmmoCost80" />, and <see cref="F:Terraria.Player.huntressAmmoCost90" /> can be convenient, but will not provide additional stacking benefit if the player is also using the Terraria accessory that provides that bonus already. The chances are also not customizable.
	/// 		<br /><br /> To implement ammo conservation in an accessory, armor, or buff, override <see cref="M:Terraria.ModLoader.ModPlayer.CanConsumeAmmo(Terraria.Item,Terraria.Item)" /> (and optionally <see cref="M:Terraria.ModLoader.GlobalItem.ConsumeItem(Terraria.Item,Terraria.Player)" /> if you want to apply the effect to consumable weapons). For a weapon, override <see cref="M:Terraria.ModLoader.ModItem.CanConsumeAmmo(Terraria.Item,Terraria.Player)" />.
	/// 	</AmmoConservation> </summary>
	public bool chloroAmmoCost80;

	/// <summary> Applies the "10% chance to save ammo" effect (10% ammo conservation). <AmmoConservation>
	/// 		<br /><br /> Ammo conservation effects stack, each is treated as an independent event (random chance decision). See the <see href="https://terraria.wiki.gg/wiki/Ammo_conservation">Ammo conservation wiki page</see> for more information.
	/// 		<br /><br /> Using existing effect bools like <see cref="F:Terraria.Player.ammoCost75" />, <see cref="F:Terraria.Player.ammoCost80" />, <see cref="F:Terraria.Player.chloroAmmoCost80" />, and <see cref="F:Terraria.Player.huntressAmmoCost90" /> can be convenient, but will not provide additional stacking benefit if the player is also using the Terraria accessory that provides that bonus already. The chances are also not customizable.
	/// 		<br /><br /> To implement ammo conservation in an accessory, armor, or buff, override <see cref="M:Terraria.ModLoader.ModPlayer.CanConsumeAmmo(Terraria.Item,Terraria.Item)" /> (and optionally <see cref="M:Terraria.ModLoader.GlobalItem.ConsumeItem(Terraria.Item,Terraria.Player)" /> if you want to apply the effect to consumable weapons). For a weapon, override <see cref="M:Terraria.ModLoader.ModItem.CanConsumeAmmo(Terraria.Item,Terraria.Player)" />.
	/// 	</AmmoConservation> </summary>
	public bool huntressAmmoCost90;

	/// <summary> Applies the "20% chance to save ammo" effect (20% ammo conservation). <AmmoConservation>
	/// 		<br /><br /> Ammo conservation effects stack, each is treated as an independent event (random chance decision). See the <see href="https://terraria.wiki.gg/wiki/Ammo_conservation">Ammo conservation wiki page</see> for more information.
	/// 		<br /><br /> Using existing effect bools like <see cref="F:Terraria.Player.ammoCost75" />, <see cref="F:Terraria.Player.ammoCost80" />, <see cref="F:Terraria.Player.chloroAmmoCost80" />, and <see cref="F:Terraria.Player.huntressAmmoCost90" /> can be convenient, but will not provide additional stacking benefit if the player is also using the Terraria accessory that provides that bonus already. The chances are also not customizable.
	/// 		<br /><br /> To implement ammo conservation in an accessory, armor, or buff, override <see cref="M:Terraria.ModLoader.ModPlayer.CanConsumeAmmo(Terraria.Item,Terraria.Item)" /> (and optionally <see cref="M:Terraria.ModLoader.GlobalItem.ConsumeItem(Terraria.Item,Terraria.Player)" /> if you want to apply the effect to consumable weapons). For a weapon, override <see cref="M:Terraria.ModLoader.ModItem.CanConsumeAmmo(Terraria.Item,Terraria.Player)" />.
	/// 	</AmmoConservation> </summary>
	public bool ammoCost80;

	/// <summary> Applies the "25% chance to save ammo" effect (25% ammo conservation). <AmmoConservation>
	/// 		<br /><br /> Ammo conservation effects stack, each is treated as an independent event (random chance decision). See the <see href="https://terraria.wiki.gg/wiki/Ammo_conservation">Ammo conservation wiki page</see> for more information.
	/// 		<br /><br /> Using existing effect bools like <see cref="F:Terraria.Player.ammoCost75" />, <see cref="F:Terraria.Player.ammoCost80" />, <see cref="F:Terraria.Player.chloroAmmoCost80" />, and <see cref="F:Terraria.Player.huntressAmmoCost90" /> can be convenient, but will not provide additional stacking benefit if the player is also using the Terraria accessory that provides that bonus already. The chances are also not customizable.
	/// 		<br /><br /> To implement ammo conservation in an accessory, armor, or buff, override <see cref="M:Terraria.ModLoader.ModPlayer.CanConsumeAmmo(Terraria.Item,Terraria.Item)" /> (and optionally <see cref="M:Terraria.ModLoader.GlobalItem.ConsumeItem(Terraria.Item,Terraria.Player)" /> if you want to apply the effect to consumable weapons). For a weapon, override <see cref="M:Terraria.ModLoader.ModItem.CanConsumeAmmo(Terraria.Item,Terraria.Player)" />.
	/// 	</AmmoConservation> </summary>
	public bool ammoCost75;

	public int stickyBreak;

	public bool magicQuiver;

	public bool magmaStone;

	/// <summary> Reduces damage from touching lava and halves the duration of lava inflicted <see cref="F:Terraria.ID.BuffID.OnFire" />, such as given by <see cref="F:Terraria.ID.ItemID.ObsidianRose" /> and many other items. </summary>
	public bool lavaRose;

	public bool hasMoltenQuiver;

	public int phantasmTime;

	/// <summary> Applies the "20% chance to save ammo" effect (20% ammo conservation) specific to <see cref="F:Terraria.ID.BuffID.AmmoBox" />. Does not apply to consumables. <AmmoConservation>
	/// 		<br /><br /> Ammo conservation effects stack, each is treated as an independent event (random chance decision). See the <see href="https://terraria.wiki.gg/wiki/Ammo_conservation">Ammo conservation wiki page</see> for more information.
	/// 		<br /><br /> Using existing effect bools like <see cref="F:Terraria.Player.ammoCost75" />, <see cref="F:Terraria.Player.ammoCost80" />, <see cref="F:Terraria.Player.chloroAmmoCost80" />, and <see cref="F:Terraria.Player.huntressAmmoCost90" /> can be convenient, but will not provide additional stacking benefit if the player is also using the Terraria accessory that provides that bonus already. The chances are also not customizable.
	/// 		<br /><br /> To implement ammo conservation in an accessory, armor, or buff, override <see cref="M:Terraria.ModLoader.ModPlayer.CanConsumeAmmo(Terraria.Item,Terraria.Item)" /> (and optionally <see cref="M:Terraria.ModLoader.GlobalItem.ConsumeItem(Terraria.Item,Terraria.Player)" /> if you want to apply the effect to consumable weapons). For a weapon, override <see cref="M:Terraria.ModLoader.ModItem.CanConsumeAmmo(Terraria.Item,Terraria.Player)" />.
	/// 	</AmmoConservation> </summary>
	public bool ammoBox;

	/// <summary> Applies the "20% chance to save ammo" effect (20% ammo conservation) specific to <see cref="F:Terraria.ID.BuffID.AmmoReservation" />. Does not apply to consumables. <AmmoConservation>
	/// 		<br /><br /> Ammo conservation effects stack, each is treated as an independent event (random chance decision). See the <see href="https://terraria.wiki.gg/wiki/Ammo_conservation">Ammo conservation wiki page</see> for more information.
	/// 		<br /><br /> Using existing effect bools like <see cref="F:Terraria.Player.ammoCost75" />, <see cref="F:Terraria.Player.ammoCost80" />, <see cref="F:Terraria.Player.chloroAmmoCost80" />, and <see cref="F:Terraria.Player.huntressAmmoCost90" /> can be convenient, but will not provide additional stacking benefit if the player is also using the Terraria accessory that provides that bonus already. The chances are also not customizable.
	/// 		<br /><br /> To implement ammo conservation in an accessory, armor, or buff, override <see cref="M:Terraria.ModLoader.ModPlayer.CanConsumeAmmo(Terraria.Item,Terraria.Item)" /> (and optionally <see cref="M:Terraria.ModLoader.GlobalItem.ConsumeItem(Terraria.Item,Terraria.Player)" /> if you want to apply the effect to consumable weapons). For a weapon, override <see cref="M:Terraria.ModLoader.ModItem.CanConsumeAmmo(Terraria.Item,Terraria.Player)" />.
	/// 	</AmmoConservation> </summary>
	public bool ammoPotion;

	public bool chaosState;

	/// <summary>
	/// If <see langword="true" />, then the bees created by <see cref="F:Terraria.Player.honeyCombItem" /> have a chance to be stronger.
	/// </summary>
	public bool strongBees;

	public bool sporeSac;

	public bool shinyStone;

	public bool empressBrooch;

	public bool volatileGelatin;

	public int volatileGelatinCounter;

	public bool hasMagiluminescence;

	public bool shadowArmor;

	public bool dontStarveShader;

	public bool eyebrellaCloud;

	public int yoraiz0rEye;

	public bool yoraiz0rDarkness;

	public bool hasUnicornHorn;

	public bool hasAngelHalo;

	public bool hasRainbowCursor;

	public bool leinforsHair;

	public bool stardustMonolithShader;

	public bool nebulaMonolithShader;

	public bool vortexMonolithShader;

	public bool solarMonolithShader;

	public bool moonLordMonolithShader;

	public bool bloodMoonMonolithShader;

	public bool shimmerMonolithShader;

	public int overrideFishingBobber = -1;

	public bool unlockedBiomeTorches;

	public bool ateArtisanBread;

	/// <summary>
	/// If <see langword="true" />, then this player has permanently buffed their minecarts. See <see cref="P:Terraria.Player.UsingSuperCart" /> for more info.
	/// </summary>
	public bool unlockedSuperCart;

	/// <summary>
	/// If <see langword="true" />, then this player has the effects of the Super Cart enabled. See <see cref="P:Terraria.Player.UsingSuperCart" /> for more info.
	/// </summary>
	public bool enabledSuperCart = true;

	public bool suspiciouslookingTentacle;

	public bool crimsonHeart;

	public bool lightOrb;

	public bool blueFairy;

	public bool redFairy;

	public bool greenFairy;

	public bool bunny;

	public bool turtle;

	public bool eater;

	public bool penguin;

	public bool HasGardenGnomeNearby;

	public bool magicLantern;

	public bool rabid;

	public bool sunflower;

	public bool wellFed;

	public bool puppy;

	public bool grinch;

	public bool miniMinotaur;

	public bool flowerBoots;

	public bool fairyBoots;

	public bool hellfireTreads;

	public bool moonLordLegs;

	public bool arcticDivingGear;

	public bool coolWhipBuff;

	public bool wearsRobe;

	public bool minecartLeft;

	public bool onWrongGround;

	public bool onTrack;

	public int cartRampTime;

	public bool cartFlip;

	public float trackBoost;

	public Vector2 lastBoost = Vector2.Zero;

	/// <summary>
	/// This player's <see cref="T:Terraria.Mount" />.
	/// <br /> <strong>Do not overwrite this value.</strong> Instead, call <see cref="M:Terraria.Mount.SetMount(System.Int32,Terraria.Player,System.Boolean)" /> or <see cref="M:Terraria.Mount.Dismount(Terraria.Player)" /> on it.
	/// <para /> Check <see cref="P:Terraria.Mount.Active" /> (via <c>Player.mount.Active</c>) to determine if the player is currently using a mount.
	/// </summary>
	public Mount mount;

	public bool blackCat;

	public bool spider;

	public bool squashling;

	public bool petFlagDD2Gato;

	public bool petFlagDD2Ghost;

	public bool petFlagDD2Dragon;

	public bool petFlagUpbeatStar;

	public bool petFlagSugarGlider;

	public bool petFlagBabyShark;

	public bool petFlagLilHarpy;

	public bool petFlagFennecFox;

	public bool petFlagGlitteryButterfly;

	public bool petFlagBabyImp;

	public bool petFlagBabyRedPanda;

	public bool petFlagPlantero;

	public bool petFlagDynamiteKitten;

	public bool petFlagBabyWerewolf;

	public bool petFlagShadowMimic;

	public bool petFlagVoltBunny;

	public bool petFlagKingSlimePet;

	public bool petFlagEyeOfCthulhuPet;

	public bool petFlagEaterOfWorldsPet;

	public bool petFlagBrainOfCthulhuPet;

	public bool petFlagSkeletronPet;

	public bool petFlagQueenBeePet;

	public bool petFlagDestroyerPet;

	public bool petFlagTwinsPet;

	public bool petFlagSkeletronPrimePet;

	public bool petFlagPlanteraPet;

	public bool petFlagGolemPet;

	public bool petFlagDukeFishronPet;

	public bool petFlagLunaticCultistPet;

	public bool petFlagMoonLordPet;

	public bool petFlagFairyQueenPet;

	public bool petFlagPumpkingPet;

	public bool petFlagEverscreamPet;

	public bool petFlagIceQueenPet;

	public bool petFlagMartianPet;

	public bool petFlagDD2OgrePet;

	public bool petFlagDD2BetsyPet;

	public bool petFlagQueenSlimePet;

	public bool petFlagBerniePet;

	public bool petFlagGlommerPet;

	public bool petFlagDeerclopsPet;

	public bool petFlagPigPet;

	public bool petFlagChesterPet;

	public bool petFlagJunimoPet;

	public bool petFlagBlueChickenPet;

	public bool petFlagSpiffo;

	public bool petFlagCaveling;

	public bool petFlagDirtiestBlock;

	public bool companionCube;

	public bool babyFaceMonster;

	public bool magicCuffs;

	public bool coldDash;

	public bool sailDash;

	public bool desertDash;

	/// <summary> Grants the player increased movement speed while running on sand </summary>
	public bool desertBoots;

	public bool eyeSpring;

	public bool snowman;

	public bool scope;

	public bool dino;

	public bool skeletron;

	public bool hornet;

	public bool zephyrfish;

	public bool tiki;

	public bool parrot;

	public bool truffle;

	public bool sapling;

	public bool cSapling;

	public bool wisp;

	public bool lizard;

	public bool archery;

	public bool poisoned;

	public bool venom;

	public bool blind;

	public bool blackout;

	public bool headcovered;

	public bool frostBurn;

	public bool onFrostBurn;

	public bool onFrostBurn2;

	public bool burned;

	public bool shimmering;

	public int timeShimmering;

	public float shimmerTransparency;

	public ShimmerUnstuckHelper shimmerUnstuckHelper;

	public bool suffocating;

	public byte suffocateDelay;

	public bool dripping;

	public bool drippingSlime;

	public bool drippingSparkleSlime;

	public bool onFire;

	public bool onFire2;

	public bool onFire3;

	/// <summary>
	/// When true, the player is unable to use items. Also causes the player to be drawn slightly faded. Used by <see cref="F:Terraria.ID.BuffID.Cursed" /> and <see cref="F:Terraria.ID.MountID.Drill" />.
	/// <br /><br /> Checked wherever items are being attempted to being used. Held projectiles should check this to interrupt their usage if needed.
	/// </summary>
	public bool noItems;

	public bool cursed;

	public bool hungry;

	public bool starving;

	public bool heartyMeal;

	public bool windPushed;

	public bool wereWolf;

	public bool wolfAcc;

	public bool hideMerman;

	public bool hideWolf;

	public bool forceMerman;

	public bool forceWerewolf;

	public bool rulerGrid;

	public bool rulerLine;

	public bool bleed;

	public bool confused;

	public bool accMerman;

	public bool merman;

	public bool trident;

	public bool brokenArmor;

	public bool silence;

	public bool slow;

	public bool gross;

	public bool tongued;

	public bool kbGlove;

	public bool autoReuseGlove;

	public bool meleeScaleGlove;

	public bool kbBuff;

	public bool remoteVisionForDrone;

	public Item starCloakItem;

	public Item starCloakItem_manaCloakOverrideItem;

	public Item starCloakItem_starVeilOverrideItem;

	public Item starCloakItem_beeCloakOverrideItem;

	public bool longInvince;

	public bool pStone;

	public static readonly float PhilosopherStoneDurationMultiplier = 0.75f;

	public bool manaFlower;

	public bool moonLeech;

	public bool vortexDebuff;

	public bool trapDebuffSource;

	public bool witheredArmor;

	public bool witheredWeapon;

	public bool slowOgreSpit;

	public bool parryDamageBuff;

	public bool ballistaPanic;

	public bool JustDroppedAnItem;

	public StatModifier arrowDamage = StatModifier.Default;

	public StatModifier bulletDamage = StatModifier.Default;

	public StatModifier specialistDamage = StatModifier.Default;

	/// <summary>
	/// The multiplier on this player's <see cref="F:Terraria.Player.maxRunSpeed" /> and <see cref="F:Terraria.Player.runAcceleration" />. This affects how quickly the player reaches max speed as well as the max speed itself.
	/// This is typically modified in <see cref="M:Terraria.ModLoader.ModBuff.Update(Terraria.Player,System.Int32@)" />, <see cref="M:Terraria.ModLoader.ModItem.UpdateEquip(Terraria.Player)" />, <see cref="M:Terraria.ModLoader.ModItem.UpdateAccessory(Terraria.Player,System.Boolean)" />, or <see cref="M:Terraria.ModLoader.ModPlayer.PostUpdateMiscEffects" />. <see cref="M:Terraria.ModLoader.ModPlayer.PostUpdateRunSpeeds" /> is too late to have any effect.
	/// <para /> Defaults to 1f. Effects typically add to or subtract from this, typically expressed as "X% increased movement speed" in tooltips. Some examples:
	/// <para /> Swiftness potion (<see cref="F:Terraria.ID.BuffID.Swiftness" />): <c>+= 0.25f</c>
	/// <br /> Webbed buff (<see cref="F:Terraria.ID.BuffID.Webbed" />): <c>= 0f</c>
	/// <br /> Titanium Leggings: <c>+= 0.06f</c>
	/// <br /> Frostspark Boots: <c>+= 0.08f</c>
	/// <para /> Some effects apply multiplicatively, these must be applied later on in the update process to work correctly, <see cref="M:Terraria.ModLoader.ModPlayer.PostUpdateMiscEffects" /> or <see cref="M:Terraria.ModLoader.ModPlayer.UpdateBadLifeRegen" /> are suitable places for this. Some examples:
	/// <para /> Oozed buff (<see cref="F:Terraria.Player.slowOgreSpit" />): <c>*= 1/3f</c>
	/// <br /> Slow buff (<see cref="F:Terraria.Player.slow" />): <c>*= 0.5f</c>
	/// <br /> Chilled buff (<see cref="F:Terraria.Player.chilled" />): <c>*= 0.75f</c>
	/// </summary>
	public float moveSpeed = 1f;

	/// <summary> The multiplier on this player's mining speed. For this multiplier smaller values means faster. For example the Mining Potion decreases this by .25f (25%). </summary>
	public float pickSpeed = 1f;

	/// <summary> The multiplier on this player's wall placement speed. For example the Builder Potion increases this by .25f (25%). </summary>
	public float wallSpeed = 1f;

	/// <summary> The multiplier on this player's tile placement speed. For example the Builder Potion increases this by .25f (25%). </summary>
	public float tileSpeed = 1f;

	public bool autoPaint;

	public bool autoActuator;

	/// <summary>
	/// The x tile coordinate of the bed spawn location for this player in this world. When -1 <see cref="F:Terraria.Main.spawnTileX" /> is used instead.
	/// </summary>
	public int SpawnX = -1;

	/// <summary>
	/// The y tile coordinate of the bed spawn location for this player in this world. When -1 <see cref="F:Terraria.Main.spawnTileY" /> is used instead.
	/// </summary>
	public int SpawnY = -1;

	public Vector2? PotionOfReturnOriginalUsePosition;

	public Vector2? PotionOfReturnHomePosition;

	public int[] spX = new int[200];

	public int[] spY = new int[200];

	public string[] spN = new string[200];

	public int[] spI = new int[200];

	/// <summary>
	/// The block placement and tool range. Controls how many tiles away from the player the player can place tiles/walls or target with tools. Use <see cref="F:Terraria.Player.blockRange" /> for placement-specific boosts and <see cref="F:Terraria.Item.tileBoost" /> for item-specific boosts.
	/// <br /><br /> Note that this field is static, so any adjustments to this field need to first check that the effect is for the local player to avoid bugs in multiplayer! (<c>player.whoAmI == Main.myPlayer</c>)
	/// <br /><br /> The Toolbox accessory increases this by 1 directly, but the Extendo Grip, Architect Gizmo Pack, and Hand Of Creation all use <see cref="F:Terraria.Player.equippedAnyTileRangeAcc" /> to increate range by 3 without stacking their effects.
	/// <br /><br /> tileRangeX defaults to 5 and tileRangeY defaults to 4.
	/// </summary>
	public static int tileRangeX = 5;

	/// <inheritdoc cref="F:Terraria.Player.tileRangeX" />
	public static int tileRangeY = 4;

	public int lastTileRangeX;

	public int lastTileRangeY;

	/// <summary>
	/// The tile coordinates of the tile location currently being targeted by the local players cursor for left click purposes. Since this takes into account the smart cursor feature, it isn't necessarily the tile directly under the cursor. For right clicks, see <see cref="F:Terraria.Main.SmartInteractX" />
	/// </summary>
	public static int tileTargetX;

	/// <inheritdoc cref="F:Terraria.Player.tileTargetX" />
	public static int tileTargetY;

	public static float defaultGravity = 0.4f;

	public static int jumpHeight = 15;

	/// <summary>
	/// The speed, in pixels/tick, that this players jumps at.
	/// </summary>
	public static float jumpSpeed = 5.01f;

	public float gravity = defaultGravity;

	public float maxFallSpeed = 10f;

	/// <summary>
	/// The maximum speed, in pixels/tick, that this player can reach by just running. The acceleration to that speed is a separate stat (<see cref="F:Terraria.Player.runAcceleration" />).
	/// <para /> This should only be modified in <see cref="M:Terraria.ModLoader.ModPlayer.PostUpdateRunSpeeds" />, <see cref="M:Terraria.ModLoader.ModItem.HorizontalWingSpeeds(Terraria.Player,System.Single@,System.Single@)" />, or <see cref="M:Terraria.ModLoader.ExtraJump.UpdateHorizontalSpeeds(Terraria.Player)" /> to correctly function. <see cref="F:Terraria.Player.accRunSpeed" /> is commonly adjusted in tandem if suitable.
	/// <para /> Defaults to 3f, which is then multiplied by <see cref="F:Terraria.Player.moveSpeed" />. Effects typically multiply this by some factor. Some examples:
	/// <para /> On ice with Ice Skates: <c>*= 1.25f</c>
	/// <br /> On honey block (<see cref="F:Terraria.Player.sticky" />): <c>*= 0.25f</c>
	/// <br /> On asphalt block (<see cref="F:Terraria.Player.powerrun" />): <c>*= 3.5f</c>
	/// <br /> Shadow Armor (<see cref="F:Terraria.Player.shadowArmor" />): <c>*= 1.15f</c>
	/// <br /> Extra jumps: Typically <c>*= 1.5f</c>, see <see cref="M:Terraria.ModLoader.ExtraJump.UpdateHorizontalSpeeds(Terraria.Player)" />
	/// <para /> When on a mount, all other modifiers are ignored and it is set to <see cref="P:Terraria.Mount.RunSpeed" />
	/// </summary>
	/// <remarks>To apply a global run speed modifier, use <see cref="F:Terraria.Player.moveSpeed" />.</remarks>
	public float maxRunSpeed = 3f;

	/// <summary>
	/// The acceleration, in pixels/ticks^2, that this player experiences while running. This affects how quickly the player reaches max speed, not the max speed (<see cref="F:Terraria.Player.maxRunSpeed" />) itself.
	/// <para /> This should only be modified in <see cref="M:Terraria.ModLoader.ModPlayer.PostUpdateRunSpeeds" />, <see cref="M:Terraria.ModLoader.ModItem.HorizontalWingSpeeds(Terraria.Player,System.Single@,System.Single@)" />, or <see cref="M:Terraria.ModLoader.ExtraJump.UpdateHorizontalSpeeds(Terraria.Player)" /> to correctly function.
	/// <para /> Defaults to 0.08f, which is then multiplied by <see cref="F:Terraria.Player.moveSpeed" />. Effects typically multiply this by some factor. Some examples:
	/// <para /> On ice (<see cref="F:Terraria.Player.slippy" />): <c>*= 0.7f</c> (or <c>*= 2.1f</c> if wearing Ice Skates)
	/// <br /> On honey block (<see cref="F:Terraria.Player.sticky" />): <c>*= 0.25f</c>
	/// <br /> Shadow Armor (<see cref="F:Terraria.Player.shadowArmor" />): <c>*= 1.75f</c>
	/// <br /> Wings: <c>*= <see cref="F:Terraria.DataStructures.WingStats.AccRunAccelerationMult" /></c>
	/// <br /> Extra jumps: Typically <c>*= 3f</c>, see <see cref="M:Terraria.ModLoader.ExtraJump.UpdateHorizontalSpeeds(Terraria.Player)" />
	/// <para /> When on a mount, all other modifiers are ignored and it is set to <see cref="P:Terraria.Mount.Acceleration" />
	/// </summary>
	/// <remarks>To apply a global run speed modifier, use <see cref="F:Terraria.Player.moveSpeed" />.</remarks>
	public float runAcceleration = 0.08f;

	public float runSlowdown = 0.2f;

	/// <summary> True if the player is within crafting range of a tile with water or a <see cref="F:Terraria.ID.TileID.Sets.CountsAsWaterSource" /> tile. (adjWater stands for adjacent to water) </summary>
	public bool adjWater;

	/// <summary> True if the player is within crafting range of a tile with honey or a <see cref="F:Terraria.ID.TileID.Sets.CountsAsHoneySource" /> tile. (adjHoney stands for adjacent to honey) </summary>
	public bool adjHoney;

	/// <summary> True if the player is within crafting range of a tile with shimmer or a <see cref="F:Terraria.ID.TileID.Sets.CountsAsShimmerSource" /> tile. (adjShimmer stands for adjacent to shimmer) </summary>
	public bool adjShimmer;

	/// <summary> True if the player is within crafting range of a tile with lava or a <see cref="F:Terraria.ID.TileID.Sets.CountsAsLavaSource" /> tile. (adjLava stands for adjacent to lava) </summary>
	public bool adjLava;

	public bool oldAdjWater;

	public bool oldAdjHoney;

	public bool oldAdjLava;

	public bool oldAdjShimmer;

	private bool[] _adjTile = new bool[TileLoader.TileCount];

	private bool[] _oldAdjTile = new bool[TileLoader.TileCount];

	public static int defaultItemGrabRange = 42;

	private static float itemGrabSpeed = 0.45f;

	private static float itemGrabSpeedMax = 4f;

	public int hairDye;

	public Color hairDyeColor = Color.Transparent;

	public float hairDyeVar;

	public int skinDyePacked;

	public Color hairColor = new Color(215, 90, 55);

	public Color skinColor = new Color(255, 125, 90);

	public Color eyeColor = new Color(105, 90, 75);

	public Color shirtColor = new Color(175, 165, 140);

	public Color underShirtColor = new Color(160, 180, 215);

	public Color pantsColor = new Color(255, 230, 175);

	public Color shoeColor = new Color(160, 105, 60);

	public int hair;

	/// <summary> If true, the player has PvP enabled </summary>
	public bool hostile;

	public SoundPlaySet hermesStepSound = new SoundPlaySet();

	public Vector2 instantMovementAccumulatedThisFrame;

	public int accCompass;

	public int accWatch;

	public int accDepthMeter;

	public bool accFishFinder;

	public bool accWeatherRadio;

	public bool accJarOfSouls;

	public bool accCalendar;

	/// <summary>
	/// The BannerID of the last npc damaged by this player. Used by the <see cref="F:Terraria.ID.ItemID.TallyCounter" /> to display the name of the last attacked enemy. When attacking an enemy without an assigned banner, the value will be 0 and "Kill count unavailable" will be shown.
	/// </summary>
	public int lastCreatureHit = -1;

	public bool accThirdEye;

	public byte accThirdEyeCounter;

	public byte accThirdEyeNumber;

	public bool accStopwatch;

	public bool accOreFinder;

	public bool accCritterGuide;

	public byte accCritterGuideCounter;

	public byte accCritterGuideNumber;

	public bool accDreamCatcher;

	public bool hasFootball;

	public bool drawingFootball;

	public bool ActuationRodLock;

	public bool ActuationRodLockSetting;

	public bool InfoAccMechShowWires;

	public DateTime dpsStart;

	public DateTime dpsEnd;

	public DateTime dpsLastHit;

	public int dpsDamage;

	public bool dpsStarted;

	public string displayedFishingInfo = "";

	public bool discountEquipped;

	public bool discountAvailable;

	public bool hasLuckyCoin;

	public Item boneGloveItem;

	public bool goldRing;

	public bool accDivingHelm;

	public bool hasLuck_LuckyCoin;

	public bool hasLuck_LuckyHorseshoe;

	public bool isPerformingPogostickTricks;

	public bool autoJump;

	public bool justJumped;

	/// <summary>
	/// How much to directly increase <see cref="F:Terraria.Player.jumpSpeed" />, in pixels/tick.
	/// </summary>
	public float jumpSpeedBoost;

	/// <summary>
	/// The number of extra tiles this player can fall before they start taking fall damage. For example <see cref="F:Terraria.ID.ItemID.FrogLeg" /> adds 10 to extraFall.
	/// </summary>
	/// <remarks>
	/// If you want to prevent fall damage entirely, use <see cref="F:Terraria.Player.noFallDmg" />.
	/// </remarks>
	public int extraFall;

	public bool canFloatInWater;

	public bool hasFloatingTube;

	public bool frogLegJumpBoost;

	public bool skyStoneEffects;

	public bool spawnMax;

	/// <summary>
	/// The extra block placement range. Toolbelt and Builder Potion both increase this by 1. This will be combined with <see cref="F:Terraria.Player.tileRangeX" />/Y and <see cref="F:Terraria.Item.tileBoost" /> to determine the total block placement range for the held item.
	/// <br /><br /> Defaults to 0.
	/// </summary>
	public int blockRange;

	public int[] grappling = new int[20];

	public int grapCount;

	public int rocketTime;

	public int rocketTimeMax = 7;

	public int rocketDelay;

	public int rocketDelay2;

	public int rocketSoundDelay;

	public bool rocketRelease;

	public bool rocketFrame;

	/// <summary> If greater than 0, the player can briefly fly using rocket boots. Is usually set to the same value as <see cref="F:Terraria.Player.vanityRocketBoots" /> </summary>
	public int rocketBoots;

	/// <summary> Controls which rocket boots visuals and sounds will be used: <para /> 1: Rocket Boots <br /> 2: Fairy Boots (plus <see cref="F:Terraria.Player.fairyBoots" />), Spectre Boots, Lightning Boots <br /> 3: Frostspark Boots <br /> 4: Terraspark Boots <br /> 5: Hellfire Treads </summary>
	public int vanityRocketBoots;

	public bool canRocket;

	public bool jumpBoost;

	/// <summary>
	/// If <see langword="true" />, this player will take no fall damage, such as the effect given by <see cref="F:Terraria.ID.ItemID.LuckyHorseshoe" />.
	/// <para /> If you want to increase the fall height required for fall damage, use <see cref="F:Terraria.Player.extraFall" /> instead.
	/// </summary>
	public bool noFallDmg;

	public int swimTime;

	public bool killGuide;

	public bool killClothier;

	public float equipmentBasedLuckBonus;

	public float lastEquipmentBasedLuckBonus;

	public bool hasCreditsSceneMusicBox;

	/// <summary> Complete lava immunity, such as given by <see cref="F:Terraria.ID.ItemID.ObsidianSkinPotion" />. </summary>
	public bool lavaImmune;

	public bool gills;

	public bool slowFall;

	public bool findTreasure;

	public bool biomeSight;

	public bool invis;

	public bool detectCreature;

	public bool nightVision;

	public bool enemySpawns;

	public float thorns;

	public bool turtleArmor;

	public bool turtleThorns;

	public bool cactusThorns;

	public bool spiderArmor;

	public bool anglerSetSpawnReduction;

	public bool CanSeeInvisibleBlocks;

	public bool setSolar;

	public bool setVortex;

	public bool setNebula;

	public int nebulaCD;

	public bool setStardust;

	public bool setForbidden;

	public bool setForbiddenCooldownLocked;

	public bool setSquireT3;

	public bool setHuntressT3;

	public bool setApprenticeT3;

	public bool setMonkT3;

	public bool setSquireT2;

	public bool setHuntressT2;

	public bool setApprenticeT2;

	public bool setMonkT2;

	public int maxTurrets = 1;

	public int maxTurretsOld = 1;

	public bool vortexStealthActive;

	/// <summary> Allows the player to walk on water, honey, and shimmer, such as given by <see cref="F:Terraria.ID.ItemID.WaterWalkingBoots" />. </summary>
	public bool waterWalk;

	/// <summary> Allows the player to walk on water, honey, lava, and shimmer, such as given by <see cref="F:Terraria.ID.ItemID.LavaWaders" />. </summary>
	public bool waterWalk2;

	public int forcedGravity;

	public bool gravControl;

	public bool gravControl2;

	/// <summary>
	/// If not <see langword="null" />, this player will create damaging bee projectiles when taking damage.
	/// </summary>
	public Item honeyCombItem;

	public int wireOperationsCooldown;

	public int lastChest;

	public TrackedProjectileReference piggyBankProjTracker;

	public TrackedProjectileReference voidLensChest;

	/// <summary>
	/// Represents the chest the player currently has open. If -1, the player has no chest open.<br />
	/// Positive values indicate the index of the chest in <see cref="F:Terraria.Main.chest" /> the player currently has open.<br />
	/// Negative values are used to indicate additional inventories: Piggy Bank (-2), Safe (-3), Defender's Forge (-4), Void Vault (-5)
	/// </summary>
	public int chest = -1;

	public int chestX;

	public int chestY;

	public int fallStart;

	public int fallStart2;

	public int potionDelayTime = Item.potionDelay;

	public int restorationDelayTime = Item.restorationDelay;

	public int mushroomDelayTime = Item.mushroomDelay;

	private bool _batbatCanHeal;

	private bool _spawnTentacleSpikes;

	private bool _spawnBloodButcherer;

	private bool _spawnVolcanoExplosion;

	private bool _spawnMuramasaCut;

	public bool isPettingAnimal;

	public bool isTheAnimalBeingPetSmall;

	public PlayerSittingHelper sitting;

	public PlayerSleepingHelper sleeping;

	public PlayerEyeHelper eyeHelper;

	public PlayerInteractionAnchor tileEntityAnchor;

	public DoorOpeningHelper doorHelper;

	public ShoppingSettings currentShoppingSettings = ShoppingSettings.NotInShop;

	/// <summary>The armor shader ID applied to the <see cref="F:Terraria.ModLoader.EquipType.Head" /> equip texture by a dye item (<see cref="F:Terraria.Item.dye" />) in the dye slot.</summary>
	public int cHead;

	/// <summary>The armor shader ID applied to the <see cref="F:Terraria.ModLoader.EquipType.Body" /> equip texture by a dye item (<see cref="F:Terraria.Item.dye" />) in the dye slot.</summary>
	public int cBody;

	/// <summary>The armor shader ID applied to the <see cref="F:Terraria.ModLoader.EquipType.Legs" /> equip texture by a dye item (<see cref="F:Terraria.Item.dye" />) in the dye slot.</summary>
	public int cLegs;

	public int cHandOn;

	public int cHandOff;

	public int cBack;

	public int cFront;

	public int cShoe;

	public int cWaist;

	public int cShield;

	public int cNeck;

	public int cFace;

	public int cFaceHead;

	public int cFaceFlower;

	public int cBalloon;

	public int cBalloonFront;

	public int cWings;

	public int cCarpet;

	public int cFloatingTube;

	public int cBackpack;

	public int cTail;

	public int cShieldFallback;

	/// <summary>The armor shader ID applied to the Hook equipment slot by a dye item (<see cref="F:Terraria.Item.dye" />) in the dye slot.</summary>
	public int cGrapple;

	/// <summary>The armor shader ID applied to the Mount equipment slot by a dye item (<see cref="F:Terraria.Item.dye" />) in the dye slot.</summary>
	public int cMount;

	/// <summary>The armor shader ID applied to the Minecart equipment slot by a dye item (<see cref="F:Terraria.Item.dye" />) in the dye slot.</summary>
	public int cMinecart;

	/// <summary>The armor shader ID applied to the Pet equipment slot by a dye item (<see cref="F:Terraria.Item.dye" />) in the dye slot.</summary>
	public int cPet;

	/// <summary>The armor shader ID applied to the Light Pet equipment slot by a dye item (<see cref="F:Terraria.Item.dye" />) in the dye slot.</summary>
	public int cLight;

	public int cYorai;

	public int cPortableStool;

	public int cUnicornHorn;

	public int cAngelHalo;

	public int cBeard;

	public int cMinion;

	public int cLeinShampoo;

	public int cFlameWaker;

	/// <summary>
	/// Provides efficient access to the number of projectiles of the specified type owned by this player currently active in the game world.<br />
	/// Can be used to prevent spawning additional projectiles when a limit is reached.<br />
	/// Updated each game update right before Player.UpdateBuffs.<br />
	/// For example, <c>return player.ownedProjectileCounts[Item.shoot] &lt; 1;</c> in <see cref="M:Terraria.ModLoader.ModItem.CanUseItem(Terraria.Player)" /> could prevent a player using the item if the projectile the item spawns is already in the game world for the player.
	/// </summary>
	public int[] ownedProjectileCounts = new int[ProjectileID.Count];

	/// <summary>
	/// Sets the specified NPC types as friendly to this player. Used by <see cref="F:Terraria.ID.ItemID.RoyalGel" />. Friendly NPC won't target or deal contact damage to the player.
	/// </summary>
	public bool[] npcTypeNoAggro = new bool[NPCID.Count];

	public int lastPortalColorIndex;

	public int _portalPhysicsTime;

	public bool portalPhysicsFlag;

	public int lastTeleportPylonStyleUsed;

	public float MountFishronSpecialCounter;

	public Vector2 MinionRestTargetPoint = Vector2.Zero;

	/// <summary>
	/// The index of the NPC targeted by the player, either by right clicking with a summon item (<see cref="F:Terraria.ID.ProjectileID.Sets.MinionTargettingFeature" />) or by hitting the NPC with a whip.
	/// <br /><br /> Will be -1 if there is no current target, or check <see cref="P:Terraria.Player.HasMinionAttackTargetNPC" /> instead.
	/// </summary>
	public int MinionAttackTargetNPC = -1;

	public List<Point> TouchedTiles = new List<Point>();

	/// <summary>
	/// The remaining number of frames the current item animation will last.
	/// <br /><br /> When an item is used, this and <see cref="F:Terraria.Player.itemAnimationMax" /> are set to a value derived from the item's <see cref="F:Terraria.Item.useAnimation" /> and the applicable use animation multipliers, then this counts down towards 0 each game update.
	/// <br /><br /> Note that the item animation (<see cref="F:Terraria.Player.itemAnimation" />) doesn't necessarily match or sync with the item use time. An item being animated does not necessarily mean the item is being "used".
	/// <PlayerItemUseAnimation>
	/// 		<br /><br /> The <see href="https://github.com/tModLoader/tModLoader/wiki/Player-Item-Animation">Player Item Animation wiki page</see> goes into detail about how this and other player item use and animation fields work together and provides a useful overview on this topic.
	/// 	</PlayerItemUseAnimation>
	/// </summary>
	public int itemAnimation;

	/// <summary>
	/// The total number of frames the current item animation will last.
	/// <br /><br /> When an item is used, this and <see cref="F:Terraria.Player.itemAnimation" /> are set to a value derived from the item's <see cref="F:Terraria.Item.useTime" /> and the applicable use animation multipliers, then <see cref="F:Terraria.Player.itemTime" /> counts down towards 0 each game update.
	/// <PlayerItemUseAnimation>
	/// 		<br /><br /> The <see href="https://github.com/tModLoader/tModLoader/wiki/Player-Item-Animation">Player Item Animation wiki page</see> goes into detail about how this and other player item use and animation fields work together and provides a useful overview on this topic.
	/// 	</PlayerItemUseAnimation>
	/// </summary>
	public int itemAnimationMax;

	/// <summary>
	/// The remaining number of frames the current item usage will last.
	/// <br /><br /> When an item is used, this and <see cref="F:Terraria.Player.itemTimeMax" /> are set to a value derived from the item's <see cref="F:Terraria.Item.useTime" /> and the applicable use time multipliers, then this counts down towards 0 each game update.
	/// <br /><br /> Note that the item animation (<see cref="F:Terraria.Player.itemAnimation" />) doesn't necessarily match or sync with the item use time. An item being animated does not necessarily mean the item is being "used".
	/// <br /><br /> <see cref="P:Terraria.Player.ItemTimeIsZero" /> is a helper property to check if this value is 0.
	/// <PlayerItemUseAnimation>
	/// 		<br /><br /> The <see href="https://github.com/tModLoader/tModLoader/wiki/Player-Item-Animation">Player Item Animation wiki page</see> goes into detail about how this and other player item use and animation fields work together and provides a useful overview on this topic.
	/// 	</PlayerItemUseAnimation>
	/// </summary>
	public int itemTime;

	/// <summary>
	/// The total number of frames the current item usage will last.
	/// <br /><br /> When an item is used, this and <see cref="F:Terraria.Player.itemTime" /> are set to a value derived from the item's <see cref="F:Terraria.Item.useTime" /> and the applicable use time multipliers, then <see cref="F:Terraria.Player.itemTime" /> counts down towards 0 each game update.
	/// <PlayerItemUseAnimation>
	/// 		<br /><br /> The <see href="https://github.com/tModLoader/tModLoader/wiki/Player-Item-Animation">Player Item Animation wiki page</see> goes into detail about how this and other player item use and animation fields work together and provides a useful overview on this topic.
	/// 	</PlayerItemUseAnimation>
	/// </summary>
	public int itemTimeMax;

	public int toolTime;

	public static int BlockInteractionWithProjectiles = 3;

	public const int SafeItemAnimationTimeForPreventingExploits = 20;

	private HashSet<Point> _blackListedTileCoordsForGrappling = new HashSet<Point>();

	private bool makeStrongBee;

	/// <summary> Increases <see cref="F:Terraria.Player.tileRangeX" />/Y by 3. Used by Extendo Grip, Architect Gizmo Pack, and Hand Of Creation to increase range without stacking their effects. </summary>
	public bool equippedAnyTileRangeAcc;

	/// <summary> Increases <see cref="F:Terraria.Player.tileSpeed" />/Y by 0.5f (50%). Used by Brick Layer, Architect Gizmo Pack, and Hand Of Creation to increase tile placement speed without stacking their effects. </summary>
	public bool equippedAnyTileSpeedAcc;

	/// <summary> Increases <see cref="F:Terraria.Player.wallSpeed" />/Y by 0.5f (50%). Used by Portable Cement Mixer, Architect Gizmo Pack, and Hand Of Creation to increase wall placement speed without stacking their effects. </summary>
	public bool equippedAnyWallSpeedAcc;

	private static List<NPC> _hallucinationCandidates = new List<NPC>();

	public bool behindBackWall;

	public int _funkytownAchievementCheckCooldown;

	private float _stormShaderObstruction = 1f;

	private float _shaderObstructionInternalValue = 1f;

	private int graveImmediateTime;

	public static float airLightDecay = 1f;

	public static float solidLightDecay = 1f;

	private float _deerclopsBlizzardSmoothedEffect;

	public const int ChairSittingMaxDistance = 40;

	private static SmartInteractSystem _smartInteractSys = new SmartInteractSystem();

	private int _lastSmartCursorToolStrategy = -1;

	private bool[] nearbyTorch = new bool[TorchID.Count];

	private bool dryCoralTorch;

	private int luckyTorchCounter;

	private int nearbyTorches;

	public float torchLuck;

	private Vector2 _nextTorchLuckCheckCenter;

	public bool happyFunTorchTime;

	private int torchFunTimer;

	private int torchGodCooldown;

	private int numberOfTorchAttacksMade;

	private static int maxTorchAttacks = 200;

	private int[] unlitTorchX = new int[maxTorchAttacks];

	private int[] unlitTorchY = new int[maxTorchAttacks];

	private static int[] _torchAttackPosX = new int[400];

	private static int[] _torchAttackPosY = new int[400];

	public double ladyBugLuckTimeLeft;

	public float luck;

	public float luckMinimumCap = -0.7f;

	public float luckMaximumCap = 1f;

	public float coinLuck;

	public bool luckNeedsSync;

	public int disableVoidBag = -1;

	private int _quickGrappleCooldown;

	public PlayerMovementAccsCache movementAbilitiesCache;

	public float wingAccRunSpeed = -1f;

	public float wingRunAccelerationMult = 1f;

	public const int SHIELD_PARRY_DURATION = 20;

	public const int SHIELD_PARRY_DURATION_DRAWING_TWEAKER = 20;

	public const int SHIELD_PARRY_DAMAGE_BUFF_MULTIPLIER = 5;

	public bool hasRaisableShield;

	public bool shieldRaised;

	public int shieldParryTimeLeft;

	public int shield_parry_cooldown;

	private bool _forceForwardCursor;

	private Point _inputMouseCoordsForward;

	private Point _mainMouseCoordsForward;

	private bool _forceSmartSelectCursor;

	private Point _inputMouseCoordsSmartSelect;

	private Point _mainMouseCoordsSmartSelect;

	private Point _tileTargetSmartSelect;

	private bool botherWithUnaimedMinecartTracks = true;

	private List<int> _projectilesToInteractWith = new List<int>();

	private int _lockTileInteractionsTimer;

	public int[] hurtCooldowns = new int[5];

	public static int FlexibleWandRandomSeed;

	public static int FlexibleWandCycleOffset;

	public static Point FlexibleWandLastPosition;

	public static bool lastPound = true;

	private static Point[] _tentacleSpikesMax5 = (Point[])(object)new Point[5];

	private static Point[] _bloodButchererMax5 = (Point[])(object)new Point[5];

	public int[] meleeNPCHitCooldown = new int[200];

	public static int musicNotes = 6;

	public float musicDist;

	private static List<Projectile> _oldestProjCheckList = new List<Projectile>();

	public EquipmentLoadout[] Loadouts = new EquipmentLoadout[3]
	{
		new EquipmentLoadout(),
		new EquipmentLoadout(),
		new EquipmentLoadout()
	};

	public int CurrentLoadoutIndex;

	public SavedPlayerDataWithAnnoyingRules savedPerPlayerFieldsThatArentInThePlayerClass;

	private const int SaveSlotIndex_MouseItem = 0;

	private const int SaveSlotIndex_CreativeSacrifice = 1;

	private const int SaveSlotIndex_GuideItem = 2;

	private const int SaveSlotIndex_TinkererItem = 3;

	private const int SaveSlotIndexCount = 4;

	internal Item[] _temporaryItemSlots = new Item[4];

	private static readonly PlayerFileData _visualCloneDummyData = new PlayerFileData();

	private static readonly MemoryStream _visualCloneStream = new MemoryStream();

	private static readonly BinaryWriter _visualCloneWriter = new BinaryWriter(_visualCloneStream);

	private static readonly BinaryReader _visualCloneReader = new BinaryReader(_visualCloneStream);

	private Player _clientClone;

	internal IList<string> usedMods;

	internal string modPack;

	internal ModPlayer[] modPlayers = Array.Empty<ModPlayer>();

	public Item equippedWings;

	/// <summary>
	/// Set by any gem robe when worn by the player in the functional armor slot. Increases the spawn rate of <see cref="F:Terraria.ID.NPCID.Tim" />.
	/// </summary>
	public bool hasGemRobe;

	/// <summary>
	/// Causes <see cref="M:Terraria.Player.SmartSelectLookup" /> to run the next time an item animation is finished, even if <see cref="F:Terraria.Player.controlUseItem" /> is held. <br />
	/// Used internally by tML to when a hotbar key is pressed while using an item.
	/// </summary>
	public bool selectItemOnNextUse;

	private int consumedLifeCrystals;

	/// <summary>
	/// The maximum amount of Life Crystals this player is allowed to consume total
	/// </summary>
	public const int LifeCrystalMax = 15;

	private int consumedLifeFruit;

	/// <summary>
	/// The maximum amount of Life Fruit this player is allowed to consume total
	/// </summary>
	public const int LifeFruitMax = 20;

	private int consumedManaCrystals;

	/// <summary>
	/// The maximum amount of Mana Crystals this player is allowed to consume total
	/// </summary>
	public const int ManaCrystalMax = 9;

	/// <summary>
	/// How effectively the player can hold their breath underwater. Controls how long it takes for <see cref="F:Terraria.Player.breath" /> to decrease. Breathing Reed adds 1 (100%) to this value and Diving Gear multiplies it by 6.
	/// <para /> Modded effects should add to this instead of multiplying to avoid values getting unreasonable large. Adding 1.5f for example will increase breath time by 150%.
	/// <para /> Applied in the calculation of <see cref="P:Terraria.Player.breathCDMax" />.
	/// </summary>
	public StatModifier breathEffectiveness = StatModifier.Default;

	/// <summary>
	/// Modifies the cooldown of health potions. Can be used to adjust potion cooldown calculations, similar to the Philosopher's Stone.
	/// </summary>
	public StatModifier PotionDelayModifier = StatModifier.Default;

	private DamageClassData[] damageData;

	/// <summary>
	/// Stores whether or not the player is in a modbiome using boolean bits.
	/// </summary>
	internal BitArray modBiomeFlags = new BitArray(0);

	private ExtraJumpState[] extraJumps = new ExtraJumpState[ExtraJumpLoader.ExtraJumpCount];

	/// <summary>
	/// When <see langword="true" />, all extra jumps will be blocked, including Flipper usage.<br />
	/// Setting this field to <see langword="true" /> will not stop any currently active extra jumps.
	/// </summary>
	public bool blockExtraJumps;

	public bool sandStorm
	{
		get
		{
			if (_sandStormLogicEnabled)
			{
				return GetJumpState<SandstormInABottleJump>().Active;
			}
			return false;
		}
		set
		{
			_sandStormLogicEnabled = value;
		}
	}

	internal static int maxBuffs => 44 + BuffLoader.extraPlayerBuffCount;

	public static int MaxBuffs => maxBuffs;

	internal ref float armorPenetration => ref GetArmorPenetration(DamageClass.Generic);

	internal ref float allCrit => ref GetCritChance(DamageClass.Generic);

	internal ref float meleeCrit => ref GetCritChance(DamageClass.Melee);

	internal ref float magicCrit => ref GetCritChance(DamageClass.Magic);

	internal ref float rangedCrit => ref GetCritChance(DamageClass.Ranged);

	internal ref StatModifier allDamage => ref GetDamage(DamageClass.Generic);

	internal ref StatModifier meleeDamage => ref GetDamage(DamageClass.Melee);

	internal ref StatModifier magicDamage => ref GetDamage(DamageClass.Magic);

	internal ref StatModifier rangedDamage => ref GetDamage(DamageClass.Ranged);

	private ref StatModifier arrowDamageAdditiveStack => ref arrowDamage;

	internal ref StatModifier minionDamage => ref GetDamage(DamageClass.Summon);

	internal ref StatModifier allKB => ref GetKnockback(DamageClass.Generic);

	internal ref float minionKB => ref GetKnockback(DamageClass.Summon).Base;

	internal ref float meleeSpeed => ref GetAttackSpeed(DamageClass.Melee);

	internal float inverseMeleeSpeed => 1f / GetTotalAttackSpeed(DamageClass.Melee);

	internal ref float summonerWeaponSpeedBonus => ref GetAttackSpeed(DamageClass.SummonMeleeSpeed);

	/// <summary>
	/// An array indexed by tile type (<see cref="P:Terraria.Tile.TileType" />, <see cref="T:Terraria.ID.TileID" />) indicating if the player is within crafting range of each tile type. Used to determine if a player satisfies crafting station requirements for recipes. Note that this includes tiles acting like other tiles (<see cref="P:Terraria.ModLoader.ModTile.AdjTiles" />, <see cref="M:Terraria.Player.AdjTiles" />), so the player might not actually be near specific tiles. For example a player near a <see cref="F:Terraria.ID.TileID.MythrilAnvil" /> tile will count as being near <see cref="F:Terraria.ID.TileID.Anvils" />.
	/// </summary>
	public bool[] adjTile
	{
		get
		{
			if (_adjTile.Length != TileLoader.TileCount)
			{
				Array.Resize(ref _adjTile, TileLoader.TileCount);
			}
			return _adjTile;
		}
		set
		{
			_adjTile = value;
		}
	}

	public bool[] oldAdjTile
	{
		get
		{
			if (_oldAdjTile.Length != TileLoader.TileCount)
			{
				Array.Resize(ref _oldAdjTile, TileLoader.TileCount);
			}
			return _oldAdjTile;
		}
		set
		{
			_oldAdjTile = value;
		}
	}

	public bool accFlipper
	{
		get
		{
			return GetJumpState<FlipperJump>().Enabled;
		}
		set
		{
			ref ExtraJumpState jumpState = ref GetJumpState<FlipperJump>();
			if (value)
			{
				jumpState.Enable();
				jumpState.Available = true;
			}
			else
			{
				jumpState.Disable();
			}
		}
	}

	internal bool hasJumpOption_Cloud
	{
		set
		{
			if (value)
			{
				GetJumpState<CloudInABottleJump>().Enable();
				return;
			}
			throw new ArgumentException("Forgot to comment out a hasJumpOption_X = false statement");
		}
	}

	internal bool hasJumpOption_Sandstorm
	{
		set
		{
			if (value)
			{
				GetJumpState<SandstormInABottleJump>().Enable();
				return;
			}
			throw new ArgumentException("Forgot to comment out a hasJumpOption_X = false statement");
		}
	}

	internal bool hasJumpOption_Blizzard
	{
		set
		{
			if (value)
			{
				GetJumpState<BlizzardInABottleJump>().Enable();
				return;
			}
			throw new ArgumentException("Forgot to comment out a hasJumpOption_X = false statement");
		}
	}

	internal bool hasJumpOption_Fart
	{
		set
		{
			if (value)
			{
				GetJumpState<FartInAJarJump>().Enable();
				return;
			}
			throw new ArgumentException("Forgot to comment out a hasJumpOption_X = false statement");
		}
	}

	internal bool hasJumpOption_Sail
	{
		set
		{
			if (value)
			{
				GetJumpState<TsunamiInABottleJump>().Enable();
				return;
			}
			throw new ArgumentException("Forgot to comment out a hasJumpOption_X = false statement");
		}
	}

	internal bool hasJumpOption_Unicorn
	{
		set
		{
			if (value)
			{
				GetJumpState<UnicornMountJump>().Enable();
				return;
			}
			throw new ArgumentException("Forgot to comment out a hasJumpOption_X = false statement");
		}
	}

	internal bool hasJumpOption_Santank
	{
		set
		{
			if (value)
			{
				GetJumpState<SantankMountJump>().Enable();
				return;
			}
			throw new ArgumentException("Forgot to comment out a hasJumpOption_X = false statement");
		}
	}

	internal bool hasJumpOption_WallOfFleshGoat
	{
		set
		{
			if (value)
			{
				GetJumpState<GoatMountJump>().Enable();
				return;
			}
			throw new ArgumentException("Forgot to comment out a hasJumpOption_X = false statement");
		}
	}

	internal bool hasJumpOption_Basilisk
	{
		set
		{
			if (value)
			{
				GetJumpState<BasiliskMountJump>().Enable();
				return;
			}
			throw new ArgumentException("Forgot to comment out a hasJumpOption_X = false statement");
		}
	}

	public Vector2 BlehOldPositionFixer => -Vector2.UnitY;

	public float HeightOffsetVisual
	{
		get
		{
			if (mount.Active)
			{
				return mount.PlayerOffset;
			}
			if (portableStoolInfo.IsInUse)
			{
				return portableStoolInfo.VisualYOffset;
			}
			return 0f;
		}
	}

	public float HeightOffsetHitboxCenter
	{
		get
		{
			if (mount.Active)
			{
				return mount.PlayerOffsetHitbox;
			}
			if (portableStoolInfo.IsInUse)
			{
				return portableStoolInfo.HeightBoost - portableStoolInfo.VisualYOffset;
			}
			return 0f;
		}
	}

	public float MountXOffset
	{
		get
		{
			if (mount.Active)
			{
				return mount.PlayerXOFfset;
			}
			return 0f;
		}
	}

	public int HeightOffsetBoost
	{
		get
		{
			if (mount.Active)
			{
				return mount.HeightBoost;
			}
			if (portableStoolInfo.IsInUse)
			{
				return portableStoolInfo.HeightBoost;
			}
			return 0;
		}
	}

	public int HeightMapOffset
	{
		get
		{
			if (mount.Active)
			{
				return mount.PlayerHeadOffset;
			}
			if (portableStoolInfo.IsInUse)
			{
				return portableStoolInfo.HeightBoost;
			}
			return 0;
		}
	}

	public Rectangle HitboxForBestiaryNearbyCheck
	{
		get
		{
			//IL_003c: Unknown result type (might be due to invalid IL or missing references)
			Rectangle result = default(Rectangle);
			((Rectangle)(ref result))..ctor((int)position.X, (int)position.Y, width, height);
			((Rectangle)(ref result)).Inflate(300, 200);
			return result;
		}
	}

	public bool IsStandingStillForSpecialEffects
	{
		get
		{
			if ((double)Math.Abs(velocity.X) < 0.05)
			{
				return (double)Math.Abs(velocity.Y) < 0.05;
			}
			return false;
		}
	}

	/// <summary>
	/// Returns the player's center adjusted for mount and step stool usage. Typically used in conjunction with <see cref="M:Terraria.Player.RotatedRelativePoint(Microsoft.Xna.Framework.Vector2,System.Boolean,System.Boolean)" /> to retrieve a suitable position for positioning items and effects originating from the player.
	/// </summary>
	public Vector2 MountedCenter
	{
		get
		{
			//IL_002d: Unknown result type (might be due to invalid IL or missing references)
			return new Vector2(position.X + (float)(width / 2), position.Y + 21f + HeightOffsetHitboxCenter);
		}
		set
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0011: Unknown result type (might be due to invalid IL or missing references)
			//IL_0024: Unknown result type (might be due to invalid IL or missing references)
			//IL_0029: Unknown result type (might be due to invalid IL or missing references)
			position = new Vector2(value.X - (float)(width / 2), value.Y - 21f - HeightOffsetHitboxCenter);
		}
	}

	public bool TileReplacementEnabled => builderAccStatus[10] == 0;

	public override Vector2 VisualPosition => position + new Vector2(0f, gfxOffY);

	/// <summary>
	/// Checks if the player is currently "crowd controlled", meaning the player is <see cref="F:Terraria.Player.frozen" />, <see cref="F:Terraria.Player.webbed" />, or <see cref="F:Terraria.Player.stoned" />. Used in various checks to prevent some player actions that shouldn't be possible while in those states, such as channeling attacks, quick using items, and swapping loadouts.
	/// </summary>
	public bool CCed
	{
		get
		{
			if (!frozen && !webbed)
			{
				return stoned;
			}
			return true;
		}
	}

	public float miscCounterNormalized => (float)miscCounter / 300f;

	public bool Male
	{
		get
		{
			return PlayerVariantID.Sets.Male[skinVariant];
		}
		set
		{
			if (value)
			{
				if (!Male)
				{
					skinVariant = PlayerVariantID.Sets.AltGenderReference[skinVariant];
				}
			}
			else if (Male)
			{
				skinVariant = PlayerVariantID.Sets.AltGenderReference[skinVariant];
			}
		}
	}

	public bool ZoneDungeon
	{
		get
		{
			return zone1[0];
		}
		set
		{
			zone1[0] = value;
		}
	}

	public bool ZoneCorrupt
	{
		get
		{
			return zone1[1];
		}
		set
		{
			zone1[1] = value;
		}
	}

	public bool ZoneHallow
	{
		get
		{
			return zone1[2];
		}
		set
		{
			zone1[2] = value;
		}
	}

	public bool ZoneMeteor
	{
		get
		{
			return zone1[3];
		}
		set
		{
			zone1[3] = value;
		}
	}

	public bool ZoneJungle
	{
		get
		{
			return zone1[4];
		}
		set
		{
			zone1[4] = value;
		}
	}

	public bool ZoneSnow
	{
		get
		{
			return zone1[5];
		}
		set
		{
			zone1[5] = value;
		}
	}

	public bool ZoneCrimson
	{
		get
		{
			return zone1[6];
		}
		set
		{
			zone1[6] = value;
		}
	}

	public bool ZoneWaterCandle
	{
		get
		{
			return zone1[7];
		}
		set
		{
			zone1[7] = value;
		}
	}

	public bool ZonePeaceCandle
	{
		get
		{
			return zone2[0];
		}
		set
		{
			zone2[0] = value;
		}
	}

	public bool ZoneTowerSolar
	{
		get
		{
			return zone2[1];
		}
		set
		{
			zone2[1] = value;
		}
	}

	public bool ZoneTowerVortex
	{
		get
		{
			return zone2[2];
		}
		set
		{
			zone2[2] = value;
		}
	}

	public bool ZoneTowerNebula
	{
		get
		{
			return zone2[3];
		}
		set
		{
			zone2[3] = value;
		}
	}

	public bool ZoneTowerStardust
	{
		get
		{
			return zone2[4];
		}
		set
		{
			zone2[4] = value;
		}
	}

	public bool ZoneDesert
	{
		get
		{
			return zone2[5];
		}
		set
		{
			zone2[5] = value;
		}
	}

	public bool ZoneGlowshroom
	{
		get
		{
			return zone2[6];
		}
		set
		{
			zone2[6] = value;
		}
	}

	public bool ZoneUndergroundDesert
	{
		get
		{
			return zone2[7];
		}
		set
		{
			zone2[7] = value;
		}
	}

	/// <summary>
	/// If <see langword="true" />, then this player is the top 35% of the world.
	/// <br /> <strong>NOTE:</strong> Vanilla uses a lot of different conditions for what counts as space. This flag is never used in vanilla, but the logic behind it is used for NPC shops and enemy spawns.
	/// </summary>
	public bool ZoneSkyHeight
	{
		get
		{
			return zone3[0];
		}
		set
		{
			zone3[0] = value;
		}
	}

	/// <summary>
	/// If <see langword="true" />, then this player is above ground (<see cref="F:Terraria.Main.worldSurface" />) but not in space (<see cref="P:Terraria.Player.ZoneSkyHeight" />).
	/// </summary>
	public bool ZoneOverworldHeight
	{
		get
		{
			return zone3[1];
		}
		set
		{
			zone3[1] = value;
		}
	}

	/// <summary>
	/// If <see langword="true" />, then this player is underground (<see cref="F:Terraria.Main.worldSurface" />) but above the Caverns layer (<see cref="F:Terraria.Main.rockLayer" />).
	/// </summary>
	public bool ZoneDirtLayerHeight
	{
		get
		{
			return zone3[2];
		}
		set
		{
			zone3[2] = value;
		}
	}

	/// <summary>
	/// If <see langword="true" />, then this player is in the Caverns layer (<see cref="F:Terraria.Main.rockLayer" />) but not in the Underworld (<see cref="P:Terraria.Main.UnderworldLayer" />).
	/// </summary>
	public bool ZoneRockLayerHeight
	{
		get
		{
			return zone3[3];
		}
		set
		{
			zone3[3] = value;
		}
	}

	/// <summary>
	/// If <see langword="true" />, then this player is in the Underworld (<see cref="P:Terraria.Main.UnderworldLayer" />).
	/// </summary>
	public bool ZoneUnderworldHeight
	{
		get
		{
			return zone3[4];
		}
		set
		{
			zone3[4] = value;
		}
	}

	public bool ZoneBeach
	{
		get
		{
			return zone3[5];
		}
		set
		{
			zone3[5] = value;
		}
	}

	public bool ZoneRain
	{
		get
		{
			return zone3[6];
		}
		set
		{
			zone3[6] = value;
		}
	}

	public bool ZoneSandstorm
	{
		get
		{
			return zone3[7];
		}
		set
		{
			zone3[7] = value;
		}
	}

	public bool ZoneOldOneArmy
	{
		get
		{
			return zone4[0];
		}
		set
		{
			zone4[0] = value;
		}
	}

	public bool ZoneGranite
	{
		get
		{
			return zone4[1];
		}
		set
		{
			zone4[1] = value;
		}
	}

	public bool ZoneMarble
	{
		get
		{
			return zone4[2];
		}
		set
		{
			zone4[2] = value;
		}
	}

	public bool ZoneHive
	{
		get
		{
			return zone4[3];
		}
		set
		{
			zone4[3] = value;
		}
	}

	public bool ZoneGemCave
	{
		get
		{
			return zone4[4];
		}
		set
		{
			zone4[4] = value;
		}
	}

	public bool ZoneLihzhardTemple
	{
		get
		{
			return zone4[5];
		}
		set
		{
			zone4[5] = value;
		}
	}

	public bool ZoneGraveyard
	{
		get
		{
			return zone4[6];
		}
		set
		{
			zone4[6] = value;
		}
	}

	public bool ZoneShadowCandle
	{
		get
		{
			return zone4[7];
		}
		set
		{
			zone4[7] = value;
		}
	}

	public bool ZoneShimmer
	{
		get
		{
			return zone5[0];
		}
		set
		{
			zone5[0] = value;
		}
	}

	public bool ShoppingZone_AnyBiome
	{
		get
		{
			if (!ZoneDungeon && !ZoneCorrupt && !ZoneCrimson && !ZoneGlowshroom && !ZoneHallow && !ZoneJungle && !ZoneSnow && !ZoneBeach)
			{
				return ZoneDesert;
			}
			return true;
		}
	}

	public bool ShoppingZone_BelowSurface => (double)position.Y > Main.worldSurface * 16.0;

	public bool ShoppingZone_Forest
	{
		get
		{
			if (ShoppingZone_AnyBiome || ShoppingZone_BelowSurface)
			{
				return false;
			}
			return true;
		}
	}

	/// <summary> A Vector2 comprised of <see cref="F:Terraria.Entity.direction" /> (X) and <see cref="F:Terraria.Player.gravDir" /> (Y). </summary>
	public Vector2 Directions => new Vector2((float)direction, gravDir);

	/// <summary> The <see cref="T:Terraria.Item" /> within the <see cref="F:Terraria.Player.inventory" /> currently selected by the player. </summary>
	public Item HeldItem => inventory[selectedItem];

	/// <summary> How long it takes for <see cref="F:Terraria.Player.breathCD" /> to cause <see cref="F:Terraria.Player.breath" /> to decrease by 1. Defaults to 7 before <see cref="F:Terraria.Player.breathEffectiveness" /> is applied. </summary>
	public int breathCDMax
	{
		get
		{
			StatModifier statModifier = breathEffectiveness;
			if (inventory[selectedItem].type == 186 && itemAnimation == 0)
			{
				statModifier += 1f;
			}
			if (accDivingHelm)
			{
				statModifier *= 6f;
			}
			return (int)statModifier.ApplyTo(7f);
		}
	}

	public bool ShouldFloatInWater
	{
		get
		{
			if (canFloatInWater && !controlDown)
			{
				if (mount.Active)
				{
					return mount.Type == 37;
				}
				return true;
			}
			return false;
		}
	}

	public bool CanBeTalkedTo
	{
		get
		{
			if (active && !dead && !ShouldNotDraw)
			{
				return stealth == 1f;
			}
			return false;
		}
	}

	public bool IsVoidVaultEnabled
	{
		get
		{
			return voidVaultInfo[0];
		}
		set
		{
			voidVaultInfo[0] = value;
		}
	}

	public bool DeadOrGhost
	{
		get
		{
			if (!dead)
			{
				return ghost;
			}
			return true;
		}
	}

	public bool TryingToHoverUp
	{
		get
		{
			if (!controlUp)
			{
				return tryKeepingHoveringUp;
			}
			return true;
		}
	}

	public bool TryingToHoverDown
	{
		get
		{
			if (!controlDown)
			{
				return tryKeepingHoveringDown;
			}
			return true;
		}
	}

	public Vector2 DefaultSize => new Vector2(20f, 42f);

	public bool UsingBiomeTorches
	{
		get
		{
			if (!unlockedBiomeTorches)
			{
				return false;
			}
			return builderAccStatus[11] == 0;
		}
		set
		{
			builderAccStatus[11] = ((!value) ? 1 : 0);
		}
	}

	/// <summary>
	/// If <see langword="true" />, then any minecart (<see cref="F:Terraria.ID.MountID.Sets.Cart" />) this player rides in will be significantly faster and fire lasers.
	/// <br /> Cannot be <see langword="true" /> if <see cref="F:Terraria.Player.unlockedSuperCart" /> is <see langword="false" />.
	/// </summary>
	public bool UsingSuperCart
	{
		get
		{
			if (!unlockedSuperCart)
			{
				return false;
			}
			return enabledSuperCart;
		}
		set
		{
			enabledSuperCart = value;
		}
	}

	public bool ShouldNotDraw
	{
		get
		{
			if (invis && itemAnimation == 0)
			{
				if (!isDisplayDollOrInanimate)
				{
					return !isHatRackDoll;
				}
				return false;
			}
			return false;
		}
	}

	public int talkNPC { get; private set; }

	/// <summary>
	/// The NPC instance the player is talking to, or null if <see cref="P:Terraria.Player.talkNPC" /> is -1
	/// </summary>
	public NPC TalkNPC
	{
		get
		{
			if (talkNPC < 0)
			{
				return null;
			}
			return Main.npc[talkNPC];
		}
	}

	public bool isLockedToATile
	{
		get
		{
			if (!sitting.isSitting)
			{
				return sleeping.isSleeping;
			}
			return true;
		}
	}

	public bool PortalPhysicsEnabled
	{
		get
		{
			if (_portalPhysicsTime > 0)
			{
				return !mount.Active;
			}
			return false;
		}
	}

	public bool MountFishronSpecial
	{
		get
		{
			//IL_0045: Unknown result type (might be due to invalid IL or missing references)
			if (statLife >= statLifeMax2 / 2 && (!wet || lavaWet || honeyWet) && !dripping && !(MountFishronSpecialCounter > 0f))
			{
				if (Main.raining)
				{
					return WorldGen.InAPlaceWithWind(position, width, height);
				}
				return false;
			}
			return true;
		}
	}

	public bool HasMinionRestTarget => MinionRestTargetPoint != Vector2.Zero;

	/// <summary> True if the player currently has a minion attack target (<see cref="F:Terraria.Player.MinionAttackTargetNPC" />. </summary>
	public bool HasMinionAttackTargetNPC => MinionAttackTargetNPC != -1;

	/// <summary>
	/// Evaluates to <see langword="true" /> if the item usage is in it's first frame. Equivalent to <c>itemTime == 0</c>. Note that this particular property is only valid to be used in <see cref="M:Terraria.ModLoader.ModItem.UseItem(Terraria.Player)" /> and <see cref="M:Terraria.ModLoader.ModItem.UseAnimation(Terraria.Player)" /> hooks.
	/// <br /><br /> <see href="https://github.com/tModLoader/tModLoader/blob/stable/ExampleMod/Content/Items/Tools/ExamplePickaxe.cs">ExamplePickaxe</see> uses this to run code once per swing.
	/// </summary>
	public bool ItemTimeIsZero => itemTime == 0;

	/// <summary>
	/// Returns true if the item animation is in its first frame.
	/// </summary>
	public bool ItemAnimationJustStarted
	{
		get
		{
			if (itemAnimation == itemAnimationMax)
			{
				return itemAnimation > 0;
			}
			return false;
		}
	}

	public float NormalizedLuck
	{
		get
		{
			float num = 0f;
			if (luck > 0f)
			{
				num = luck / luckMaximumCap;
			}
			else if (luck < 0f)
			{
				num = 0f - luck / luckMinimumCap;
			}
			return MathHelper.Clamp(num, -1f, 1f);
		}
	}

	public bool SlimeDontHyperJump
	{
		get
		{
			if (mount.Active && mount.IsConsideredASlimeMount && wetSlime > 0)
			{
				return !controlJump;
			}
			return false;
		}
	}

	public Vector2? MouthPosition
	{
		get
		{
			//IL_004c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0053: Unknown result type (might be due to invalid IL or missing references)
			//IL_0058: Unknown result type (might be due to invalid IL or missing references)
			//IL_0062: Unknown result type (might be due to invalid IL or missing references)
			//IL_0068: Unknown result type (might be due to invalid IL or missing references)
			//IL_0069: Unknown result type (might be due to invalid IL or missing references)
			//IL_006e: Unknown result type (might be due to invalid IL or missing references)
			if (mount.Active)
			{
				Mount.MountDelegatesData.OverridePositionMethod mouthPosition = mount.Delegations.MouthPosition;
				if (mouthPosition != null && mouthPosition(this, out var result))
				{
					return result;
				}
			}
			Vector2 spinningpoint = default(Vector2);
			((Vector2)(ref spinningpoint))..ctor((float)(direction * 8), gravDir * -4f);
			return RotatedRelativePoint(MountedCenter, reverseRotation: false, addGfxOffY: false) + spinningpoint.RotatedBy(fullRotation);
		}
	}

	public Vector2? HandPosition
	{
		get
		{
			//IL_0041: Unknown result type (might be due to invalid IL or missing references)
			//IL_004b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0050: Unknown result type (might be due to invalid IL or missing references)
			//IL_0068: Unknown result type (might be due to invalid IL or missing references)
			//IL_009b: Unknown result type (might be due to invalid IL or missing references)
			//IL_00be: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
			//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
			//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
			//IL_0100: Unknown result type (might be due to invalid IL or missing references)
			//IL_0107: Unknown result type (might be due to invalid IL or missing references)
			//IL_008f: Unknown result type (might be due to invalid IL or missing references)
			if (mount.Active)
			{
				Mount.MountDelegatesData.OverridePositionMethod handPosition = mount.Delegations.HandPosition;
				if (handPosition != null && handPosition(this, out var result))
				{
					return result;
				}
			}
			Vector2 val = Main.OffsetsPlayerOnhand[bodyFrame.Y / 56] * 2f;
			if (direction != 1)
			{
				val.X = (float)bodyFrame.Width - val.X;
			}
			if (gravDir != 1f)
			{
				val.Y = (float)bodyFrame.Height - val.Y;
			}
			val -= new Vector2((float)(bodyFrame.Width - width), (float)(bodyFrame.Height - 42)) / 2f;
			Vector2 val2 = -new Vector2(20f, 42f) / 2f + val;
			return RotatedRelativePoint(MountedCenter + val2);
		}
	}

	/// <summary> Contains error messages from ModPlayer.SaveData from a previous player save retrieved from the .tplr. Shown when entering a world and on player select menu. Maps ModSystem.FullName.MethodName to exception string.</summary>
	internal Dictionary<string, string> ModSaveErrors { get; set; } = new Dictionary<string, string>();

	/// <summary>
	/// How many Life Crystals this player has consumed
	/// </summary>
	public int ConsumedLifeCrystals
	{
		get
		{
			return consumedLifeCrystals;
		}
		set
		{
			consumedLifeCrystals = Utils.Clamp(value, 0, 15);
		}
	}

	/// <summary>
	/// How many Life Fruit this player has consumed
	/// </summary>
	public int ConsumedLifeFruit
	{
		get
		{
			return consumedLifeFruit;
		}
		set
		{
			consumedLifeFruit = Utils.Clamp(value, 0, 20);
		}
	}

	/// <summary>
	/// How many Mana Crystals this player has consumed
	/// </summary>
	public int ConsumedManaCrystals
	{
		get
		{
			return consumedManaCrystals;
		}
		set
		{
			consumedManaCrystals = Utils.Clamp(value, 0, 9);
		}
	}

	/// <summary>
	/// Checks or sets <see cref="F:Terraria.Player.meleeEnchant" />, indicating if a melee enchantment is active or not. Mods can check the <see cref="F:Terraria.Player.meleeEnchant" /> value directly to act on existing melee enchantments, but modded melee enchantments do not have specific assigned values.
	/// </summary>
	public bool MeleeEnchantActive
	{
		get
		{
			return meleeEnchant > 0;
		}
		set
		{
			meleeEnchant = byte.MaxValue;
		}
	}

	public RefReadOnlyArray<ModPlayer> ModPlayers => modPlayers;

	RefReadOnlyArray<ModPlayer> IEntityWithInstances<ModPlayer>.Instances => modPlayers;

	public HashSet<int> NearbyModTorch { get; private set; } = new HashSet<int>();

	/// <summary>
	/// Multiplier to shot projectile velocity before throwing. Result will be capped to 16f.
	/// <br />Only applies to items counted as the <see cref="P:Terraria.ModLoader.DamageClass.Throwing" /> damage type
	/// </summary>
	public float ThrownVelocity { get; set; }

	/// <summary>
	/// If true, player has a 33% chance of not consuming the thrown item.
	/// <br />Only applies to consumable items and projectiles counted as the <see cref="P:Terraria.ModLoader.DamageClass.Throwing" /> damage type.
	/// <br />Projectiles spawned from a player who holds such item will set <see cref="F:Terraria.Projectile.noDropItem" /> to prevent duplication.
	/// <br />Stacks with <see cref="P:Terraria.Player.ThrownCost50" /> multiplicatively
	/// </summary>
	public bool ThrownCost33 { get; set; }

	/// <summary>
	/// If true, player has a 50% chance of not consuming the thrown item.
	/// <br />Only applies to consumable items counted as the <see cref="P:Terraria.ModLoader.DamageClass.Throwing" /> damage type.
	/// <br />Projectiles spawned from a player who holds such item will set <see cref="F:Terraria.Projectile.noDropItem" /> to prevent duplication.
	/// <br />Stacks with <see cref="P:Terraria.Player.ThrownCost33" /> multiplicatively
	/// </summary>
	public bool ThrownCost50 { get; set; }

	/// <summary>
	/// Returns true if either <see cref="P:Terraria.Player.ThrownCost33" /> or <see cref="P:Terraria.Player.ThrownCost50" /> are true
	/// </summary>
	public bool AnyThrownCostReduction
	{
		get
		{
			if (!ThrownCost33)
			{
				return ThrownCost50;
			}
			return true;
		}
	}

	/// <summary>
	/// Container for current SceneEffect client properties such as: Backgrounds, music, and water styling
	/// </summary>
	public SceneEffectLoader.SceneEffectInstance CurrentSceneEffect { get; set; } = new SceneEffectLoader.SceneEffectInstance();

	/// <summary>
	/// The zone property storing if the player is not in any particular biome. Updated in <see cref="M:Terraria.Player.UpdateBiomes" />
	/// Does NOT account for height. Please use ZoneForest / ZoneNormalX for height based derivatives.
	/// </summary>
	public bool ZonePurity { get; set; }

	/// <summary> Shorthand for <code>ZonePurity &amp;&amp; ZoneOverworldHeight</code></summary>
	public bool ZoneForest
	{
		get
		{
			if (ZonePurity)
			{
				return ZoneOverworldHeight;
			}
			return false;
		}
	}

	/// <summary> Shorthand for <code>ZonePurity &amp;&amp; ZoneRockLayerHeight</code></summary>
	public bool ZoneNormalCaverns
	{
		get
		{
			if (ZonePurity)
			{
				return ZoneRockLayerHeight;
			}
			return false;
		}
	}

	/// <summary> Shorthand for <code>ZonePurity &amp;&amp; ZoneDirtLayerHeight</code></summary>
	public bool ZoneNormalUnderground
	{
		get
		{
			if (ZonePurity)
			{
				return ZoneDirtLayerHeight;
			}
			return false;
		}
	}

	/// <summary> Shorthand for <code>ZonePurity &amp;&amp; ZoneSkyHeight</code></summary>
	public bool ZoneNormalSpace
	{
		get
		{
			if (ZonePurity)
			{
				return ZoneSkyHeight;
			}
			return false;
		}
	}

	/// <summary>
	/// Returns true if an item animation is currently running.
	/// </summary>
	public bool ItemAnimationActive => itemAnimation > 0;

	/// <summary>
	/// Returns true if the item animation is on or after its last frame. Meaning it could (if the player clicks etc) start again next frame. <br />
	/// Vanilla uses it to despawn spears, but it's not recommended because it will desync in multiplayer <br />
	/// (a remote player could get the packet for a new projectile just as they're finishing a swing). <br />
	/// It is recommended to use ai counters for the lifetime of animation bound projectiles instead.
	/// </summary>
	public bool ItemAnimationEndingOrEnded => itemAnimation <= 1;

	/// <summary>
	/// The number of times the item has been used/fired this animation (swing)
	/// </summary>
	public int ItemUsesThisAnimation { get; private set; }

	public Span<ExtraJumpState> ExtraJumps => extraJumps.AsSpan();

	public void RotateRelativePoint(ref float x, ref float y)
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		Vector2 val = RotatedRelativePoint(new Vector2(x, y));
		x = val.X;
		y = val.Y;
	}

	public Vector2 RotatedRelativePointOld(Vector2 pos, bool rotateForward = true)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		Vector2 val = position + fullRotationOrigin;
		Matrix val2 = Matrix.CreateRotationZ(fullRotation * (float)rotateForward.ToInt());
		pos -= position + fullRotationOrigin;
		pos = Vector2.Transform(pos, val2);
		return pos + val;
	}

	/// <summary>
	/// Takes an input position and returns the position adjusted to the players visual rotation and offset. This accounts for the player being shifted up or down and rotated while riding a mount, sitting in a chair, and sleeping. <br />
	/// </summary>
	/// <param name="pos"></param>
	/// <param name="reverseRotation"></param>
	/// <param name="addGfxOffY"></param>
	/// <returns></returns>
	public Vector2 RotatedRelativePoint(Vector2 pos, bool reverseRotation = false, bool addGfxOffY = true)
	{
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		float num = (reverseRotation ? (0f - fullRotation) : fullRotation);
		if (sleeping.isSleeping)
		{
			num = 0f;
		}
		Vector2 val = base.Bottom + new Vector2(0f, gfxOffY);
		int num2 = mount.PlayerOffset / 2 + 4;
		Vector2 val2 = new Vector2(0f, (float)(-num2)) + Utils.RotatedBy(new Vector2(0f, (float)num2), (double)num, default(Vector2));
		if (addGfxOffY)
		{
			pos.Y += gfxOffY;
		}
		pos = val + (pos - val).RotatedBy(num) + val2;
		if (sleeping.isSleeping)
		{
			sleeping.GetSleepingOffsetInfo(this, out var posOffset);
			pos += posOffset;
		}
		if (sitting.isSitting)
		{
			sitting.GetSittingOffsetInfo(this, out var posOffset2, out var seatAdjustment);
			pos += posOffset2 + new Vector2(0f, seatAdjustment);
		}
		return pos;
	}

	public bool CanDemonHeartAccessoryBeShown()
	{
		if (!IsItemSlotUnlockedAndUsable(8) && armor[8].type <= 0 && armor[18].type <= 0)
		{
			return dye[8].type > 0;
		}
		return true;
	}

	public bool CanMasterModeAccessoryBeShown()
	{
		if (!IsItemSlotUnlockedAndUsable(9) && armor[9].type <= 0 && armor[19].type <= 0)
		{
			return dye[9].type > 0;
		}
		return true;
	}

	public int GetAmountOfExtraAccessorySlotsToShow()
	{
		int num = 0;
		if (CanDemonHeartAccessoryBeShown())
		{
			num++;
		}
		if (CanMasterModeAccessoryBeShown())
		{
			num++;
		}
		return num;
	}

	/// <summary>
	/// Returns positioning data for this player <paramref name="shadowIndex" /> frames ago, up to <see cref="F:Terraria.Player.availableAdvancedShadowsCount" />.
	/// <br /><br /> This can be used to draw trails that follow the movement of the player. You'll usually want to iterate from <see cref="F:Terraria.Player.availableAdvancedShadowsCount" /> down to 1 for proper draw layering and to skip index 0 which would be the current frame when using this to draw a trail.
	/// <br /><br /> See <see href="https://github.com/tModLoader/tModLoader/blob/stable/ExampleMod/ExampleMod/Common/Players/ExampleArmorSetBonusPlayer.cs">ExampleArmorSetBonusPlayer.DrawPlayer</see> for an example of correctly using this.
	/// </summary>
	public EntityShadowInfo GetAdvancedShadow(int shadowIndex)
	{
		if (shadowIndex > availableAdvancedShadowsCount)
		{
			shadowIndex = availableAdvancedShadowsCount;
		}
		int num = (_lastAddedAvancedShadow - shadowIndex).ModulusPositive(60);
		return _advancedShadows[num];
	}

	public void UpdateAdvancedShadows()
	{
		availableAdvancedShadowsCount++;
		if (availableAdvancedShadowsCount > 60)
		{
			availableAdvancedShadowsCount = 60;
		}
		if (++_lastAddedAvancedShadow >= 60)
		{
			_lastAddedAvancedShadow = 0;
		}
		_advancedShadows[_lastAddedAvancedShadow].CopyPlayer(this);
	}

	public void ResetAdvancedShadows()
	{
		availableAdvancedShadowsCount = 0;
	}

	public void SetCompositeArmFront(bool enabled, CompositeArmStretchAmount stretch, float rotation)
	{
		if (gravDir == -1f)
		{
			rotation = 0f - rotation;
		}
		compositeFrontArm = new CompositeArmData(enabled, stretch, rotation);
	}

	public void SetCompositeArmBack(bool enabled, CompositeArmStretchAmount stretch, float rotation)
	{
		if (gravDir == -1f)
		{
			rotation = 0f - rotation;
		}
		compositeBackArm = new CompositeArmData(enabled, stretch, rotation);
	}

	public void SetTalkNPC(int npcIndex, bool fromNet = false)
	{
		talkNPC = npcIndex;
		if (Main.netMode != 1 && npcIndex >= 0 && npcIndex < 200)
		{
			Main.BestiaryTracker.Chats.RegisterChatStartWith(Main.npc[npcIndex]);
		}
		if (talkNPC == -1)
		{
			currentShoppingSettings = ShoppingSettings.NotInShop;
		}
		else
		{
			currentShoppingSettings = Main.ShopHelper.GetShoppingSettings(this, Main.npc[talkNPC]);
		}
		if (currentShoppingSettings.PriceAdjustment <= 0.8199999928474426)
		{
			AchievementsHelper.HandleSpecialEvent(this, 20);
		}
	}

	public void SetItemTime(int frames)
	{
		itemTime = frames;
		itemTimeMax = frames;
	}

	/// <summary>
	/// Handles the internal logic of starting an individual item usage. Can be used to manually start an item usage outside of the normal logic.
	/// <br /><br /> The provided <paramref name="multiplier" />, if provided, is combined with the player's use time multipliers to scale the Item's <see cref="F:Terraria.Item.useTime" />. The resulting value will be used to set <see cref="F:Terraria.Player.itemTime" />, starting an item usage.
	/// <PlayerItemUseAnimation>
	/// 		<br /><br /> The <see href="https://github.com/tModLoader/tModLoader/wiki/Player-Item-Animation">Player Item Animation wiki page</see> goes into detail about how this and other player item use and animation fields work together and provides a useful overview on this topic.
	/// 	</PlayerItemUseAnimation>
	/// </summary>
	public void ApplyItemTime(Item sItem, float multiplier = 1f, bool? callUseItem = null)
	{
		if (!(callUseItem ?? ItemTimeIsZero) || ItemLoader.UseItem(sItem, this) != false)
		{
			SetItemTime(CombinedHooks.TotalUseTime((float)sItem.useTime * multiplier, this, sItem));
			ItemUsesThisAnimation++;
		}
	}

	/// <summary>
	/// Sets <see cref="F:Terraria.Player.itemTime" /> and <see cref="F:Terraria.Player.itemAnimation" /> to the provided <paramref name="frames" /> value. Also sets <see cref="F:Terraria.Player.itemTimeMax" /> to that value plus one.
	/// <br /><br /> Commonly used by held projectiles to put the player in a state of using an item. This is usually done each time AI executes to lock the player in that state until the player releases the "Use Item" keybind.
	/// <PlayerItemUseAnimation>
	/// 		<br /><br /> The <see href="https://github.com/tModLoader/tModLoader/wiki/Player-Item-Animation">Player Item Animation wiki page</see> goes into detail about how this and other player item use and animation fields work together and provides a useful overview on this topic.
	/// 	</PlayerItemUseAnimation>
	/// </summary>
	public void SetDummyItemTime(int frames)
	{
		itemAnimation = frames;
		itemTime = frames;
		itemTimeMax = frames + 1;
	}

	public void SetItemAnimation(int frames)
	{
		itemAnimation = frames;
		itemAnimationMax = frames;
	}

	public void ApplyItemAnimation(Item sItem)
	{
		if (sItem.createTile >= 0)
		{
			ApplyItemAnimation(sItem, tileSpeed);
		}
		else if (sItem.createWall >= 0)
		{
			ApplyItemAnimation(sItem, wallSpeed);
		}
		else
		{
			ApplyItemAnimation(sItem, 1f);
		}
	}

	public void ApplyItemAnimation(Item sItem, float multiplier, int? itemReuseDelay = null)
	{
		ItemLoader.UseAnimation(sItem, this);
		SetItemAnimation(CombinedHooks.TotalAnimationTime((float)sItem.useAnimation * multiplier, this, sItem));
		reuseDelay = (int)((float)(itemReuseDelay ?? sItem.reuseDelay) / CombinedHooks.TotalUseSpeedMultiplier(this, sItem));
		ItemUsesThisAnimation = 0;
	}

	public void MatchItemTimeToItemAnimation()
	{
		itemTime = itemAnimation;
	}

	public bool InOpposingTeam(Player otherPlayer)
	{
		if (hostile && otherPlayer.hostile)
		{
			if (otherPlayer.team != 0)
			{
				return otherPlayer.team != team;
			}
			return true;
		}
		return false;
	}

	public bool TeamChangeAllowed()
	{
		return true;
	}

	/// <summary>
	/// Spawns a <see cref="T:Terraria.CombatText" /> indicating the player healed <paramref name="healAmount" /> life and syncs it if <paramref name="broadcast" /> is true. <br />
	/// Note that this doesn't actually heal the player, it only spawns the floating text. The <see cref="M:Terraria.Player.Heal(System.Int32)" /> method heals the player and calls this method and is more commonly used.
	/// </summary>
	public void HealEffect(int healAmount, bool broadcast = true)
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		CombatText.NewText(new Rectangle((int)position.X, (int)position.Y, width, height), CombatText.HealLife, healAmount);
		if (broadcast && Main.netMode == 1 && whoAmI == Main.myPlayer)
		{
			NetMessage.SendData(35, -1, -1, null, whoAmI, healAmount);
		}
	}

	public void ManaEffect(int manaAmount)
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		CombatText.NewText(new Rectangle((int)position.X, (int)position.Y, width, height), CombatText.HealMana, manaAmount);
		if (Main.netMode == 1 && whoAmI == Main.myPlayer)
		{
			NetMessage.SendData(43, -1, -1, null, whoAmI, manaAmount);
		}
	}

	/// <summary>
	/// If the tile location currently being targetted by the players mouse (<see cref="F:Terraria.Player.tileTargetX" />) has a tile of the specified tile type, then item usage will be blocked until the player releases the use button (left mouse button) and clicks again.
	/// <para /> What this typically means in practice is that an auto-swinging pickaxe will not attempt to swing again until the player deliberately releases the mouse button and clicks again. This is usually used by tile entities that drop their contained item when mined to prevent the player from accidentally mining the tile itself when attempting to "mine" the item from the tile entity.
	/// </summary>
	public void InterruptItemUsageIfOverTile(int tileTypeToBeOver)
	{
		Tile tile = Main.tile[tileTargetX, tileTargetY];
		if (tile != null && tile.active() && tile.type == tileTypeToBeOver)
		{
			Main.blockMouse = true;
		}
	}

	public Vector2 GetHairDrawOffset(int hairID, bool hatHair)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		Vector2 zero = Vector2.Zero;
		if (!hatHair && hairID == 163)
		{
			return new Vector2(0f, -2f) * Directions;
		}
		if (hairID == 164)
		{
			return new Vector2(-2f, 0f) * Directions;
		}
		return zero;
	}

	public Vector2 GetHelmetDrawOffset()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_013d: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0131: Unknown result type (might be due to invalid IL or missing references)
		//IL_0136: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		Vector2 headOffset = Vector2.Zero;
		if (head == 270)
		{
			headOffset = new Vector2(-10f, 0f) * Directions;
			if (direction == -1)
			{
				headOffset.X -= 2f;
			}
		}
		else if (head == 268)
		{
			headOffset = new Vector2(0f, -6f) * Directions;
		}
		else if (head == 222)
		{
			float num = 0f;
			if (hair == 15 || hair == 76 || hair == 108)
			{
				num = 4f;
			}
			headOffset = new Vector2(0f, num) * Directions;
		}
		else if (head == 272)
		{
			if (hair == 15 || hair == 76 || hair == 108)
			{
				headOffset = new Vector2(0f, 4f) * Directions;
			}
		}
		else if (head == 275)
		{
			headOffset = new Vector2(0f, -4f) * Directions;
		}
		return GetHelmetOffsetAddonFromFaceHead(headOffset);
	}

	public Vector2 GetBeardDrawOffsetFromHelmet()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		Vector2 zero = Vector2.Zero;
		switch (head)
		{
		case 165:
			((Vector2)(ref zero))..ctor((float)(8 * direction), 0f);
			break;
		case 146:
		case 150:
		case 152:
			((Vector2)(ref zero))..ctor((float)(2 * direction), 0f);
			break;
		case 148:
			((Vector2)(ref zero))..ctor((float)(2 * direction), 0f);
			break;
		}
		return zero;
	}

	public Vector2 GetFaceHeadOffsetFromHelmet()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		Vector2 zero = Vector2.Zero;
		if (faceHead == 12 || faceHead == 13 || faceHead == 10 || faceHead == 11 || faceHead == 17 || faceHead == 18 || faceHead == 15 || faceHead == 16)
		{
			switch (head)
			{
			case 20:
			case 221:
				((Vector2)(ref zero))..ctor(0f, -2f);
				break;
			case 196:
				((Vector2)(ref zero))..ctor(2f, 0f);
				break;
			}
		}
		return zero * Directions;
	}

	public Vector2 GetHelmetOffsetAddonFromFaceHead(Vector2 headOffset)
	{
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_016b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0171: Unknown result type (might be due to invalid IL or missing references)
		//IL_0176: Unknown result type (might be due to invalid IL or missing references)
		//IL_017b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0180: Unknown result type (might be due to invalid IL or missing references)
		//IL_0187: Unknown result type (might be due to invalid IL or missing references)
		//IL_0192: Unknown result type (might be due to invalid IL or missing references)
		//IL_0198: Unknown result type (might be due to invalid IL or missing references)
		//IL_019d: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0215: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0204: Unknown result type (might be due to invalid IL or missing references)
		//IL_0209: Unknown result type (might be due to invalid IL or missing references)
		//IL_020e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0213: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01da: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ef: Unknown result type (might be due to invalid IL or missing references)
		if (faceHead == 12 || faceHead == 13 || faceHead == 10 || faceHead == 11 || faceHead == 17 || faceHead == 18 || faceHead == 15 || faceHead == 16)
		{
			switch (head)
			{
			case 16:
			case 21:
			case 24:
			case 65:
			case 67:
			case 94:
			case 95:
			case 96:
			case 159:
			case 222:
			case 231:
			case 250:
				headOffset += new Vector2(2f, 0f) * Directions;
				break;
			case 59:
			case 64:
			case 106:
			case 138:
			case 181:
			case 220:
				headOffset += new Vector2(0f, -2f) * Directions;
				break;
			case 26:
			case 51:
			case 60:
			case 81:
				headOffset += new Vector2(2f, -2f) * Directions;
				break;
			case 97:
				headOffset += new Vector2(-2f, 0f) * Directions;
				break;
			case 117:
				headOffset += new Vector2(-4f, 0f) * Directions;
				break;
			}
		}
		return headOffset;
	}

	public Vector2 GetLegsDrawOffset()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		Vector2 result = Vector2.Zero;
		if (legs == 226)
		{
			result = new Vector2(-6f, 0f) * Directions;
		}
		return result;
	}

	public void AccumulateGolfingScore(int score)
	{
		int num = score;
		if (golferScoreAccumulated + num > 1000000000)
		{
			num = 1000000000 - golferScoreAccumulated;
		}
		golferScoreAccumulated += num;
	}

	/// <summary>
	/// Finds and returns the index of the closest player to the center of a rectangle defined by the provided arguments. The arguments are usually <see cref="F:Terraria.Entity.position" />, <see cref="F:Terraria.Entity.width" />, and <see cref="F:Terraria.Entity.height" />.
	/// </summary>
	public static byte FindClosest(Vector2 Position, int Width, int Height)
	{
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		byte result = 0;
		for (int i = 0; i < 255; i++)
		{
			if (Main.player[i].active)
			{
				result = (byte)i;
				break;
			}
		}
		float num = -1f;
		for (int j = 0; j < 255; j++)
		{
			if (Main.player[j].active && !Main.player[j].dead)
			{
				float num2 = Math.Abs(Main.player[j].position.X + (float)(Main.player[j].width / 2) - (Position.X + (float)(Width / 2))) + Math.Abs(Main.player[j].position.Y + (float)(Main.player[j].height / 2) - (Position.Y + (float)(Height / 2)));
				if (num == -1f || num2 < num)
				{
					num = num2;
					result = (byte)j;
				}
			}
		}
		return result;
	}

	public void ToggleInv()
	{
		bool grappleAndInteractAreShared = PlayerInput.GrappleAndInteractAreShared;
		if (Main.mapFullscreen)
		{
			Main.mapFullscreen = false;
			releaseInventory = false;
			SoundEngine.PlaySound(11);
			if (PlayerInput.GrappleAndInteractAreShared)
			{
				LockGamepadTileInteractions();
			}
		}
		else if (PlayerInput.InBuildingMode)
		{
			PlayerInput.ExitBuildingMode();
		}
		else if (Main.ingameOptionsWindow)
		{
			if (PlayerInput.UsingGamepadUI && UILinkPointNavigator.CurrentPage == 1002)
			{
				UILinkPointNavigator.ChangePage(1001);
			}
			else
			{
				IngameOptions.Close();
			}
		}
		else if (Main.inFancyUI)
		{
			IngameFancyUI.Close();
		}
		else if (CaptureManager.Instance.Active)
		{
			CaptureManager.Instance.Active = false;
		}
		else if (talkNPC >= 0)
		{
			SetTalkNPC(-1);
			Main.npcChatCornerItem = 0;
			Main.npcChatText = "";
			SoundEngine.PlaySound(11);
			if (PlayerInput.UsingGamepad)
			{
				Main.npcChatRelease = false;
			}
		}
		else if (sign >= 0)
		{
			sign = -1;
			Main.editSign = false;
			Main.npcChatText = "";
			SoundEngine.PlaySound(11);
		}
		else if (Main.clothesWindow)
		{
			Main.CancelClothesWindow();
		}
		else if (!Main.playerInventory)
		{
			OpenInventory();
		}
		else
		{
			Main.playerInventory = false;
			if (channel && Main.mouseItem != null && !Main.mouseItem.IsAir)
			{
				channel = false;
			}
			tileEntityAnchor.Clear();
			if (!PlayerInput.UsingGamepad)
			{
				Main.EquipPageSelected = 0;
			}
			else
			{
				PlayerInput.NavigatorUnCachePosition();
				Main.GamepadCursorAlpha = 0f;
				BlockInteractionWithProjectiles = 3;
				if (PlayerInput.GrappleAndInteractAreShared)
				{
					LockGamepadTileInteractions();
				}
			}
			SoundEngine.PlaySound(11);
			if (ItemSlot.Options.HighlightNewItems)
			{
				Item[] array = inventory;
				for (int i = 0; i < array.Length; i++)
				{
					array[i].newAndShiny = false;
				}
			}
			if (PlayerInput.UsingGamepad)
			{
				Main.npcChatRelease = false;
				tileInteractionHappened = true;
				releaseInventory = false;
				Main.mouseRight = true;
			}
		}
		if (grappleAndInteractAreShared)
		{
			GamepadEnableGrappleCooldown();
		}
	}

	private static void OpenInventory()
	{
		Recipe.FindRecipes();
		Main.playerInventory = true;
		Main.EquipPageSelected = 0;
		SoundEngine.PlaySound(10);
	}

	public void ToggleCreativeMenu()
	{
		if (dead || difficulty != 3)
		{
			return;
		}
		bool flag = false;
		if (Main.mapFullscreen)
		{
			Main.mapFullscreen = false;
			flag = true;
		}
		if (PlayerInput.InBuildingMode)
		{
			PlayerInput.ExitBuildingMode();
		}
		if (Main.ingameOptionsWindow)
		{
			IngameOptions.Close();
		}
		if (Main.inFancyUI)
		{
			IngameFancyUI.Close();
		}
		if (CaptureManager.Instance.Active)
		{
			CaptureManager.Instance.Active = false;
		}
		if (talkNPC >= 0)
		{
			SetTalkNPC(-1);
			Main.npcChatCornerItem = 0;
			Main.npcChatText = "";
			flag = true;
			if (PlayerInput.UsingGamepad)
			{
				Main.npcChatRelease = false;
			}
		}
		if (sign >= 0)
		{
			sign = -1;
			Main.editSign = false;
			Main.npcChatText = "";
			flag = true;
		}
		else if (Main.clothesWindow)
		{
			Main.CancelClothesWindow();
		}
		if (tileEntityAnchor.InUse)
		{
			Recipe.FindRecipes();
			tileEntityAnchor.Clear();
			flag = true;
		}
		if (flag)
		{
			SoundEngine.PlaySound(11);
		}
		if (!Main.playerInventory)
		{
			OpenInventory();
		}
		Main.CreativeMenu.ToggleMenu();
	}

	public void dropItemCheck()
	{
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_0298: Unknown result type (might be due to invalid IL or missing references)
		//IL_029d: Unknown result type (might be due to invalid IL or missing references)
		if (!Main.playerInventory)
		{
			noThrow = 0;
		}
		if (noThrow > 0)
		{
			noThrow--;
		}
		GetItemSettings getItemInDropItemCheck = GetItemSettings.GetItemInDropItemCheck;
		if (!Main.InGuideCraftMenu && Main.guideItem.type > 0)
		{
			Main.guideItem.position = base.Center;
			Item item = GetItem(whoAmI, Main.guideItem, getItemInDropItemCheck);
			if (item.stack > 0)
			{
				int num = Item.NewItem(new EntitySource_OverfullInventory(this), position, width, height, item, noBroadcast: false, noGrabDelay: true);
				Main.item[num].newAndShiny = false;
				if (Main.netMode == 1)
				{
					NetMessage.SendData(21, -1, -1, null, num, 1f);
				}
			}
			Main.guideItem = new Item();
		}
		if (!Main.InReforgeMenu && Main.reforgeItem.type > 0)
		{
			Main.reforgeItem.position = base.Center;
			Item item2 = GetItem(whoAmI, Main.reforgeItem, getItemInDropItemCheck);
			if (item2.stack > 0)
			{
				int num2 = Item.NewItem(new EntitySource_OverfullInventory(this), position, width, height, item2, noBroadcast: false, noGrabDelay: true);
				Main.item[num2].newAndShiny = false;
				if (Main.netMode == 1)
				{
					NetMessage.SendData(21, -1, -1, null, num2, 1f);
				}
			}
			Main.reforgeItem = new Item();
		}
		if (Main.myPlayer == whoAmI)
		{
			inventory[58] = Main.mouseItem.Clone();
		}
		bool flag = true;
		if (Main.mouseItem.type > 0 && Main.mouseItem.stack > 0)
		{
			if (!Main.gamePaused)
			{
				tileTargetX = (int)(((float)Main.mouseX + Main.screenPosition.X) / 16f);
				tileTargetY = (int)(((float)Main.mouseY + Main.screenPosition.Y) / 16f);
				if (gravDir == -1f)
				{
					tileTargetY = (int)((Main.screenPosition.Y + (float)Main.screenHeight - (float)Main.mouseY) / 16f);
				}
			}
			if (selectedItem != 58)
			{
				oldSelectItem = selectedItem;
			}
			selectedItem = 58;
			flag = false;
		}
		if (flag && selectedItem == 58 && ItemTimeIsZero && itemAnimation == 0)
		{
			selectedItem = oldSelectItem;
		}
		if (Main.mouseItem.type > 0 && !Main.playerInventory)
		{
			Main.mouseItem.position = base.Center;
			Item item3 = GetItem(whoAmI, Main.mouseItem, getItemInDropItemCheck);
			if (item3.stack > 0)
			{
				int num3 = Item.NewItem(new EntitySource_OverfullInventory(this), (int)position.X, (int)position.Y, width, height, item3.type, item3.stack, noBroadcast: false, Main.mouseItem.prefix, noGrabDelay: true);
				Main.item[num3] = item3.Clone();
				Main.item[num3].newAndShiny = false;
				if (Main.netMode == 1)
				{
					NetMessage.SendData(21, -1, -1, null, num3, 1f);
				}
			}
			Main.mouseItem = new Item();
			inventory[58] = new Item();
			Recipe.FindRecipes();
		}
		if (((controlThrow && releaseThrow && !inventory[selectedItem].favorited && inventory[selectedItem].type > 0 && !Main.drawingPlayerChat) || (((Main.mouseRight && !mouseInterface && Main.mouseRightRelease) || !Main.playerInventory) && Main.mouseItem.type > 0 && Main.mouseItem.stack > 0)) && noThrow <= 0)
		{
			DropSelectedItem();
		}
		if (Main.gamePaused && selectedItem == 58)
		{
			selectedItem = oldSelectItem;
		}
	}

	public void DropSelectedItem()
	{
		if (Main.mouseItem != null && Main.mouseItem.type > 0 && Main.mouseItem.stack > 0)
		{
			DropSelectedItem(58, ref inventory[58]);
		}
		else
		{
			DropSelectedItem(selectedItem, ref inventory[selectedItem]);
		}
	}

	public void DropSelectedItem(int slot, ref Item theItemWeDrop)
	{
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		bool flag = false;
		if (theItemWeDrop.favorited)
		{
			theItemWeDrop = GetItem(whoAmI, theItemWeDrop, GetItemSettings.GetItemInDropItemCheck);
			if (slot == 58)
			{
				Main.mouseItem = theItemWeDrop;
			}
			Recipe.FindRecipes();
			if (theItemWeDrop.type == 0)
			{
				flag = true;
			}
		}
		if (!flag)
		{
			Item item = new Item();
			if (((Main.mouseRight && !mouseInterface && Main.mouseRightRelease) || !Main.playerInventory) && Main.mouseItem.type > 0 && Main.mouseItem.stack > 0)
			{
				item = theItemWeDrop;
				theItemWeDrop = Main.mouseItem;
				delayUseItem = true;
				controlUseItem = false;
			}
			if (whoAmI == Main.myPlayer && theItemWeDrop.type == 5095)
			{
				LucyAxeMessage.Create(LucyAxeMessage.MessageSource.ThrownAway, base.Top, new Vector2((float)(direction * 7), -2f));
			}
			int num = Item.NewItem(GetItemSource_Misc(4), position, width, height, theItemWeDrop);
			theItemWeDrop.position = Main.item[num].position;
			Main.item[num] = theItemWeDrop;
			theItemWeDrop = new Item();
			if (slot == 58)
			{
				Main.mouseItem = new Item();
			}
			Item item2 = Main.item[num];
			if (Main.netMode == 0)
			{
				item2.noGrabDelay = 100;
			}
			item2.velocity.Y = -2f;
			item2.velocity.X = (float)(4 * direction) + velocity.X;
			item2.favorited = false;
			item2.newAndShiny = false;
			if (((Main.mouseRight && !mouseInterface) || !Main.playerInventory) && Main.mouseItem.type > 0)
			{
				theItemWeDrop = item;
				Main.mouseItem = new Item();
			}
			else
			{
				SetItemAnimation(10);
				JustDroppedAnItem = true;
				DropSelectedItem_InterruptActionsThatUseAnimations();
			}
			Recipe.FindRecipes();
			if (Main.netMode == 1)
			{
				NetMessage.SendData(21, -1, -1, null, num);
			}
		}
	}

	public void PlayDroppedItemAnimation(int time)
	{
		nonTorch = selectedItem;
		int num = 58;
		inventory[num].TurnToAir();
		selectedItem = num;
		JustDroppedAnItem = true;
		SetItemAnimation(time);
		SetItemTime(time);
		DropSelectedItem_InterruptActionsThatUseAnimations();
	}

	private void DropSelectedItem_InterruptActionsThatUseAnimations()
	{
		if (heldProj >= 0)
		{
			Projectile projectile = Main.projectile[heldProj];
			if (projectile.active && projectile.owner == whoAmI)
			{
				projectile.Kill();
			}
		}
		for (int i = 0; i < 1000; i++)
		{
			Projectile projectile2 = Main.projectile[i];
			if (projectile2.active && projectile2.owner == whoAmI && (projectile2.aiStyle == 61 || projectile2.aiStyle == 160))
			{
				projectile2.Kill();
			}
		}
	}

	public int FindBuffIndex(int type)
	{
		if (buffImmune[type])
		{
			return -1;
		}
		for (int i = 0; i < maxBuffs; i++)
		{
			if (buffTime[i] >= 1 && buffType[i] == type)
			{
				return i;
			}
		}
		return -1;
	}

	/// <summary>
	/// Gives the player the provided buff. This accounts for if the player is immune to the buff. This also accounts for adjusting the buff time for different game modes. If the player already has the buff, the re-apply logic will happen. Vanilla buff types are found in <see cref="T:Terraria.ID.BuffID" /> and modded buffs are typically retrieved using <see cref="M:Terraria.ModLoader.ModContent.BuffType``1" />. The quiet parameter will determine if the network sync message should happen. This should only be set to false in non-deterministic situations (such as random chance) and code that only runs locally. Other situations run on all clients so the buff should automatically be applied on all clients, keeping the player buff data in sync without burdening the network. When in doubt, consult vanilla source code examples or test your code.
	/// <br /> If applying a buff to a player other than the local player in pvp, quiet should be false and the buff must be true in <see cref="F:Terraria.Main.pvpBuff" /> to properly sync.
	/// </summary>
	/// <param name="type">The buff type</param>
	/// <param name="timeToAdd">The desired buff time in ticks. 60 ticks is 1 second</param>
	/// <param name="quiet">If true, the network sync message is skipped.</param>
	/// <param name="foodHack">unused</param>
	public void AddBuff(int type, int timeToAdd, bool quiet = true, bool foodHack = false)
	{
		if (buffImmune[type])
		{
			return;
		}
		bool flag = !quiet && Main.netMode == 1 && Main.pvpBuff[type] && Main.myPlayer != whoAmI;
		if (!flag && BuffID.Sets.IsFedState[type])
		{
			for (int i = 0; i < maxBuffs; i++)
			{
				if (BuffID.Sets.IsFedState[buffType[i]])
				{
					DelBuff(i);
				}
			}
		}
		int num = AddBuff_DetermineBuffTimeToAdd(type, timeToAdd);
		if (AddBuff_TryUpdatingExistingBuffTime(type, num))
		{
			return;
		}
		if (!quiet && Main.netMode == 1)
		{
			NetMessage.SendData(55, -1, -1, null, whoAmI, type, num);
			if (flag)
			{
				return;
			}
		}
		AddBuff_RemoveOldPetBuffsOfMatchingType(type);
		AddBuff_RemoveOldMeleeBuffsOfMatchingType(type);
		AddBuff_ActuallyTryToAddTheBuff(type, num);
	}

	private bool AddBuff_ActuallyTryToAddTheBuff(int type, int time)
	{
		int num = -1;
		while (num == -1)
		{
			int num2 = -1;
			for (int i = 0; i < maxBuffs; i++)
			{
				if (!Main.debuff[buffType[i]])
				{
					num2 = i;
					break;
				}
			}
			if (num2 == -1)
			{
				return false;
			}
			for (int j = num2; j < maxBuffs; j++)
			{
				if (buffType[j] == 0)
				{
					num = j;
					break;
				}
			}
			if (num == -1)
			{
				DelBuff(num2);
			}
		}
		buffType[num] = type;
		buffTime[num] = time;
		return true;
	}

	private void AddBuff_RemoveOldMeleeBuffsOfMatchingType(int type)
	{
		if (!Main.meleeBuff[type])
		{
			return;
		}
		for (int i = 0; i < maxBuffs; i++)
		{
			if (buffType[i] != type && Main.meleeBuff[buffType[i]])
			{
				DelBuff(i);
				i--;
			}
		}
	}

	private void AddBuff_RemoveOldPetBuffsOfMatchingType(int type)
	{
		if (Main.lightPet[type])
		{
			for (int i = 0; i < maxBuffs; i++)
			{
				if (Main.lightPet[buffType[i]])
				{
					DelBuff(i);
				}
			}
		}
		if (!Main.vanityPet[type])
		{
			return;
		}
		for (int j = 0; j < maxBuffs; j++)
		{
			if (Main.vanityPet[buffType[j]])
			{
				DelBuff(j);
			}
		}
	}

	private bool AddBuff_TryUpdatingExistingBuffTime(int type, int time)
	{
		bool result = false;
		for (int i = 0; i < maxBuffs; i++)
		{
			if (buffType[i] != type)
			{
				continue;
			}
			if (!BuffLoader.ReApply(type, this, time, i))
			{
				if (type == 94)
				{
					buffTime[i] += time;
					if (buffTime[i] > manaSickTimeMax)
					{
						buffTime[i] = manaSickTimeMax;
					}
				}
				else if (buffTime[i] < time)
				{
					buffTime[i] = time;
				}
			}
			result = true;
			break;
		}
		return result;
	}

	private int AddBuff_DetermineBuffTimeToAdd(int type, int time1)
	{
		int num = time1;
		if (Main.expertMode && whoAmI == Main.myPlayer && BuffID.Sets.LongerExpertDebuff[type])
		{
			float debuffTimeMultiplier = Main.GameModeInfo.DebuffTimeMultiplier;
			if (Main.GameModeInfo.IsJourneyMode)
			{
				if (Main.masterMode)
				{
					debuffTimeMultiplier = Main.RegisteredGameModes[2].DebuffTimeMultiplier;
				}
				else if (Main.expertMode)
				{
					debuffTimeMultiplier = Main.RegisteredGameModes[1].DebuffTimeMultiplier;
				}
			}
			num = (int)(debuffTimeMultiplier * (float)num);
		}
		return num;
	}

	/// <summary>
	/// Removes the buff at the provided index in <see cref="F:Terraria.Player.buffType" /> and <see cref="F:Terraria.Player.buffTime" /> and shuffles the remaining buff indexes down to fill the gap. Use <see cref="M:Terraria.Player.ClearBuff(System.Int32)" /> if you only know the <see cref="T:Terraria.ID.BuffID" />.
	/// </summary>
	/// <param name="b">The index in <see cref="F:Terraria.Player.buffType" /> of the buff to remove.</param>
	public void DelBuff(int b)
	{
		buffTime[b] = 0;
		buffType[b] = 0;
		int num = 0;
		for (int i = 0; i < maxBuffs - 1; i++)
		{
			if (buffTime[i] != 0 && buffType[i] != 0)
			{
				if (num < i)
				{
					buffTime[num] = buffTime[i];
					buffType[num] = buffType[i];
					buffTime[i] = 0;
					buffType[i] = 0;
				}
				num++;
			}
		}
	}

	/// <summary>
	/// Removes the provided buff type from the player and shuffles the remaining buff indexes down to fill the gap. Use <see cref="M:Terraria.Player.DelBuff(System.Int32)" /> if you only know the buff index
	/// </summary>
	/// <param name="type">The buff type</param>
	public void ClearBuff(int type)
	{
		if (type == 0)
		{
			return;
		}
		for (int i = 0; i < maxBuffs; i++)
		{
			if (buffType[i] == type)
			{
				DelBuff(i);
			}
		}
	}

	public int CountBuffs()
	{
		int num = 0;
		for (int i = 0; i < maxBuffs; i++)
		{
			if (buffType[num] > 0)
			{
				num++;
			}
		}
		return num;
	}

	public void QuickHeal()
	{
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		if (cursed || CCed || dead || statLife == statLifeMax2 || potionDelay > 0)
		{
			return;
		}
		Item item = QuickHeal_GetItemToUse();
		if (item == null || !ItemCheck_CheckCanUse(item))
		{
			return;
		}
		SoundEngine.PlaySound(item.UseSound, position);
		if (item.potion)
		{
			ApplyPotionDelay(item);
		}
		ItemLoader.UseItem(item, this);
		ApplyLifeAndOrMana(item);
		if (item.type == 5)
		{
			TryToResetHungerToNeutral();
		}
		if (item.buffType > 0)
		{
			int num = item.buffTime;
			if (num == 0)
			{
				num = 3600;
			}
			AddBuff(item.buffType, num);
		}
		if (item.consumable && ItemLoader.ConsumeItem(item, this))
		{
			item.stack--;
		}
		if (item.stack <= 0)
		{
			item.TurnToAir();
		}
		if (Main.myPlayer == whoAmI && item.type == 126 && breath == 0)
		{
			AchievementsHelper.HandleSpecialEvent(this, 25);
		}
		Recipe.FindRecipes();
	}

	public Item QuickHeal_GetItemToUse()
	{
		int num = statLifeMax2 - statLife;
		Item result = null;
		int num2 = -statLifeMax2;
		int num3 = 58;
		if (useVoidBag())
		{
			num3 = 98;
		}
		for (int i = 0; i < num3; i++)
		{
			Item item = ((i >= 58) ? bank4.item[i - 58] : inventory[i]);
			if (item.stack <= 0 || item.type <= 0 || !item.potion || item.healLife <= 0 || !CombinedHooks.CanUseItem(this, item))
			{
				continue;
			}
			int num4 = GetHealLife(item, quickHeal: true) - num;
			if (item.type == 227 && num4 < 0)
			{
				num4 += 30;
				if (num4 > 0)
				{
					num4 = 0;
				}
			}
			if (num2 < 0)
			{
				if (num4 > num2)
				{
					result = item;
					num2 = num4;
				}
			}
			else if (num4 < num2 && num4 >= 0)
			{
				result = item;
				num2 = num4;
			}
		}
		return result;
	}

	public void QuickMana()
	{
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		if (cursed || CCed || dead || statMana == statManaMax2)
		{
			return;
		}
		Item item = QuickMana_GetItemToUse();
		if (item != null && ItemCheck_CheckCanUse(item))
		{
			SoundEngine.PlaySound(item.UseSound, position);
			if (item.potion)
			{
				ApplyPotionDelay(item);
			}
			ItemLoader.UseItem(item, this);
			ApplyLifeAndOrMana(item);
			if (item.consumable && ItemLoader.ConsumeItem(item, this))
			{
				item.stack--;
			}
			if (item.stack <= 0)
			{
				item.TurnToAir();
			}
			Recipe.FindRecipes();
		}
	}

	public Item QuickMana_GetItemToUse()
	{
		for (int i = 0; i < 58; i++)
		{
			if (inventory[i].stack > 0 && inventory[i].type > 0 && inventory[i].healMana > 0 && (potionDelay == 0 || !inventory[i].potion) && CombinedHooks.CanUseItem(this, inventory[i]))
			{
				return inventory[i];
			}
		}
		if (useVoidBag())
		{
			for (int j = 0; j < 40; j++)
			{
				if (bank4.item[j].stack > 0 && bank4.item[j].type > 0 && bank4.item[j].healMana > 0 && (potionDelay == 0 || !bank4.item[j].potion) && CombinedHooks.CanUseItem(this, bank4.item[j]))
				{
					return bank4.item[j];
				}
			}
		}
		return null;
	}

	public void TrySwitchingLoadout(int loadoutIndex)
	{
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		bool flag = itemTime > 0 || itemAnimation > 0;
		if ((whoAmI != Main.myPlayer || (!flag && !CCed && !dead)) && loadoutIndex != CurrentLoadoutIndex && loadoutIndex >= 0 && loadoutIndex < Loadouts.Length)
		{
			int currentLoadoutIndex = CurrentLoadoutIndex;
			Loadouts[CurrentLoadoutIndex].Swap(this);
			Loadouts[loadoutIndex].Swap(this);
			CurrentLoadoutIndex = loadoutIndex;
			if (whoAmI == Main.myPlayer)
			{
				CloneLoadouts(Main.clientPlayer);
				Main.mouseLeftRelease = false;
				ItemSlot.RecordLoadoutChange();
				SoundEngine.PlaySound(12);
				NetMessage.TrySendData(147, -1, -1, null, whoAmI, loadoutIndex);
				ParticleOrchestrator.RequestParticleSpawn(clientOnly: false, ParticleOrchestraType.LoadoutChange, new ParticleOrchestraSettings
				{
					PositionInWorld = base.Center,
					UniqueInfoPiece = loadoutIndex
				}, whoAmI);
			}
			PlayerLoader.OnEquipmentLoadoutSwitched(this, currentLoadoutIndex, loadoutIndex);
		}
	}

	public void QuickBuff()
	{
		//IL_0259: Unknown result type (might be due to invalid IL or missing references)
		if (cursed || CCed || dead)
		{
			return;
		}
		SoundStyle? style = null;
		if (CountBuffs() == maxBuffs)
		{
			return;
		}
		Item item = QuickBuff_PickBestFoodItem();
		if (item != null && ItemCheck_CheckCanUse(item))
		{
			style = item.UseSound;
			int num = item.buffTime;
			if (num == 0)
			{
				num = 3600;
			}
			ItemLoader.UseItem(item, this);
			AddBuff(item.buffType, num);
			if (item.consumable && ItemLoader.ConsumeItem(item, this))
			{
				item.stack--;
				if (item.stack <= 0)
				{
					item.TurnToAir();
				}
			}
		}
		if (CountBuffs() != maxBuffs)
		{
			int num2 = 58;
			if (useVoidBag())
			{
				num2 = 98;
			}
			for (int i = 0; i < num2; i++)
			{
				Item item2 = ((i >= 58) ? bank4.item[i - 58] : inventory[i]);
				if (item2.stack <= 0 || item2.type <= 0 || item2.buffType <= 0 || item2.summon || !ItemCheck_CheckCanUse(item2))
				{
					continue;
				}
				int num3 = item2.buffType;
				bool flag = CombinedHooks.CanUseItem(this, item2) && QuickBuff_ShouldBotherUsingThisBuff(num3);
				if (item2.mana > 0 && flag)
				{
					if (CheckMana(item2, -1, pay: true, blockQuickMana: true))
					{
						manaRegenDelay = (int)maxRegenDelay;
					}
					else
					{
						flag = false;
					}
				}
				if (whoAmI == Main.myPlayer && item2.type == 603 && !Main.runningCollectorsEdition)
				{
					flag = false;
				}
				if (num3 == 27)
				{
					num3 = Main.rand.Next(3);
					if (num3 == 0)
					{
						num3 = 27;
					}
					if (num3 == 1)
					{
						num3 = 101;
					}
					if (num3 == 2)
					{
						num3 = 102;
					}
				}
				if (!flag)
				{
					continue;
				}
				ItemLoader.UseItem(item2, this);
				style = item2.UseSound;
				int num4 = item2.buffTime;
				if (num4 == 0)
				{
					num4 = 3600;
				}
				AddBuff(num3, num4);
				if (item2.consumable && ItemLoader.ConsumeItem(item2, this))
				{
					item2.stack--;
					if (item2.stack <= 0)
					{
						item2.TurnToAir();
					}
				}
				if (CountBuffs() == maxBuffs)
				{
					break;
				}
			}
		}
		if (style.HasValue)
		{
			SoundEngine.PlaySound(style, position);
			Recipe.FindRecipes();
		}
	}

	private Item QuickBuff_PickBestFoodItem()
	{
		int num = 0;
		Item item = null;
		for (int i = 0; i < maxBuffs; i++)
		{
			if (buffTime[i] >= 1)
			{
				int num2 = QuickBuff_FindFoodPriority(buffType[i]);
				if (num <= num2)
				{
					num = num2 + 1;
				}
			}
		}
		for (int j = 0; j < 58; j++)
		{
			Item item2 = inventory[j];
			if (!item2.IsAir)
			{
				int num3 = QuickBuff_FindFoodPriority(item2.buffType);
				if (num3 >= num && (item == null || item.buffTime < item2.buffTime || num3 > num))
				{
					item = item2;
					num = num3;
				}
			}
		}
		if (useVoidBag())
		{
			for (int k = 0; k < 40; k++)
			{
				Item item3 = bank4.item[k];
				if (!item3.IsAir)
				{
					int num4 = QuickBuff_FindFoodPriority(item3.buffType);
					if (num4 >= num && (item == null || item.buffTime < item3.buffTime || num4 > num))
					{
						item = item3;
						num = num4;
					}
				}
			}
		}
		return item;
	}

	private int QuickBuff_FindFoodPriority(int buffType)
	{
		return buffType switch
		{
			26 => 1, 
			206 => 2, 
			207 => 3, 
			_ => 0, 
		};
	}

	private bool QuickBuff_ShouldBotherUsingThisBuff(int attemptedType)
	{
		bool result = true;
		for (int i = 0; i < maxBuffs; i++)
		{
			if (attemptedType == 27 && (buffType[i] == 27 || buffType[i] == 101 || buffType[i] == 102))
			{
				result = false;
				break;
			}
			if (BuffID.Sets.IsWellFed[attemptedType] && BuffID.Sets.IsWellFed[buffType[i]])
			{
				result = false;
				break;
			}
			if (buffType[i] == attemptedType)
			{
				result = false;
				break;
			}
			if (Main.meleeBuff[attemptedType] && Main.meleeBuff[buffType[i]])
			{
				result = false;
				break;
			}
		}
		if (Main.lightPet[attemptedType] || Main.vanityPet[attemptedType])
		{
			for (int j = 0; j < maxBuffs; j++)
			{
				if (Main.lightPet[buffType[j]] && Main.lightPet[attemptedType])
				{
					result = false;
				}
				if (Main.vanityPet[buffType[j]] && Main.vanityPet[attemptedType])
				{
					result = false;
				}
			}
		}
		return result;
	}

	public void QuickMount()
	{
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		if (mount.Active)
		{
			mount.Dismount(this);
		}
		else
		{
			if (frozen || tongued || webbed || stoned || gravDir == -1f || dead || noItems)
			{
				return;
			}
			Item item = QuickMount_GetItemToUse();
			if (item != null && item.mountType != -1 && mount.CanMount(item.mountType, this) && ItemCheck_CheckCanUse(item))
			{
				if (!QuickMinecartSnap())
				{
					mount.SetMount(item.mountType, this);
					ItemLoader.UseItem(item, this);
					if (item.UseSound.HasValue)
					{
						SoundEngine.PlaySound(item.UseSound, base.Center);
					}
				}
			}
			else
			{
				QuickMinecart();
			}
		}
	}

	public bool CanFitSpace(int heightBoost)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		int num = 42 + heightBoost;
		return Collision.IsClearSpotTest(position + new Vector2(0f, (float)(height - num)) + velocity, 16f, width, num, fallThrough: true, fall2: true);
	}

	private void QuickMinecart()
	{
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0203: Unknown result type (might be due to invalid IL or missing references)
		//IL_020f: Unknown result type (might be due to invalid IL or missing references)
		//IL_015d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0162: Unknown result type (might be due to invalid IL or missing references)
		//IL_016c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0176: Unknown result type (might be due to invalid IL or missing references)
		//IL_017b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0180: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_018c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0196: Unknown result type (might be due to invalid IL or missing references)
		//IL_019b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01af: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c8: Unknown result type (might be due to invalid IL or missing references)
		int num = 0;
		int value = (int)(position.X / 16f) - tileRangeX - num + 1;
		int value2 = (int)((position.X + (float)width) / 16f) + tileRangeX + num - 1;
		int value3 = (int)(position.Y / 16f) - tileRangeY - num + 1;
		int value4 = (int)((position.Y + (float)height) / 16f) + tileRangeY + num - 2;
		int num2 = Utils.Clamp(value, 10, Main.maxTilesX - 10);
		value2 = Utils.Clamp(value2, 10, Main.maxTilesX - 10);
		value3 = Utils.Clamp(value3, 10, Main.maxTilesY - 10);
		List<Point> list = Collision.GetTilesIn(BottomRight: new Vector2((float)(value2 + 1), (float)(Utils.Clamp(value4, 10, Main.maxTilesY - 10) + 1)) * 16f, TopLeft: new Vector2((float)num2, (float)value3) * 16f);
		if (list.Count <= 0)
		{
			return;
		}
		Point? val = null;
		_ = base.Hitbox;
		for (int i = 0; i < list.Count; i++)
		{
			Point val2 = list[i];
			Tile tileSafely = Framing.GetTileSafely(val2.X, val2.Y);
			if (tileSafely.active() && tileSafely.type == 314)
			{
				Vector2 val3 = list[i].ToVector2() * 16f + new Vector2(8f);
				if (!val.HasValue || (Distance(val3) < Distance(val.Value.ToVector2() * 16f + new Vector2(8f)) && Collision.CanHitLine(base.Center, 0, 0, val3, 0, 0)))
				{
					val = list[i];
				}
			}
		}
		if (val.HasValue)
		{
			LaunchMinecartHook(val.Value.X, val.Value.Y);
		}
	}

	private bool QuickMinecartSnap()
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0132: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		bool result = false;
		List<Point> tilesIn = Collision.GetTilesIn(base.TopLeft - new Vector2(24f), base.BottomRight + new Vector2(24f));
		if (tilesIn.Count > 0)
		{
			Point? val = null;
			_ = base.Hitbox;
			for (int i = 0; i < tilesIn.Count; i++)
			{
				Point val2 = tilesIn[i];
				Tile tileSafely = Framing.GetTileSafely(val2.X, val2.Y);
				if (tileSafely.active() && tileSafely.type == 314)
				{
					Vector2 val3 = tilesIn[i].ToVector2() * 16f + new Vector2(8f);
					if (!val.HasValue || (Distance(val3) < Distance(val.Value.ToVector2() * 16f + new Vector2(8f)) && Collision.CanHitLine(base.Center, 0, 0, val3, 0, 0)))
					{
						val = tilesIn[i];
					}
				}
			}
			if (val.HasValue)
			{
				LaunchMinecartHook(val.Value.X, val.Value.Y);
				result = true;
			}
		}
		return result;
	}

	public Item QuickMount_GetItemToUse()
	{
		Item item = null;
		bool flag = false;
		if (item == null && miscEquips[3].mountType != -1 && !MountID.Sets.Cart[miscEquips[3].mountType])
		{
			flag = true;
		}
		if (flag && CombinedHooks.CanUseItem(this, miscEquips[3]))
		{
			item = miscEquips[3];
		}
		if (item == null)
		{
			for (int i = 0; i < 58; i++)
			{
				if (inventory[i].mountType != -1 && !MountID.Sets.Cart[inventory[i].mountType] && CombinedHooks.CanUseItem(this, inventory[i]))
				{
					item = inventory[i];
					break;
				}
			}
		}
		return item;
	}

	public void ClearGrapplingBlacklist()
	{
		_blackListedTileCoordsForGrappling.Clear();
	}

	public bool IsBlacklistedForGrappling(Point p)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return _blackListedTileCoordsForGrappling.Contains(p);
	}

	public void UpdateBlacklistedTilesForGrappling()
	{
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		ClearGrapplingBlacklist();
		for (int i = 0; i < 1000; i++)
		{
			if (!Main.projectile[i].active || Main.projectile[i].owner != whoAmI || Main.projectile[i].aiStyle != 7 || Main.projectile[i].ai[0] != 2f)
			{
				continue;
			}
			Point val = Main.projectile[i].Center.ToTileCoordinates();
			for (int j = -1; j <= 1; j++)
			{
				for (int k = -1; k <= 1; k++)
				{
					if (!WorldGen.SolidTile(val.X + j, val.Y + k))
					{
						_blackListedTileCoordsForGrappling.Add(new Point(val.X + j, val.Y + k));
					}
				}
			}
		}
	}

	public void QuickGrapple()
	{
		//IL_0451: Unknown result type (might be due to invalid IL or missing references)
		//IL_07d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_07f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0822: Unknown result type (might be due to invalid IL or missing references)
		//IL_0894: Unknown result type (might be due to invalid IL or missing references)
		//IL_089b: Unknown result type (might be due to invalid IL or missing references)
		if (frozen || tongued || webbed || stoned || dead)
		{
			return;
		}
		if (PlayerInput.GrappleAndInteractAreShared)
		{
			if (Main.HoveringOverAnNPC || Main.SmartInteractShowingGenuine || Main.SmartInteractShowingFake || (_quickGrappleCooldown > 0 && !Main.mapFullscreen) || (WiresUI.Settings.DrawToolModeUI && PlayerInput.UsingGamepad))
			{
				return;
			}
			bool num = controlUseTile;
			bool flag = releaseUseTile;
			if (!num && !flag)
			{
				return;
			}
			Tile tileSafely = Framing.GetTileSafely(tileTargetX, tileTargetY);
			if ((tileSafely.active() && (tileSafely.type == 4 || tileSafely.type == 33 || tileSafely.type == 372 || tileSafely.type == 174 || tileSafely.type == 646 || tileSafely.type == 49)) || (inventory[selectedItem].type == 3384 && PlayerInput.UsingGamepad))
			{
				return;
			}
		}
		if (noItems)
		{
			return;
		}
		if (mount.Active)
		{
			mount.Dismount(this);
		}
		Item item = QuickGrapple_GetItemToUse();
		if (item == null || !ItemCheck_CheckCanUse(item))
		{
			return;
		}
		bool? flag2 = ProjectileLoader.CanUseGrapple(item.shoot, this);
		if (flag2.HasValue)
		{
			if (flag2 != true)
			{
				item = null;
			}
		}
		else if (item.shoot == 73)
		{
			int num2 = 0;
			for (int i = 0; i < 1000; i++)
			{
				if (Main.projectile[i].active && Main.projectile[i].owner == Main.myPlayer && (Main.projectile[i].type == 73 || Main.projectile[i].type == 74))
				{
					num2++;
				}
			}
			if (num2 > 1)
			{
				item = null;
			}
		}
		else if (item.shoot == 165)
		{
			int num3 = 0;
			for (int j = 0; j < 1000; j++)
			{
				if (Main.projectile[j].active && Main.projectile[j].owner == Main.myPlayer && Main.projectile[j].type == 165)
				{
					num3++;
				}
			}
			if (num3 > 8)
			{
				item = null;
			}
		}
		else if (item.shoot == 372)
		{
			int num4 = 0;
			for (int k = 0; k < 1000; k++)
			{
				if (Main.projectile[k].active && Main.projectile[k].owner == Main.myPlayer && Main.projectile[k].type == 372)
				{
					num4++;
				}
			}
			if (num4 > 2)
			{
				item = null;
			}
		}
		else if (item.shoot == 652)
		{
			int num5 = 0;
			for (int l = 0; l < 1000; l++)
			{
				if (Main.projectile[l].active && Main.projectile[l].owner == Main.myPlayer && Main.projectile[l].type == 652)
				{
					num5++;
				}
			}
			if (num5 > 1)
			{
				item = null;
			}
		}
		else if (item.type == 3572)
		{
			int num6 = 0;
			bool flag3 = false;
			for (int m = 0; m < 1000; m++)
			{
				if (Main.projectile[m].active && Main.projectile[m].owner == Main.myPlayer && Main.projectile[m].type >= 646 && Main.projectile[m].type <= 649)
				{
					num6++;
					if (Main.projectile[m].ai[0] == 2f)
					{
						flag3 = true;
					}
				}
			}
			if (num6 > 4 || (!flag3 && num6 > 3))
			{
				item = null;
			}
		}
		else
		{
			for (int n = 0; n < 1000; n++)
			{
				if (Main.projectile[n].active && Main.projectile[n].owner == Main.myPlayer && Main.projectile[n].type == item.shoot && Main.projectile[n].ai[0] != 2f)
				{
					item = null;
					break;
				}
			}
		}
		if (item == null)
		{
			return;
		}
		UpdateBlacklistedTilesForGrappling();
		SoundEngine.PlaySound(item.UseSound, position);
		if (Main.netMode == 1 && whoAmI == Main.myPlayer)
		{
			NetMessage.SendData(51, -1, -1, null, whoAmI, 2f);
		}
		int type = item.shoot;
		float shootSpeed = item.shootSpeed;
		int damage = item.damage;
		float knockBack = item.knockBack;
		if (ProjectileID.Sets.SingleGrappleHook[type])
		{
			grappling[0] = -1;
			grapCount = 0;
			for (int num7 = 0; num7 < 1000; num7++)
			{
				if (Main.projectile[num7].active && Main.projectile[num7].owner == whoAmI && ProjectileID.Sets.SingleGrappleHook[Main.projectile[num7].type])
				{
					Main.projectile[num7].Kill();
				}
			}
		}
		if (type == 256)
		{
			int num8 = 0;
			int num9 = -1;
			int num10 = 100000;
			for (int num11 = 0; num11 < 1000; num11++)
			{
				if (Main.projectile[num11].active && Main.projectile[num11].owner == whoAmI && Main.projectile[num11].type == 256)
				{
					num8++;
					if (Main.projectile[num11].timeLeft < num10)
					{
						num9 = num11;
						num10 = Main.projectile[num11].timeLeft;
					}
				}
			}
			if (num8 > 1)
			{
				Main.projectile[num9].Kill();
			}
		}
		if (type == 652)
		{
			int num12 = 0;
			int num13 = -1;
			int num14 = 100000;
			for (int num15 = 0; num15 < 1000; num15++)
			{
				if (Main.projectile[num15].active && Main.projectile[num15].owner == whoAmI && Main.projectile[num15].type == 652)
				{
					num12++;
					if (Main.projectile[num15].timeLeft < num14)
					{
						num13 = num15;
						num14 = Main.projectile[num15].timeLeft;
					}
				}
			}
			if (num12 > 1)
			{
				Main.projectile[num13].Kill();
			}
		}
		if (type == 73)
		{
			for (int num16 = 0; num16 < 1000; num16++)
			{
				if (Main.projectile[num16].active && Main.projectile[num16].owner == whoAmI && Main.projectile[num16].type == 73)
				{
					type = 74;
				}
			}
		}
		if (item.type == 3572)
		{
			int num17 = -1;
			int num18 = -1;
			for (int num19 = 0; num19 < 1000; num19++)
			{
				Projectile projectile = Main.projectile[num19];
				if (projectile.active && projectile.owner == whoAmI && projectile.type >= 646 && projectile.type <= 649 && (num18 == -1 || num18 < projectile.timeLeft))
				{
					num17 = projectile.type;
					num18 = projectile.timeLeft;
				}
			}
			switch (num17)
			{
			case 646:
				type = 647;
				break;
			case 647:
				type = 648;
				break;
			case 648:
				type = 649;
				break;
			case -1:
			case 649:
				type = 646;
				break;
			}
		}
		ProjectileLoader.UseGrapple(this, ref type);
		Vector2 val = default(Vector2);
		((Vector2)(ref val))..ctor(position.X + (float)width * 0.5f, position.Y + (float)height * 0.5f);
		float num20 = (float)Main.mouseX + Main.screenPosition.X - val.X;
		float num21 = (float)Main.mouseY + Main.screenPosition.Y - val.Y;
		if (gravDir == -1f)
		{
			num21 = Main.screenPosition.Y + (float)Main.screenHeight - (float)Main.mouseY - val.Y;
		}
		float num22 = (float)Math.Sqrt(num20 * num20 + num21 * num21);
		if ((float.IsNaN(num20) && float.IsNaN(num21)) || (num20 == 0f && num21 == 0f))
		{
			num20 = direction;
			num21 = 0f;
			num22 = shootSpeed;
		}
		else
		{
			num22 = shootSpeed / num22;
		}
		num20 *= num22;
		num21 *= num22;
		Projectile.NewProjectile(GetProjectileSource_Item(item), val.X, val.Y, num20, num21, type, damage, knockBack, whoAmI);
	}

	public Item QuickGrapple_GetItemToUse()
	{
		Item item = null;
		if (Main.projHook[miscEquips[4].shoot])
		{
			item = miscEquips[4];
		}
		if (item == null)
		{
			for (int i = 0; i < 58; i++)
			{
				if (Main.projHook[inventory[i].shoot])
				{
					item = inventory[i];
					break;
				}
			}
		}
		return item;
	}

	public void StatusToNPC(int type, int i)
	{
		if (meleeEnchant > 0)
		{
			if (meleeEnchant == 1)
			{
				Main.npc[i].AddBuff(70, 60 * Main.rand.Next(5, 10));
			}
			if (meleeEnchant == 2)
			{
				Main.npc[i].AddBuff(39, 60 * Main.rand.Next(3, 7));
			}
			if (meleeEnchant == 3)
			{
				Main.npc[i].AddBuff(24, 60 * Main.rand.Next(3, 7));
			}
			if (meleeEnchant == 5)
			{
				Main.npc[i].AddBuff(69, 60 * Main.rand.Next(10, 20));
			}
			if (meleeEnchant == 6)
			{
				Main.npc[i].AddBuff(31, 60 * Main.rand.Next(1, 4));
			}
			if (meleeEnchant == 8)
			{
				Main.npc[i].AddBuff(20, 60 * Main.rand.Next(5, 10));
			}
			if (meleeEnchant == 4)
			{
				Main.npc[i].AddBuff(72, 120);
			}
		}
		if (frostBurn)
		{
			Main.npc[i].AddBuff(324, 60 * Main.rand.Next(5, 15));
		}
		if (magmaStone)
		{
			if (Main.rand.Next(4) == 0)
			{
				Main.npc[i].AddBuff(323, 360);
			}
			else if (Main.rand.Next(2) == 0)
			{
				Main.npc[i].AddBuff(323, 240);
			}
			else
			{
				Main.npc[i].AddBuff(323, 120);
			}
		}
		if (type == 3211)
		{
			Main.npc[i].AddBuff(69, 60 * Main.rand.Next(5, 10));
		}
		if (type == 5129)
		{
			Main.npc[i].AddBuff(120, 300);
		}
		switch (type)
		{
		case 121:
			if (Main.rand.Next(2) == 0)
			{
				Main.npc[i].AddBuff(24, 180);
			}
			break;
		case 3823:
			if (Main.rand.Next(4) == 0)
			{
				Main.npc[i].AddBuff(323, 300);
			}
			break;
		case 5382:
			if (Main.rand.Next(3) == 0)
			{
				Main.npc[i].AddBuff(323, 300);
			}
			break;
		case 122:
			if (Main.rand.Next(10) == 0)
			{
				Main.npc[i].AddBuff(24, 180);
			}
			break;
		case 190:
			if (Main.rand.Next(4) == 0)
			{
				Main.npc[i].AddBuff(20, 420);
			}
			break;
		case 217:
			if (Main.rand.Next(5) == 0)
			{
				Main.npc[i].AddBuff(24, 180);
			}
			break;
		case 1123:
			if (Main.rand.Next(10) != 0)
			{
				Main.npc[i].AddBuff(31, 120);
			}
			break;
		}
	}

	public void StatusToPlayerPvP(int type, int i)
	{
		if (meleeEnchant > 0)
		{
			if (meleeEnchant == 1)
			{
				Main.player[i].AddBuff(70, 60 * Main.rand.Next(5, 10), quiet: false);
			}
			if (meleeEnchant == 2)
			{
				Main.player[i].AddBuff(39, 60 * Main.rand.Next(3, 7), quiet: false);
			}
			if (meleeEnchant == 3)
			{
				Main.player[i].AddBuff(24, 60 * Main.rand.Next(3, 7), quiet: false);
			}
			if (meleeEnchant == 5)
			{
				Main.player[i].AddBuff(69, 60 * Main.rand.Next(10, 20), quiet: false);
			}
			if (meleeEnchant == 6)
			{
				Main.player[i].AddBuff(31, 60 * Main.rand.Next(1, 4), quiet: false);
			}
			if (meleeEnchant == 8)
			{
				Main.player[i].AddBuff(20, 60 * Main.rand.Next(5, 10), quiet: false);
			}
		}
		if (frostBurn)
		{
			Main.player[i].AddBuff(324, 60 * Main.rand.Next(1, 8), quiet: false);
		}
		if (magmaStone)
		{
			if (Main.rand.Next(7) == 0)
			{
				Main.player[i].AddBuff(323, 360, quiet: false);
			}
			else if (Main.rand.Next(3) == 0)
			{
				Main.player[i].AddBuff(323, 120, quiet: false);
			}
			else
			{
				Main.player[i].AddBuff(323, 60, quiet: false);
			}
		}
		if (type == 5129)
		{
			Main.player[i].AddBuff(120, 300, quiet: false);
		}
		switch (type)
		{
		case 121:
			if (Main.rand.Next(2) == 0)
			{
				Main.player[i].AddBuff(24, 180, quiet: false);
			}
			break;
		case 3823:
			if (Main.rand.Next(4) == 0)
			{
				Main.player[i].AddBuff(323, 300, quiet: false);
			}
			break;
		case 5382:
			if (Main.rand.Next(3) == 0)
			{
				Main.player[i].AddBuff(323, 300, quiet: false);
			}
			break;
		case 122:
			if (Main.rand.Next(10) == 0)
			{
				Main.player[i].AddBuff(24, 180, quiet: false);
			}
			break;
		case 190:
			if (Main.rand.Next(4) == 0)
			{
				Main.player[i].AddBuff(20, 420, quiet: false);
			}
			break;
		case 217:
			if (Main.rand.Next(5) == 0)
			{
				Main.player[i].AddBuff(24, 180, quiet: false);
			}
			break;
		case 1123:
			if (Main.rand.Next(9) != 0)
			{
				Main.player[i].AddBuff(31, 120, quiet: false);
			}
			break;
		}
	}

	public void Ghost()
	{
		//IL_02cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02db: Unknown result type (might be due to invalid IL or missing references)
		immune = false;
		immuneAlpha = 0;
		if (Main.hasFocus && whoAmI == Main.myPlayer)
		{
			controlUp = false;
			controlLeft = false;
			controlDown = false;
			controlRight = false;
			controlJump = false;
			if (!Main.drawingPlayerChat && !Main.editSign && !Main.editChest && !Main.blockInput)
			{
				PlayerInput.Triggers.Current.CopyInto(this);
				TrySyncingInput();
				TryOpeningInGameOptionsBasedOnInput();
			}
		}
		float num = 7f;
		float num2 = 0.2f;
		if (controlUp || controlJump)
		{
			if (velocity.Y > 0f)
			{
				velocity.Y *= 0.9f;
			}
			velocity.Y -= num2;
			if (velocity.Y < 0f - num)
			{
				velocity.Y = 0f - num;
			}
		}
		else if (controlDown)
		{
			if (velocity.Y < 0f)
			{
				velocity.Y *= 0.9f;
			}
			velocity.Y += num2;
			if (velocity.Y > num)
			{
				velocity.Y = num;
			}
		}
		else if ((double)velocity.Y < -0.1 || (double)velocity.Y > 0.1)
		{
			velocity.Y *= 0.9f;
		}
		else
		{
			velocity.Y = 0f;
		}
		if (controlLeft && !controlRight)
		{
			if (velocity.X > 0f)
			{
				velocity.X *= 0.9f;
			}
			velocity.X -= num2;
			if (velocity.X < 0f - num)
			{
				velocity.X = 0f - num;
			}
		}
		else if (controlRight && !controlLeft)
		{
			if (velocity.X < 0f)
			{
				velocity.X *= 0.9f;
			}
			velocity.X += num2;
			if (velocity.X > num)
			{
				velocity.X = num;
			}
		}
		else if (velocity.X < 0f - num2 || velocity.X > num2)
		{
			velocity.X *= 0.9f;
		}
		else
		{
			velocity.X = 0f;
		}
		position += velocity;
		ghostFrameCounter++;
		if (velocity.X < 0f)
		{
			direction = -1;
		}
		else if (velocity.X > 0f)
		{
			direction = 1;
		}
		if (ghostFrameCounter >= 8)
		{
			ghostFrameCounter = 0;
			ghostFrame++;
			if (ghostFrame >= 4)
			{
				ghostFrame = 0;
			}
		}
		if (position.X < Main.leftWorld + (float)(Lighting.OffScreenTiles * 16) + 16f)
		{
			position.X = Main.leftWorld + (float)(Lighting.OffScreenTiles * 16) + 16f;
			velocity.X = 0f;
		}
		if (position.X + (float)width > Main.rightWorld - (float)(Lighting.OffScreenTiles * 16) - 32f)
		{
			position.X = Main.rightWorld - (float)(Lighting.OffScreenTiles * 16) - 32f - (float)width;
			velocity.X = 0f;
		}
		if (position.Y < Main.topWorld + (float)(Lighting.OffScreenTiles * 16) + 16f)
		{
			position.Y = Main.topWorld + (float)(Lighting.OffScreenTiles * 16) + 16f;
			if ((double)velocity.Y < -0.1)
			{
				velocity.Y = -0.1f;
			}
		}
		if (position.Y > Main.bottomWorld - (float)(Lighting.OffScreenTiles * 16) - 32f - (float)height)
		{
			position.Y = Main.bottomWorld - (float)(Lighting.OffScreenTiles * 16) - 32f - (float)height;
			velocity.Y = 0f;
		}
	}

	private void TrySyncingInput()
	{
		if (Main.netMode == 1)
		{
			bool flag = false;
			Player clientPlayer = Main.clientPlayer;
			if (controlUp != clientPlayer.controlUp)
			{
				flag = true;
			}
			if (controlDown != clientPlayer.controlDown)
			{
				flag = true;
			}
			if (controlLeft != clientPlayer.controlLeft)
			{
				flag = true;
			}
			if (controlRight != clientPlayer.controlRight)
			{
				flag = true;
			}
			if (controlJump != clientPlayer.controlJump)
			{
				flag = true;
			}
			if (controlUseItem != clientPlayer.controlUseItem)
			{
				flag = true;
			}
			if (selectedItem != clientPlayer.selectedItem)
			{
				flag = true;
			}
			if (autoReuseAllWeapons != clientPlayer.autoReuseAllWeapons)
			{
				flag = true;
			}
			if (controlDownHold != clientPlayer.controlDownHold)
			{
				flag = true;
			}
			if (isOperatingAnotherEntity != clientPlayer.isOperatingAnotherEntity)
			{
				flag = true;
			}
			if (flag)
			{
				NetMessage.SendData(13, -1, -1, null, Main.myPlayer);
			}
		}
	}

	public void OnHit(float x, float y, Entity victim)
	{
		if (Main.myPlayer == whoAmI)
		{
			OnHit_Inner(x, y, victim);
			PlayerLoader.OnHitAnything(this, x, y, victim);
		}
	}

	private void OnHit_Inner(float x, float y, Entity victim)
	{
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_024f: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0401: Unknown result type (might be due to invalid IL or missing references)
		//IL_0454: Unknown result type (might be due to invalid IL or missing references)
		//IL_0460: Unknown result type (might be due to invalid IL or missing references)
		//IL_0466: Unknown result type (might be due to invalid IL or missing references)
		//IL_017e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0184: Unknown result type (might be due to invalid IL or missing references)
		//IL_0189: Unknown result type (might be due to invalid IL or missing references)
		//IL_018e: Unknown result type (might be due to invalid IL or missing references)
		//IL_04b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_04ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_01af: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_048b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0493: Unknown result type (might be due to invalid IL or missing references)
		//IL_0498: Unknown result type (might be due to invalid IL or missing references)
		bool flag = victim is NPC && (((NPC)victim).type == 488 || ((NPC)victim).SpawnedFromStatue);
		if (titaniumStormCooldown > 0)
		{
			flag = true;
		}
		if (victim is NPC)
		{
			Main.BigBossProgressBar.TryTracking(victim.whoAmI);
		}
		if (onHitTitaniumStorm && !flag)
		{
			titaniumStormCooldown = 10;
			AddBuff(306, 600);
			if (ownedProjectileCounts[908] < 7)
			{
				ownedProjectileCounts[908]++;
				Projectile.NewProjectile(GetProjectileSource_OnHit(victim, 4), base.Center, Vector2.Zero, 908, 50, 15f, whoAmI);
			}
		}
		if (onHitDodge && shadowDodgeTimer == 0)
		{
			AddBuff(59, 1800);
		}
		if (onHitRegen)
		{
			AddBuff(58, 300);
		}
		if (stardustMinion && victim is NPC)
		{
			for (int i = 0; i < 1000; i++)
			{
				Projectile projectile = Main.projectile[i];
				if (projectile.active && projectile.owner == whoAmI && projectile.type == 613 && !(projectile.localAI[1] > 0f) && Main.rand.Next(2) == 0)
				{
					Vector2 val = new Vector2(x, y) - projectile.Center;
					if (((Vector2)(ref val)).Length() > 0f)
					{
						((Vector2)(ref val)).Normalize();
					}
					val *= 20f;
					Projectile.NewProjectile(Entity.InheritSource(projectile), projectile.Center.X, projectile.Center.Y, val.X, val.Y, 614, projectile.damage / 3, 0f, projectile.owner, 0f, victim.whoAmI);
					projectile.localAI[1] = 30 + Main.rand.Next(4) * 10;
				}
			}
		}
		if (onHitPetal && petalTimer == 0)
		{
			petalTimer = 20;
			_ = position;
			_ = width / 2;
			int num = direction;
			float num2 = Main.screenPosition.X;
			if (num < 0)
			{
				num2 += (float)Main.screenWidth;
			}
			float y2 = Main.screenPosition.Y;
			y2 += (float)Main.rand.Next(Main.screenHeight);
			Vector2 val2 = default(Vector2);
			((Vector2)(ref val2))..ctor(num2, y2);
			float num3 = x - val2.X;
			float num4 = y - val2.Y;
			num3 += (float)Main.rand.Next(-50, 51) * 0.1f;
			num4 += (float)Main.rand.Next(-50, 51) * 0.1f;
			float num5 = (float)Math.Sqrt(num3 * num3 + num4 * num4);
			num5 = 24f / num5;
			num3 *= num5;
			num4 *= num5;
			Projectile.NewProjectile(GetProjectileSource_OnHit(victim, 5), num2, y2, num3, num4, 221, 36, 0f, whoAmI);
		}
		if (!crystalLeaf || petalTimer != 0)
		{
			return;
		}
		Vector2 val3 = default(Vector2);
		for (int j = 0; j < 1000; j++)
		{
			if (Main.projectile[j].owner != whoAmI || Main.projectile[j].type != 226)
			{
				continue;
			}
			petalTimer = 50;
			float num6 = 12f;
			((Vector2)(ref val3))..ctor(Main.projectile[j].position.X + (float)width * 0.5f, Main.projectile[j].position.Y + (float)height * 0.5f);
			float num7 = x - val3.X;
			float num8 = y - val3.Y;
			float num9 = (float)Math.Sqrt(num7 * num7 + num8 * num8);
			int num10 = 180;
			float num11 = num6 * (float)num10;
			if (!(num9 >= num11))
			{
				num9 = num6 / num9;
				num7 *= num9;
				num8 *= num9;
				Utils.ChaseResults chaseResults = Utils.GetChaseResults(Main.projectile[j].Center, num6 * (float)num10, victim.Center, victim.velocity);
				if (chaseResults.InterceptionHappens && chaseResults.InterceptionTime <= 180f)
				{
					Vector2 val4 = chaseResults.ChaserVelocity / (float)num10;
					num7 = val4.X;
					num8 = val4.Y;
				}
				Projectile.NewProjectile(GetProjectileSource_SetBonus(6), Main.projectile[j].Center.X - 4f, Main.projectile[j].Center.Y, num7, num8, 227, crystalLeafDamage, crystalLeafKB, whoAmI);
				break;
			}
		}
	}

	public void OpenPresent(int itemType)
	{
		DropFromItem(itemType);
	}

	public void OpenLegacyPresent(int itemType)
	{
		DropFromItem(itemType);
	}

	/// <summary>
	/// Spawns an item into the world at this players position. This is a simpler alternative to <see cref="M:Terraria.Item.NewItem(Terraria.DataStructures.IEntitySource,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Boolean,System.Int32,System.Boolean,System.Boolean)" />. This method can be called from multiplayer client code without necessitating manually syncing the item.
	/// <br /> Use <see cref="M:Terraria.Player.QuickSpawnItem(Terraria.DataStructures.IEntitySource,Terraria.Item,System.Int32)" /> if a specific instance of an Item needs to be spawned into the world to preserve modded data.
	/// </summary>
	/// <param name="source"></param>
	/// <param name="item"></param>
	/// <param name="stack"></param>
	/// <returns>The index of the item within <see cref="F:Terraria.Main.item" /></returns>
	public int QuickSpawnItem(IEntitySource source, int item, int stack = 1)
	{
		int num = Item.NewItem(source, (int)position.X, (int)position.Y, width, height, item, stack, noBroadcast: false, -1);
		if (Main.netMode == 1)
		{
			NetMessage.SendData(21, -1, -1, null, num, 1f);
		}
		return num;
	}

	public void OpenBossBag(int type)
	{
		DropFromItem(type);
		if (!ItemID.Sets.PreHardmodeLikeBossBag[type])
		{
			TryGettingDevArmor(GetItemSource_OpenItem(type));
		}
	}

	public void TryGettingDevArmor(IEntitySource source)
	{
		ModLoaderMod.TryGettingPatreonOrDevArmor(source, this);
		if (Main.rand.Next(Main.tenthAnniversaryWorld ? 8 : 16) == 0)
		{
			switch (Main.rand.Next(18))
			{
			case 0:
				QuickSpawnItem(source, 666);
				QuickSpawnItem(source, 667);
				QuickSpawnItem(source, 668);
				QuickSpawnItem(source, 665);
				QuickSpawnItem(source, 3287);
				break;
			case 1:
				QuickSpawnItem(source, 1554);
				QuickSpawnItem(source, 1555);
				QuickSpawnItem(source, 1556);
				QuickSpawnItem(source, 1586);
				break;
			case 2:
				QuickSpawnItem(source, 1554);
				QuickSpawnItem(source, 1587);
				QuickSpawnItem(source, 1588);
				QuickSpawnItem(source, 1586);
				break;
			case 3:
				QuickSpawnItem(source, 1557);
				QuickSpawnItem(source, 1558);
				QuickSpawnItem(source, 1559);
				QuickSpawnItem(source, 1585);
				break;
			case 4:
				QuickSpawnItem(source, 1560);
				QuickSpawnItem(source, 1561);
				QuickSpawnItem(source, 1562);
				QuickSpawnItem(source, 1584);
				break;
			case 5:
				QuickSpawnItem(source, 1563);
				QuickSpawnItem(source, 1564);
				QuickSpawnItem(source, 1565);
				QuickSpawnItem(source, 3582);
				break;
			case 6:
				QuickSpawnItem(source, 1566);
				QuickSpawnItem(source, 1567);
				QuickSpawnItem(source, 1568);
				break;
			case 7:
				QuickSpawnItem(source, 1580);
				QuickSpawnItem(source, 1581);
				QuickSpawnItem(source, 1582);
				QuickSpawnItem(source, 1583);
				break;
			case 8:
				QuickSpawnItem(source, 3226);
				QuickSpawnItem(source, 3227);
				QuickSpawnItem(source, 3228);
				QuickSpawnItem(source, 3288);
				break;
			case 9:
				QuickSpawnItem(source, 3583);
				QuickSpawnItem(source, 3581);
				QuickSpawnItem(source, 3578);
				QuickSpawnItem(source, 3579);
				QuickSpawnItem(source, 3580);
				break;
			case 10:
				QuickSpawnItem(source, 3585);
				QuickSpawnItem(source, 3586);
				QuickSpawnItem(source, 3587);
				QuickSpawnItem(source, 3588);
				QuickSpawnItem(source, 3024, 4);
				break;
			case 11:
				QuickSpawnItem(source, 3589);
				QuickSpawnItem(source, 3590);
				QuickSpawnItem(source, 3591);
				QuickSpawnItem(source, 3592);
				QuickSpawnItem(source, 3599, 4);
				break;
			case 12:
				QuickSpawnItem(source, 3368);
				QuickSpawnItem(source, 3921);
				QuickSpawnItem(source, 3922);
				QuickSpawnItem(source, 3923);
				QuickSpawnItem(source, 3924);
				break;
			case 13:
				QuickSpawnItem(source, 3925);
				QuickSpawnItem(source, 3926);
				QuickSpawnItem(source, 3927);
				QuickSpawnItem(source, 3928);
				QuickSpawnItem(source, 3929);
				break;
			case 14:
				QuickSpawnItem(source, 4732);
				QuickSpawnItem(source, 4733);
				QuickSpawnItem(source, 4734);
				QuickSpawnItem(source, 4730);
				break;
			case 15:
				QuickSpawnItem(source, 4747);
				QuickSpawnItem(source, 4748);
				QuickSpawnItem(source, 4749);
				QuickSpawnItem(source, 4746);
				break;
			case 16:
				QuickSpawnItem(source, 4751);
				QuickSpawnItem(source, 4752);
				QuickSpawnItem(source, 4753);
				QuickSpawnItem(source, 4750);
				break;
			case 17:
				QuickSpawnItem(source, 4755);
				QuickSpawnItem(source, 4756);
				QuickSpawnItem(source, 4757);
				QuickSpawnItem(source, 4754);
				break;
			}
		}
	}

	public void OpenFishingCrate(int crateItemID)
	{
		DropFromItem(crateItemID);
	}

	/// <summary>
	/// Counts the total stack of the specified item type in this players <see cref="F:Terraria.Player.inventory" />. <br />
	/// Does not check Void Bag. <br />
	/// Use <see cref="M:Terraria.Player.HasItem(System.Int32)" /> to check if the player has the item at all. <br />
	/// </summary>
	/// <param name="type">The item type to count</param>
	/// <param name="stopCountingAt">When to stop counting, useful to avoid unnecessary calculations</param>
	/// <returns>The total amount counted</returns>
	public int CountItem(int type, int stopCountingAt = 0)
	{
		int num = 0;
		for (int i = 0; i != 58; i++)
		{
			if (inventory[i].stack > 0 && inventory[i].type == type)
			{
				num += inventory[i].stack;
				if (num >= stopCountingAt)
				{
					return num;
				}
			}
		}
		return num;
	}

	/// <summary>
	/// Use to consume a single item. The item does not have to be <see cref="F:Terraria.Item.consumable" />. <br />
	/// Attempts to reduce the <see cref="F:Terraria.Item.stack" /> of the first <see cref="T:Terraria.Item" /> found in the <see cref="F:Terraria.Player.inventory" /> by 1. <br />
	/// Respects <see cref="M:Terraria.ModLoader.ItemLoader.ConsumeItem(Terraria.Item,Terraria.Player)" />, so the item won't necessarily be consumed. <br />
	/// To consume multiple of the item, first check <see cref="M:Terraria.Player.CountItem(System.Int32,System.Int32)" /> to ensure that there are enough of the item, then use a for loop to call this method many times. <br />
	/// </summary>
	/// <param name="type">The item type to consume</param>
	/// <param name="reverseOrder">If true, the search for the item will start at the end of the player inventory</param>
	/// <param name="includeVoidBag">If true, the void bag, if open, will also be considered for finding an item to consume</param>
	/// <returns>True if the item was found and attempted to be consumed</returns>
	public bool ConsumeItem(int type, bool reverseOrder = false, bool includeVoidBag = false)
	{
		int num = 0;
		int num2 = 58;
		int num3 = 1;
		if (reverseOrder)
		{
			num = 57;
			num2 = -1;
			num3 = -1;
		}
		for (int i = num; i != num2; i += num3)
		{
			if (inventory[i].stack > 0 && inventory[i].type == type)
			{
				if (ItemLoader.ConsumeItem(inventory[i], this))
				{
					inventory[i].stack--;
				}
				if (inventory[i].stack <= 0)
				{
					inventory[i].SetDefaults();
				}
				return true;
			}
		}
		if (includeVoidBag && useVoidBag())
		{
			int num4 = FindItem(type, bank4.item);
			if (num4 == -1)
			{
				return false;
			}
			Item item = bank4.item[num4];
			item.stack--;
			if (item.stack <= 0)
			{
				item.TurnToAir();
			}
			return true;
		}
		return false;
	}

	public void OpenShadowLockbox(int boxType)
	{
		DropFromItem(boxType);
	}

	public void OpenLockBox(int lockboxItemType)
	{
		DropFromItem(lockboxItemType);
	}

	public void OpenHerbBag(int bagType)
	{
		DropFromItem(bagType);
	}

	public void OpenCanofWorms(int sourceItemType)
	{
		DropFromItem(sourceItemType);
	}

	public void OpenOyster(int sourceItemType)
	{
		DropFromItem(sourceItemType);
	}

	public void OpenGoodieBag(int itemType)
	{
		DropFromItem(itemType);
	}

	public void UpdateDyes()
	{
		cShieldFallback = -1;
		cHead = (cBody = (cLegs = (cHandOn = (cHandOff = (cBack = (cFront = (cShoe = (cWaist = (cShield = (cNeck = (cFace = (cFaceHead = (cFaceFlower = (cBalloon = (cBalloon = (cWings = (cCarpet = (cFloatingTube = (cBackpack = (cTail = 0))))))))))))))))))));
		cGrapple = (cMount = (cMinecart = (cPet = (cLight = (cYorai = (cPortableStool = (cUnicornHorn = (cAngelHalo = (cBeard = (cMinion = (cLeinShampoo = (cFlameWaker = 0))))))))))));
		skinDyePacked = 0;
		cHead = dye[0].dye;
		cBody = dye[1].dye;
		cLegs = dye[2].dye;
		if (wearsRobe)
		{
			cLegs = cBody;
		}
		cPet = miscDyes[0].dye;
		cLight = miscDyes[1].dye;
		cMinecart = miscDyes[2].dye;
		cMount = miscDyes[3].dye;
		cGrapple = miscDyes[4].dye;
		for (int i = 0; i < 20; i++)
		{
			if (IsItemSlotUnlockedAndUsable(i))
			{
				int num = i % 10;
				UpdateItemDye(i < 10, hideVisibleAccessory[num], armor[i], dye[num]);
			}
			if (i == 9)
			{
				AccessorySlotLoader.ModSlotPlayer(this).UpdateDyes(socialSlots: false);
			}
			if (i == 19)
			{
				AccessorySlotLoader.ModSlotPlayer(this).UpdateDyes(socialSlots: true);
			}
		}
		PlayerLoader.UpdateDyes(this);
		cYorai = cPet;
	}

	internal void UpdateItemDye(bool isNotInVanitySlot, bool isSetToHidden, Item armorItem, Item dyeItem)
	{
		if (armorItem.IsAir)
		{
			return;
		}
		bool num = armorItem.wingSlot > 0 || armorItem.type == 934 || armorItem.type == 4341 || armorItem.type == 5126 || armorItem.type == 4563 || armorItem.type == 1987;
		bool flag = isNotInVanitySlot && isSetToHidden;
		if (armorItem.shieldSlot > 0 && armorItem.shieldSlot < ArmorIDs.Shield.Count && (cShieldFallback == -1 || !flag))
		{
			cShieldFallback = dyeItem.dye;
		}
		ItemLoader.UpdateItemDye(armorItem, this, dyeItem.dye, flag);
		if (!num && flag)
		{
			return;
		}
		if (armorItem.handOnSlot > 0)
		{
			cHandOn = dyeItem.dye;
		}
		if (armorItem.handOffSlot > 0)
		{
			cHandOff = dyeItem.dye;
		}
		if (armorItem.backSlot > 0)
		{
			if (ArmorIDs.Back.Sets.DrawInBackpackLayer[armorItem.backSlot])
			{
				cBackpack = dyeItem.dye;
			}
			else if (ArmorIDs.Back.Sets.DrawInTailLayer[armorItem.backSlot])
			{
				cTail = dyeItem.dye;
			}
			else
			{
				cBack = dyeItem.dye;
			}
		}
		if (armorItem.frontSlot > 0)
		{
			cFront = dyeItem.dye;
		}
		if (armorItem.shoeSlot > 0)
		{
			if (armorItem.type == 4822 || armorItem.type == 4874)
			{
				cFlameWaker = dyeItem.dye;
			}
			else
			{
				cShoe = dyeItem.dye;
			}
		}
		if (armorItem.waistSlot > 0)
		{
			cWaist = dyeItem.dye;
		}
		if (armorItem.shieldSlot > 0)
		{
			cShield = dyeItem.dye;
		}
		if (armorItem.neckSlot > 0)
		{
			cNeck = dyeItem.dye;
		}
		if (armorItem.faceSlot > 0)
		{
			if (ArmorIDs.Face.Sets.DrawInFaceHeadLayer[armorItem.faceSlot])
			{
				cFaceHead = dyeItem.dye;
			}
			else if (ArmorIDs.Face.Sets.DrawInFaceFlowerLayer[armorItem.faceSlot])
			{
				cFaceFlower = dyeItem.dye;
			}
			else
			{
				cFace = dyeItem.dye;
			}
		}
		if (armorItem.beardSlot > 0)
		{
			cBeard = dyeItem.dye;
		}
		if (armorItem.balloonSlot > 0)
		{
			if (ArmorIDs.Balloon.Sets.DrawInFrontOfBackArmLayer[armorItem.balloonSlot])
			{
				cBalloonFront = dyeItem.dye;
			}
			else
			{
				cBalloon = dyeItem.dye;
			}
		}
		if (armorItem.wingSlot > 0)
		{
			cWings = dyeItem.dye;
		}
		if (armorItem.type == 934)
		{
			cCarpet = dyeItem.dye;
		}
		if (armorItem.type == 4404)
		{
			cFloatingTube = dyeItem.dye;
		}
		if (armorItem.type == 4341 || armorItem.type == 5126)
		{
			cPortableStool = dyeItem.dye;
		}
		if (armorItem.type == 4563)
		{
			cUnicornHorn = dyeItem.dye;
		}
		if (armorItem.type == 1987)
		{
			cAngelHalo = dyeItem.dye;
		}
		if (armorItem.type == 4762)
		{
			cMinion = dyeItem.dye;
		}
		if (armorItem.type == 3929)
		{
			cLeinShampoo = dyeItem.dye;
		}
	}

	public int ArmorSetDye()
	{
		return Main.rand.Next(3) switch
		{
			0 => cHead, 
			1 => cBody, 
			2 => cLegs, 
			_ => cBody, 
		};
	}

	public IEntitySource GetSource_Buff(int buffIndex)
	{
		return GetProjectileSource_Buff(buffIndex);
	}

	internal IEntitySource GetProjectileSource_Buff(int buffIndex)
	{
		int buffId = buffType[buffIndex];
		return new EntitySource_Buff(this, buffId, buffIndex);
	}

	internal IEntitySource GetProjectileSource_Item(Item item)
	{
		return GetSource_ItemUse(item);
	}

	internal IEntitySource GetItemSource_OpenItem(int itemType)
	{
		return GetSource_OpenItem(itemType);
	}

	internal IEntitySource GetItemSource_Death()
	{
		return GetSource_Death();
	}

	internal IEntitySource GetItemSource_Misc(int itemSourceId)
	{
		return GetSource_Misc(ItemSourceID.ToContextString(itemSourceId));
	}

	internal IEntitySource GetProjectileSource_Item_WithPotentialAmmo(Item item, int ammoItemId)
	{
		return GetSource_ItemUse_WithPotentialAmmo(item, ammoItemId);
	}

	internal IEntitySource GetProjectileSource_OnHit(Entity victim, int projectileSourceId)
	{
		return GetSource_OnHit(victim, ProjectileSourceID.ToContextString(projectileSourceId));
	}

	internal IEntitySource GetProjectileSource_OnHurt(Entity attacker, int projectileSourceId)
	{
		return GetSource_OnHurt(attacker, ProjectileSourceID.ToContextString(projectileSourceId));
	}

	internal IEntitySource GetProjectileSource_Accessory(Item item)
	{
		return GetSource_Accessory(item);
	}

	internal IEntitySource GetProjectileSource_Misc(int projectileSourceId)
	{
		return GetSource_Misc(ProjectileSourceID.ToContextString(projectileSourceId));
	}

	internal IEntitySource GetProjectileSource_TileInteraction(int tileCoordsX, int tileCoordsY)
	{
		return GetSource_TileInteraction(tileCoordsX, tileCoordsY);
	}

	internal IEntitySource GetItemSource_TileInteraction(int tileCoordsX, int tileCoordsY)
	{
		return GetSource_TileInteraction(tileCoordsX, tileCoordsY);
	}

	internal IEntitySource GetNPCSource_TileInteraction(int tileCoordsX, int tileCoordsY)
	{
		return GetSource_TileInteraction(tileCoordsX, tileCoordsY);
	}

	internal IEntitySource GetItemSource_OnHit(Entity victim, int itemSourceId)
	{
		return GetSource_OnHit(victim, ItemSourceID.ToContextString(itemSourceId));
	}

	internal IEntitySource GetProjectileSource_SetBonus(int projectileSourceId)
	{
		return GetSource_FromThis(ProjectileSourceID.ToContextString(projectileSourceId));
	}

	public void UpdateBuffs(int i)
	{
		//IL_08b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_08c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c0b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c1a: Unknown result type (might be due to invalid IL or missing references)
		//IL_096b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0972: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a32: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a39: Unknown result type (might be due to invalid IL or missing references)
		//IL_126d: Unknown result type (might be due to invalid IL or missing references)
		//IL_127f: Unknown result type (might be due to invalid IL or missing references)
		//IL_17df: Unknown result type (might be due to invalid IL or missing references)
		//IL_17e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_445c: Unknown result type (might be due to invalid IL or missing references)
		//IL_4461: Unknown result type (might be due to invalid IL or missing references)
		//IL_444f: Unknown result type (might be due to invalid IL or missing references)
		//IL_4454: Unknown result type (might be due to invalid IL or missing references)
		if (soulDrain > 0 && whoAmI == Main.myPlayer)
		{
			AddBuff(151, 2);
		}
		if (Main.dontStarveWorld)
		{
			UpdateStarvingState(withEmote: true);
		}
		for (int j = 0; j < maxBuffs; j++)
		{
			if (buffType[j] <= 0 || buffTime[j] <= 0)
			{
				continue;
			}
			if (whoAmI == Main.myPlayer && !BuffID.Sets.TimeLeftDoesNotDecrease[buffType[j]])
			{
				buffTime[j]--;
			}
			int num = j;
			if (buffType[j] == 1)
			{
				lavaImmune = true;
				fireWalk = true;
				buffImmune[24] = true;
			}
			else if (BuffID.Sets.BasicMountData[buffType[j]] != null)
			{
				BuffID.Sets.BuffMountData buffMountData = BuffID.Sets.BasicMountData[buffType[j]];
				mount.SetMount(buffMountData.mountID, this, buffMountData.faceLeft);
				buffTime[j] = 10;
			}
			else if (buffType[j] == 158)
			{
				manaRegenDelayBonus += 0.5f;
				manaRegenBonus += 10;
			}
			else if (buffType[j] == 159)
			{
				GetArmorPenetration(DamageClass.Melee) += 12f;
			}
			else if (buffType[j] == 192)
			{
				pickSpeed -= 0.2f;
				moveSpeed += 0.2f;
			}
			else if (buffType[j] == 321)
			{
				int num2 = 10;
				allCrit += num2;
				minionDamage += (float)num2 / 100f;
			}
			else if (buffType[j] == 2)
			{
				lifeRegen += 4;
			}
			else if (buffType[j] == 3)
			{
				moveSpeed += 0.25f;
			}
			else if (buffType[j] == 4)
			{
				gills = true;
			}
			else if (buffType[j] == 5)
			{
				statDefense += 8;
			}
			else if (buffType[j] == 6)
			{
				manaRegenBuff = true;
			}
			else if (buffType[j] == 7)
			{
				magicDamage += 0.2f;
			}
			else if (buffType[j] == 8)
			{
				slowFall = true;
			}
			else if (buffType[j] == 9)
			{
				findTreasure = true;
			}
			else if (buffType[j] == 343)
			{
				biomeSight = true;
			}
			else if (buffType[j] == 10)
			{
				invis = true;
			}
			else if (buffType[j] == 11)
			{
				Lighting.AddLight((int)(position.X + (float)(width / 2)) / 16, (int)(position.Y + (float)(height / 2)) / 16, 0.8f, 0.95f, 1f);
			}
			else if (buffType[j] == 12)
			{
				nightVision = true;
			}
			else if (buffType[j] == 13)
			{
				enemySpawns = true;
			}
			else if (buffType[j] == 14)
			{
				if (thorns < 1f)
				{
					thorns = 1f;
				}
			}
			else if (buffType[j] == 15)
			{
				waterWalk = true;
			}
			else if (buffType[j] == 16)
			{
				archery = true;
				arrowDamage *= 1.1f;
			}
			else if (buffType[j] == 17)
			{
				detectCreature = true;
			}
			else if (buffType[j] == 18)
			{
				gravControl = true;
			}
			else if (buffType[j] == 30)
			{
				bleed = true;
			}
			else if (buffType[j] == 31)
			{
				confused = true;
			}
			else if (buffType[j] == 32)
			{
				slow = true;
			}
			else if (buffType[j] == 35)
			{
				silence = true;
			}
			else if (buffType[j] == 160)
			{
				dazed = true;
			}
			else if (buffType[j] == 46)
			{
				chilled = true;
			}
			else if (buffType[j] == 47)
			{
				frozen = true;
			}
			else if (buffType[j] == 156)
			{
				stoned = true;
			}
			else if (buffType[j] == 69)
			{
				ichor = true;
				statDefense -= 15;
			}
			else if (buffType[j] == 36)
			{
				brokenArmor = true;
			}
			else if (buffType[j] == 48)
			{
				honey = true;
			}
			else if (buffType[j] == 59)
			{
				shadowDodge = true;
			}
			else if (buffType[j] == 93)
			{
				ammoBox = true;
			}
			else if (buffType[j] == 58)
			{
				palladiumRegen = true;
			}
			else if (buffType[j] == 306)
			{
				hasTitaniumStormBuff = true;
			}
			else if (buffType[j] == 88)
			{
				chaosState = true;
			}
			else if (buffType[j] == 215)
			{
				statDefense += 5;
			}
			else if (buffType[j] == 311)
			{
				summonerWeaponSpeedBonus += 0.35f;
			}
			else if (buffType[j] == 308)
			{
				summonerWeaponSpeedBonus += 0.25f;
			}
			else if (buffType[j] == 314)
			{
				summonerWeaponSpeedBonus += 0.12f;
			}
			else if (buffType[j] == 312)
			{
				coolWhipBuff = true;
			}
			else if (buffType[j] == 63)
			{
				moveSpeed += 1f;
			}
			else if (buffType[j] == 104)
			{
				pickSpeed -= 0.25f;
			}
			else if (buffType[j] == 105)
			{
				lifeMagnet = true;
			}
			else if (buffType[j] == 106)
			{
				calmed = true;
			}
			else if (buffType[j] == 121)
			{
				fishingSkill += 15;
			}
			else if (buffType[j] == 122)
			{
				sonarPotion = true;
			}
			else if (buffType[j] == 123)
			{
				cratePotion = true;
			}
			else if (buffType[j] == 107)
			{
				tileSpeed += 0.25f;
				wallSpeed += 0.25f;
				blockRange++;
			}
			else if (buffType[j] == 108)
			{
				kbBuff = true;
			}
			else if (buffType[j] == 109)
			{
				ignoreWater = true;
				accFlipper = true;
			}
			else if (buffType[j] == 110)
			{
				maxMinions++;
			}
			else if (buffType[j] == 150)
			{
				maxMinions++;
			}
			else if (buffType[j] == 348)
			{
				maxTurrets++;
			}
			else if (buffType[j] == 111)
			{
				dangerSense = true;
			}
			else if (buffType[j] == 112)
			{
				ammoPotion = true;
			}
			else if (buffType[j] == 113)
			{
				lifeForce = true;
				statLifeMax2 += statLifeMax / 5 / 20 * 20;
			}
			else if (buffType[j] == 114)
			{
				endurance += 0.1f;
			}
			else if (buffType[j] == 115)
			{
				allCrit += 10f;
			}
			else if (buffType[j] == 116)
			{
				inferno = true;
				Lighting.AddLight((int)(base.Center.X / 16f), (int)(base.Center.Y / 16f), 0.65f, 0.4f, 0.1f);
				int num3 = 323;
				float num4 = 200f;
				bool flag = infernoCounter % 60 == 0;
				int damage = 20;
				if (whoAmI == Main.myPlayer)
				{
					for (int k = 0; k < 200; k++)
					{
						NPC nPC = Main.npc[k];
						if (nPC.active && !nPC.friendly && nPC.damage > 0 && !nPC.dontTakeDamage && !nPC.buffImmune[num3] && CanNPCBeHitByPlayerOrPlayerProjectile(nPC) && Vector2.Distance(base.Center, nPC.Center) <= num4)
						{
							if (nPC.FindBuffIndex(num3) == -1)
							{
								nPC.AddBuff(num3, 120);
							}
							if (flag)
							{
								ApplyDamageToNPC(nPC, damage, 0f, 0);
							}
						}
					}
					if (hostile)
					{
						for (int l = 0; l < 255; l++)
						{
							Player player = Main.player[l];
							if (player == this || !player.active || player.dead || !player.hostile || player.buffImmune[num3] || (player.team == team && player.team != 0) || !(Vector2.Distance(base.Center, player.Center) <= num4))
							{
								continue;
							}
							if (player.FindBuffIndex(num3) == -1)
							{
								player.AddBuff(num3, 120);
							}
							if (flag)
							{
								PlayerDeathReason playerDeathReason = PlayerDeathReason.ByOther(16, whoAmI);
								player.Hurt(playerDeathReason, damage, 0, pvp: true);
								if (Main.netMode != 0)
								{
									NetMessage.SendPlayerHurt(l, playerDeathReason, damage, 0, critical: false, pvp: true, -1);
								}
							}
						}
					}
				}
			}
			else if (buffType[j] == 117)
			{
				allDamage += 0.1f;
			}
			else if (buffType[j] == 119)
			{
				loveStruck = true;
			}
			else if (buffType[j] == 120)
			{
				stinky = true;
			}
			else if (buffType[j] == 124)
			{
				resistCold = true;
			}
			else if (buffType[j] == 257)
			{
				if (Main.myPlayer == whoAmI)
				{
					if (buffTime[j] > 36000)
					{
						luckPotion = 3;
					}
					else if (buffTime[j] > 18000)
					{
						luckPotion = 2;
					}
					else
					{
						luckPotion = 1;
					}
				}
			}
			else if (buffType[j] == 165)
			{
				lifeRegen += 6;
				statDefense += 8;
				dryadWard = true;
				if (thorns < 1f)
				{
					thorns += 0.5f;
				}
			}
			else if (buffType[j] == 144)
			{
				electrified = true;
				Lighting.AddLight((int)base.Center.X / 16, (int)base.Center.Y / 16, 0.3f, 0.8f, 1.1f);
			}
			else if (buffType[j] == 94)
			{
				manaSick = true;
				manaSickReduction = manaSickLessDmg * ((float)buffTime[j] / (float)manaSickTime);
			}
			else if (buffType[j] >= 95 && buffType[j] <= 97)
			{
				buffTime[j] = 5;
				int num5 = (byte)(1 + buffType[j] - 95);
				if (beetleOrbs > 0 && beetleOrbs != num5)
				{
					if (beetleOrbs > num5)
					{
						DelBuff(j);
						j--;
					}
					else
					{
						for (int m = 0; m < maxBuffs; m++)
						{
							if (buffType[m] >= 95 && buffType[m] <= 95 + num5 - 1)
							{
								DelBuff(m);
								m--;
							}
						}
					}
				}
				beetleOrbs = num5;
				if (!beetleDefense)
				{
					beetleOrbs = 0;
					DelBuff(j);
					j--;
				}
				else
				{
					beetleBuff = true;
				}
			}
			else if (buffType[j] >= 170 && buffType[j] <= 172)
			{
				buffTime[j] = 5;
				int num6 = (byte)(1 + buffType[j] - 170);
				if (solarShields > 0 && solarShields != num6)
				{
					if (solarShields > num6)
					{
						DelBuff(j);
						j--;
					}
					else
					{
						for (int n = 0; n < maxBuffs; n++)
						{
							if (buffType[n] >= 170 && buffType[n] <= 170 + num6 - 1)
							{
								DelBuff(n);
								n--;
							}
						}
					}
				}
				solarShields = num6;
				if (!setSolar)
				{
					solarShields = 0;
					DelBuff(j);
					j--;
				}
			}
			else if (buffType[j] >= 98 && buffType[j] <= 100)
			{
				int num7 = (byte)(1 + buffType[j] - 98);
				if (beetleOrbs > 0 && beetleOrbs != num7)
				{
					if (beetleOrbs > num7)
					{
						DelBuff(j);
						j--;
					}
					else
					{
						for (int num8 = 0; num8 < maxBuffs; num8++)
						{
							if (buffType[num8] >= 98 && buffType[num8] <= 98 + num7 - 1)
							{
								DelBuff(num8);
								num8--;
							}
						}
					}
				}
				beetleOrbs = num7;
				meleeDamage += 0.1f * (float)beetleOrbs;
				meleeSpeed += 0.1f * (float)beetleOrbs;
				if (!beetleOffense)
				{
					beetleOrbs = 0;
					DelBuff(j);
					j--;
				}
				else
				{
					beetleBuff = true;
				}
			}
			else if (buffType[j] >= 176 && buffType[j] <= 178)
			{
				int num9 = nebulaLevelMana;
				int num10 = (byte)(1 + buffType[j] - 176);
				if (num9 > 0 && num9 != num10)
				{
					if (num9 > num10)
					{
						DelBuff(j);
						j--;
					}
					else
					{
						for (int num11 = 0; num11 < maxBuffs; num11++)
						{
							if (buffType[num11] >= 176 && buffType[num11] <= 178 + num10 - 1)
							{
								DelBuff(num11);
								num11--;
							}
						}
					}
				}
				nebulaLevelMana = num10;
				if (buffTime[j] == 2 && nebulaLevelMana > 1)
				{
					nebulaLevelMana--;
					buffType[j]--;
					buffTime[j] = 480;
				}
			}
			else if (buffType[j] >= 173 && buffType[j] <= 175)
			{
				int num12 = nebulaLevelLife;
				int num13 = (byte)(1 + buffType[j] - 173);
				if (num12 > 0 && num12 != num13)
				{
					if (num12 > num13)
					{
						DelBuff(j);
						j--;
					}
					else
					{
						for (int num14 = 0; num14 < maxBuffs; num14++)
						{
							if (buffType[num14] >= 173 && buffType[num14] <= 175 + num13 - 1)
							{
								DelBuff(num14);
								num14--;
							}
						}
					}
				}
				nebulaLevelLife = num13;
				if (buffTime[j] == 2 && nebulaLevelLife > 1)
				{
					nebulaLevelLife--;
					buffType[j]--;
					buffTime[j] = 480;
				}
				lifeRegen += 6 * nebulaLevelLife;
			}
			else if (buffType[j] >= 179 && buffType[j] <= 181)
			{
				int num15 = nebulaLevelDamage;
				int num16 = (byte)(1 + buffType[j] - 179);
				if (num15 > 0 && num15 != num16)
				{
					if (num15 > num16)
					{
						DelBuff(j);
						j--;
					}
					else
					{
						for (int num17 = 0; num17 < maxBuffs; num17++)
						{
							if (buffType[num17] >= 179 && buffType[num17] <= 181 + num16 - 1)
							{
								DelBuff(num17);
								num17--;
							}
						}
					}
				}
				nebulaLevelDamage = num16;
				if (buffTime[j] == 2 && nebulaLevelDamage > 1)
				{
					nebulaLevelDamage--;
					buffType[j]--;
					buffTime[j] = 480;
				}
				float num18 = 0.15f * (float)nebulaLevelDamage;
				allDamage += num18;
			}
			else if (buffType[j] == 62)
			{
				if ((double)statLife <= (double)statLifeMax2 * 0.5)
				{
					Lighting.AddLight((int)(base.Center.X / 16f), (int)(base.Center.Y / 16f), 0.1f, 0.2f, 0.45f);
					iceBarrier = true;
					endurance += 0.25f;
					iceBarrierFrameCounter++;
					if (iceBarrierFrameCounter > 2)
					{
						iceBarrierFrameCounter = 0;
						iceBarrierFrame++;
						if (iceBarrierFrame >= 12)
						{
							iceBarrierFrame = 0;
						}
					}
				}
				else
				{
					DelBuff(j);
					j--;
				}
			}
			else if (buffType[j] == 49)
			{
				for (int num19 = 191; num19 <= 194; num19++)
				{
					if (ownedProjectileCounts[num19] > 0)
					{
						pygmy = true;
					}
				}
				if (!pygmy)
				{
					DelBuff(j);
					j--;
				}
				else
				{
					buffTime[j] = 18000;
				}
			}
			else if (buffType[j] == 83)
			{
				if (ownedProjectileCounts[317] > 0)
				{
					raven = true;
				}
				if (!raven)
				{
					DelBuff(j);
					j--;
				}
				else
				{
					buffTime[j] = 18000;
				}
			}
			else if (buffType[j] == 64)
			{
				if (ownedProjectileCounts[266] > 0)
				{
					slime = true;
				}
				if (!slime)
				{
					DelBuff(j);
					j--;
				}
				else
				{
					buffTime[j] = 18000;
				}
			}
			else if (buffType[j] == 125)
			{
				if (ownedProjectileCounts[373] > 0)
				{
					hornetMinion = true;
				}
				if (!hornetMinion)
				{
					DelBuff(j);
					j--;
				}
				else
				{
					buffTime[j] = 18000;
				}
			}
			else if (buffType[j] == 126)
			{
				if (ownedProjectileCounts[375] > 0)
				{
					impMinion = true;
				}
				if (!impMinion)
				{
					DelBuff(j);
					j--;
				}
				else
				{
					buffTime[j] = 18000;
				}
			}
			else if (buffType[j] == 133)
			{
				if (ownedProjectileCounts[390] > 0 || ownedProjectileCounts[391] > 0 || ownedProjectileCounts[392] > 0)
				{
					spiderMinion = true;
				}
				if (!spiderMinion)
				{
					DelBuff(j);
					j--;
				}
				else
				{
					buffTime[j] = 18000;
				}
			}
			else if (buffType[j] == 134)
			{
				if (ownedProjectileCounts[387] > 0 || ownedProjectileCounts[388] > 0)
				{
					twinsMinion = true;
				}
				if (!twinsMinion)
				{
					DelBuff(j);
					j--;
				}
				else
				{
					buffTime[j] = 18000;
				}
			}
			else if (buffType[j] == 135)
			{
				if (ownedProjectileCounts[393] > 0 || ownedProjectileCounts[394] > 0 || ownedProjectileCounts[395] > 0)
				{
					pirateMinion = true;
				}
				if (!pirateMinion)
				{
					DelBuff(j);
					j--;
				}
				else
				{
					buffTime[j] = 18000;
				}
			}
			else if (buffType[j] == 214)
			{
				if (ownedProjectileCounts[758] > 0)
				{
					vampireFrog = true;
				}
				if (!vampireFrog)
				{
					DelBuff(j);
					j--;
				}
				else
				{
					buffTime[j] = 18000;
				}
			}
			else if (buffType[j] == 139)
			{
				if (ownedProjectileCounts[407] > 0)
				{
					sharknadoMinion = true;
				}
				if (!sharknadoMinion)
				{
					DelBuff(j);
					j--;
				}
				else
				{
					buffTime[j] = 18000;
				}
			}
			else if (buffType[j] == 140)
			{
				if (ownedProjectileCounts[423] > 0)
				{
					UFOMinion = true;
				}
				if (!UFOMinion)
				{
					DelBuff(j);
					j--;
				}
				else
				{
					buffTime[j] = 18000;
				}
			}
			else if (buffType[j] == 182)
			{
				if (ownedProjectileCounts[613] > 0)
				{
					stardustMinion = true;
				}
				if (!stardustMinion)
				{
					DelBuff(j);
					j--;
				}
				else
				{
					buffTime[j] = 18000;
				}
			}
			else if (buffType[j] == 213)
			{
				if (ownedProjectileCounts[755] > 0)
				{
					batsOfLight = true;
				}
				if (!batsOfLight)
				{
					DelBuff(j);
					j--;
				}
				else
				{
					buffTime[j] = 18000;
				}
			}
			else if (buffType[j] == 216)
			{
				bool flag2 = true;
				if (ownedProjectileCounts[759] > 0)
				{
					babyBird = true;
				}
				else if (whoAmI == Main.myPlayer)
				{
					if (numMinions < maxMinions)
					{
						int num20 = FindItem(4281);
						if (num20 != -1)
						{
							Item item = inventory[num20];
							int num21 = Projectile.NewProjectile(GetProjectileSource_Item(item), base.Top, Vector2.Zero, item.shoot, item.damage, item.knockBack, whoAmI);
							Main.projectile[num21].originalDamage = item.damage;
							babyBird = true;
						}
					}
					if (!babyBird)
					{
						DelBuff(j);
						j--;
						flag2 = false;
					}
				}
				if (flag2)
				{
					buffTime[j] = 18000;
				}
			}
			else if (buffType[j] == 325)
			{
				if (ownedProjectileCounts[951] > 0)
				{
					flinxMinion = true;
				}
				if (!flinxMinion)
				{
					DelBuff(j);
					j--;
				}
				else
				{
					buffTime[j] = 18000;
				}
			}
			else if (buffType[j] == 335)
			{
				if (ownedProjectileCounts[970] > 0)
				{
					abigailMinion = true;
				}
				if (!abigailMinion)
				{
					DelBuff(j);
					j--;
				}
				else
				{
					buffTime[j] = 18000;
				}
				if (whoAmI == Main.myPlayer)
				{
					UpdateAbigailStatus();
				}
			}
			else if (buffType[j] == 263)
			{
				if (ownedProjectileCounts[831] > 0)
				{
					stormTiger = true;
				}
				if (!stormTiger)
				{
					DelBuff(j);
					j--;
				}
				else
				{
					buffTime[j] = 18000;
				}
				if (whoAmI == Main.myPlayer)
				{
					UpdateStormTigerStatus();
				}
			}
			else if (buffType[j] == 271)
			{
				if (ownedProjectileCounts[864] > 0)
				{
					smolstar = true;
				}
				if (!smolstar)
				{
					DelBuff(j);
					j--;
				}
				else
				{
					buffTime[j] = 18000;
				}
			}
			else if (buffType[j] == 322)
			{
				if (ownedProjectileCounts[946] > 0)
				{
					empressBlade = true;
				}
				if (!empressBlade)
				{
					DelBuff(j);
					j--;
				}
				else
				{
					buffTime[j] = 18000;
				}
			}
			else if (buffType[j] == 187)
			{
				if (ownedProjectileCounts[623] > 0)
				{
					stardustGuardian = true;
				}
				if (!stardustGuardian)
				{
					DelBuff(j);
					j--;
				}
				else
				{
					buffTime[j] = 18000;
				}
			}
			else if (buffType[j] == 188)
			{
				if (ownedProjectileCounts[625] > 0)
				{
					stardustDragon = true;
				}
				if (!stardustDragon)
				{
					DelBuff(j);
					j--;
				}
				else
				{
					buffTime[j] = 18000;
				}
			}
			else if (buffType[j] == 161)
			{
				if (ownedProjectileCounts[533] > 0)
				{
					DeadlySphereMinion = true;
				}
				if (!DeadlySphereMinion)
				{
					DelBuff(j);
					j--;
				}
				else
				{
					buffTime[j] = 18000;
				}
			}
			else if (buffType[j] == 90)
			{
				mount.SetMount(0, this);
				buffTime[j] = 10;
			}
			else if (buffType[j] == 128)
			{
				mount.SetMount(1, this);
				buffTime[j] = 10;
			}
			else if (buffType[j] == 129)
			{
				mount.SetMount(2, this);
				buffTime[j] = 10;
			}
			else if (buffType[j] == 130)
			{
				mount.SetMount(3, this);
				buffTime[j] = 10;
			}
			else if (buffType[j] == 131)
			{
				ignoreWater = true;
				accFlipper = true;
				mount.SetMount(4, this);
				buffTime[j] = 10;
			}
			else if (buffType[j] == 132)
			{
				mount.SetMount(5, this);
				buffTime[j] = 10;
			}
			else if (buffType[j] == 168)
			{
				ignoreWater = true;
				accFlipper = true;
				mount.SetMount(12, this);
				buffTime[j] = 10;
			}
			else if (buffType[j] == 141)
			{
				mount.SetMount(7, this);
				buffTime[j] = 10;
			}
			else if (buffType[j] == 142)
			{
				mount.SetMount(8, this);
				buffTime[j] = 10;
			}
			else if (buffType[j] == 143)
			{
				mount.SetMount(9, this);
				buffTime[j] = 10;
			}
			else if (buffType[j] == 162)
			{
				mount.SetMount(10, this);
				buffTime[j] = 10;
			}
			else if (buffType[j] == 193)
			{
				mount.SetMount(14, this);
				buffTime[j] = 10;
			}
			else if (buffType[j] == 212)
			{
				mount.SetMount(17, this);
				buffTime[j] = 10;
			}
			else if (buffType[j] == 230)
			{
				mount.SetMount(23, this);
				buffTime[j] = 10;
			}
			else if (buffType[j] == 265)
			{
				canFloatInWater = true;
				accFlipper = true;
				mount.SetMount(37, this);
				buffTime[j] = 10;
			}
			else if (buffType[j] == 275)
			{
				mount.SetMount(40, this);
				buffTime[j] = 10;
			}
			else if (buffType[j] == 276)
			{
				mount.SetMount(41, this);
				buffTime[j] = 10;
			}
			else if (buffType[j] == 277)
			{
				mount.SetMount(42, this);
				buffTime[j] = 10;
			}
			else if (buffType[j] == 278)
			{
				mount.SetMount(43, this);
				buffTime[j] = 10;
			}
			else if (buffType[j] == 279)
			{
				ignoreWater = true;
				accFlipper = true;
				mount.SetMount(44, this);
				buffTime[j] = 10;
			}
			else if (buffType[j] == 280)
			{
				mount.SetMount(45, this);
				buffTime[j] = 10;
			}
			else if (buffType[j] == 281)
			{
				mount.SetMount(46, this);
				buffTime[j] = 10;
			}
			else if (buffType[j] == 282)
			{
				mount.SetMount(47, this);
				buffTime[j] = 10;
			}
			else if (buffType[j] == 283)
			{
				mount.SetMount(48, this);
				buffTime[j] = 10;
			}
			else if (buffType[j] == 305)
			{
				ignoreWater = true;
				accFlipper = true;
				lavaImmune = true;
				mount.SetMount(49, this);
				buffTime[j] = 10;
			}
			else if (buffType[j] == 318)
			{
				mount.SetMount(50, this);
				buffTime[j] = 10;
			}
			else if (buffType[j] == 342)
			{
				mount.SetMount(52, this);
				buffTime[j] = 10;
			}
			else if (buffType[j] == 37)
			{
				if (Main.wofNPCIndex >= 0 && Main.npc[Main.wofNPCIndex].type == 113)
				{
					gross = true;
					buffTime[j] = 10;
				}
				else
				{
					DelBuff(j);
					j--;
				}
			}
			else if (buffType[j] == 38)
			{
				buffTime[j] = 10;
				tongued = true;
			}
			else if (buffType[j] == 146)
			{
				moveSpeed += 0.1f;
				moveSpeed *= 1.1f;
				sunflower = true;
			}
			else if (buffType[j] == 19)
			{
				buffTime[j] = 18000;
				lightOrb = true;
				bool flag3 = true;
				if (ownedProjectileCounts[18] > 0)
				{
					flag3 = false;
				}
				if (flag3 && whoAmI == Main.myPlayer)
				{
					Projectile.NewProjectile(GetProjectileSource_Buff(j), position.X + (float)(width / 2), position.Y + (float)(height / 2), 0f, 0f, 18, 0, 0f, whoAmI);
				}
			}
			else if (buffType[j] == 155)
			{
				buffTime[j] = 18000;
				crimsonHeart = true;
				bool flag4 = true;
				if (ownedProjectileCounts[500] > 0)
				{
					flag4 = false;
				}
				if (flag4 && whoAmI == Main.myPlayer)
				{
					Projectile.NewProjectile(GetProjectileSource_Buff(j), position.X + (float)(width / 2), position.Y + (float)(height / 2), 0f, 0f, 500, 0, 0f, whoAmI);
				}
			}
			else if (buffType[j] == 191)
			{
				BuffHandle_SpawnPetIfNeededAndSetTime(j, ref companionCube, 653);
			}
			else if (buffType[j] == 202)
			{
				BuffHandle_SpawnPetIfNeededAndSetTime(j, ref petFlagDD2Dragon, 701);
			}
			else if (buffType[j] == 217)
			{
				BuffHandle_SpawnPetIfNeededAndSetTime(j, ref petFlagUpbeatStar, 764);
			}
			else if (buffType[j] == 219)
			{
				BuffHandle_SpawnPetIfNeededAndSetTime(j, ref petFlagBabyShark, 774);
			}
			else if (buffType[j] == 258)
			{
				BuffHandle_SpawnPetIfNeededAndSetTime(j, ref petFlagLilHarpy, 815);
			}
			else if (buffType[j] == 259)
			{
				BuffHandle_SpawnPetIfNeededAndSetTime(j, ref petFlagFennecFox, 816);
			}
			else if (buffType[j] == 260)
			{
				BuffHandle_SpawnPetIfNeededAndSetTime(j, ref petFlagGlitteryButterfly, 817);
			}
			else if (buffType[j] == 261)
			{
				BuffHandle_SpawnPetIfNeededAndSetTime(j, ref petFlagBabyImp, 821);
			}
			else if (buffType[j] == 262)
			{
				BuffHandle_SpawnPetIfNeededAndSetTime(j, ref petFlagBabyRedPanda, 825);
			}
			else if (buffType[j] == 264)
			{
				BuffHandle_SpawnPetIfNeededAndSetTime(j, ref petFlagPlantero, 854);
			}
			else if (buffType[j] == 266)
			{
				BuffHandle_SpawnPetIfNeededAndSetTime(j, ref petFlagDynamiteKitten, 858);
			}
			else if (buffType[j] == 267)
			{
				BuffHandle_SpawnPetIfNeededAndSetTime(j, ref petFlagBabyWerewolf, 859);
			}
			else if (buffType[j] == 268)
			{
				BuffHandle_SpawnPetIfNeededAndSetTime(j, ref petFlagShadowMimic, 860);
			}
			else if (buffType[j] == 274)
			{
				BuffHandle_SpawnPetIfNeededAndSetTime(j, ref petFlagVoltBunny, 875);
			}
			else if (buffType[j] == 284)
			{
				BuffHandle_SpawnPetIfNeededAndSetTime(j, ref petFlagKingSlimePet, 881);
			}
			else if (buffType[j] == 285)
			{
				BuffHandle_SpawnPetIfNeededAndSetTime(j, ref petFlagEyeOfCthulhuPet, 882);
			}
			else if (buffType[j] == 286)
			{
				BuffHandle_SpawnPetIfNeededAndSetTime(j, ref petFlagEaterOfWorldsPet, 883);
			}
			else if (buffType[j] == 287)
			{
				BuffHandle_SpawnPetIfNeededAndSetTime(j, ref petFlagBrainOfCthulhuPet, 884);
			}
			else if (buffType[j] == 288)
			{
				BuffHandle_SpawnPetIfNeededAndSetTime(j, ref petFlagSkeletronPet, 885);
			}
			else if (buffType[j] == 289)
			{
				BuffHandle_SpawnPetIfNeededAndSetTime(j, ref petFlagQueenBeePet, 886);
			}
			else if (buffType[j] == 290)
			{
				BuffHandle_SpawnPetIfNeededAndSetTime(j, ref petFlagDestroyerPet, 887);
			}
			else if (buffType[j] == 291)
			{
				BuffHandle_SpawnPetIfNeededAndSetTime(j, ref petFlagTwinsPet, 888);
			}
			else if (buffType[j] == 292)
			{
				BuffHandle_SpawnPetIfNeededAndSetTime(j, ref petFlagSkeletronPrimePet, 889);
			}
			else if (buffType[j] == 293)
			{
				BuffHandle_SpawnPetIfNeededAndSetTime(j, ref petFlagPlanteraPet, 890);
			}
			else if (buffType[j] == 294)
			{
				BuffHandle_SpawnPetIfNeededAndSetTime(j, ref petFlagGolemPet, 891);
			}
			else if (buffType[j] == 295)
			{
				BuffHandle_SpawnPetIfNeededAndSetTime(j, ref petFlagDukeFishronPet, 892);
			}
			else if (buffType[j] == 296)
			{
				BuffHandle_SpawnPetIfNeededAndSetTime(j, ref petFlagLunaticCultistPet, 893);
			}
			else if (buffType[j] == 297)
			{
				BuffHandle_SpawnPetIfNeededAndSetTime(j, ref petFlagMoonLordPet, 894);
			}
			else if (buffType[j] == 298)
			{
				BuffHandle_SpawnPetIfNeededAndSetTime(j, ref petFlagFairyQueenPet, 895);
			}
			else if (buffType[j] == 299)
			{
				BuffHandle_SpawnPetIfNeededAndSetTime(j, ref petFlagPumpkingPet, 896);
			}
			else if (buffType[j] == 300)
			{
				BuffHandle_SpawnPetIfNeededAndSetTime(j, ref petFlagEverscreamPet, 897);
			}
			else if (buffType[j] == 301)
			{
				BuffHandle_SpawnPetIfNeededAndSetTime(j, ref petFlagIceQueenPet, 898);
			}
			else if (buffType[j] == 302)
			{
				BuffHandle_SpawnPetIfNeededAndSetTime(j, ref petFlagMartianPet, 899);
			}
			else if (buffType[j] == 303)
			{
				BuffHandle_SpawnPetIfNeededAndSetTime(j, ref petFlagDD2OgrePet, 900);
			}
			else if (buffType[j] == 304)
			{
				BuffHandle_SpawnPetIfNeededAndSetTime(j, ref petFlagDD2BetsyPet, 901);
			}
			else if (buffType[j] == 317)
			{
				BuffHandle_SpawnPetIfNeededAndSetTime(j, ref petFlagQueenSlimePet, 934);
			}
			else if (buffType[j] == 327)
			{
				BuffHandle_SpawnPetIfNeededAndSetTime(j, ref petFlagBerniePet, 956);
			}
			else if (buffType[j] == 328)
			{
				BuffHandle_SpawnPetIfNeededAndSetTime(j, ref petFlagGlommerPet, 957);
			}
			else if (buffType[j] == 329)
			{
				BuffHandle_SpawnPetIfNeededAndSetTime(j, ref petFlagDeerclopsPet, 958);
			}
			else if (buffType[j] == 330)
			{
				BuffHandle_SpawnPetIfNeededAndSetTime(j, ref petFlagPigPet, 959);
			}
			else if (buffType[j] == 331)
			{
				BuffHandle_SpawnPetIfNeededAndSetTime(j, ref petFlagChesterPet, 960);
			}
			else if (buffType[j] == 341)
			{
				BuffHandle_SpawnPetIfNeededAndSetTime(j, ref petFlagKingSlimePet, 881);
				BuffHandle_SpawnPetIfNeededAndSetTime(j, ref petFlagQueenSlimePet, 934);
			}
			else if (buffType[j] == 345)
			{
				BuffHandle_SpawnPetIfNeededAndSetTime(j, ref petFlagJunimoPet, 994);
			}
			else if (buffType[j] == 349)
			{
				BuffHandle_SpawnPetIfNeededAndSetTime(j, ref petFlagBlueChickenPet, 998);
			}
			else if (buffType[j] == 351)
			{
				BuffHandle_SpawnPetIfNeededAndSetTime(j, ref petFlagSpiffo, 1003);
			}
			else if (buffType[j] == 352)
			{
				BuffHandle_SpawnPetIfNeededAndSetTime(j, ref petFlagCaveling, 1004);
			}
			else if (buffType[j] == 354)
			{
				BuffHandle_SpawnPetIfNeededAndSetTime(j, ref petFlagDirtiestBlock, 1018);
			}
			else if (buffType[j] == 200)
			{
				BuffHandle_SpawnPetIfNeededAndSetTime(j, ref petFlagDD2Gato, 703);
			}
			else if (buffType[j] == 201)
			{
				BuffHandle_SpawnPetIfNeededAndSetTime(j, ref petFlagDD2Ghost, 702);
			}
			else if (buffType[j] == 218)
			{
				BuffHandle_SpawnPetIfNeededAndSetTime(j, ref petFlagSugarGlider, 765);
			}
			else if (buffType[j] == 190)
			{
				buffTime[j] = 18000;
				suspiciouslookingTentacle = true;
				bool flag5 = true;
				if (ownedProjectileCounts[650] > 0)
				{
					flag5 = false;
				}
				if (flag5 && whoAmI == Main.myPlayer)
				{
					Projectile.NewProjectile(GetProjectileSource_Buff(j), position.X + (float)(width / 2), position.Y + (float)(height / 2), 0f, 0f, 650, 0, 0f, whoAmI);
				}
			}
			else if (buffType[j] == 27 || buffType[j] == 101 || buffType[j] == 102)
			{
				buffTime[j] = 18000;
				bool flag6 = true;
				int num22 = 72;
				if (buffType[j] == 27)
				{
					blueFairy = true;
				}
				if (buffType[j] == 101)
				{
					num22 = 86;
					redFairy = true;
				}
				if (buffType[j] == 102)
				{
					num22 = 87;
					greenFairy = true;
				}
				if (head == 45 && body == 26 && legs == 25)
				{
					num22 = 72;
				}
				if (ownedProjectileCounts[num22] > 0)
				{
					flag6 = false;
				}
				if (flag6 && whoAmI == Main.myPlayer)
				{
					Projectile.NewProjectile(GetProjectileSource_Buff(j), position.X + (float)(width / 2), position.Y + (float)(height / 2), 0f, 0f, num22, 0, 0f, whoAmI);
				}
			}
			else if (buffType[j] == 40)
			{
				buffTime[j] = 18000;
				bunny = true;
				bool flag7 = true;
				if (ownedProjectileCounts[111] > 0)
				{
					flag7 = false;
				}
				if (flag7 && whoAmI == Main.myPlayer)
				{
					Projectile.NewProjectile(GetProjectileSource_Buff(j), position.X + (float)(width / 2), position.Y + (float)(height / 2), 0f, 0f, 111, 0, 0f, whoAmI);
				}
			}
			else if (buffType[j] == 148)
			{
				rabid = true;
				if (Main.rand.Next(1200) == 0)
				{
					int num23 = Main.rand.Next(6);
					float num24 = (float)Main.rand.Next(60, 100) * 0.01f;
					switch (num23)
					{
					case 0:
						AddBuff(22, (int)(60f * num24 * 3f));
						break;
					case 1:
						AddBuff(23, (int)(60f * num24 * 0.75f));
						break;
					case 2:
						AddBuff(31, (int)(60f * num24 * 1.5f));
						break;
					case 3:
						AddBuff(32, (int)(60f * num24 * 3.5f));
						break;
					case 4:
						AddBuff(33, (int)(60f * num24 * 5f));
						break;
					case 5:
						AddBuff(35, (int)(60f * num24 * 1f));
						break;
					}
				}
				allDamage += 0.2f;
			}
			else if (buffType[j] == 41)
			{
				buffTime[j] = 18000;
				penguin = true;
				bool flag8 = true;
				if (ownedProjectileCounts[112] > 0)
				{
					flag8 = false;
				}
				if (flag8 && whoAmI == Main.myPlayer)
				{
					Projectile.NewProjectile(GetProjectileSource_Buff(j), position.X + (float)(width / 2), position.Y + (float)(height / 2), 0f, 0f, 112, 0, 0f, whoAmI);
				}
			}
			else if (buffType[j] == 152)
			{
				buffTime[j] = 18000;
				magicLantern = true;
				if (ownedProjectileCounts[492] == 0 && whoAmI == Main.myPlayer)
				{
					Projectile.NewProjectile(GetProjectileSource_Buff(j), position.X + (float)(width / 2), position.Y + (float)(height / 2), 0f, 0f, 492, 0, 0f, whoAmI);
				}
			}
			else if (buffType[j] == 91)
			{
				buffTime[j] = 18000;
				puppy = true;
				bool flag9 = true;
				if (ownedProjectileCounts[334] > 0)
				{
					flag9 = false;
				}
				if (flag9 && whoAmI == Main.myPlayer)
				{
					Projectile.NewProjectile(GetProjectileSource_Buff(j), position.X + (float)(width / 2), position.Y + (float)(height / 2), 0f, 0f, 334, 0, 0f, whoAmI);
				}
			}
			else if (buffType[j] == 92)
			{
				buffTime[j] = 18000;
				grinch = true;
				bool flag10 = true;
				if (ownedProjectileCounts[353] > 0)
				{
					flag10 = false;
				}
				if (flag10 && whoAmI == Main.myPlayer)
				{
					Projectile.NewProjectile(GetProjectileSource_Buff(j), position.X + (float)(width / 2), position.Y + (float)(height / 2), 0f, 0f, 353, 0, 0f, whoAmI);
				}
			}
			else if (buffType[j] == 84)
			{
				buffTime[j] = 18000;
				blackCat = true;
				bool flag11 = true;
				if (ownedProjectileCounts[319] > 0)
				{
					flag11 = false;
				}
				if (flag11 && whoAmI == Main.myPlayer)
				{
					Projectile.NewProjectile(GetProjectileSource_Buff(j), position.X + (float)(width / 2), position.Y + (float)(height / 2), 0f, 0f, 319, 0, 0f, whoAmI);
				}
			}
			else if (buffType[j] == 61)
			{
				buffTime[j] = 18000;
				dino = true;
				bool flag12 = true;
				if (ownedProjectileCounts[236] > 0)
				{
					flag12 = false;
				}
				if (flag12 && whoAmI == Main.myPlayer)
				{
					Projectile.NewProjectile(GetProjectileSource_Buff(j), position.X + (float)(width / 2), position.Y + (float)(height / 2), 0f, 0f, 236, 0, 0f, whoAmI);
				}
			}
			else if (buffType[j] == 154)
			{
				buffTime[j] = 18000;
				babyFaceMonster = true;
				bool flag13 = true;
				if (ownedProjectileCounts[499] > 0)
				{
					flag13 = false;
				}
				if (flag13 && whoAmI == Main.myPlayer)
				{
					Projectile.NewProjectile(GetProjectileSource_Buff(j), position.X + (float)(width / 2), position.Y + (float)(height / 2), 0f, 0f, 499, 0, 0f, whoAmI);
				}
			}
			else if (buffType[j] == 65)
			{
				buffTime[j] = 18000;
				eyeSpring = true;
				bool flag14 = true;
				if (ownedProjectileCounts[268] > 0)
				{
					flag14 = false;
				}
				if (flag14 && whoAmI == Main.myPlayer)
				{
					Projectile.NewProjectile(GetProjectileSource_Buff(j), position.X + (float)(width / 2), position.Y + (float)(height / 2), 0f, 0f, 268, 0, 0f, whoAmI);
				}
			}
			else if (buffType[j] == 66)
			{
				buffTime[j] = 18000;
				snowman = true;
				bool flag15 = true;
				if (ownedProjectileCounts[269] > 0)
				{
					flag15 = false;
				}
				if (flag15 && whoAmI == Main.myPlayer)
				{
					Projectile.NewProjectile(GetProjectileSource_Buff(j), position.X + (float)(width / 2), position.Y + (float)(height / 2), 0f, 0f, 269, 0, 0f, whoAmI);
				}
			}
			else if (buffType[j] == 42)
			{
				buffTime[j] = 18000;
				turtle = true;
				bool flag16 = true;
				if (ownedProjectileCounts[127] > 0)
				{
					flag16 = false;
				}
				if (flag16 && whoAmI == Main.myPlayer)
				{
					Projectile.NewProjectile(GetProjectileSource_Buff(j), position.X + (float)(width / 2), position.Y + (float)(height / 2), 0f, 0f, 127, 0, 0f, whoAmI);
				}
			}
			else if (buffType[j] == 45)
			{
				buffTime[j] = 18000;
				eater = true;
				bool flag17 = true;
				if (ownedProjectileCounts[175] > 0)
				{
					flag17 = false;
				}
				if (flag17 && whoAmI == Main.myPlayer)
				{
					Projectile.NewProjectile(GetProjectileSource_Buff(j), position.X + (float)(width / 2), position.Y + (float)(height / 2), 0f, 0f, 175, 0, 0f, whoAmI);
				}
			}
			else if (buffType[j] == 50)
			{
				buffTime[j] = 18000;
				skeletron = true;
				bool flag18 = true;
				if (ownedProjectileCounts[197] > 0)
				{
					flag18 = false;
				}
				if (flag18 && whoAmI == Main.myPlayer)
				{
					Projectile.NewProjectile(GetProjectileSource_Buff(j), position.X + (float)(width / 2), position.Y + (float)(height / 2), 0f, 0f, 197, 0, 0f, whoAmI);
				}
			}
			else if (buffType[j] == 51)
			{
				buffTime[j] = 18000;
				hornet = true;
				bool flag19 = true;
				if (ownedProjectileCounts[198] > 0)
				{
					flag19 = false;
				}
				if (flag19 && whoAmI == Main.myPlayer)
				{
					Projectile.NewProjectile(GetProjectileSource_Buff(j), position.X + (float)(width / 2), position.Y + (float)(height / 2), 0f, 0f, 198, 0, 0f, whoAmI);
				}
			}
			else if (buffType[j] == 52)
			{
				buffTime[j] = 18000;
				tiki = true;
				bool flag20 = true;
				if (ownedProjectileCounts[199] > 0)
				{
					flag20 = false;
				}
				if (flag20 && whoAmI == Main.myPlayer)
				{
					Projectile.NewProjectile(GetProjectileSource_Buff(j), position.X + (float)(width / 2), position.Y + (float)(height / 2), 0f, 0f, 199, 0, 0f, whoAmI);
				}
			}
			else if (buffType[j] == 53)
			{
				buffTime[j] = 18000;
				lizard = true;
				bool flag21 = true;
				if (ownedProjectileCounts[200] > 0)
				{
					flag21 = false;
				}
				if (flag21 && whoAmI == Main.myPlayer)
				{
					Projectile.NewProjectile(GetProjectileSource_Buff(j), position.X + (float)(width / 2), position.Y + (float)(height / 2), 0f, 0f, 200, 0, 0f, whoAmI);
				}
			}
			else if (buffType[j] == 54)
			{
				buffTime[j] = 18000;
				parrot = true;
				bool flag22 = true;
				if (ownedProjectileCounts[208] > 0)
				{
					flag22 = false;
				}
				if (flag22 && whoAmI == Main.myPlayer)
				{
					Projectile.NewProjectile(GetProjectileSource_Buff(j), position.X + (float)(width / 2), position.Y + (float)(height / 2), 0f, 0f, 208, 0, 0f, whoAmI);
				}
			}
			else if (buffType[j] == 55)
			{
				buffTime[j] = 18000;
				truffle = true;
				bool flag23 = true;
				if (ownedProjectileCounts[209] > 0)
				{
					flag23 = false;
				}
				if (flag23 && whoAmI == Main.myPlayer)
				{
					Projectile.NewProjectile(GetProjectileSource_Buff(j), position.X + (float)(width / 2), position.Y + (float)(height / 2), 0f, 0f, 209, 0, 0f, whoAmI);
				}
			}
			else if (buffType[j] == 56)
			{
				buffTime[j] = 18000;
				sapling = true;
				bool flag24 = true;
				if (ownedProjectileCounts[210] > 0)
				{
					flag24 = false;
				}
				if (flag24 && whoAmI == Main.myPlayer)
				{
					Projectile.NewProjectile(GetProjectileSource_Buff(j), position.X + (float)(width / 2), position.Y + (float)(height / 2), 0f, 0f, 210, 0, 0f, whoAmI);
				}
			}
			else if (buffType[j] == 85)
			{
				buffTime[j] = 18000;
				cSapling = true;
				bool flag25 = true;
				if (ownedProjectileCounts[324] > 0)
				{
					flag25 = false;
				}
				if (flag25 && whoAmI == Main.myPlayer)
				{
					Projectile.NewProjectile(GetProjectileSource_Buff(j), position.X + (float)(width / 2), position.Y + (float)(height / 2), 0f, 0f, 324, 0, 0f, whoAmI);
				}
			}
			else if (buffType[j] == 81)
			{
				buffTime[j] = 18000;
				spider = true;
				bool flag26 = true;
				if (ownedProjectileCounts[313] > 0)
				{
					flag26 = false;
				}
				if (flag26 && whoAmI == Main.myPlayer)
				{
					Projectile.NewProjectile(GetProjectileSource_Buff(j), position.X + (float)(width / 2), position.Y + (float)(height / 2), 0f, 0f, 313, 0, 0f, whoAmI);
				}
			}
			else if (buffType[j] == 82)
			{
				buffTime[j] = 18000;
				squashling = true;
				bool flag27 = true;
				if (ownedProjectileCounts[314] > 0)
				{
					flag27 = false;
				}
				if (flag27 && whoAmI == Main.myPlayer)
				{
					Projectile.NewProjectile(GetProjectileSource_Buff(j), position.X + (float)(width / 2), position.Y + (float)(height / 2), 0f, 0f, 314, 0, 0f, whoAmI);
				}
			}
			else if (buffType[j] == 57)
			{
				buffTime[j] = 18000;
				wisp = true;
				bool flag28 = true;
				if (ownedProjectileCounts[211] > 0)
				{
					flag28 = false;
				}
				if (flag28 && whoAmI == Main.myPlayer)
				{
					Projectile.NewProjectile(GetProjectileSource_Buff(j), position.X + (float)(width / 2), position.Y + (float)(height / 2), 0f, 0f, 211, 0, 0f, whoAmI);
				}
			}
			else if (buffType[j] == 60)
			{
				buffTime[j] = 18000;
				crystalLeaf = true;
				bool flag29 = true;
				for (int num25 = 0; num25 < 1000; num25++)
				{
					if (Main.projectile[num25].active && Main.projectile[num25].owner == whoAmI && Main.projectile[num25].type == 226)
					{
						if (!flag29)
						{
							Main.projectile[num25].Kill();
						}
						flag29 = false;
					}
				}
				if (flag29 && whoAmI == Main.myPlayer)
				{
					Projectile.NewProjectile(GetProjectileSource_Buff(j), position.X + (float)(width / 2), position.Y + (float)(height / 2), 0f, 0f, 226, 0, 0f, whoAmI);
				}
			}
			else if (buffType[j] == 127)
			{
				buffTime[j] = 18000;
				zephyrfish = true;
				bool flag30 = true;
				if (ownedProjectileCounts[380] > 0)
				{
					flag30 = false;
				}
				if (flag30 && whoAmI == Main.myPlayer)
				{
					Projectile.NewProjectile(GetProjectileSource_Buff(j), position.X + (float)(width / 2), position.Y + (float)(height / 2), 0f, 0f, 380, 0, 0f, whoAmI);
				}
			}
			else if (buffType[j] == 136)
			{
				buffTime[j] = 18000;
				miniMinotaur = true;
				bool flag31 = true;
				if (ownedProjectileCounts[398] > 0)
				{
					flag31 = false;
				}
				if (flag31 && whoAmI == Main.myPlayer)
				{
					Projectile.NewProjectile(GetProjectileSource_Buff(j), position.X + (float)(width / 2), position.Y + (float)(height / 2), 0f, 0f, 398, 0, 0f, whoAmI);
				}
			}
			else if (buffType[j] == 70)
			{
				venom = true;
			}
			else if (buffType[j] == 20)
			{
				poisoned = true;
			}
			else if (buffType[j] == 21)
			{
				potionDelay = buffTime[j];
			}
			else if (buffType[j] == 22)
			{
				blind = true;
			}
			else if (buffType[j] == 80)
			{
				blackout = true;
			}
			else if (buffType[j] == 23)
			{
				noItems = true;
				cursed = true;
			}
			else if (buffType[j] == 24)
			{
				onFire = true;
			}
			else if (buffType[j] == 103)
			{
				dripping = true;
			}
			else if (buffType[j] == 137)
			{
				drippingSlime = true;
			}
			else if (buffType[j] == 320)
			{
				drippingSparkleSlime = true;
			}
			else if (buffType[j] == 67)
			{
				burned = true;
			}
			else if (buffType[j] == 68)
			{
				suffocating = true;
			}
			else if (buffType[j] == 39)
			{
				onFire2 = true;
			}
			else if (buffType[j] == 323)
			{
				onFire3 = true;
			}
			else if (buffType[j] == 44)
			{
				onFrostBurn = true;
			}
			else if (buffType[j] == 324)
			{
				onFrostBurn2 = true;
			}
			else if (buffType[j] == 353)
			{
				shimmering = true;
				frozen = true;
				fallStart = (int)(position.Y / 16f);
				if (Main.myPlayer == whoAmI)
				{
					if (position.Y / 16f > (float)Main.UnderworldLayer)
					{
						if (Main.myPlayer == whoAmI)
						{
							DelBuff(j);
							j--;
						}
					}
					else if (shimmerWet)
					{
						buffTime[j] = 60;
					}
					else
					{
						bool flag32 = false;
						for (int num26 = (int)(position.X / 16f); (float)num26 <= (position.X + (float)width) / 16f; num26++)
						{
							for (int num27 = (int)(position.Y / 16f); (float)num27 <= (position.Y + (float)height) / 16f; num27++)
							{
								if (WorldGen.SolidTile3(num26, num27))
								{
									flag32 = true;
								}
							}
						}
						if (flag32)
						{
							buffTime[j] = 6;
						}
						else
						{
							DelBuff(j);
							j--;
						}
					}
				}
			}
			else if (buffType[j] == 163)
			{
				headcovered = true;
				bleed = true;
			}
			else if (buffType[j] == 164)
			{
				vortexDebuff = true;
			}
			else if (buffType[j] == 194)
			{
				windPushed = true;
			}
			else if (buffType[j] == 195)
			{
				witheredArmor = true;
			}
			else if (buffType[j] == 205)
			{
				ballistaPanic = true;
			}
			else if (buffType[j] == 196)
			{
				witheredWeapon = true;
			}
			else if (buffType[j] == 197)
			{
				slowOgreSpit = true;
			}
			else if (buffType[j] == 198)
			{
				parryDamageBuff = true;
			}
			else if (buffType[j] == 145)
			{
				moonLeech = true;
			}
			else if (buffType[j] == 149)
			{
				webbed = true;
				if (velocity.Y != 0f)
				{
					velocity = new Vector2(0f, 1E-06f);
				}
				else
				{
					velocity = Vector2.Zero;
				}
				jumpHeight = 0;
				gravity = 0f;
				moveSpeed = 0f;
				dash = 0;
				dashType = 0;
				noKnockback = true;
				RemoveAllGrapplingHooks();
			}
			else if (buffType[j] == 43)
			{
				defendedByPaladin = true;
			}
			else if (buffType[j] == 29)
			{
				magicCrit += 2f;
				magicDamage += 0.05f;
				statManaMax2 += 20;
				manaCost -= 0.02f;
			}
			else if (buffType[j] == 28)
			{
				if (!Main.dayTime && wolfAcc && !merman)
				{
					lifeRegen++;
					wereWolf = true;
					meleeCrit += 2f;
					meleeDamage += 0.051f;
					meleeSpeed += 0.051f;
					statDefense += 3;
					moveSpeed += 0.05f;
				}
				else
				{
					DelBuff(j);
					j--;
				}
			}
			else if (buffType[j] == 33)
			{
				meleeDamage -= 0.051f;
				meleeSpeed -= 0.051f;
				statDefense -= 4;
				moveSpeed -= 0.1f;
			}
			else if (buffType[j] == 25)
			{
				tipsy = true;
				statDefense -= 4;
				meleeCrit += 2f;
				meleeDamage += 0.1f;
				meleeSpeed += 0.1f;
			}
			else if (buffType[j] == 26)
			{
				wellFed = true;
				statDefense += 2;
				allCrit += 2f;
				allDamage += 0.05f;
				meleeSpeed += 0.05f;
				minionKB += 0.5f;
				moveSpeed += 0.2f;
				pickSpeed -= 0.05f;
			}
			else if (buffType[j] == 206)
			{
				wellFed = true;
				statDefense += 3;
				allCrit += 3f;
				allDamage += 0.075f;
				meleeSpeed += 0.075f;
				minionKB += 0.75f;
				moveSpeed += 0.3f;
				pickSpeed -= 0.1f;
			}
			else if (buffType[j] == 207)
			{
				wellFed = true;
				statDefense += 4;
				allCrit += 4f;
				allDamage += 0.1f;
				meleeSpeed += 0.1f;
				minionKB += 1f;
				moveSpeed += 0.4f;
				pickSpeed -= 0.15f;
			}
			else if (buffType[j] == 333)
			{
				hungry = true;
				statDefense -= 2;
				allCrit -= 2f;
				allDamage -= 0.05f;
				meleeSpeed -= 0.05f;
				minionKB -= 0.5f;
				pickSpeed += 0.05f;
			}
			else if (buffType[j] == 334)
			{
				starving = true;
				statDefense -= 4;
				allCrit -= 4f;
				allDamage -= 0.1f;
				meleeSpeed -= 0.1f;
				minionKB -= 1f;
				pickSpeed += 0.15f;
			}
			else if (buffType[j] == 336)
			{
				heartyMeal = true;
			}
			else if (buffType[j] == 71)
			{
				meleeEnchant = 1;
			}
			else if (buffType[j] == 73)
			{
				meleeEnchant = 2;
			}
			else if (buffType[j] == 74)
			{
				meleeEnchant = 3;
			}
			else if (buffType[j] == 75)
			{
				meleeEnchant = 4;
			}
			else if (buffType[j] == 76)
			{
				meleeEnchant = 5;
			}
			else if (buffType[j] == 77)
			{
				meleeEnchant = 6;
			}
			else if (buffType[j] == 78)
			{
				meleeEnchant = 7;
			}
			else if (buffType[j] == 79)
			{
				meleeEnchant = 8;
			}
			if (j == num)
			{
				BuffLoader.Update(buffType[j], this, ref j);
			}
		}
		UpdateHungerBuffs();
		if (whoAmI == Main.myPlayer && luckPotion != oldLuckPotion)
		{
			luckNeedsSync = true;
			oldLuckPotion = luckPotion;
		}
	}

	public void TryToResetHungerToNeutral()
	{
		bool flag = false;
		for (int i = 0; i < maxBuffs; i++)
		{
			if (buffType[i] > 0 && buffTime[i] > 0 && (buffType[i] == 332 || buffType[i] == 333 || buffType[i] == 334))
			{
				buffTime[i] = 0;
				flag = true;
			}
		}
		if (flag)
		{
			UpdateHungerBuffs();
		}
	}

	public void UpdateHungerBuffs()
	{
		for (int i = 0; i < maxBuffs; i++)
		{
			if (buffType[i] <= 0 || buffTime[i] <= 0)
			{
				continue;
			}
			if (buffType[i] == 332)
			{
				if (buffTime[i] <= 2 && whoAmI == Main.myPlayer)
				{
					if (Main.remixWorld && Main.dontStarveWorld)
					{
						AddBuff(333, 28800);
					}
					else
					{
						AddBuff(333, 18000);
					}
					EmoteBubble.MakeLocalPlayerEmote(147);
				}
				if (!Main.dontStarveWorld)
				{
					buffTime[i] = 0;
				}
			}
			else if (buffType[i] == 333)
			{
				if (buffTime[i] <= 2 && whoAmI == Main.myPlayer)
				{
					if (Main.remixWorld && Main.dontStarveWorld)
					{
						AddBuff(334, 5);
					}
					else
					{
						AddBuff(334, 5);
					}
					EmoteBubble.MakeLocalPlayerEmote(148);
				}
				if (!Main.dontStarveWorld)
				{
					buffTime[i] = 0;
				}
			}
			else if (buffType[i] == 334 && !Main.dontStarveWorld)
			{
				buffTime[i] = 0;
			}
		}
	}

	public void UpdateStarvingState(bool withEmote)
	{
		if (whoAmI != Main.myPlayer)
		{
			return;
		}
		bool flag = false;
		for (int i = 0; i < maxBuffs; i++)
		{
			if (buffTime[i] > 0 && BuffID.Sets.IsFedState[buffType[i]])
			{
				flag = true;
				break;
			}
		}
		if (!flag)
		{
			if (Main.remixWorld && Main.dontStarveWorld)
			{
				AddBuff(332, 28800);
			}
			else
			{
				AddBuff(332, 18000);
			}
			if (withEmote)
			{
				EmoteBubble.MakeLocalPlayerEmote(146);
			}
		}
	}

	private void UpdateProjectileCaches(int i)
	{
		for (int j = 0; j < 1000; j++)
		{
			if (!Main.projectile[j].active || Main.projectile[j].owner != i)
			{
				continue;
			}
			ownedProjectileCounts[Main.projectile[j].type]++;
			switch (Main.projectile[j].type)
			{
			case 831:
			{
				int originalDamage2 = Main.projectile[j].originalDamage;
				if (highestStormTigerGemOriginalDamage < originalDamage2)
				{
					highestStormTigerGemOriginalDamage = originalDamage2;
				}
				break;
			}
			case 970:
			{
				int originalDamage = Main.projectile[j].originalDamage;
				if (highestAbigailCounterOriginalDamage < originalDamage)
				{
					highestAbigailCounterOriginalDamage = originalDamage;
				}
				break;
			}
			}
		}
	}

	private void ResetProjectileCaches()
	{
		highestStormTigerGemOriginalDamage = 0;
		highestAbigailCounterOriginalDamage = 0;
		for (int i = 0; i < ownedProjectileCounts.Length; i++)
		{
			ownedProjectileCounts[i] = 0;
		}
	}

	/// <summary>
	/// A helper method that handles code common to pet buffs. Can be used during the buff update code.<br />
	/// Sets the buff time to the value and spawns the corresponding pet projectile for the player if not yet spawned.<br />
	/// </summary>
	/// <param name="buffIndex"></param>
	/// <param name="petBool"></param>
	/// <param name="petProjID"></param>
	/// <param name="buffTimeToGive"></param>
	public void BuffHandle_SpawnPetIfNeededAndSetTime(int buffIndex, ref bool petBool, int petProjID, int buffTimeToGive = 18000)
	{
		buffTime[buffIndex] = buffTimeToGive;
		BuffHandle_SpawnPetIfNeeded(ref petBool, petProjID, buffIndex);
	}

	public void BuffHandle_SpawnPetIfNeeded(ref bool petBool, int petProjID, int buffIndex)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		petBool = true;
		bool flag = true;
		if (ownedProjectileCounts[petProjID] > 0)
		{
			flag = false;
		}
		Vector2 val = base.Center;
		if (buffType[buffIndex] == 341)
		{
			float num = 10f;
			val = ((petProjID != 934) ? (val - new Vector2(num * (float)direction, 0f)) : (val + new Vector2(num * (float)direction, 0f)));
		}
		if (flag && whoAmI == Main.myPlayer)
		{
			Projectile.NewProjectile(GetProjectileSource_Buff(buffIndex), val.X, val.Y, 0f, 0f, petProjID, 0, 0f, whoAmI);
		}
	}

	private void UpdateAbigailStatus()
	{
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		int num = 963;
		if (ownedProjectileCounts[970] < 1)
		{
			for (int i = 0; i < 1000; i++)
			{
				Projectile projectile = Main.projectile[i];
				if (projectile.active && projectile.owner == whoAmI && projectile.type == num)
				{
					projectile.Kill();
				}
			}
		}
		else if (ownedProjectileCounts[num] < 1)
		{
			Projectile.NewProjectile(GetProjectileSource_Misc(14), base.Center, Vector2.Zero, num, 0, 0f, whoAmI);
		}
	}

	private void UpdateStormTigerStatus()
	{
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		int num = GetDesiredStormTigerMinionRank() switch
		{
			1 => 833, 
			2 => 834, 
			3 => 835, 
			_ => -1, 
		};
		bool flag = false;
		if (num == -1)
		{
			flag = true;
		}
		for (int i = 0; i < ProjectileID.Sets.StormTigerIds.Length; i++)
		{
			int num2 = ProjectileID.Sets.StormTigerIds[i];
			if (num2 != num && ownedProjectileCounts[num2] >= 1)
			{
				flag = true;
				break;
			}
		}
		if (flag)
		{
			for (int j = 0; j < 1000; j++)
			{
				Projectile projectile = Main.projectile[j];
				if (projectile.active && projectile.owner == whoAmI && projectile.type != num && ProjectileID.Sets.StormTiger[projectile.type])
				{
					projectile.Kill();
				}
			}
		}
		else if (ownedProjectileCounts[num] < 1)
		{
			int num3 = Projectile.NewProjectile(GetProjectileSource_Misc(13), base.Center, Vector2.Zero, num, 0, 0f, whoAmI, 0f, 1f);
			Main.projectile[num3].localAI[0] = 60f;
		}
	}

	private int GetDesiredStormTigerMinionRank()
	{
		int result = 0;
		int num = ownedProjectileCounts[831];
		if (num > 0)
		{
			result = 1;
		}
		if (num > 3)
		{
			result = 2;
		}
		if (num > 6)
		{
			result = 3;
		}
		return result;
	}

	public void Counterweight(Vector2 hitPos, int dmg, float kb)
	{
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_013c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0143: Unknown result type (might be due to invalid IL or missing references)
		//IL_0148: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01da: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_016e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0179: Unknown result type (might be due to invalid IL or missing references)
		//IL_0183: Unknown result type (might be due to invalid IL or missing references)
		//IL_018a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		if (!yoyoGlove && counterWeight <= 0)
		{
			return;
		}
		int num = -1;
		int num2 = 0;
		int num3 = 0;
		for (int i = 0; i < 1000; i++)
		{
			if (Main.projectile[i].active && Main.projectile[i].owner == whoAmI)
			{
				if (Main.projectile[i].counterweight)
				{
					num3++;
				}
				else if (Main.projectile[i].aiStyle == 99)
				{
					num2++;
					num = i;
				}
			}
		}
		if (yoyoGlove && num2 < 2)
		{
			if (num >= 0)
			{
				Vector2 val = hitPos - base.Center;
				((Vector2)(ref val)).Normalize();
				val *= 16f;
				Projectile.NewProjectile(Entity.InheritSource(Main.projectile[num]), base.Center.X, base.Center.Y, val.X, val.Y, Main.projectile[num].type, Main.projectile[num].damage, Main.projectile[num].knockBack, whoAmI, 1f);
			}
		}
		else if (num3 < num2)
		{
			Vector2 val2 = hitPos - base.Center;
			((Vector2)(ref val2)).Normalize();
			val2 *= 16f;
			float knockBack = (kb + 6f) / 2f;
			IEntitySource spawnSource = Entity.InheritSource(Main.projectile[num]);
			if (num3 > 0)
			{
				Projectile.NewProjectile(spawnSource, base.Center.X, base.Center.Y, val2.X, val2.Y, counterWeight, (int)((double)dmg * 0.8), knockBack, whoAmI, 1f);
			}
			else
			{
				Projectile.NewProjectile(spawnSource, base.Center.X, base.Center.Y, val2.X, val2.Y, counterWeight, (int)((double)dmg * 0.8), knockBack, whoAmI);
			}
		}
	}

	public int beeType()
	{
		if (strongBees && Main.rand.Next(2) == 0)
		{
			makeStrongBee = true;
			return 566;
		}
		makeStrongBee = false;
		return 181;
	}

	public int beeDamage(int dmg)
	{
		if (makeStrongBee)
		{
			return dmg + Main.rand.Next(1, 4);
		}
		return dmg + Main.rand.Next(2);
	}

	public float beeKB(float KB)
	{
		if (makeStrongBee)
		{
			return 0.5f + KB * 1.1f;
		}
		return KB;
	}

	public void Yoraiz0rEye()
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_014e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0159: Unknown result type (might be due to invalid IL or missing references)
		//IL_015e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0163: Unknown result type (might be due to invalid IL or missing references)
		//IL_0164: Unknown result type (might be due to invalid IL or missing references)
		//IL_0169: Unknown result type (might be due to invalid IL or missing references)
		//IL_0182: Unknown result type (might be due to invalid IL or missing references)
		//IL_0187: Unknown result type (might be due to invalid IL or missing references)
		//IL_0188: Unknown result type (might be due to invalid IL or missing references)
		//IL_018d: Unknown result type (might be due to invalid IL or missing references)
		//IL_018f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0194: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_02bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_0271: Unknown result type (might be due to invalid IL or missing references)
		//IL_027b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0280: Unknown result type (might be due to invalid IL or missing references)
		//IL_0285: Unknown result type (might be due to invalid IL or missing references)
		//IL_0287: Unknown result type (might be due to invalid IL or missing references)
		//IL_0291: Unknown result type (might be due to invalid IL or missing references)
		//IL_0296: Unknown result type (might be due to invalid IL or missing references)
		//IL_029b: Unknown result type (might be due to invalid IL or missing references)
		//IL_020f: Unknown result type (might be due to invalid IL or missing references)
		//IL_021d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0223: Unknown result type (might be due to invalid IL or missing references)
		//IL_0225: Unknown result type (might be due to invalid IL or missing references)
		//IL_022a: Unknown result type (might be due to invalid IL or missing references)
		//IL_023b: Unknown result type (might be due to invalid IL or missing references)
		//IL_025d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0262: Unknown result type (might be due to invalid IL or missing references)
		//IL_0440: Unknown result type (might be due to invalid IL or missing references)
		//IL_0442: Unknown result type (might be due to invalid IL or missing references)
		//IL_0450: Unknown result type (might be due to invalid IL or missing references)
		//IL_0452: Unknown result type (might be due to invalid IL or missing references)
		//IL_0371: Unknown result type (might be due to invalid IL or missing references)
		//IL_0376: Unknown result type (might be due to invalid IL or missing references)
		//IL_038f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0394: Unknown result type (might be due to invalid IL or missing references)
		//IL_0398: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_040f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0415: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_03cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_03dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_047e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0497: Unknown result type (might be due to invalid IL or missing references)
		//IL_049d: Unknown result type (might be due to invalid IL or missing references)
		//IL_04ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_04ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_04b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_04ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_04c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_04cc: Unknown result type (might be due to invalid IL or missing references)
		int num = 0;
		num += bodyFrame.Y / 56;
		if (num >= Main.OffsetsPlayerHeadgear.Length)
		{
			num = 0;
		}
		Vector2 val = Main.OffsetsPlayerHeadgear[num];
		val *= Directions;
		Vector2 val2 = new Vector2((float)(width / 2), (float)(height / 2)) + val + (MountedCenter - base.Center);
		sitting.GetSittingOffsetInfo(this, out var posOffset, out var seatAdjustment);
		val2 += posOffset + new Vector2(0f, seatAdjustment);
		if (face == 19)
		{
			val2.Y -= 5f * gravDir;
		}
		if (head == 276)
		{
			val2.X += 2.5f * (float)direction;
		}
		if (mount.Active && mount.Type == 52)
		{
			val2.X += 14f * (float)direction;
			val2.Y -= 2f * gravDir;
		}
		float num2 = -11.5f * gravDir;
		Vector2 val3 = new Vector2((float)(3 * direction - ((direction == 1) ? 1 : 0)), num2) + Vector2.UnitY * gfxOffY + val2;
		Vector2 val4 = new Vector2((float)(3 * shadowDirection[1] - ((direction == 1) ? 1 : 0)), num2) + val2;
		Vector2 val5 = Vector2.Zero;
		if (mount.Active && mount.Cart)
		{
			int num3 = Math.Sign(velocity.X);
			if (num3 == 0)
			{
				num3 = direction;
			}
			val5 = Utils.RotatedBy(new Vector2(MathHelper.Lerp(0f, -8f, fullRotation / ((float)Math.PI / 4f)), MathHelper.Lerp(0f, 2f, Math.Abs(fullRotation / ((float)Math.PI / 4f)))), (double)fullRotation, default(Vector2));
			if (num3 == Math.Sign(fullRotation))
			{
				val5 *= MathHelper.Lerp(1f, 0.6f, Math.Abs(fullRotation / ((float)Math.PI / 4f)));
			}
		}
		if (fullRotation != 0f)
		{
			val3 = val3.RotatedBy(fullRotation, fullRotationOrigin);
			val4 = val4.RotatedBy(fullRotation, fullRotationOrigin);
		}
		float num4 = 0f;
		Vector2 val6 = position + val3 + val5;
		Vector2 val7 = oldPosition + val4 + val5;
		val7.Y -= num4 / 2f;
		val6.Y -= num4 / 2f;
		float num5 = 1f;
		switch (yoraiz0rEye % 10)
		{
		case 1:
			return;
		case 2:
			num5 = 0.5f;
			break;
		case 3:
			num5 = 0.625f;
			break;
		case 4:
			num5 = 0.75f;
			break;
		case 5:
			num5 = 0.875f;
			break;
		case 6:
			num5 = 1f;
			break;
		case 7:
			num5 = 1.1f;
			break;
		}
		Color newColor;
		if (yoraiz0rEye < 7)
		{
			newColor = Main.hslToRgb(Main.rgbToHsl(eyeColor).X, 1f, 0.5f);
			DelegateMethods.v3_1 = ((Color)(ref newColor)).ToVector3() * 0.5f * num5;
			if (velocity != Vector2.Zero)
			{
				Utils.PlotTileLine(base.Center, base.Center + velocity * 2f, 4f, DelegateMethods.CastLightOpen);
			}
			else
			{
				Utils.PlotTileLine(base.Left, base.Right, 4f, DelegateMethods.CastLightOpen);
			}
		}
		int num6 = (int)Vector2.Distance(val6, val7) / 3 + 1;
		if (Vector2.Distance(val6, val7) % 3f != 0f)
		{
			num6++;
		}
		for (float num7 = 1f; num7 <= (float)num6; num7 += 1f)
		{
			Dust[] dust = Main.dust;
			Vector2 center = base.Center;
			newColor = default(Color);
			Dust obj = dust[Dust.NewDust(center, 0, 0, 182, 0f, 0f, 0, newColor)];
			obj.position = Vector2.Lerp(val7, val6, num7 / (float)num6);
			obj.noGravity = true;
			obj.velocity = Vector2.Zero;
			obj.customData = this;
			obj.scale = num5;
			obj.shader = GameShaders.Armor.GetSecondaryShader(cYorai, this);
		}
	}

	public bool IsItemSlotUnlockedAndUsable(int slot)
	{
		switch (slot)
		{
		default:
			return true;
		case 8:
		case 18:
		{
			bool result2 = extraAccessory;
			if (!Main.expertMode && !Main.gameMenu)
			{
				result2 = false;
			}
			return result2;
		}
		case 9:
		case 19:
		{
			bool result = true;
			if (!Main.masterMode && !Main.gameMenu)
			{
				result = false;
			}
			return result;
		}
		}
	}

	public void RefreshInfoAccs()
	{
		bool flag = false;
		accWatch = 0;
		accCompass = 0;
		accDepthMeter = 0;
		accFishFinder = false;
		accWeatherRadio = false;
		accCalendar = false;
		accThirdEye = false;
		accJarOfSouls = false;
		accCritterGuide = false;
		accStopwatch = false;
		accOreFinder = false;
		accDreamCatcher = false;
		PlayerLoader.ResetInfoAccessories(this);
		for (int i = 0; i < 58; i++)
		{
			int type = inventory[i].type;
			RefreshInfoAccsFromItemType(inventory[i]);
			if (type == 4131)
			{
				flag = true;
			}
		}
		for (int j = 0; j < 10; j++)
		{
			_ = armor[j].type;
			RefreshInfoAccsFromItemType(armor[j]);
		}
		if (flag)
		{
			for (int k = 0; k < 40; k++)
			{
				int type2 = bank4.item[k].type;
				if (type2 < 0 || ItemID.Sets.WorksInVoidBag[type2])
				{
					RefreshInfoAccsFromItemType(bank4.item[k]);
				}
			}
		}
		RefreshInfoAccsFromTeamPlayers();
	}

	public void RefreshInfoAccsFromTeamPlayers()
	{
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		if (Main.netMode != 1 || whoAmI != Main.myPlayer)
		{
			return;
		}
		for (int i = 0; i < 255; i++)
		{
			if (i == whoAmI || !Main.player[i].active || Main.player[i].dead || Main.player[i].team != team || Main.player[i].team == 0)
			{
				continue;
			}
			int num = 800;
			Vector2 val = Main.player[i].Center - base.Center;
			if (((Vector2)(ref val)).Length() < (float)num)
			{
				if (Main.player[i].accWatch > accWatch)
				{
					accWatch = Main.player[i].accWatch;
				}
				if (Main.player[i].accCompass > accCompass)
				{
					accCompass = Main.player[i].accCompass;
				}
				if (Main.player[i].accDepthMeter > accDepthMeter)
				{
					accDepthMeter = Main.player[i].accDepthMeter;
				}
				if (Main.player[i].accFishFinder)
				{
					accFishFinder = true;
				}
				if (Main.player[i].accWeatherRadio)
				{
					accWeatherRadio = true;
				}
				if (Main.player[i].accThirdEye)
				{
					accThirdEye = true;
				}
				if (Main.player[i].accJarOfSouls)
				{
					accJarOfSouls = true;
				}
				if (Main.player[i].accCalendar)
				{
					accCalendar = true;
				}
				if (Main.player[i].accStopwatch)
				{
					accStopwatch = true;
				}
				if (Main.player[i].accOreFinder)
				{
					accOreFinder = true;
				}
				if (Main.player[i].accCritterGuide)
				{
					accCritterGuide = true;
				}
				if (Main.player[i].accDreamCatcher)
				{
					accDreamCatcher = true;
				}
				if (Main.player[i].hasLuck_LuckyHorseshoe)
				{
					hasLuck_LuckyHorseshoe = true;
				}
				if (Main.player[i].hasLuck_LuckyCoin)
				{
					hasLuck_LuckyCoin = true;
				}
				PlayerLoader.RefreshInfoAccessoriesFromTeamPlayers(this, Main.player[i]);
			}
		}
	}

	public void RefreshInfoAccsFromItemType(Item item)
	{
		RefreshInfoAccsFromItemType(item.type);
		ItemLoader.UpdateInfoAccessory(item, this);
	}

	private void RefreshInfoAccsFromItemType(int accType)
	{
		if ((accType == 15 || accType == 707) && accWatch < 1)
		{
			accWatch = 1;
		}
		if ((accType == 16 || accType == 708) && accWatch < 2)
		{
			accWatch = 2;
		}
		if ((accType == 17 || accType == 709) && accWatch < 3)
		{
			accWatch = 3;
		}
		if (accType == 393)
		{
			accCompass = 1;
		}
		if (accType == 18)
		{
			accDepthMeter = 1;
		}
		if (accType == 395 || accType == 3123 || accType == 3124 || accType == 5358 || accType == 5359 || accType == 5360 || accType == 5361)
		{
			accWatch = 3;
			accDepthMeter = 1;
			accCompass = 1;
		}
		if (accType == 3120 || accType == 3036 || accType == 3123 || accType == 3124 || accType == 5358 || accType == 5359 || accType == 5360 || accType == 5361)
		{
			accFishFinder = true;
		}
		if (accType == 3037 || accType == 3036 || accType == 3123 || accType == 3124 || accType == 5358 || accType == 5359 || accType == 5360 || accType == 5361)
		{
			accWeatherRadio = true;
		}
		if (accType == 3096 || accType == 3036 || accType == 3123 || accType == 3124 || accType == 5358 || accType == 5359 || accType == 5360 || accType == 5361)
		{
			accCalendar = true;
		}
		if (accType == 3084 || accType == 3122 || accType == 3123 || accType == 3124 || accType == 5358 || accType == 5359 || accType == 5360 || accType == 5361)
		{
			accThirdEye = true;
		}
		if (accType == 3095 || accType == 3122 || accType == 3123 || accType == 3124 || accType == 5358 || accType == 5359 || accType == 5360 || accType == 5361)
		{
			accJarOfSouls = true;
		}
		if (accType == 3118 || accType == 3122 || accType == 3123 || accType == 3124 || accType == 5358 || accType == 5359 || accType == 5360 || accType == 5361)
		{
			accCritterGuide = true;
		}
		if (accType == 3099 || accType == 3121 || accType == 3123 || accType == 3124 || accType == 5358 || accType == 5359 || accType == 5360 || accType == 5361)
		{
			accStopwatch = true;
		}
		if (accType == 3102 || accType == 3121 || accType == 3123 || accType == 3124 || accType == 5358 || accType == 5359 || accType == 5360 || accType == 5361)
		{
			accOreFinder = true;
		}
		if (accType == 3119 || accType == 3121 || accType == 3123 || accType == 3124 || accType == 5358 || accType == 5359 || accType == 5360 || accType == 5361)
		{
			accDreamCatcher = true;
		}
	}

	public void RefreshMechanicalAccsFromItemType(int accType)
	{
		if (accType == 3619 || accType == 3611)
		{
			InfoAccMechShowWires = true;
		}
		if (accType == 486 || accType == 3611)
		{
			rulerLine = true;
		}
		if (accType == 2799 || accType == 3611)
		{
			rulerGrid = true;
		}
		if (accType == 2216 || accType == 3061 || accType == 5126)
		{
			autoPaint = true;
		}
		if (accType == 3624)
		{
			autoActuator = true;
		}
		if (accType == 4346)
		{
			preventAllItemPickups = true;
		}
		if (accType == 4767 || accType == 5323)
		{
			dontHurtCritters = true;
		}
		if (accType == 5309 || accType == 5323)
		{
			dontHurtNature = true;
		}
		if (accType == 5095)
		{
			hasLucyTheAxe = true;
		}
	}

	public void UpdatePermanentBoosters()
	{
		if (usedAegisFruit)
		{
			statDefense += 4;
		}
		if (usedGummyWorm)
		{
			fishingSkill += 3;
		}
		if (usedAmbrosia)
		{
			pickSpeed -= 0.05f;
			tileSpeed += 0.05f;
			wallSpeed += 0.05f;
		}
	}

	private bool UpdateEquips_CanItemGrantBenefits(int itemSlot, Item item)
	{
		switch (itemSlot)
		{
		default:
			return true;
		case 0:
			return item.headSlot > -1;
		case 1:
			return item.bodySlot > -1;
		case 2:
			return item.legSlot > -1;
		case 3:
		case 4:
		case 5:
		case 6:
		case 7:
		case 8:
		case 9:
			return item.accessory;
		}
	}

	public void UpdateEquips(int i)
	{
		if (inventory[selectedItem].type == 277 && (!mount.Active || !mount.Cart))
		{
			trident = true;
		}
		bool flag = false;
		for (int j = 0; j < 58; j++)
		{
			int type = inventory[j].type;
			ItemLoader.UpdateInventory(inventory[j], this);
			RefreshInfoAccsFromItemType(inventory[j]);
			RefreshMechanicalAccsFromItemType(type);
			if (type == 4743)
			{
				hasFootball = true;
			}
			if (type == 4131)
			{
				flag = true;
			}
		}
		if (inventory[58].type == 4743)
		{
			hasFootball = true;
		}
		for (int k = 0; k < 10; k++)
		{
			Item item = armor[k];
			if (!item.IsAir && IsItemSlotUnlockedAndUsable(k) && (!item.expertOnly || Main.expertMode) && UpdateEquips_CanItemGrantBenefits(k, item))
			{
				if (item.accessory)
				{
					GrantPrefixBenefits(item);
				}
				GrantArmorBenefits(item);
			}
		}
		if (flag)
		{
			for (int l = 0; l < 40; l++)
			{
				int type2 = bank4.item[l].type;
				if (ItemID.Sets.WorksInVoidBag[type2])
				{
					ItemLoader.UpdateInventory(bank4.item[l], this);
					RefreshInfoAccsFromItemType(bank4.item[l]);
					RefreshMechanicalAccsFromItemType(type2);
				}
			}
		}
		equippedAnyWallSpeedAcc = false;
		equippedAnyTileSpeedAcc = false;
		equippedAnyTileRangeAcc = false;
		if (whoAmI == Main.myPlayer)
		{
			Main.musicBoxNotModifiedByVolume = -1;
		}
		for (int m = 3; m < 10; m++)
		{
			if (IsItemSlotUnlockedAndUsable(m))
			{
				ApplyEquipFunctional(armor[m], hideVisibleAccessory[m]);
			}
		}
		PlayerLoader.UpdateEquips(this);
		if (kbGlove)
		{
			GetKnockback(DamageClass.Melee) *= 2f;
		}
		if (accFishingBobber)
		{
			fishingSkill += 10;
		}
		if (skyStoneEffects)
		{
			lifeRegen += 2;
			statDefense += 4;
			meleeSpeed += 0.1f;
			allDamage += 0.1f;
			allCrit += 2f;
			pickSpeed -= 0.15f;
			minionKB += 0.5f;
		}
		if (dd2Accessory)
		{
			minionDamage += 0.1f;
			maxTurrets++;
		}
		for (int n = 13; n < 20; n++)
		{
			if (IsItemSlotUnlockedAndUsable(n))
			{
				ApplyEquipVanity(n, armor[n]);
			}
		}
		if (wet && ShouldFloatInWater)
		{
			accFlipper = true;
		}
		if (whoAmI == Main.myPlayer && Main.SceneMetrics.HasClock && accWatch < 3)
		{
			accWatch++;
		}
		if (equippedAnyTileSpeedAcc && inventory[selectedItem].createTile != 4)
		{
			tileSpeed += 0.5f;
		}
		if (chiselSpeed)
		{
			pickSpeed -= 0.25f;
		}
		if (equippedAnyWallSpeedAcc)
		{
			wallSpeed += 0.5f;
		}
		if (equippedAnyTileRangeAcc && whoAmI == Main.myPlayer)
		{
			tileRangeX += 3;
			tileRangeY += 2;
		}
		if (!accThirdEye)
		{
			accThirdEyeCounter = 0;
		}
		RefreshInfoAccsFromTeamPlayers();
		if (whoAmI == Main.myPlayer && hasLuck_LuckyHorseshoe)
		{
			equipmentBasedLuckBonus += 0.05f;
		}
		if (whoAmI == Main.myPlayer && hasLuck_LuckyCoin)
		{
			equipmentBasedLuckBonus += 0.05f;
		}
		if (!accDreamCatcher && dpsStarted)
		{
			dpsStarted = false;
			dpsEnd = DateTime.Now;
		}
		if (HeldItem.type == 4760 && ownedProjectileCounts[866] < 1)
		{
			hasRaisableShield = true;
		}
		int num = 0;
		int num2 = 10 + num;
		if (armor[num].type == 5101 || armor[num2].type == 5101)
		{
			DoEyebrellaRainEffect();
			eyebrellaCloud = true;
		}
		if (lastEquipmentBasedLuckBonus != equipmentBasedLuckBonus)
		{
			lastEquipmentBasedLuckBonus = equipmentBasedLuckBonus;
			luckNeedsSync = true;
		}
	}

	public void GrantArmorBenefits(Item armorPiece)
	{
		int type = armorPiece.type;
		RefreshInfoAccsFromItemType(armorPiece);
		RefreshMechanicalAccsFromItemType(type);
		if (armorPiece.type == 3017 || armorPiece.type == 3993)
		{
			flowerBoots = true;
			if (whoAmI == Main.myPlayer)
			{
				DoBootsEffect(DoBootsEffect_PlaceFlowersOnTile);
			}
		}
		if (armorPiece.type == 5001)
		{
			moveSpeed += 0.25f;
			moonLordLegs = true;
		}
		statDefense += armorPiece.defense;
		lifeRegen += armorPiece.lifeRegen;
		if (armorPiece.shieldSlot > 0)
		{
			hasRaisableShield = true;
		}
		switch (armorPiece.type)
		{
		case 3797:
			maxTurrets++;
			manaCost -= 0.1f;
			magicDamage += 0.1f;
			break;
		case 3798:
			magicDamage += 0.1f;
			minionDamage += 0.2f;
			break;
		case 3799:
			minionDamage += 0.1f;
			magicCrit += 20f;
			moveSpeed += 0.2f;
			break;
		case 3800:
			maxTurrets++;
			lifeRegen += 4;
			break;
		case 3801:
			meleeDamage += 0.15f;
			minionDamage += 0.15f;
			break;
		case 3802:
			minionDamage += 0.15f;
			meleeCrit += 15f;
			moveSpeed += 0.15f;
			break;
		case 3806:
			maxTurrets++;
			meleeSpeed += 0.2f;
			break;
		case 3807:
			meleeDamage += 0.2f;
			minionDamage += 0.2f;
			break;
		case 3808:
			minionDamage += 0.1f;
			meleeCrit += 15f;
			moveSpeed += 0.2f;
			break;
		case 3803:
			maxTurrets++;
			rangedCrit += 10f;
			break;
		case 3804:
			rangedDamage += 0.2f;
			minionDamage += 0.2f;
			huntressAmmoCost90 = true;
			break;
		case 3805:
			minionDamage += 0.1f;
			moveSpeed += 0.2f;
			break;
		case 3871:
			maxTurrets += 2;
			meleeDamage += 0.1f;
			minionDamage += 0.1f;
			break;
		case 3872:
			minionDamage += 0.3f;
			lifeRegen += 8;
			break;
		case 3873:
			minionDamage += 0.2f;
			meleeCrit += 20f;
			moveSpeed += 0.2f;
			break;
		case 3874:
			maxTurrets += 2;
			magicDamage += 0.15f;
			minionDamage += 0.15f;
			break;
		case 3875:
			minionDamage += 0.25f;
			magicDamage += 0.1f;
			manaCost -= 0.15f;
			break;
		case 3876:
			minionDamage += 0.2f;
			magicCrit += 25f;
			moveSpeed += 0.2f;
			break;
		case 3877:
			maxTurrets += 2;
			minionDamage += 0.1f;
			rangedCrit += 10f;
			break;
		case 3878:
			minionDamage += 0.25f;
			rangedDamage += 0.25f;
			ammoCost80 = true;
			break;
		case 3879:
			minionDamage += 0.25f;
			rangedCrit += 10f;
			moveSpeed += 0.2f;
			break;
		case 3880:
			maxTurrets += 2;
			minionDamage += 0.2f;
			meleeDamage += 0.2f;
			break;
		case 3881:
			meleeSpeed += 0.2f;
			meleeCrit += 5f;
			minionDamage += 0.2f;
			break;
		case 3882:
			minionDamage += 0.2f;
			meleeCrit += 20f;
			moveSpeed += 0.3f;
			break;
		}
		if (armorPiece.type == 5100)
		{
			SpawnHallucination(armorPiece);
		}
		if (armorPiece.type == 268)
		{
			accDivingHelm = true;
		}
		if (armorPiece.type == 238)
		{
			magicDamage += 0.05f;
			if (Main.tenthAnniversaryWorld)
			{
				maxMinions++;
			}
		}
		if (armorPiece.type == 3770)
		{
			slowFall = true;
		}
		if (armorPiece.type == 4404)
		{
			canFloatInWater = true;
		}
		if (armorPiece.type == 3776)
		{
			magicDamage += 0.15f;
			minionDamage += 0.15f;
		}
		if (armorPiece.type == 3777)
		{
			statManaMax2 += 40;
			minionDamage += 0.1f;
			maxMinions++;
		}
		if (armorPiece.type == 3778)
		{
			statManaMax2 += 40;
			magicDamage += 0.1f;
			maxMinions++;
		}
		if (armorPiece.type == 3212)
		{
			armorPenetration += 5f;
		}
		if (armorPiece.type == 2277)
		{
			allDamage += 0.05f;
			allCrit += 5f;
			meleeSpeed += 0.1f;
			moveSpeed += 0.1f;
		}
		if (armorPiece.type == 2279)
		{
			magicDamage += 0.06f;
			magicCrit += 6f;
			manaCost -= 0.1f;
		}
		if (armorPiece.type == 3109 || armorPiece.type == 4008)
		{
			nightVision = true;
		}
		if (armorPiece.type == 256 || armorPiece.type == 257 || armorPiece.type == 258)
		{
			allCrit += 3f;
		}
		if (armorPiece.type == 3374)
		{
			rangedCrit += 4f;
		}
		if (armorPiece.type == 3375)
		{
			rangedDamage += 0.05f;
		}
		if (armorPiece.type == 3376)
		{
			rangedCrit += 4f;
		}
		if (armorPiece.type == 151 || armorPiece.type == 959 || armorPiece.type == 152 || armorPiece.type == 153)
		{
			rangedDamage += 0.05f;
		}
		if (armorPiece.type == 2275)
		{
			magicDamage += 0.06f;
			magicCrit += 6f;
		}
		if (armorPiece.type == 123 || armorPiece.type == 124 || armorPiece.type == 125)
		{
			magicDamage += 0.09f;
		}
		if (armorPiece.type == 228 || armorPiece.type == 960)
		{
			statManaMax2 += 40;
			magicCrit += 6f;
		}
		if (armorPiece.type == 229 || armorPiece.type == 961)
		{
			statManaMax2 += 20;
			magicDamage += 0.06f;
		}
		if (armorPiece.type == 230 || armorPiece.type == 962)
		{
			statManaMax2 += 20;
			magicCrit += 6f;
		}
		if (armorPiece.type == 100 || armorPiece.type == 101 || armorPiece.type == 102)
		{
			allCrit += 5f;
		}
		if (armorPiece.type == 956 || armorPiece.type == 957 || armorPiece.type == 958)
		{
			allCrit += 5f;
		}
		if (armorPiece.type == 792 || armorPiece.type == 793 || armorPiece.type == 794)
		{
			allDamage += 0.03f;
		}
		if (armorPiece.type == 231)
		{
			meleeCrit += 7f;
		}
		if (armorPiece.type == 232)
		{
			meleeDamage += 0.07f;
		}
		if (armorPiece.type == 233)
		{
			meleeSpeed += 0.07f;
		}
		if (armorPiece.type == 371)
		{
			magicCrit += 9f;
			magicDamage += 0.1f;
			statManaMax2 += 40;
		}
		if (armorPiece.type == 372)
		{
			moveSpeed += 0.1f;
			meleeDamage += 0.15f;
		}
		if (armorPiece.type == 373)
		{
			rangedDamage += 0.1f;
			rangedCrit += 10f;
		}
		if (armorPiece.type == 374)
		{
			allCrit += 5f;
		}
		if (armorPiece.type == 375)
		{
			allDamage += 0.03f;
			moveSpeed += 0.1f;
		}
		if (armorPiece.type == 376)
		{
			magicDamage += 0.15f;
			statManaMax2 += 60;
		}
		if (armorPiece.type == 377)
		{
			meleeCrit += 8f;
			meleeDamage += 0.1f;
		}
		if (armorPiece.type == 378)
		{
			rangedDamage += 0.12f;
			rangedCrit += 7f;
		}
		if (armorPiece.type == 379)
		{
			allDamage += 0.07f;
		}
		if (armorPiece.type == 380)
		{
			allCrit += 10f;
		}
		if (armorPiece.type >= 2367 && armorPiece.type <= 2369)
		{
			fishingSkill += 5;
		}
		if (armorPiece.type == 400)
		{
			magicDamage += 0.12f;
			magicCrit += 12f;
			statManaMax2 += 80;
		}
		if (armorPiece.type == 401)
		{
			meleeCrit += 7f;
			meleeDamage += 0.14f;
		}
		if (armorPiece.type == 402)
		{
			rangedDamage += 0.14f;
			rangedCrit += 10f;
		}
		if (armorPiece.type == 403)
		{
			allDamage += 0.08f;
		}
		if (armorPiece.type == 404)
		{
			allCrit += 7f;
			moveSpeed += 0.05f;
		}
		if (armorPiece.type == 1205)
		{
			meleeDamage += 0.12f;
			meleeSpeed += 0.12f;
		}
		if (armorPiece.type == 1206)
		{
			rangedDamage += 0.09f;
			rangedCrit += 9f;
		}
		if (armorPiece.type == 1207)
		{
			magicDamage += 0.09f;
			magicCrit += 9f;
			statManaMax2 += 60;
		}
		if (armorPiece.type == 1208)
		{
			allDamage += 0.03f;
			allCrit += 2f;
		}
		if (armorPiece.type == 1209)
		{
			allDamage += 0.02f;
			allCrit += 1f;
		}
		if (armorPiece.type == 1210)
		{
			meleeDamage += 0.11f;
			meleeSpeed += 0.11f;
			moveSpeed += 0.07f;
		}
		if (armorPiece.type == 1211)
		{
			rangedCrit += 15f;
			moveSpeed += 0.08f;
		}
		if (armorPiece.type == 1212)
		{
			magicCrit += 18f;
			statManaMax2 += 80;
		}
		if (armorPiece.type == 1213)
		{
			allCrit += 6f;
		}
		if (armorPiece.type == 1214)
		{
			moveSpeed += 0.11f;
			allDamage += 0.08f;
		}
		if (armorPiece.type == 1215)
		{
			meleeDamage += 0.09f;
			meleeCrit += 9f;
			meleeSpeed += 0.09f;
		}
		if (armorPiece.type == 1216)
		{
			rangedDamage += 0.16f;
			rangedCrit += 7f;
		}
		if (armorPiece.type == 1217)
		{
			magicDamage += 0.16f;
			magicCrit += 7f;
			statManaMax2 += 100;
		}
		if (armorPiece.type == 1218)
		{
			allDamage += 0.04f;
			allCrit += 3f;
		}
		if (armorPiece.type == 1219)
		{
			allDamage += 0.03f;
			allCrit += 3f;
			moveSpeed += 0.06f;
		}
		if (armorPiece.type == 558 || armorPiece.type == 4898)
		{
			magicDamage += 0.12f;
			magicCrit += 12f;
			statManaMax2 += 100;
		}
		if (armorPiece.type == 559 || armorPiece.type == 4896)
		{
			meleeCrit += 10f;
			meleeDamage += 0.1f;
			meleeSpeed += 0.1f;
		}
		if (armorPiece.type == 553 || armorPiece.type == 4897)
		{
			rangedDamage += 0.15f;
			rangedCrit += 8f;
		}
		if (armorPiece.type == 4873 || armorPiece.type == 4899)
		{
			minionDamage += 0.1f;
			maxMinions++;
		}
		if (armorPiece.type == 551 || armorPiece.type == 4900)
		{
			allCrit += 7f;
		}
		if (armorPiece.type == 552 || armorPiece.type == 4901)
		{
			allDamage += 0.07f;
			moveSpeed += 0.08f;
		}
		if (armorPiece.type == 4982)
		{
			allCrit += 5f;
			manaCost -= 0.1f;
		}
		if (armorPiece.type == 4983)
		{
			allDamage += 0.05f;
			huntressAmmoCost90 = true;
		}
		if (armorPiece.type == 4984)
		{
			meleeSpeed += 0.1f;
			moveSpeed += 0.2f;
		}
		if (armorPiece.type == 1001)
		{
			meleeDamage += 0.16f;
			meleeCrit += 6f;
		}
		if (armorPiece.type == 1002)
		{
			rangedDamage += 0.16f;
			chloroAmmoCost80 = true;
		}
		if (armorPiece.type == 1003)
		{
			statManaMax2 += 80;
			manaCost -= 0.17f;
			magicDamage += 0.16f;
		}
		if (armorPiece.type == 1004)
		{
			allDamage += 0.05f;
			allCrit += 7f;
		}
		if (armorPiece.type == 1005)
		{
			allCrit += 8f;
			moveSpeed += 0.05f;
		}
		if (armorPiece.type == 2189)
		{
			statManaMax2 += 60;
			manaCost -= 0.13f;
			magicDamage += 0.1f;
			magicCrit += 10f;
		}
		if (armorPiece.type == 1504)
		{
			magicDamage += 0.07f;
			magicCrit += 7f;
		}
		if (armorPiece.type == 1505)
		{
			magicDamage += 0.08f;
			moveSpeed += 0.08f;
		}
		if (armorPiece.type == 1546)
		{
			rangedCrit += 5f;
			arrowDamage *= 1.15f;
		}
		if (armorPiece.type == 1547)
		{
			rangedCrit += 5f;
			bulletDamage *= 1.15f;
		}
		if (armorPiece.type == 1548)
		{
			rangedCrit += 5f;
			specialistDamage *= 1.15f;
		}
		if (armorPiece.type == 1549)
		{
			rangedCrit += 13f;
			rangedDamage += 0.13f;
			ammoCost80 = true;
		}
		if (armorPiece.type == 1550)
		{
			rangedCrit += 7f;
			moveSpeed += 0.12f;
		}
		if (armorPiece.type == 1282)
		{
			statManaMax2 += 20;
			manaCost -= 0.05f;
		}
		if (armorPiece.type == 1283)
		{
			statManaMax2 += 40;
			manaCost -= 0.07f;
		}
		if (armorPiece.type == 1284)
		{
			statManaMax2 += 40;
			manaCost -= 0.09f;
		}
		if (armorPiece.type == 1285)
		{
			statManaMax2 += 60;
			manaCost -= 0.11f;
		}
		if (armorPiece.type == 1286 || armorPiece.type == 4256)
		{
			statManaMax2 += 60;
			manaCost -= 0.13f;
		}
		if (armorPiece.type == 1287)
		{
			statManaMax2 += 80;
			manaCost -= 0.15f;
		}
		if (armorPiece.type == 1316 || armorPiece.type == 1317 || armorPiece.type == 1318)
		{
			aggro += 250;
		}
		if (armorPiece.type == 1316)
		{
			meleeDamage += 0.06f;
		}
		if (armorPiece.type == 1317)
		{
			meleeDamage += 0.08f;
			meleeCrit += 8f;
		}
		if (armorPiece.type == 1318)
		{
			meleeCrit += 4f;
		}
		if (armorPiece.type == 2199 || armorPiece.type == 2202)
		{
			aggro += 250;
		}
		if (armorPiece.type == 2201)
		{
			aggro += 400;
		}
		if (armorPiece.type == 2199)
		{
			meleeDamage += 0.06f;
		}
		if (armorPiece.type == 2200)
		{
			meleeDamage += 0.08f;
			meleeCrit += 8f;
			meleeSpeed += 0.06f;
			moveSpeed += 0.06f;
		}
		if (armorPiece.type == 2201)
		{
			meleeDamage += 0.05f;
			meleeCrit += 5f;
		}
		if (armorPiece.type == 2202)
		{
			meleeSpeed += 0.06f;
			moveSpeed += 0.06f;
		}
		if (armorPiece.type == 684)
		{
			rangedDamage += 0.16f;
			meleeDamage += 0.16f;
		}
		if (armorPiece.type == 685)
		{
			meleeCrit += 11f;
			rangedCrit += 11f;
		}
		if (armorPiece.type == 686)
		{
			moveSpeed += 0.08f;
			meleeSpeed += 0.1f;
		}
		if (armorPiece.type == 5068)
		{
			maxMinions++;
			minionDamage += 0.05f;
		}
		if (armorPiece.type == 2361)
		{
			maxMinions++;
			minionDamage += 0.04f;
		}
		if (armorPiece.type == 2362)
		{
			maxMinions++;
			minionDamage += 0.04f;
		}
		if (armorPiece.type == 2363)
		{
			minionDamage += 0.05f;
		}
		if (armorPiece.type == 3266)
		{
			minionDamage += 0.08f;
		}
		if (armorPiece.type == 3267)
		{
			maxMinions++;
		}
		if (armorPiece.type == 3268)
		{
			minionDamage += 0.08f;
		}
		if (armorPiece.type == 410)
		{
			pickSpeed -= 0.1f;
		}
		if (armorPiece.type == 411)
		{
			pickSpeed -= 0.1f;
		}
		if (armorPiece.type >= 1158 && armorPiece.type <= 1161)
		{
			maxMinions++;
		}
		if (armorPiece.type == 1159)
		{
			whipRangeMultiplier += 0.1f;
		}
		if (armorPiece.type >= 1159 && armorPiece.type <= 1161)
		{
			minionDamage += 0.1f;
		}
		if (armorPiece.type >= 2370 && armorPiece.type <= 2371)
		{
			minionDamage += 0.05f;
			maxMinions++;
		}
		if (armorPiece.type == 2372)
		{
			minionDamage += 0.06f;
			maxMinions++;
		}
		if (armorPiece.type == 3381)
		{
			maxMinions++;
			maxTurrets++;
			minionDamage += 0.22f;
		}
		if (armorPiece.type == 3382 || armorPiece.type == 3383)
		{
			maxMinions += 2;
			whipRangeMultiplier += 0.15f;
			minionDamage += 0.22f;
		}
		if (armorPiece.type == 2763)
		{
			aggro += 300;
			meleeCrit += 26f;
			lifeRegen += 2;
		}
		if (armorPiece.type == 2764)
		{
			aggro += 300;
			meleeDamage += 0.29f;
			lifeRegen += 2;
		}
		if (armorPiece.type == 2765)
		{
			aggro += 300;
			meleeSpeed += 0.15f;
			moveSpeed += 0.15f;
			lifeRegen += 2;
		}
		if (armorPiece.type == 2757)
		{
			rangedCrit += 7f;
			rangedDamage += 0.16f;
		}
		if (armorPiece.type == 2758)
		{
			ammoCost75 = true;
			rangedCrit += 12f;
			rangedDamage += 0.12f;
		}
		if (armorPiece.type == 2759)
		{
			rangedCrit += 8f;
			rangedDamage += 0.08f;
			moveSpeed += 0.1f;
		}
		if (armorPiece.type == 2760)
		{
			statManaMax2 += 60;
			manaCost -= 0.15f;
			magicCrit += 7f;
			magicDamage += 0.07f;
		}
		if (armorPiece.type == 2761)
		{
			magicDamage += 0.09f;
			magicCrit += 9f;
		}
		if (armorPiece.type == 2762)
		{
			moveSpeed += 0.1f;
			magicDamage += 0.1f;
		}
		if (armorPiece.type == 1832)
		{
			maxMinions++;
			minionDamage += 0.11f;
		}
		if (armorPiece.type == 1833)
		{
			maxMinions += 2;
			minionDamage += 0.11f;
		}
		if (armorPiece.type == 1834)
		{
			moveSpeed += 0.2f;
			maxMinions++;
			minionDamage += 0.11f;
		}
		if (armorPiece.type == 4256 || (armorPiece.type >= 1282 && armorPiece.type <= 1287))
		{
			hasGemRobe = true;
		}
		ItemLoader.UpdateEquip(armorPiece, this);
	}

	public void GrantPrefixBenefits(Item item)
	{
		if (item.prefix == 62)
		{
			++statDefense;
		}
		if (item.prefix == 63)
		{
			statDefense += 2;
		}
		if (item.prefix == 64)
		{
			statDefense += 3;
		}
		if (item.prefix == 65)
		{
			statDefense += 4;
		}
		if (item.prefix == 66)
		{
			statManaMax2 += 20;
		}
		if (item.prefix == 67)
		{
			allCrit += 2f;
		}
		if (item.prefix == 68)
		{
			allCrit += 4f;
		}
		if (item.prefix == 69)
		{
			allDamage += 0.01f;
		}
		if (item.prefix == 70)
		{
			allDamage += 0.02f;
		}
		if (item.prefix == 71)
		{
			allDamage += 0.03f;
		}
		if (item.prefix == 72)
		{
			allDamage += 0.04f;
		}
		if (item.prefix == 73)
		{
			moveSpeed += 0.01f;
		}
		if (item.prefix == 74)
		{
			moveSpeed += 0.02f;
		}
		if (item.prefix == 75)
		{
			moveSpeed += 0.03f;
		}
		if (item.prefix == 76)
		{
			moveSpeed += 0.04f;
		}
		if (item.prefix == 77)
		{
			meleeSpeed += 0.01f;
		}
		if (item.prefix == 78)
		{
			meleeSpeed += 0.02f;
		}
		if (item.prefix == 79)
		{
			meleeSpeed += 0.03f;
		}
		if (item.prefix == 80)
		{
			meleeSpeed += 0.04f;
		}
		PrefixLoader.ApplyAccessoryEffects(this, item);
	}

	private void SpawnHallucination(Item item)
	{
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		if (whoAmI != Main.myPlayer)
		{
			return;
		}
		insanityShadowCooldown = Utils.Clamp(insanityShadowCooldown - 1, 0, 100);
		if (insanityShadowCooldown > 0)
		{
			return;
		}
		insanityShadowCooldown = Main.rand.Next(20, 101);
		float num = 500f;
		int damage = 18;
		_hallucinationCandidates.Clear();
		for (int i = 0; i < 200; i++)
		{
			NPC nPC = Main.npc[i];
			if (nPC.CanBeChasedBy(this) && !(Distance(nPC.Center) > num) && Collision.CanHitLine(position, width, height, nPC.position, nPC.width, nPC.height))
			{
				_hallucinationCandidates.Add(nPC);
			}
		}
		if (_hallucinationCandidates.Count != 0)
		{
			Projectile.RandomizeInsanityShadowFor(Main.rand.NextFromCollection(_hallucinationCandidates), isHostile: false, out var spawnposition, out var spawnvelocity, out var ai, out var ai2);
			Projectile.NewProjectile(new EntitySource_ItemUse(this, item), spawnposition, spawnvelocity, 964, damage, 0f, whoAmI, ai, ai2);
		}
	}

	public void DoBootsEffect(Utils.TileActionAttempt theEffectMethod)
	{
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		if (miscCounter % 2 == 0 && velocity.Y == 0f && grappling[0] == -1 && velocity.X != 0f)
		{
			int x = (int)base.Center.X / 16;
			int y = (int)(position.Y + (float)height - 1f) / 16;
			theEffectMethod(x, y);
		}
	}

	public bool DoBootsEffect_PlaceFlamesOnTile(int X, int Y)
	{
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		Tile tile = Main.tile[X, Y + 1];
		if (tile == null || !tile.active() || tile.liquid > 0 || !WorldGen.SolidTileAllowBottomSlope(X, Y + 1))
		{
			return false;
		}
		ParticleOrchestrator.RequestParticleSpawn(clientOnly: true, ParticleOrchestraType.FlameWaders, new ParticleOrchestraSettings
		{
			PositionInWorld = new Vector2((float)(X * 16 + 8), (float)(Y * 16 + 16))
		}, whoAmI);
		return true;
	}

	public bool DoBootsEffect_PlaceFlowersOnTile(int X, int Y)
	{
		Tile tile = Main.tile[X, Y];
		if (tile == null)
		{
			return false;
		}
		if (!tile.active() && tile.liquid == 0 && Main.tile[X, Y + 1] != null && WorldGen.SolidTile(X, Y + 1))
		{
			tile.frameY = 0;
			tile.slope(0);
			tile.halfBrick(halfBrick: false);
			if (Main.tile[X, Y + 1].type == 2 || Main.tile[X, Y + 1].type == 477)
			{
				int num = Main.rand.NextFromList<int>(6, 7, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 24, 27, 30, 33, 36, 39, 42);
				switch (num)
				{
				case 21:
				case 24:
				case 27:
				case 30:
				case 33:
				case 36:
				case 39:
				case 42:
					num += Main.rand.Next(3);
					break;
				}
				tile.active(active: true);
				tile.type = 3;
				tile.frameX = (short)(num * 18);
				tile.CopyPaintAndCoating(Main.tile[X, Y + 1]);
				if (Main.netMode == 1)
				{
					NetMessage.SendTileSquare(-1, X, Y);
				}
				return true;
			}
			if (Main.tile[X, Y + 1].type == 109 || Main.tile[X, Y + 1].type == 492)
			{
				if (Main.rand.Next(2) == 0)
				{
					tile.active(active: true);
					tile.type = 110;
					tile.frameX = (short)(18 * Main.rand.Next(4, 7));
					tile.CopyPaintAndCoating(Main.tile[X, Y + 1]);
					while (tile.frameX == 90)
					{
						tile.frameX = (short)(18 * Main.rand.Next(4, 7));
					}
				}
				else
				{
					tile.active(active: true);
					tile.type = 113;
					tile.frameX = (short)(18 * Main.rand.Next(2, 8));
					tile.CopyPaintAndCoating(Main.tile[X, Y + 1]);
					while (tile.frameX == 90)
					{
						tile.frameX = (short)(18 * Main.rand.Next(2, 8));
					}
				}
				if (Main.netMode == 1)
				{
					NetMessage.SendTileSquare(-1, X, Y);
				}
				return true;
			}
			if (Main.tile[X, Y + 1].type == 60)
			{
				tile.active(active: true);
				tile.type = 74;
				tile.frameX = (short)(18 * Main.rand.Next(9, 17));
				tile.CopyPaintAndCoating(Main.tile[X, Y + 1]);
				if (Main.netMode == 1)
				{
					NetMessage.SendTileSquare(-1, X, Y);
				}
				return true;
			}
			if (Main.tile[X, Y + 1].type == 633)
			{
				tile.active(active: true);
				tile.type = 637;
				tile.frameX = (short)(18 * Main.rand.Next(6, 11));
				tile.CopyPaintAndCoating(Main.tile[X, Y + 1]);
				if (Main.netMode == 1)
				{
					NetMessage.SendTileSquare(-1, X, Y);
				}
				return true;
			}
		}
		return false;
	}

	private void ApplyEquipVanity(int itemSlot, Item currentItem)
	{
		ApplyEquipVanity(currentItem);
	}

	public void ApplyEquipVanity(Item currentItem)
	{
		int type = currentItem.type;
		if (currentItem.wingSlot > 0)
		{
			wings = currentItem.wingSlot;
		}
		if (type == 861 || type == 3110 || type == 485)
		{
			hideWolf = false;
			forceWerewolf = true;
		}
		switch (type)
		{
		case 5452:
			remoteVisionForDrone = true;
			break;
		case 3538:
			stardustMonolithShader = true;
			break;
		case 3537:
			nebulaMonolithShader = true;
			break;
		case 3536:
			vortexMonolithShader = true;
			break;
		case 3539:
			solarMonolithShader = true;
			break;
		case 4318:
			moonLordMonolithShader = true;
			break;
		case 4054:
			bloodMoonMonolithShader = true;
			break;
		case 5345:
			CanSeeInvisibleBlocks = true;
			break;
		case 5347:
			shimmerMonolithShader = true;
			break;
		}
		if (type == 5113)
		{
			dontStarveShader = !dontStarveShader;
		}
		if (((wet && !lavaWet && (!mount.Active || !mount.IsConsideredASlimeMount)) || !forceWerewolf) && (type == 861 || type == 3110 || type == 497))
		{
			hideMerman = false;
			forceMerman = true;
		}
		if ((!mount.Active || mount.Type != 47) && (type == 4822 || type == 4874))
		{
			DoBootsEffect(DoBootsEffect_PlaceFlamesOnTile);
		}
		if (Main.myPlayer == whoAmI)
		{
			ApplyMusicBox(currentItem);
		}
		UpdateBootVisualEffects(currentItem);
		UpdateFishingBobber(currentItem);
		ItemLoader.UpdateVanity(currentItem, this);
	}

	private void DoEyebrellaRainEffect()
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		if (Main.netMode == 2 || Main.dedServ || Main.rand.Next(4) != 0)
		{
			return;
		}
		Vector2 val = MountedCenter - new Vector2(0f, (float)height * 0.5f) + new Vector2((-0.5f + Main.rand.NextFloat()) * (float)(width + 18), -30f);
		int x = (int)(val.X / 16f);
		int y = (int)(val.Y / 16f);
		if (WorldGen.InWorld(x, y))
		{
			Tile tile = Main.tile[x, y];
			if (tile != null && !WorldGen.SolidTile3(tile) && tile.liquid <= 0)
			{
				Vector2 val2 = default(Vector2);
				((Vector2)(ref val2))..ctor(Main.windSpeedCurrent * 3f, 9f);
				Rain.NewRainForced(val, val2);
			}
		}
	}

	public WingStats GetWingStats(int wingID)
	{
		if (wingID <= 0 || wingID >= ArmorIDs.Wing.Sets.Stats.Length)
		{
			return default(WingStats);
		}
		return ArmorIDs.Wing.Sets.Stats[wingID];
	}

	public void ApplyEquipFunctional(Item currentItem, bool hideVisual)
	{
		//IL_04a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_04ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_04c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_04c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_04cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_04d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_04d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_04e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_04e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0512: Unknown result type (might be due to invalid IL or missing references)
		//IL_0518: Unknown result type (might be due to invalid IL or missing references)
		//IL_14bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_14cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_154e: Unknown result type (might be due to invalid IL or missing references)
		//IL_155d: Unknown result type (might be due to invalid IL or missing references)
		//IL_14f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_1505: Unknown result type (might be due to invalid IL or missing references)
		//IL_15ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_15fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_1588: Unknown result type (might be due to invalid IL or missing references)
		//IL_1597: Unknown result type (might be due to invalid IL or missing references)
		//IL_1628: Unknown result type (might be due to invalid IL or missing references)
		//IL_1637: Unknown result type (might be due to invalid IL or missing references)
		//IL_20c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_20cf: Unknown result type (might be due to invalid IL or missing references)
		int num = 0;
		bool[] array = new bool[1] { hideVisual };
		if ((currentItem.expertOnly && !Main.expertMode) || (currentItem.masterOnly && !Main.masterMode))
		{
			return;
		}
		if (currentItem.type == 3810 || currentItem.type == 3809 || currentItem.type == 3812 || currentItem.type == 3811)
		{
			dd2Accessory = true;
		}
		if (!array[num])
		{
			UpdateBootVisualEffects(currentItem);
			UpdateFishingBobber(currentItem);
		}
		switch (currentItem.type)
		{
		case 4056:
			chiselSpeed = true;
			break;
		case 3990:
			accRunSpeed = 6f;
			autoJump = true;
			jumpSpeedBoost += 1.6f;
			extraFall += 10;
			break;
		case 3991:
			manaFlower = true;
			manaCost -= 0.08f;
			aggro -= 400;
			break;
		case 3992:
			kbGlove = true;
			autoReuseGlove = true;
			meleeScaleGlove = true;
			meleeSpeed += 0.12f;
			aggro += 400;
			break;
		case 3993:
			accRunSpeed = 6f;
			rocketBoots = (vanityRocketBoots = 2);
			break;
		case 4055:
			accRunSpeed = 6f;
			desertBoots = true;
			break;
		case 3994:
			autoJump = true;
			jumpSpeedBoost += 1.6f;
			extraFall += 10;
			accFlipper = true;
			break;
		case 3995:
			autoJump = true;
			jumpSpeedBoost += 1.6f;
			extraFall += 10;
			accFlipper = true;
			spikedBoots += 2;
			break;
		case 3996:
			autoJump = true;
			jumpSpeedBoost += 1.6f;
			extraFall += 10;
			spikedBoots += 2;
			break;
		case 3998:
			aggro += 400;
			break;
		case 4038:
			fireWalk = true;
			break;
		case 4003:
			fireWalk = true;
			lavaRose = true;
			break;
		case 4000:
			manaFlower = true;
			manaCost -= 0.08f;
			manaMagnet = true;
			break;
		case 4001:
			manaFlower = true;
			manaCost -= 0.08f;
			starCloakItem = currentItem;
			starCloakItem_manaCloakOverrideItem = currentItem;
			break;
		case 4002:
			magicQuiver = true;
			arrowDamageAdditiveStack += 0.1f;
			hasMoltenQuiver = true;
			break;
		case 4004:
			fireWalk = true;
			lavaRose = true;
			break;
		case 3999:
			fireWalk = true;
			break;
		case 4005:
			rangedCrit += 10f;
			rangedDamage += 0.1f;
			aggro -= 400;
			break;
		case 4006:
			aggro -= 400;
			magicQuiver = true;
			arrowDamageAdditiveStack += 0.1f;
			break;
		case 4007:
			honeyCombItem = currentItem;
			armorPenetration += 5f;
			break;
		case 4341:
		case 5126:
			portableStoolInfo.SetStats(26, 26, 26);
			break;
		case 4409:
			CanSeeInvisibleBlocks = true;
			break;
		case 5010:
			treasureMagnet = true;
			break;
		case 3245:
			boneGloveItem = currentItem;
			break;
		case 5107:
			hasMagiluminescence = true;
			MountedCenter.ToTileCoordinates();
			DelegateMethods.v3_1 = new Vector3(0.9f, 0.8f, 0.5f);
			Utils.PlotTileLine(base.Center, base.Center + velocity * 6f, 20f, DelegateMethods.CastLightOpen);
			Utils.PlotTileLine(base.Left, base.Right, 20f, DelegateMethods.CastLightOpen);
			break;
		}
		if (currentItem.type == 3015)
		{
			aggro -= 400;
			allDamage += 0.05f;
			allCrit += 5f;
		}
		if (currentItem.type == 3016)
		{
			aggro += 400;
		}
		if (currentItem.type == 2373)
		{
			accFishingLine = true;
		}
		if (currentItem.type == 2374)
		{
			fishingSkill += 10;
		}
		if (currentItem.type == 5139 || currentItem.type == 5144 || currentItem.type == 5142 || currentItem.type == 5141 || currentItem.type == 5146 || currentItem.type == 5140 || currentItem.type == 5145 || currentItem.type == 5143)
		{
			accFishingBobber = true;
		}
		if (currentItem.type == 2375)
		{
			accTackleBox = true;
		}
		if (currentItem.type == 4881)
		{
			accLavaFishing = true;
		}
		if (currentItem.type == 3721)
		{
			accFishingLine = true;
			accTackleBox = true;
			fishingSkill += 10;
		}
		if (currentItem.type == 5064)
		{
			accFishingLine = true;
			accTackleBox = true;
			fishingSkill += 10;
			accLavaFishing = true;
		}
		if (currentItem.type == 3090)
		{
			npcTypeNoAggro[1] = true;
			npcTypeNoAggro[16] = true;
			npcTypeNoAggro[59] = true;
			npcTypeNoAggro[71] = true;
			npcTypeNoAggro[81] = true;
			npcTypeNoAggro[138] = true;
			npcTypeNoAggro[121] = true;
			npcTypeNoAggro[122] = true;
			npcTypeNoAggro[141] = true;
			npcTypeNoAggro[147] = true;
			npcTypeNoAggro[183] = true;
			npcTypeNoAggro[184] = true;
			npcTypeNoAggro[204] = true;
			npcTypeNoAggro[225] = true;
			npcTypeNoAggro[244] = true;
			npcTypeNoAggro[302] = true;
			npcTypeNoAggro[333] = true;
			npcTypeNoAggro[335] = true;
			npcTypeNoAggro[334] = true;
			npcTypeNoAggro[336] = true;
			npcTypeNoAggro[537] = true;
			npcTypeNoAggro[676] = true;
			npcTypeNoAggro[667] = true;
		}
		if (currentItem.stringColor > 0)
		{
			yoyoString = true;
		}
		if (currentItem.type == 3366)
		{
			counterWeight = 556 + Main.rand.Next(6);
			yoyoGlove = true;
			yoyoString = true;
		}
		if (currentItem.type >= 3309 && currentItem.type <= 3314)
		{
			counterWeight = 556 + currentItem.type - 3309;
		}
		if (currentItem.type == 3334)
		{
			yoyoGlove = true;
		}
		if (currentItem.type == 3337)
		{
			shinyStone = true;
		}
		if (currentItem.type == 4989)
		{
			empressBrooch = true;
			moveSpeed += 0.075f;
		}
		if (currentItem.type == 3336)
		{
			SporeSac(currentItem);
			sporeSac = true;
		}
		if (currentItem.type == 4987)
		{
			VolatileGelatin(currentItem);
			volatileGelatin = true;
		}
		switch (currentItem.type)
		{
		case 3538:
			stardustMonolithShader = true;
			break;
		case 3537:
			nebulaMonolithShader = true;
			break;
		case 3536:
			vortexMonolithShader = true;
			break;
		case 3539:
			solarMonolithShader = true;
			break;
		case 4318:
			moonLordMonolithShader = true;
			break;
		case 4054:
			bloodMoonMonolithShader = true;
			break;
		case 5345:
			CanSeeInvisibleBlocks = true;
			break;
		case 5347:
			shimmerMonolithShader = true;
			break;
		}
		if (currentItem.type == 5113)
		{
			dontStarveShader = !dontStarveShader;
		}
		if (currentItem.type == 2423)
		{
			autoJump = true;
			jumpSpeedBoost += 1.6f;
			extraFall += 10;
		}
		if (currentItem.type == 857)
		{
			hasJumpOption_Sandstorm = true;
		}
		if (currentItem.type == 983)
		{
			hasJumpOption_Sandstorm = true;
			jumpBoost = true;
		}
		if (currentItem.type == 987)
		{
			hasJumpOption_Blizzard = true;
		}
		if (currentItem.type == 1163)
		{
			hasJumpOption_Blizzard = true;
			jumpBoost = true;
		}
		if (currentItem.type == 1724)
		{
			hasJumpOption_Fart = true;
		}
		if (currentItem.type == 1863)
		{
			hasJumpOption_Fart = true;
			jumpBoost = true;
		}
		if (currentItem.type == 1164)
		{
			hasJumpOption_Cloud = true;
			hasJumpOption_Sandstorm = true;
			hasJumpOption_Blizzard = true;
			jumpBoost = true;
		}
		if (currentItem.type == 5331)
		{
			hasJumpOption_Cloud = true;
			hasJumpOption_Sandstorm = true;
			hasJumpOption_Blizzard = true;
			jumpBoost = true;
			noFallDmg = true;
			hasLuck_LuckyHorseshoe = true;
		}
		if (currentItem.type == 1250)
		{
			jumpBoost = true;
			hasJumpOption_Cloud = true;
			noFallDmg = true;
			hasLuck_LuckyHorseshoe = true;
		}
		if (currentItem.type == 1252)
		{
			hasJumpOption_Sandstorm = true;
			jumpBoost = true;
			noFallDmg = true;
			hasLuck_LuckyHorseshoe = true;
		}
		if (currentItem.type == 1251)
		{
			hasJumpOption_Blizzard = true;
			jumpBoost = true;
			noFallDmg = true;
			hasLuck_LuckyHorseshoe = true;
		}
		if (currentItem.type == 3250)
		{
			hasJumpOption_Fart = true;
			jumpBoost = true;
			noFallDmg = true;
			hasLuck_LuckyHorseshoe = true;
		}
		if (currentItem.type == 3252)
		{
			hasJumpOption_Sail = true;
			jumpBoost = true;
			noFallDmg = true;
			hasLuck_LuckyHorseshoe = true;
		}
		if (currentItem.type == 3251)
		{
			jumpBoost = true;
			honeyCombItem = currentItem;
			noFallDmg = true;
			hasLuck_LuckyHorseshoe = true;
		}
		if (currentItem.type == 1249)
		{
			jumpBoost = true;
			honeyCombItem = currentItem;
		}
		if (currentItem.type == 3241)
		{
			jumpBoost = true;
			hasJumpOption_Sail = true;
		}
		if ((currentItem.type == 1253 || currentItem.type == 3997) && (double)statLife <= (double)statLifeMax2 * 0.5)
		{
			AddBuff(62, 5);
		}
		if (currentItem.type == 1290)
		{
			panic = true;
		}
		if ((currentItem.type == 1300 || currentItem.type == 1858 || currentItem.type == 4005) && (inventory[selectedItem].useAmmo == AmmoID.Bullet || inventory[selectedItem].useAmmo == AmmoID.CandyCorn || inventory[selectedItem].useAmmo == AmmoID.Stake || inventory[selectedItem].useAmmo == 23 || inventory[selectedItem].useAmmo == AmmoID.Solution))
		{
			scope = true;
		}
		if (currentItem.type == 1858)
		{
			rangedCrit += 10f;
			rangedDamage += 0.1f;
		}
		if (currentItem.type == 1301)
		{
			allDamage += 0.1f;
			allCrit += 8f;
		}
		if (currentItem.type == 111)
		{
			statManaMax2 += 20;
		}
		if (currentItem.type == 982)
		{
			statManaMax2 += 20;
			manaRegenDelayBonus += 1f;
			manaRegenBonus += 25;
		}
		if (currentItem.type == 1595)
		{
			statManaMax2 += 20;
			magicCuffs = true;
		}
		if (currentItem.type == 2219)
		{
			manaMagnet = true;
		}
		if (currentItem.type == 2220)
		{
			manaMagnet = true;
			magicDamage += 0.15f;
		}
		if (currentItem.type == 2221)
		{
			manaMagnet = true;
			statManaMax2 += 20;
			magicCuffs = true;
		}
		if (whoAmI == Main.myPlayer && currentItem.type == 1923)
		{
			tileRangeX++;
			tileRangeY++;
		}
		if (currentItem.type == 1247)
		{
			starCloakItem = currentItem;
			honeyCombItem = currentItem;
			starCloakItem_beeCloakOverrideItem = currentItem;
		}
		if (currentItem.type == 1248)
		{
			allCrit += 10f;
		}
		if (currentItem.type == 854)
		{
			discountEquipped = true;
		}
		if (currentItem.type == 855)
		{
			hasLuckyCoin = true;
			hasLuck_LuckyCoin = true;
		}
		if (currentItem.type == 3033)
		{
			goldRing = true;
		}
		if (currentItem.type == 3034)
		{
			goldRing = true;
			hasLuckyCoin = true;
			hasLuck_LuckyCoin = true;
		}
		if (currentItem.type == 3035)
		{
			goldRing = true;
			hasLuckyCoin = true;
			hasLuck_LuckyCoin = true;
			discountEquipped = true;
		}
		if (currentItem.type == 53)
		{
			hasJumpOption_Cloud = true;
		}
		if (currentItem.type == 3201)
		{
			hasJumpOption_Sail = true;
		}
		if (currentItem.type == 54)
		{
			accRunSpeed = 6f;
		}
		if (currentItem.type == 3068)
		{
			cordage = true;
		}
		if (currentItem.type == 1579)
		{
			accRunSpeed = 6f;
		}
		if (currentItem.type == 3200)
		{
			accRunSpeed = 6f;
		}
		if (currentItem.type == 128)
		{
			rocketBoots = (vanityRocketBoots = 1);
		}
		if (currentItem.type == 156)
		{
			noKnockback = true;
		}
		if (currentItem.type == 158)
		{
			noFallDmg = true;
			hasLuck_LuckyHorseshoe = true;
		}
		if (currentItem.type == 934)
		{
			carpet = true;
		}
		if (currentItem.type == 953)
		{
			spikedBoots++;
		}
		if (currentItem.type == 975)
		{
			spikedBoots++;
		}
		if (currentItem.type == 976)
		{
			spikedBoots += 2;
		}
		if (currentItem.type == 977)
		{
			dashType = 1;
		}
		if (currentItem.type == 3097)
		{
			dashType = 2;
		}
		if (currentItem.type == 963)
		{
			blackBelt = true;
		}
		if (currentItem.type == 984)
		{
			blackBelt = true;
			dashType = 1;
			spikedBoots = 2;
		}
		if (currentItem.type == 1131)
		{
			gravControl2 = true;
		}
		if (currentItem.type == 1132)
		{
			honeyCombItem = currentItem;
		}
		if (currentItem.type == 1578)
		{
			honeyCombItem = currentItem;
			panic = true;
		}
		if (currentItem.type == 3224)
		{
			endurance += 0.17f;
		}
		if (currentItem.type == 3223)
		{
			brainOfConfusionItem = currentItem;
		}
		if (currentItem.type == 950)
		{
			iceSkate = true;
		}
		if (currentItem.type == 159)
		{
			jumpBoost = true;
		}
		if (currentItem.type == 3225)
		{
			jumpBoost = true;
		}
		if (currentItem.type == 187)
		{
			accFlipper = true;
		}
		if (currentItem.type == 211)
		{
			autoReuseGlove = true;
			meleeSpeed += 0.12f;
		}
		if (currentItem.type == 223)
		{
			manaCost -= 0.06f;
		}
		if (currentItem.type == 285)
		{
			moveSpeed += 0.05f;
		}
		if (currentItem.type == 212)
		{
			moveSpeed += 0.1f;
		}
		if (currentItem.type == 267)
		{
			killGuide = true;
		}
		if (currentItem.type == 1307)
		{
			killClothier = true;
		}
		if (currentItem.type == 193)
		{
			fireWalk = true;
		}
		if (currentItem.type == 861)
		{
			accMerman = true;
			wolfAcc = true;
			if (array[num])
			{
				hideMerman = true;
				hideWolf = true;
			}
		}
		if (currentItem.type == 862)
		{
			starCloakItem = currentItem;
			longInvince = true;
			starCloakItem_starVeilOverrideItem = currentItem;
		}
		if (currentItem.type == 860)
		{
			pStone = true;
		}
		if (currentItem.type == 863)
		{
			waterWalk2 = true;
		}
		if (currentItem.type == 907)
		{
			waterWalk2 = true;
			fireWalk = true;
		}
		if (currentItem.type == 5044)
		{
			hasCreditsSceneMusicBox = true;
		}
		if (currentItem.type == 908 || currentItem.type == 5000)
		{
			waterWalk = true;
			fireWalk = true;
			lavaMax += 420;
			lavaRose = true;
		}
		if ((!mount.Active || mount.Type != 47) && !array[num] && (currentItem.type == 4822 || currentItem.type == 4874))
		{
			DoBootsEffect(DoBootsEffect_PlaceFlamesOnTile);
		}
		if (currentItem.type == 906 || currentItem.type == 4038 || currentItem.type == 3999 || currentItem.type == 4003)
		{
			lavaMax += 420;
		}
		if (currentItem.type == 485)
		{
			wolfAcc = true;
			if (array[num])
			{
				hideWolf = true;
			}
		}
		if (currentItem.type == 486)
		{
			rulerLine = true;
		}
		if (currentItem.type == 2799)
		{
			rulerGrid = true;
		}
		if (currentItem.type == 394)
		{
			accFlipper = true;
			accDivingHelm = true;
		}
		if (currentItem.type == 396)
		{
			noFallDmg = true;
			fireWalk = true;
			hasLuck_LuckyHorseshoe = true;
		}
		if (currentItem.type == 397)
		{
			noKnockback = true;
			fireWalk = true;
		}
		if (currentItem.type == 399)
		{
			jumpBoost = true;
			hasJumpOption_Cloud = true;
		}
		if (currentItem.type == 405)
		{
			accRunSpeed = 6f;
			rocketBoots = (vanityRocketBoots = 2);
		}
		if (currentItem.type == 1303)
		{
			if (!wet)
			{
				Lighting.AddLight((int)base.Center.X / 16, (int)base.Center.Y / 16, 0.225f, 0.05f, 0.15f);
			}
			if (wet)
			{
				Lighting.AddLight((int)base.Center.X / 16, (int)base.Center.Y / 16, 1.8f, 0.4f, 1.2f);
			}
		}
		if (currentItem.type == 1860)
		{
			accFlipper = true;
			accDivingHelm = true;
			if (!wet)
			{
				Lighting.AddLight((int)base.Center.X / 16, (int)base.Center.Y / 16, 0.225f, 0.05f, 0.15f);
			}
			if (wet)
			{
				Lighting.AddLight((int)base.Center.X / 16, (int)base.Center.Y / 16, 1.8f, 0.4f, 1.2f);
			}
		}
		if (currentItem.type == 1861)
		{
			arcticDivingGear = true;
			accFlipper = true;
			accDivingHelm = true;
			iceSkate = true;
			if (!wet)
			{
				Lighting.AddLight((int)base.Center.X / 16, (int)base.Center.Y / 16, 0.05f, 0.15f, 0.225f);
			}
			if (wet)
			{
				Lighting.AddLight((int)base.Center.X / 16, (int)base.Center.Y / 16, 0.4f, 1.2f, 1.8f);
			}
		}
		if (currentItem.type == 2214)
		{
			equippedAnyTileSpeedAcc = true;
		}
		if (currentItem.type == 2215)
		{
			equippedAnyTileRangeAcc = true;
		}
		if (currentItem.type == 2216)
		{
			autoPaint = true;
		}
		if (currentItem.type == 2217)
		{
			equippedAnyWallSpeedAcc = true;
		}
		if (currentItem.type == 3061)
		{
			equippedAnyWallSpeedAcc = true;
			equippedAnyTileSpeedAcc = true;
			autoPaint = true;
			equippedAnyTileRangeAcc = true;
		}
		if (currentItem.type == 5126)
		{
			equippedAnyWallSpeedAcc = true;
			equippedAnyTileSpeedAcc = true;
			autoPaint = true;
			equippedAnyTileRangeAcc = true;
			treasureMagnet = true;
			chiselSpeed = true;
		}
		if (currentItem.type == 3624)
		{
			autoActuator = true;
		}
		if (currentItem.type == 897)
		{
			kbGlove = true;
			autoReuseGlove = true;
			meleeScaleGlove = true;
			meleeSpeed += 0.12f;
		}
		if (currentItem.type == 1343)
		{
			kbGlove = true;
			autoReuseGlove = true;
			meleeScaleGlove = true;
			meleeSpeed += 0.12f;
			meleeDamage += 0.12f;
			magmaStone = true;
		}
		if (currentItem.type == 1167)
		{
			minionKB += 2f;
			minionDamage += 0.15f;
		}
		if (currentItem.type == 1864)
		{
			minionKB += 2f;
			minionDamage += 0.15f;
			maxMinions++;
		}
		if (currentItem.type == 1845)
		{
			minionDamage += 0.1f;
			maxMinions++;
		}
		if (currentItem.type == 1321)
		{
			magicQuiver = true;
			arrowDamageAdditiveStack += 0.1f;
		}
		if (currentItem.type == 1322)
		{
			magmaStone = true;
		}
		if (currentItem.type == 1323)
		{
			lavaRose = true;
		}
		if (currentItem.type == 3333)
		{
			strongBees = true;
		}
		if (currentItem.type == 938 || currentItem.type == 3997 || currentItem.type == 3998)
		{
			noKnockback = true;
			if ((float)statLife > (float)statLifeMax2 * 0.25f)
			{
				hasPaladinShield = true;
				if (whoAmI != Main.myPlayer && miscCounter % 10 == 0)
				{
					int myPlayer = Main.myPlayer;
					if (Main.player[myPlayer].team == team && team != 0)
					{
						float num2 = position.X - Main.player[myPlayer].position.X;
						float num3 = position.Y - Main.player[myPlayer].position.Y;
						if ((float)Math.Sqrt(num2 * num2 + num3 * num3) < 800f)
						{
							Main.player[myPlayer].AddBuff(43, 20);
						}
					}
				}
			}
		}
		if (currentItem.type == 936)
		{
			kbGlove = true;
			autoReuseGlove = true;
			meleeScaleGlove = true;
			meleeSpeed += 0.12f;
			meleeDamage += 0.12f;
		}
		if (currentItem.type == 898)
		{
			accRunSpeed = 6.75f;
			rocketBoots = (vanityRocketBoots = 2);
			moveSpeed += 0.08f;
		}
		if (currentItem.type == 1862)
		{
			accRunSpeed = 6.75f;
			rocketBoots = (vanityRocketBoots = 3);
			moveSpeed += 0.08f;
			iceSkate = true;
		}
		if (currentItem.type == 5000)
		{
			accRunSpeed = 6.75f;
			rocketBoots = (vanityRocketBoots = 4);
			moveSpeed += 0.08f;
			iceSkate = true;
		}
		if (currentItem.type == 4874)
		{
			accRunSpeed = 6f;
			rocketBoots = (vanityRocketBoots = 5);
		}
		if (currentItem.type == 3110)
		{
			accMerman = true;
			wolfAcc = true;
			if (array[num])
			{
				hideMerman = true;
				hideWolf = true;
			}
		}
		if (currentItem.type == 1865 || currentItem.type == 3110)
		{
			skyStoneEffects = true;
		}
		if (currentItem.type == 899 && Main.dayTime)
		{
			skyStoneEffects = true;
		}
		if (currentItem.type == 900 && (!Main.dayTime || Main.eclipse))
		{
			skyStoneEffects = true;
		}
		if (currentItem.type == 407)
		{
			blockRange++;
		}
		if (currentItem.type == 489)
		{
			magicDamage += 0.15f;
		}
		if (currentItem.type == 490)
		{
			meleeDamage += 0.15f;
		}
		if (currentItem.type == 491)
		{
			rangedDamage += 0.15f;
		}
		if (currentItem.type == 2998)
		{
			minionDamage += 0.15f;
		}
		if (currentItem.type == 935)
		{
			allDamage += 0.12f;
		}
		if (currentItem.wingSlot != -1)
		{
			wingTimeMax = GetWingStats(currentItem.wingSlot).FlyTime;
		}
		if (currentItem.wingSlot == 26)
		{
			ignoreWater = true;
		}
		if (currentItem.type == 5452)
		{
			remoteVisionForDrone = true;
		}
		if (currentItem.type == 885)
		{
			buffImmune[30] = true;
		}
		if (currentItem.type == 886)
		{
			buffImmune[36] = true;
		}
		if (currentItem.type == 887)
		{
			buffImmune[20] = true;
		}
		if (currentItem.type == 888)
		{
			buffImmune[22] = true;
		}
		if (currentItem.type == 889)
		{
			buffImmune[32] = true;
		}
		if (currentItem.type == 890)
		{
			buffImmune[35] = true;
		}
		if (currentItem.type == 891)
		{
			buffImmune[23] = true;
		}
		if (currentItem.type == 892)
		{
			buffImmune[33] = true;
		}
		if (currentItem.type == 893)
		{
			buffImmune[31] = true;
		}
		if (currentItem.type == 3781)
		{
			buffImmune[156] = true;
		}
		if (currentItem.type == 901)
		{
			buffImmune[33] = true;
			buffImmune[36] = true;
		}
		if (currentItem.type == 902)
		{
			buffImmune[30] = true;
			buffImmune[20] = true;
		}
		if (currentItem.type == 903)
		{
			buffImmune[32] = true;
			buffImmune[31] = true;
		}
		if (currentItem.type == 904)
		{
			buffImmune[35] = true;
			buffImmune[23] = true;
		}
		if (currentItem.type == 5354)
		{
			buffImmune[22] = true;
			buffImmune[156] = true;
		}
		if (currentItem.type == 5355 && !controlDownHold)
		{
			shimmerImmune = true;
		}
		if (currentItem.type == 1921)
		{
			buffImmune[46] = true;
			buffImmune[47] = true;
		}
		if (currentItem.type == 1612)
		{
			buffImmune[33] = true;
			buffImmune[36] = true;
			buffImmune[30] = true;
			buffImmune[20] = true;
			buffImmune[32] = true;
			buffImmune[31] = true;
			buffImmune[35] = true;
			buffImmune[23] = true;
			buffImmune[22] = true;
			buffImmune[156] = true;
		}
		if (currentItem.type == 1613)
		{
			buffImmune[46] = true;
			noKnockback = true;
			fireWalk = true;
			buffImmune[33] = true;
			buffImmune[36] = true;
			buffImmune[30] = true;
			buffImmune[20] = true;
			buffImmune[32] = true;
			buffImmune[31] = true;
			buffImmune[35] = true;
			buffImmune[23] = true;
			buffImmune[22] = true;
			buffImmune[156] = true;
		}
		if (currentItem.type == 497)
		{
			accMerman = true;
			if (array[num])
			{
				hideMerman = true;
			}
		}
		if (currentItem.type == 535)
		{
			pStone = true;
		}
		if (currentItem.type == 536)
		{
			kbGlove = true;
			meleeScaleGlove = true;
		}
		if (currentItem.type == 532)
		{
			starCloakItem = currentItem;
		}
		if (currentItem.type == 554)
		{
			longInvince = true;
		}
		if (currentItem.type == 555)
		{
			manaFlower = true;
			manaCost -= 0.08f;
		}
		if (currentItem.wingSlot > 0)
		{
			if (!array[num] || (velocity.Y != 0f && !mount.Active))
			{
				wings = currentItem.wingSlot;
			}
			wingsLogic = currentItem.wingSlot;
			equippedWings = currentItem;
		}
		ItemLoader.UpdateAccessory(currentItem, this, hideVisual);
		if (Main.myPlayer != whoAmI)
		{
			return;
		}
		if (currentItem.type == 5104 || currentItem.type == 5105)
		{
			ApplyWilsonBeard(currentItem);
		}
		else if (currentItem.type == 576 && Main.rand.Next(540) == 0 && Main.curMusic > 0)
		{
			SoundEngine.PlaySound(in SoundID.Item166, base.Center);
			int num4 = -1;
			if (Main.curMusic == 1)
			{
				num4 = 0;
			}
			if (Main.curMusic == 2)
			{
				num4 = 1;
			}
			if (Main.curMusic == 3)
			{
				num4 = 2;
			}
			if (Main.curMusic == 4)
			{
				num4 = 4;
			}
			if (Main.curMusic == 5)
			{
				num4 = 5;
			}
			if (Main.curMusic == 6)
			{
				num4 = 3;
			}
			if (Main.curMusic == 7)
			{
				num4 = 6;
			}
			if (Main.curMusic == 8)
			{
				num4 = 7;
			}
			if (Main.curMusic == 9)
			{
				num4 = 9;
			}
			if (Main.curMusic == 10)
			{
				num4 = 8;
			}
			if (Main.curMusic == 11)
			{
				num4 = 11;
			}
			if (Main.curMusic == 12)
			{
				num4 = 10;
			}
			if (Main.curMusic == 13)
			{
				num4 = 12;
			}
			int value;
			if (Main.curMusic == 28)
			{
				currentItem.SetDefaults(1963);
			}
			else if (Main.curMusic == 29)
			{
				currentItem.SetDefaults(1610);
			}
			else if (Main.curMusic == 30)
			{
				currentItem.SetDefaults(1963);
			}
			else if (Main.curMusic == 31)
			{
				currentItem.SetDefaults(1964);
			}
			else if (Main.curMusic == 32)
			{
				currentItem.SetDefaults(1965);
			}
			else if (Main.curMusic == 33)
			{
				currentItem.SetDefaults(2742);
			}
			else if (Main.curMusic == 34)
			{
				currentItem.SetDefaults(3370);
			}
			else if (Main.curMusic == 35)
			{
				currentItem.SetDefaults(3236);
			}
			else if (Main.curMusic == 36)
			{
				currentItem.SetDefaults(3237);
			}
			else if (Main.curMusic == 37)
			{
				currentItem.SetDefaults(3235);
			}
			else if (Main.curMusic == 38)
			{
				currentItem.SetDefaults(3044);
			}
			else if (Main.curMusic == 39)
			{
				currentItem.SetDefaults(3371);
			}
			else if (Main.curMusic == 40)
			{
				currentItem.SetDefaults(3796);
			}
			else if (Main.curMusic == 41)
			{
				currentItem.SetDefaults(3869);
			}
			else if (Main.curMusic == 42)
			{
				currentItem.SetDefaults(4079);
			}
			else if (Main.curMusic == 43)
			{
				currentItem.SetDefaults(4077);
			}
			else if (Main.curMusic == 44)
			{
				currentItem.SetDefaults(4082);
			}
			else if (Main.curMusic == 46)
			{
				currentItem.SetDefaults(4080);
			}
			else if (Main.curMusic == 47)
			{
				currentItem.SetDefaults(4081);
			}
			else if (Main.curMusic == 48)
			{
				currentItem.SetDefaults(4078);
			}
			else if (Main.curMusic == 49)
			{
				currentItem.SetDefaults(4237);
			}
			else if (Main.curMusic == 51)
			{
				currentItem.SetDefaults(4356);
			}
			else if (Main.curMusic == 52)
			{
				currentItem.SetDefaults(4357);
			}
			else if (Main.curMusic == 53)
			{
				currentItem.SetDefaults(4358);
			}
			else if (Main.curMusic == 54)
			{
				currentItem.SetDefaults(4421);
			}
			else if (Main.curMusic == 55)
			{
				currentItem.SetDefaults(4606);
			}
			else if (Main.curMusic == 56)
			{
				currentItem.SetDefaults(4979);
			}
			else if (Main.curMusic == 57)
			{
				currentItem.SetDefaults(4985);
			}
			else if (Main.curMusic == 58)
			{
				currentItem.SetDefaults(4990);
			}
			else if (Main.curMusic == 59)
			{
				currentItem.SetDefaults(4991);
			}
			else if (Main.curMusic == 60)
			{
				currentItem.SetDefaults(4992);
			}
			else if (Main.curMusic == 61)
			{
				currentItem.SetDefaults(5006);
			}
			else if (Main.curMusic == 62)
			{
				currentItem.SetDefaults(5014);
			}
			else if (Main.curMusic == 63)
			{
				currentItem.SetDefaults(5015);
			}
			else if (Main.curMusic == 64)
			{
				currentItem.SetDefaults(5016);
			}
			else if (Main.curMusic == 65)
			{
				currentItem.SetDefaults(5017);
			}
			else if (Main.curMusic == 66)
			{
				currentItem.SetDefaults(5018);
			}
			else if (Main.curMusic == 67)
			{
				currentItem.SetDefaults(5019);
			}
			else if (Main.curMusic == 68)
			{
				currentItem.SetDefaults(5020);
			}
			else if (Main.curMusic == 69)
			{
				currentItem.SetDefaults(5021);
			}
			else if (Main.curMusic == 70)
			{
				currentItem.SetDefaults(5022);
			}
			else if (Main.curMusic == 71)
			{
				currentItem.SetDefaults(5023);
			}
			else if (Main.curMusic == 72)
			{
				currentItem.SetDefaults(5024);
			}
			else if (Main.curMusic == 73)
			{
				currentItem.SetDefaults(5025);
			}
			else if (Main.curMusic == 74)
			{
				currentItem.SetDefaults(5026);
			}
			else if (Main.curMusic == 75)
			{
				currentItem.SetDefaults(5027);
			}
			else if (Main.curMusic == 76)
			{
				currentItem.SetDefaults(5028);
			}
			else if (Main.curMusic == 77)
			{
				currentItem.SetDefaults(5029);
			}
			else if (Main.curMusic == 78)
			{
				currentItem.SetDefaults(5030);
			}
			else if (Main.curMusic == 79)
			{
				currentItem.SetDefaults(5031);
			}
			else if (Main.curMusic == 80)
			{
				currentItem.SetDefaults(5032);
			}
			else if (Main.curMusic == 81)
			{
				currentItem.SetDefaults(5033);
			}
			else if (Main.curMusic == 82)
			{
				currentItem.SetDefaults(5034);
			}
			else if (Main.curMusic == 83)
			{
				currentItem.SetDefaults(5035);
			}
			else if (Main.curMusic == 84)
			{
				currentItem.SetDefaults(5036);
			}
			else if (Main.curMusic == 85)
			{
				currentItem.SetDefaults(5037);
			}
			else if (Main.curMusic == 86)
			{
				currentItem.SetDefaults(5038);
			}
			else if (Main.curMusic == 87)
			{
				currentItem.SetDefaults(5039);
			}
			else if (Main.curMusic == 88)
			{
				currentItem.SetDefaults(5040);
			}
			else if (Main.curMusic == 89)
			{
				currentItem.SetDefaults(5044);
			}
			else if (Main.curMusic == 90)
			{
				currentItem.SetDefaults(5112);
			}
			else if (Main.curMusic == 91)
			{
				currentItem.SetDefaults(5362);
			}
			else if (Main.curMusic > 13 && Main.curMusic < Main.maxMusic)
			{
				currentItem.SetDefaults(1596 + Main.curMusic - 14);
			}
			else if (num4 != -1 && Main.curMusic < Main.maxMusic)
			{
				currentItem.SetDefaults(num4 + 562);
			}
			else if (MusicLoader.musicToItem.TryGetValue(Main.curMusic, out value))
			{
				currentItem.SetDefaults(value);
			}
		}
		ApplyMusicBox(currentItem);
	}

	private void ApplyWilsonBeard(Item currentItem)
	{
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		beardGrowthTimer++;
		if (beardGrowthTimer >= 43200 && Main.rand.Next(540) == 0)
		{
			beardGrowthTimer = 0;
			short defaults = 5105;
			if (currentItem.type == 5105)
			{
				defaults = 5106;
			}
			SoundEngine.PlaySound(in SoundID.Item60, base.Center);
			currentItem.SetDefaults(defaults);
		}
	}

	private void ApplyMusicBox(Item currentItem)
	{
		if (currentItem.type >= 562 && currentItem.type <= 574)
		{
			Main.musicBox2 = currentItem.type - 562;
		}
		if (currentItem.type >= 1596 && currentItem.type <= 1609)
		{
			Main.musicBox2 = currentItem.type - 1596 + 13;
		}
		if (currentItem.type == 1610)
		{
			Main.musicBox2 = 27;
		}
		if (currentItem.type == 1963)
		{
			Main.musicBox2 = 28;
		}
		if (currentItem.type == 1964)
		{
			Main.musicBox2 = 29;
		}
		if (currentItem.type == 1965)
		{
			Main.musicBox2 = 30;
		}
		if (currentItem.type == 2742)
		{
			Main.musicBox2 = 31;
		}
		if (currentItem.type == 3044)
		{
			Main.musicBox2 = 32;
		}
		if (currentItem.type == 3235)
		{
			Main.musicBox2 = 33;
		}
		if (currentItem.type == 3236)
		{
			Main.musicBox2 = 34;
		}
		if (currentItem.type == 3237)
		{
			Main.musicBox2 = 35;
		}
		if (currentItem.type == 3370)
		{
			Main.musicBox2 = 36;
		}
		if (currentItem.type == 3371)
		{
			Main.musicBox2 = 37;
		}
		if (currentItem.type == 3796)
		{
			Main.musicBox2 = 38;
		}
		if (currentItem.type == 3869)
		{
			Main.musicBox2 = 39;
		}
		if (currentItem.type == 4082)
		{
			Main.musicBox2 = 40;
		}
		if (currentItem.type == 4078)
		{
			Main.musicBox2 = 41;
		}
		if (currentItem.type == 4079)
		{
			Main.musicBox2 = 42;
		}
		if (currentItem.type == 4077)
		{
			Main.musicBox2 = 43;
		}
		if (currentItem.type == 4080)
		{
			Main.musicBox2 = 44;
		}
		if (currentItem.type == 4081)
		{
			Main.musicBox2 = 45;
		}
		if (currentItem.type == 4237)
		{
			Main.musicBox2 = 46;
		}
		if (currentItem.type == 4356)
		{
			Main.musicBox2 = 47;
		}
		if (currentItem.type == 4357)
		{
			Main.musicBox2 = 48;
		}
		if (currentItem.type == 4358)
		{
			Main.musicBox2 = 49;
		}
		if (currentItem.type == 4421)
		{
			Main.musicBox2 = 50;
		}
		if (currentItem.type == 4606)
		{
			Main.musicBox2 = 51;
		}
		if (currentItem.type == 4979)
		{
			Main.musicBox2 = 52;
		}
		if (currentItem.type == 4985)
		{
			Main.musicBox2 = 53;
		}
		if (currentItem.type == 4990)
		{
			Main.musicBox2 = 54;
		}
		if (currentItem.type == 4991)
		{
			Main.musicBox2 = 55;
		}
		if (currentItem.type == 4992)
		{
			Main.musicBox2 = 56;
		}
		if (currentItem.type == 5006)
		{
			Main.musicBox2 = 57;
		}
		if (currentItem.type == 5014)
		{
			Main.musicBox2 = 58;
		}
		if (currentItem.type == 5015)
		{
			Main.musicBox2 = 59;
		}
		if (currentItem.type == 5016)
		{
			Main.musicBox2 = 60;
		}
		if (currentItem.type == 5017)
		{
			Main.musicBox2 = 61;
		}
		if (currentItem.type == 5018)
		{
			Main.musicBox2 = 62;
		}
		if (currentItem.type == 5019)
		{
			Main.musicBox2 = 63;
		}
		if (currentItem.type == 5020)
		{
			Main.musicBox2 = 64;
		}
		if (currentItem.type == 5021)
		{
			Main.musicBox2 = 65;
		}
		if (currentItem.type == 5022)
		{
			Main.musicBox2 = 66;
		}
		if (currentItem.type == 5023)
		{
			Main.musicBox2 = 67;
		}
		if (currentItem.type == 5024)
		{
			Main.musicBox2 = 68;
		}
		if (currentItem.type == 5025)
		{
			Main.musicBox2 = 69;
		}
		if (currentItem.type == 5026)
		{
			Main.musicBox2 = 70;
		}
		if (currentItem.type == 5027)
		{
			Main.musicBox2 = 71;
		}
		if (currentItem.type == 5028)
		{
			Main.musicBox2 = 72;
		}
		if (currentItem.type == 5029)
		{
			Main.musicBox2 = 73;
		}
		if (currentItem.type == 5030)
		{
			Main.musicBox2 = 74;
		}
		if (currentItem.type == 5031)
		{
			Main.musicBox2 = 75;
		}
		if (currentItem.type == 5032)
		{
			Main.musicBox2 = 76;
		}
		if (currentItem.type == 5033)
		{
			Main.musicBox2 = 77;
		}
		if (currentItem.type == 5034)
		{
			Main.musicBox2 = 78;
		}
		if (currentItem.type == 5035)
		{
			Main.musicBox2 = 79;
		}
		if (currentItem.type == 5036)
		{
			Main.musicBox2 = 80;
		}
		if (currentItem.type == 5037)
		{
			Main.musicBox2 = 81;
		}
		if (currentItem.type == 5038)
		{
			Main.musicBox2 = 82;
		}
		if (currentItem.type == 5039)
		{
			Main.musicBox2 = 83;
		}
		if (currentItem.type == 5040)
		{
			Main.musicBox2 = 84;
		}
		if (currentItem.type == 5044)
		{
			Main.musicBox2 = 85;
		}
		if (currentItem.type == 5112)
		{
			Main.musicBox2 = 86;
		}
		if (currentItem.type == 5362)
		{
			Main.musicBox2 = 87;
		}
		if (MusicLoader.itemToMusic.TryGetValue(currentItem.type, out var value))
		{
			Main.musicBox2 = value;
		}
		Main.musicBoxNotModifiedByVolume = Main.musicBox2;
	}

	public void UpdateArmorSets(int i)
	{
		//IL_0767: Unknown result type (might be due to invalid IL or missing references)
		//IL_0774: Unknown result type (might be due to invalid IL or missing references)
		//IL_0779: Unknown result type (might be due to invalid IL or missing references)
		//IL_077e: Unknown result type (might be due to invalid IL or missing references)
		//IL_09bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_09c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_09cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_09d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_09d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0999: Unknown result type (might be due to invalid IL or missing references)
		//IL_09a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_09a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_168d: Unknown result type (might be due to invalid IL or missing references)
		//IL_1692: Unknown result type (might be due to invalid IL or missing references)
		//IL_16b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_16c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_16ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_16cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_16f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_1703: Unknown result type (might be due to invalid IL or missing references)
		//IL_1708: Unknown result type (might be due to invalid IL or missing references)
		//IL_15df: Unknown result type (might be due to invalid IL or missing references)
		//IL_15ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_1605: Unknown result type (might be due to invalid IL or missing references)
		//IL_1631: Unknown result type (might be due to invalid IL or missing references)
		//IL_163b: Unknown result type (might be due to invalid IL or missing references)
		//IL_1640: Unknown result type (might be due to invalid IL or missing references)
		//IL_1750: Unknown result type (might be due to invalid IL or missing references)
		//IL_175a: Unknown result type (might be due to invalid IL or missing references)
		//IL_175f: Unknown result type (might be due to invalid IL or missing references)
		//IL_1769: Unknown result type (might be due to invalid IL or missing references)
		//IL_176e: Unknown result type (might be due to invalid IL or missing references)
		//IL_1a01: Unknown result type (might be due to invalid IL or missing references)
		//IL_1930: Unknown result type (might be due to invalid IL or missing references)
		//IL_193b: Unknown result type (might be due to invalid IL or missing references)
		setBonus = "";
		if (body == 67 && legs == 56 && head >= 103 && head <= 105)
		{
			setBonus = Language.GetTextValue("ArmorSetBonus.Shroomite");
			shroomiteStealth = true;
		}
		if ((head == 52 && body == 32 && legs == 31) || (head == 53 && body == 33 && legs == 32) || (head == 54 && body == 34 && legs == 33) || (head == 55 && body == 35 && legs == 34) || (head == 71 && body == 47 && legs == 43) || (head == 166 && body == 173 && legs == 108) || (head == 167 && body == 174 && legs == 109))
		{
			setBonus = Language.GetTextValue("ArmorSetBonus.Wood");
			++statDefense;
		}
		if (head == 278 && body == 246 && legs == 234)
		{
			setBonus = Language.GetTextValue("ArmorSetBonus.AshWood");
			ashWoodBonus = true;
		}
		if ((head == 1 && body == 1 && legs == 1) || ((head == 72 || head == 2) && body == 2 && legs == 2) || (head == 47 && body == 28 && legs == 27))
		{
			setBonus = Language.GetTextValue("ArmorSetBonus.MetalTier1");
			statDefense += 2;
		}
		if ((head == 3 && body == 3 && legs == 3) || ((head == 73 || head == 4) && body == 4 && legs == 4) || (head == 48 && body == 29 && legs == 28) || (head == 49 && body == 30 && legs == 29))
		{
			setBonus = Language.GetTextValue("ArmorSetBonus.MetalTier2");
			statDefense += 3;
		}
		if (head == 50 && body == 31 && legs == 30)
		{
			setBonus = Language.GetTextValue("ArmorSetBonus.Platinum");
			statDefense += 4;
		}
		if (head == 112 && body == 75 && legs == 64)
		{
			setBonus = Language.GetTextValue("ArmorSetBonus.Pumpkin");
			allDamage += 0.1f;
		}
		if (head == 180 && body == 182 && legs == 122)
		{
			setBonus = Language.GetTextValue("ArmorSetBonus.Gladiator");
			noKnockback = true;
		}
		if (head == 22 && body == 14 && legs == 14)
		{
			setBonus = Language.GetTextValue("ArmorSetBonus.Ninja");
			moveSpeed += 0.2f;
		}
		if (head == 188 && body == 189 && legs == 129)
		{
			setBonus = Language.GetTextValue("ArmorSetBonus.Fossil");
			ammoCost80 = true;
		}
		if ((head == 75 || head == 7) && body == 7 && legs == 7)
		{
			setBonus = Language.GetTextValue("ArmorSetBonus.Bone");
			rangedCrit += 10f;
		}
		if (head == 157 && body == 105 && legs == 98)
		{
			int num = 0;
			setBonus = Language.GetTextValue("ArmorSetBonus.BeetleDamage");
			beetleOffense = true;
			beetleCounter -= 3f;
			beetleCounter -= beetleCountdown / 20;
			beetleCountdown++;
			if (beetleCounter < 0f)
			{
				beetleCounter = 0f;
			}
			int num2 = 400;
			int num3 = 1200;
			int num4 = 3600;
			if (beetleCounter > (float)(num2 + num3 + num4 + num3))
			{
				beetleCounter = num2 + num3 + num4 + num3;
			}
			if (beetleCounter > (float)(num2 + num3 + num4))
			{
				AddBuff(100, 5, quiet: false);
				num = 3;
			}
			else if (beetleCounter > (float)(num2 + num3))
			{
				AddBuff(99, 5, quiet: false);
				num = 2;
			}
			else if (beetleCounter > (float)num2)
			{
				AddBuff(98, 5, quiet: false);
				num = 1;
			}
			if (num < beetleOrbs)
			{
				beetleCountdown = 0;
			}
			else if (num > beetleOrbs)
			{
				beetleCounter += 200f;
			}
			if (num != beetleOrbs && beetleOrbs > 0)
			{
				for (int j = 0; j < maxBuffs; j++)
				{
					if (buffType[j] >= 98 && buffType[j] <= 100 && buffType[j] != 97 + num)
					{
						DelBuff(j);
					}
				}
			}
		}
		else if (head == 157 && body == 106 && legs == 98)
		{
			setBonus = Language.GetTextValue("ArmorSetBonus.BeetleDefense");
			beetleDefense = true;
			beetleCounter += 1f;
			int num5 = 180;
			if (beetleCounter >= (float)num5)
			{
				if (beetleOrbs > 0 && beetleOrbs < 3)
				{
					for (int k = 0; k < maxBuffs; k++)
					{
						if (buffType[k] >= 95 && buffType[k] <= 96)
						{
							DelBuff(k);
						}
					}
				}
				if (beetleOrbs < 3)
				{
					AddBuff(95 + beetleOrbs, 5, quiet: false);
					beetleCounter = 0f;
				}
				else
				{
					beetleCounter = num5;
				}
			}
		}
		if (!beetleDefense && !beetleOffense)
		{
			beetleCounter = 0f;
		}
		else
		{
			beetleFrameCounter++;
			if (beetleFrameCounter >= 1)
			{
				beetleFrameCounter = 0;
				beetleFrame++;
				if (beetleFrame > 2)
				{
					beetleFrame = 0;
				}
			}
			for (int l = beetleOrbs; l < 3; l++)
			{
				beetlePos[l].X = 0f;
				beetlePos[l].Y = 0f;
			}
			for (int m = 0; m < beetleOrbs; m++)
			{
				ref Vector2 reference = ref beetlePos[m];
				reference += beetleVel[m];
				beetleVel[m].X += (float)Main.rand.Next(-100, 101) * 0.005f;
				beetleVel[m].Y += (float)Main.rand.Next(-100, 101) * 0.005f;
				float x = beetlePos[m].X;
				float y = beetlePos[m].Y;
				float num6 = (float)Math.Sqrt(x * x + y * y);
				if (num6 > 100f)
				{
					num6 = 20f / num6;
					x *= 0f - num6;
					y *= 0f - num6;
					int num7 = 10;
					beetleVel[m].X = (beetleVel[m].X * (float)(num7 - 1) + x) / (float)num7;
					beetleVel[m].Y = (beetleVel[m].Y * (float)(num7 - 1) + y) / (float)num7;
				}
				else if (num6 > 30f)
				{
					num6 = 10f / num6;
					x *= 0f - num6;
					y *= 0f - num6;
					int num8 = 20;
					beetleVel[m].X = (beetleVel[m].X * (float)(num8 - 1) + x) / (float)num8;
					beetleVel[m].Y = (beetleVel[m].Y * (float)(num8 - 1) + y) / (float)num8;
				}
				x = beetleVel[m].X;
				y = beetleVel[m].Y;
				num6 = (float)Math.Sqrt(x * x + y * y);
				if (num6 > 2f)
				{
					ref Vector2 reference2 = ref beetleVel[m];
					reference2 *= 0.9f;
				}
				ref Vector2 reference3 = ref beetlePos[m];
				reference3 -= velocity * 0.25f;
			}
		}
		if (head == 14 && ((body >= 58 && body <= 63) || body == 167 || body == 213))
		{
			setBonus = Language.GetTextValue("ArmorSetBonus.Wizard");
			magicCrit += 10f;
		}
		if (head == 159 && ((body >= 58 && body <= 63) || body == 167 || body == 213))
		{
			setBonus = Language.GetTextValue("ArmorSetBonus.MagicHat");
			statManaMax2 += 60;
		}
		if ((head == 5 || head == 74) && (body == 5 || body == 48) && (legs == 5 || legs == 44))
		{
			setBonus = Language.GetTextValue("ArmorSetBonus.ShadowScale");
			shadowArmor = true;
		}
		if (head == 57 && body == 37 && legs == 35)
		{
			setBonus = Language.GetTextValue("ArmorSetBonus.Crimson");
			crimsonRegen = true;
		}
		if (head == 101 && body == 66 && legs == 55)
		{
			setBonus = Language.GetTextValue("ArmorSetBonus.SpectreHealing");
			ghostHeal = true;
			magicDamage -= 0.4f;
		}
		if (head == 156 && body == 66 && legs == 55)
		{
			setBonus = Language.GetTextValue("ArmorSetBonus.SpectreDamage");
			ghostHurt = true;
		}
		if (head == 6 && body == 6 && legs == 6)
		{
			setBonus = Language.GetTextValue("ArmorSetBonus.Meteor");
			spaceGun = true;
		}
		if (head == 46 && body == 27 && legs == 26)
		{
			setBonus = Language.GetTextValue("ArmorSetBonus.Frost");
			frostBurn = true;
			meleeDamage += 0.1f;
			rangedDamage += 0.1f;
		}
		if ((head == 76 || head == 8) && (body == 49 || body == 8) && (legs == 45 || legs == 8))
		{
			setBonus = Language.GetTextValue("ArmorSetBonus.Jungle");
			manaCost -= 0.16f;
		}
		if (head == 9 && body == 9 && legs == 9)
		{
			setBonus = Language.GetTextValue("ArmorSetBonus.Molten");
			meleeDamage += 0.1f;
			buffImmune[24] = true;
		}
		if ((head == 58 || head == 77) && (body == 38 || body == 50) && (legs == 36 || legs == 46))
		{
			setBonus = Language.GetTextValue("ArmorSetBonus.Snow");
			buffImmune[46] = true;
			buffImmune[47] = true;
		}
		if (head == 11 && body == 20 && legs == 19)
		{
			setBonus = Language.GetTextValue("ArmorSetBonus.Mining");
			pickSpeed -= 0.1f;
		}
		if (head == 216 && body == 20 && legs == 19)
		{
			setBonus = Language.GetTextValue("ArmorSetBonus.Mining");
			pickSpeed -= 0.1f;
		}
		if (head == 78 && body == 51 && legs == 47)
		{
			setBonus = Language.GetTextValue("ArmorSetBonus.ChlorophyteMelee");
			AddBuff(60, 18000);
			endurance += 0.05f;
		}
		else if ((head == 80 || head == 79) && body == 51 && legs == 47)
		{
			setBonus = Language.GetTextValue("ArmorSetBonus.Chlorophyte");
			AddBuff(60, 18000);
		}
		else if (crystalLeaf)
		{
			for (int n = 0; n < maxBuffs; n++)
			{
				if (buffType[n] == 60)
				{
					DelBuff(n);
				}
			}
		}
		if (head == 161 && body == 169 && legs == 104)
		{
			setBonus = Language.GetTextValue("ArmorSetBonus.Angler");
			anglerSetSpawnReduction = true;
		}
		if (head == 70 && body == 46 && legs == 42)
		{
			setBonus = Language.GetTextValue("ArmorSetBonus.Cactus");
			cactusThorns = true;
		}
		if (head == 99 && body == 65 && legs == 54)
		{
			setBonus = Language.GetTextValue("ArmorSetBonus.Turtle");
			endurance += 0.15f;
			thorns = 1f;
			turtleThorns = true;
		}
		if (body == 17 && legs == 16)
		{
			if (head == 29)
			{
				setBonus = Language.GetTextValue("ArmorSetBonus.CobaltCaster");
				manaCost -= 0.14f;
			}
			else if (head == 30)
			{
				setBonus = Language.GetTextValue("ArmorSetBonus.CobaltMelee");
				meleeSpeed += 0.15f;
			}
			else if (head == 31)
			{
				setBonus = Language.GetTextValue("ArmorSetBonus.CobaltRanged");
				ammoCost80 = true;
			}
		}
		if (body == 18 && legs == 17)
		{
			if (head == 32)
			{
				setBonus = Language.GetTextValue("ArmorSetBonus.MythrilCaster");
				manaCost -= 0.17f;
			}
			else if (head == 33)
			{
				setBonus = Language.GetTextValue("ArmorSetBonus.MythrilMelee");
				meleeCrit += 10f;
			}
			else if (head == 34)
			{
				setBonus = Language.GetTextValue("ArmorSetBonus.MythrilRanged");
				ammoCost80 = true;
			}
		}
		if (body == 19 && legs == 18)
		{
			if (head == 35)
			{
				setBonus = Language.GetTextValue("ArmorSetBonus.AdamantiteCaster");
				manaCost -= 0.19f;
			}
			else if (head == 36)
			{
				setBonus = Language.GetTextValue("ArmorSetBonus.AdamantiteMelee");
				meleeSpeed += 0.2f;
				moveSpeed += 0.2f;
			}
			else if (head == 37)
			{
				setBonus = Language.GetTextValue("ArmorSetBonus.AdamantiteRanged");
				ammoCost75 = true;
			}
		}
		if (body == 54 && legs == 49 && (head == 83 || head == 84 || head == 85))
		{
			setBonus = Language.GetTextValue("ArmorSetBonus.Palladium");
			onHitRegen = true;
		}
		if (body == 55 && legs == 50 && (head == 86 || head == 87 || head == 88))
		{
			setBonus = Language.GetTextValue("ArmorSetBonus.Orichalcum");
			onHitPetal = true;
		}
		if (body == 56 && legs == 51)
		{
			bool flag = false;
			if (head == 91)
			{
				setBonus = Language.GetTextValue("ArmorSetBonus.Titanium");
				flag = true;
			}
			else if (head == 89)
			{
				setBonus = Language.GetTextValue("ArmorSetBonus.Titanium");
				flag = true;
			}
			else if (head == 90)
			{
				setBonus = Language.GetTextValue("ArmorSetBonus.Titanium");
				flag = true;
			}
			if (flag)
			{
				onHitTitaniumStorm = true;
			}
		}
		if ((body == 24 || body == 229) && (legs == 23 || legs == 212) && (head == 42 || head == 41 || head == 43 || head == 254 || head == 257 || head == 256 || head == 255 || head == 258))
		{
			if (head == 254 || head == 258)
			{
				setBonus = Language.GetTextValue("ArmorSetBonus.HallowedSummoner");
				maxMinions += 2;
			}
			else
			{
				setBonus = Language.GetTextValue("ArmorSetBonus.Hallowed");
			}
			onHitDodge = true;
		}
		if (head == 261 && body == 230 && legs == 213)
		{
			setBonus = Language.GetTextValue("ArmorSetBonus.CrystalNinja");
			allDamage += 0.1f;
			allCrit += 10f;
			dashType = 5;
		}
		if (head == 82 && body == 53 && legs == 48)
		{
			setBonus = Language.GetTextValue("ArmorSetBonus.Tiki");
			maxMinions++;
			whipRangeMultiplier += 0.2f;
		}
		if (head == 134 && body == 95 && legs == 79)
		{
			setBonus = Language.GetTextValue("ArmorSetBonus.Spooky");
			minionDamage += 0.25f;
		}
		if (head == 160 && body == 168 && legs == 103)
		{
			setBonus = Language.GetTextValue("ArmorSetBonus.Bee");
			minionDamage += 0.1f;
			if (itemAnimation > 0 && inventory[selectedItem].type == 1121)
			{
				AchievementsHelper.HandleSpecialEvent(this, 3);
			}
		}
		if (head == 162 && body == 170 && legs == 105)
		{
			setBonus = Language.GetTextValue("ArmorSetBonus.Spider");
			minionDamage += 0.12f;
		}
		if (head == 171 && body == 177 && legs == 112)
		{
			endurance += 0.12f;
			setSolar = true;
			setBonus = Language.GetTextValue("ArmorSetBonus.Solar");
			solarCounter++;
			int num9 = 180;
			if (solarCounter >= num9)
			{
				if (solarShields > 0 && solarShields < 3)
				{
					for (int num10 = 0; num10 < maxBuffs; num10++)
					{
						if (buffType[num10] >= 170 && buffType[num10] <= 171)
						{
							DelBuff(num10);
						}
					}
				}
				if (solarShields < 3)
				{
					AddBuff(170 + solarShields, 5, quiet: false);
					for (int num11 = 0; num11 < 16; num11++)
					{
						Dust obj = Main.dust[Dust.NewDust(position, width, height, 6, 0f, 0f, 100)];
						obj.noGravity = true;
						obj.scale = 1.7f;
						obj.fadeIn = 0.5f;
						obj.velocity *= 5f;
						obj.shader = GameShaders.Armor.GetSecondaryShader(ArmorSetDye(), this);
					}
					solarCounter = 0;
				}
				else
				{
					solarCounter = num9;
				}
			}
			for (int num12 = solarShields; num12 < 3; num12++)
			{
				solarShieldPos[num12] = Vector2.Zero;
			}
			for (int num13 = 0; num13 < solarShields; num13++)
			{
				ref Vector2 reference4 = ref solarShieldPos[num13];
				reference4 += solarShieldVel[num13];
				Vector2 val = ((float)miscCounter / 100f * ((float)Math.PI * 2f) + (float)num13 * ((float)Math.PI * 2f / (float)solarShields)).ToRotationVector2() * 6f;
				val.X = direction * 20;
				if (mount.Active && mount.Type == 52)
				{
					val.X = direction * 50;
				}
				solarShieldVel[num13] = (val - solarShieldPos[num13]) * 0.2f;
			}
			if (dashDelay >= 0)
			{
				solarDashing = false;
				solarDashConsumedFlare = false;
			}
			bool flag2 = solarDashing && dashDelay < 0;
			if (solarShields > 0 || flag2)
			{
				dashType = 3;
			}
		}
		else
		{
			solarCounter = 0;
		}
		if (head == 169 && body == 175 && legs == 110)
		{
			setVortex = true;
			setBonus = Language.GetTextValue("ArmorSetBonus.Vortex", Language.GetTextValue(Main.ReversedUpDownArmorSetBonuses ? "Key.UP" : "Key.DOWN"));
		}
		else
		{
			vortexStealthActive = false;
		}
		if (head == 170 && body == 176 && legs == 111)
		{
			if (nebulaCD > 0)
			{
				nebulaCD--;
			}
			setNebula = true;
			setBonus = Language.GetTextValue("ArmorSetBonus.Nebula");
		}
		if (head == 189 && body == 190 && legs == 130)
		{
			setBonus = Language.GetTextValue("ArmorSetBonus.Stardust", Language.GetTextValue(Main.ReversedUpDownArmorSetBonuses ? "Key.UP" : "Key.DOWN"));
			setStardust = true;
			if (whoAmI == Main.myPlayer)
			{
				if (FindBuffIndex(187) == -1)
				{
					AddBuff(187, 3600);
				}
				if (ownedProjectileCounts[623] < 1)
				{
					int num14 = 10;
					int num15 = 30;
					int num16 = Projectile.NewProjectile(GetProjectileSource_SetBonus(7), base.Center.X, base.Center.Y, 0f, -1f, 623, num15, num14, Main.myPlayer);
					Main.projectile[num16].originalDamage = num15;
				}
			}
		}
		else if (FindBuffIndex(187) != -1)
		{
			DelBuff(FindBuffIndex(187));
		}
		if (head == 200 && body == 198 && legs == 142)
		{
			setBonus = Language.GetTextValue("ArmorSetBonus.Forbidden", Language.GetTextValue(Main.ReversedUpDownArmorSetBonuses ? "Key.UP" : "Key.DOWN"));
			setForbidden = true;
			UpdateForbiddenSetLock();
			Lighting.AddLight(base.Center, 0.8f, 0.7f, 0.2f);
		}
		if (head == 204 && body == 201 && legs == 145)
		{
			setBonus = Language.GetTextValue("ArmorSetBonus.SquireTier2");
			setSquireT2 = true;
			maxTurrets++;
		}
		if (head == 203 && body == 200 && legs == 144)
		{
			setBonus = Language.GetTextValue("ArmorSetBonus.ApprenticeTier2");
			setApprenticeT2 = true;
			maxTurrets++;
		}
		if (head == 205 && body == 202 && (legs == 147 || legs == 146))
		{
			setBonus = Language.GetTextValue("ArmorSetBonus.HuntressTier2");
			setHuntressT2 = true;
			maxTurrets++;
		}
		if (head == 206 && body == 203 && legs == 148)
		{
			setBonus = Language.GetTextValue("ArmorSetBonus.MonkTier2");
			setMonkT2 = true;
			maxTurrets++;
		}
		if (head == 210 && body == 204 && legs == 152)
		{
			setBonus = Language.GetTextValue("ArmorSetBonus.SquireTier3");
			setSquireT3 = true;
			setSquireT2 = true;
			maxTurrets++;
		}
		if (head == 211 && body == 205 && legs == 153)
		{
			setBonus = Language.GetTextValue("ArmorSetBonus.ApprenticeTier3");
			setApprenticeT3 = true;
			setApprenticeT2 = true;
			maxTurrets++;
		}
		if (head == 212 && body == 206 && (legs == 154 || legs == 155))
		{
			setBonus = Language.GetTextValue("ArmorSetBonus.HuntressTier3");
			setHuntressT3 = true;
			setHuntressT2 = true;
			maxTurrets++;
		}
		if (head == 213 && body == 207 && legs == 156)
		{
			setBonus = Language.GetTextValue("ArmorSetBonus.MonkTier3");
			setMonkT3 = true;
			setMonkT2 = true;
			maxTurrets++;
		}
		if (head == 185 && body == 187 && legs == 127)
		{
			setBonus = Language.GetTextValue("ArmorSetBonus.ObsidianOutlaw");
			minionDamage += 0.15f;
			whipRangeMultiplier += 0.3f;
			float num17 = 1.15f;
			summonerWeaponSpeedBonus += num17 - 1f;
		}
		ApplyArmorSoundAndDustChanges();
		ItemLoader.UpdateArmorSet(this, armor[0], armor[1], armor[2]);
	}

	public void UpdateSocialShadow()
	{
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		for (int num = 2; num > 0; num--)
		{
			shadowDirection[num] = shadowDirection[num - 1];
		}
		shadowDirection[0] = direction;
		shadowCount++;
		if (shadowCount == 1)
		{
			shadowPos[2] = shadowPos[1];
			shadowRotation[2] = shadowRotation[1];
			shadowOrigin[2] = shadowOrigin[1];
		}
		else if (shadowCount == 2)
		{
			shadowPos[1] = shadowPos[0];
			shadowRotation[1] = shadowRotation[0];
			shadowOrigin[1] = shadowOrigin[0];
		}
		else if (shadowCount >= 3)
		{
			shadowCount = 0;
			shadowPos[0] = position;
			shadowPos[0].Y += gfxOffY;
			shadowRotation[0] = fullRotation;
			shadowOrigin[0] = fullRotationOrigin;
		}
	}

	public void UpdateTeleportVisuals()
	{
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0105: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0188: Unknown result type (might be due to invalid IL or missing references)
		//IL_0192: Unknown result type (might be due to invalid IL or missing references)
		//IL_0197: Unknown result type (might be due to invalid IL or missing references)
		//IL_028b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0290: Unknown result type (might be due to invalid IL or missing references)
		//IL_0215: Unknown result type (might be due to invalid IL or missing references)
		//IL_0238: Unknown result type (might be due to invalid IL or missing references)
		//IL_023e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0251: Unknown result type (might be due to invalid IL or missing references)
		//IL_0256: Unknown result type (might be due to invalid IL or missing references)
		//IL_02bb: Unknown result type (might be due to invalid IL or missing references)
		if (!(teleportTime > 0f))
		{
			return;
		}
		if (teleportStyle == 0)
		{
			if ((float)Main.rand.Next(100) <= 100f * teleportTime * 2f)
			{
				int num = Dust.NewDust(new Vector2((float)getRect().X, (float)getRect().Y), getRect().Width, getRect().Height, 159);
				Main.dust[num].scale = teleportTime * 1.5f;
				Main.dust[num].noGravity = true;
				Dust obj = Main.dust[num];
				obj.velocity *= 1.1f;
			}
		}
		else if (teleportStyle == 1)
		{
			if ((float)Main.rand.Next(100) <= 100f * teleportTime)
			{
				int num2 = Dust.NewDust(new Vector2((float)getRect().X, (float)getRect().Y), getRect().Width, getRect().Height, 164);
				Main.dust[num2].scale = teleportTime * 1.5f;
				Main.dust[num2].noGravity = true;
				Dust obj2 = Main.dust[num2];
				obj2.velocity *= 1.1f;
			}
		}
		else if (teleportStyle == 2)
		{
			teleportTime = 0.005f;
		}
		else if (teleportStyle == 3)
		{
			teleportTime = 0.005f;
		}
		else if (teleportStyle == 4)
		{
			teleportTime -= 0.02f;
			if ((float)Main.rand.Next(100) <= 100f * teleportTime)
			{
				Dust obj3 = Main.dust[Dust.NewDust(position, width, height, 263)];
				obj3.color = PortalHelper.GetPortalColor(lastPortalColorIndex);
				obj3.noLight = true;
				obj3.noGravity = true;
				obj3.scale = 1.2f;
				obj3.fadeIn = 0.4f;
			}
		}
		else if (teleportStyle == 9)
		{
			Rectangle hitbox = base.Hitbox;
			((Rectangle)(ref hitbox)).Inflate(5, 5);
			if ((float)Main.rand.Next(100) <= 100f * teleportTime)
			{
				TeleportPylonsSystem.SpawnInWorldDust(lastTeleportPylonStyleUsed, hitbox);
			}
		}
		teleportTime -= 0.005f;
	}

	private void UpdateGraveyard(bool now = false)
	{
		float lerpValue = Utils.GetLerpValue(SceneMetrics.GraveyardTileMin, SceneMetrics.GraveyardTileMax, Main.SceneMetrics.GraveyardTileCount, clamped: true);
		if (now)
		{
			graveImmediateTime = 30;
		}
		if (graveImmediateTime > 0)
		{
			graveImmediateTime--;
			Main.GraveyardVisualIntensity = lerpValue;
		}
		else if (Main.GraveyardVisualIntensity < lerpValue)
		{
			Main.GraveyardVisualIntensity += 0.02f;
			if (Main.GraveyardVisualIntensity > lerpValue)
			{
				Main.GraveyardVisualIntensity = lerpValue;
			}
		}
		else if (Main.GraveyardVisualIntensity > lerpValue)
		{
			Main.GraveyardVisualIntensity -= 0.01f;
			if (Main.GraveyardVisualIntensity < lerpValue)
			{
				Main.GraveyardVisualIntensity = lerpValue;
			}
		}
	}

	public void ForceUpdateBiomes()
	{
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		if (whoAmI == Main.myPlayer)
		{
			Main.GetAreaToLight(out var firstTileX, out var lastTileX, out var firstTileY, out var lastTileY);
			Rectangle value = default(Rectangle);
			((Rectangle)(ref value))..ctor(firstTileX, firstTileY, lastTileX - firstTileX, lastTileY - firstTileY);
			int num = 28;
			((Rectangle)(ref value)).Inflate(num, num);
			Main.SceneMetrics.ScanAndExportToMain(new SceneMetricsScanSettings
			{
				VisualScanArea = value,
				BiomeScanCenterPositionInWorld = base.Center,
				ScanOreFinderData = accOreFinder
			});
			UpdateBiomes();
		}
	}

	public bool CanSeeShimmerEffects()
	{
		if (Main.SceneMetrics.ShimmerMonolithState == 2)
		{
			return false;
		}
		if (ZoneShimmer)
		{
			return true;
		}
		if (shimmerMonolithShader || Main.SceneMetrics.ShimmerMonolithState == 1)
		{
			return true;
		}
		if (!((double)(Main.screenPosition.Y / 16f) > Main.worldSurface + 50.0) || !(Main.screenPosition.Y / 16f < (float)(Main.maxTilesY - 330 - 100)))
		{
			return false;
		}
		return shimmering;
	}

	public void UpdateBiomes()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_13ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_13b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_13b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_13b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_13bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_11f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_1202: Unknown result type (might be due to invalid IL or missing references)
		//IL_13d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_13dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_121f: Unknown result type (might be due to invalid IL or missing references)
		//IL_1224: Unknown result type (might be due to invalid IL or missing references)
		//IL_13f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_13fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_12b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_12c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_1246: Unknown result type (might be due to invalid IL or missing references)
		//IL_1251: Unknown result type (might be due to invalid IL or missing references)
		//IL_123c: Unknown result type (might be due to invalid IL or missing references)
		//IL_1241: Unknown result type (might be due to invalid IL or missing references)
		//IL_1363: Unknown result type (might be due to invalid IL or missing references)
		//IL_1368: Unknown result type (might be due to invalid IL or missing references)
		//IL_12ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_12f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_12f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_1324: Unknown result type (might be due to invalid IL or missing references)
		//IL_1329: Unknown result type (might be due to invalid IL or missing references)
		//IL_132e: Unknown result type (might be due to invalid IL or missing references)
		//IL_137f: Unknown result type (might be due to invalid IL or missing references)
		//IL_1384: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_03eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0410: Unknown result type (might be due to invalid IL or missing references)
		//IL_041e: Unknown result type (might be due to invalid IL or missing references)
		//IL_043f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0460: Unknown result type (might be due to invalid IL or missing references)
		//IL_0466: Unknown result type (might be due to invalid IL or missing references)
		//IL_047e: Unknown result type (might be due to invalid IL or missing references)
		//IL_04cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_049f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0533: Unknown result type (might be due to invalid IL or missing references)
		//IL_0538: Unknown result type (might be due to invalid IL or missing references)
		//IL_053a: Unknown result type (might be due to invalid IL or missing references)
		//IL_053f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0541: Unknown result type (might be due to invalid IL or missing references)
		//IL_0546: Unknown result type (might be due to invalid IL or missing references)
		//IL_0548: Unknown result type (might be due to invalid IL or missing references)
		//IL_054d: Unknown result type (might be due to invalid IL or missing references)
		//IL_054f: Unknown result type (might be due to invalid IL or missing references)
		//IL_058c: Unknown result type (might be due to invalid IL or missing references)
		//IL_05d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_05af: Unknown result type (might be due to invalid IL or missing references)
		//IL_05b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0624: Unknown result type (might be due to invalid IL or missing references)
		//IL_05fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0600: Unknown result type (might be due to invalid IL or missing references)
		//IL_0816: Unknown result type (might be due to invalid IL or missing references)
		//IL_0823: Unknown result type (might be due to invalid IL or missing references)
		//IL_0670: Unknown result type (might be due to invalid IL or missing references)
		//IL_0647: Unknown result type (might be due to invalid IL or missing references)
		//IL_064c: Unknown result type (might be due to invalid IL or missing references)
		//IL_06b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0690: Unknown result type (might be due to invalid IL or missing references)
		//IL_0695: Unknown result type (might be due to invalid IL or missing references)
		//IL_06d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_06db: Unknown result type (might be due to invalid IL or missing references)
		//IL_0978: Unknown result type (might be due to invalid IL or missing references)
		//IL_0995: Unknown result type (might be due to invalid IL or missing references)
		//IL_09d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_09e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_09e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_09fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a07: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a0c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a22: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a2e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a33: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a49: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a55: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a5a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a76: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a7c: Unknown result type (might be due to invalid IL or missing references)
		//IL_09a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0aa7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0aad: Unknown result type (might be due to invalid IL or missing references)
		//IL_0ac4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0aca: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b25: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b2b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0ae2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b90: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b63: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b69: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c42: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c48: Unknown result type (might be due to invalid IL or missing references)
		//IL_0cb3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0cb9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0d1e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0dbf: Unknown result type (might be due to invalid IL or missing references)
		//IL_0dfe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0e77: Unknown result type (might be due to invalid IL or missing references)
		//IL_0ffe: Unknown result type (might be due to invalid IL or missing references)
		//IL_1003: Unknown result type (might be due to invalid IL or missing references)
		//IL_1005: Unknown result type (might be due to invalid IL or missing references)
		//IL_100c: Unknown result type (might be due to invalid IL or missing references)
		//IL_1014: Unknown result type (might be due to invalid IL or missing references)
		Point val = base.Center.ToTileCoordinates();
		ZoneDungeon = false;
		if (Main.SceneMetrics.DungeonTileCount >= 250 && (double)base.Center.Y > Main.worldSurface * 16.0)
		{
			int x = (int)base.Center.X / 16;
			int y = (int)base.Center.Y / 16;
			if (Main.tile[x, y] != null && Main.wallDungeon[Main.tile[x, y].wall])
			{
				ZoneDungeon = true;
			}
		}
		ZoneLihzhardTemple = false;
		int x2 = (int)base.Center.X / 16;
		int y2 = (int)base.Center.Y / 16;
		if (Main.tile[x2, y2] != null && Main.tile[x2, y2].wall == 87)
		{
			ZoneLihzhardTemple = true;
		}
		Tile tileSafely = Framing.GetTileSafely(base.Center);
		if (tileSafely != null)
		{
			behindBackWall = tileSafely.wall > 0;
		}
		if (behindBackWall && ZoneDesert && (double)base.Center.Y > Main.worldSurface)
		{
			if (WallID.Sets.Conversion.Sandstone[tileSafely.wall] || WallID.Sets.Conversion.HardenedSand[tileSafely.wall])
			{
				ZoneUndergroundDesert = true;
			}
		}
		else
		{
			ZoneUndergroundDesert = false;
		}
		if (behindBackWall && (tileSafely.wall == 184 || tileSafely.wall == 180))
		{
			ZoneGranite = true;
		}
		else
		{
			ZoneGranite = false;
		}
		if (behindBackWall && (tileSafely.wall == 183 || tileSafely.wall == 178))
		{
			ZoneMarble = true;
		}
		else
		{
			ZoneMarble = false;
		}
		if (behindBackWall && (tileSafely.wall == 108 || tileSafely.wall == 86))
		{
			ZoneHive = true;
		}
		else
		{
			ZoneHive = false;
		}
		if (behindBackWall && tileSafely.wall >= 48 && tileSafely.wall <= 53)
		{
			ZoneGemCave = true;
		}
		else
		{
			ZoneGemCave = false;
		}
		bool flag = (double)(Main.screenPosition.Y / 16f) > Main.worldSurface + 50.0 && Main.screenPosition.Y / 16f < (float)(Main.maxTilesY - 330 - 100);
		ZoneShimmer = Main.SceneMetrics.EnoughTilesForShimmer && flag;
		ZoneCorrupt = Main.SceneMetrics.EnoughTilesForCorruption;
		ZoneCrimson = Main.SceneMetrics.EnoughTilesForCrimson;
		ZoneHallow = Main.SceneMetrics.EnoughTilesForHallow;
		ZoneJungle = Main.SceneMetrics.EnoughTilesForJungle && position.Y / 16f < (float)Main.UnderworldLayer;
		ZoneSnow = Main.SceneMetrics.EnoughTilesForSnow;
		ZoneDesert = Main.SceneMetrics.EnoughTilesForDesert;
		ZoneGlowshroom = Main.SceneMetrics.EnoughTilesForGlowingMushroom;
		ZoneMeteor = Main.SceneMetrics.EnoughTilesForMeteor;
		ZoneWaterCandle = Main.SceneMetrics.WaterCandleCount > 0;
		ZonePeaceCandle = Main.SceneMetrics.PeaceCandleCount > 0;
		ZoneShadowCandle = Main.SceneMetrics.ShadowCandleCount > 0;
		ZoneGraveyard = Main.SceneMetrics.EnoughTilesForGraveyard;
		UpdateGraveyard();
		if (HasGardenGnomeNearby != Main.SceneMetrics.HasGardenGnome)
		{
			luckNeedsSync = true;
			HasGardenGnomeNearby = Main.SceneMetrics.HasGardenGnome;
		}
		ZoneUnderworldHeight = val.Y > Main.UnderworldLayer;
		ZoneRockLayerHeight = val.Y <= Main.UnderworldLayer && (double)val.Y > Main.rockLayer;
		ZoneDirtLayerHeight = (double)val.Y <= Main.rockLayer && (double)val.Y > Main.worldSurface;
		ZoneOverworldHeight = (double)val.Y <= Main.worldSurface && (double)val.Y > Main.worldSurface * 0.3499999940395355;
		ZoneSkyHeight = (double)val.Y <= Main.worldSurface * 0.3499999940395355;
		ZoneBeach = WorldGen.oceanDepths(val.X, val.Y);
		ZoneRain = Main.raining && (double)val.Y <= Main.worldSurface;
		if (Main.remixWorld)
		{
			ZoneSandstorm = (double)val.Y >= Main.rockLayer && ZoneDesert && !ZoneBeach && Sandstorm.Happening;
		}
		else
		{
			ZoneSandstorm = (double)val.Y <= Main.worldSurface && ZoneDesert && !ZoneBeach && Sandstorm.Happening;
		}
		bool flag2 = (ZoneTowerStardust = false);
		bool flag4 = flag2;
		flag2 = (ZoneTowerNebula = flag4);
		bool flag6 = flag2;
		flag2 = (ZoneTowerVortex = flag6);
		bool zoneTowerSolar = flag2;
		ZoneTowerSolar = zoneTowerSolar;
		ZoneOldOneArmy = false;
		Vector2 val2 = Vector2.Zero;
		Vector2 val3 = Vector2.Zero;
		Vector2 val4 = Vector2.Zero;
		Vector2 val5 = Vector2.Zero;
		_ = Vector2.Zero;
		for (int i = 0; i < 200; i++)
		{
			if (!Main.npc[i].active)
			{
				continue;
			}
			if (Main.npc[i].type == 493)
			{
				if (Distance(Main.npc[i].Center) <= 4000f)
				{
					ZoneTowerStardust = true;
					val5 = Main.npc[i].Center;
				}
			}
			else if (Main.npc[i].type == 507)
			{
				if (Distance(Main.npc[i].Center) <= 4000f)
				{
					ZoneTowerNebula = true;
					val4 = Main.npc[i].Center;
				}
			}
			else if (Main.npc[i].type == 422)
			{
				if (Distance(Main.npc[i].Center) <= 4000f)
				{
					ZoneTowerVortex = true;
					val3 = Main.npc[i].Center;
				}
			}
			else if (Main.npc[i].type == 517)
			{
				if (Distance(Main.npc[i].Center) <= 4000f)
				{
					ZoneTowerSolar = true;
					val2 = Main.npc[i].Center;
				}
			}
			else if (Main.npc[i].type == 549 && Distance(Main.npc[i].Center) <= 4000f)
			{
				ZoneOldOneArmy = true;
				val2 = Main.npc[i].Center;
			}
		}
		float num = 1f;
		float num2 = 1f;
		float num3 = Main.shimmerAlpha;
		if (CanSeeShimmerEffects())
		{
			num *= 1f;
			num2 *= 0.7f;
			if (num3 < 1f)
			{
				num3 += 0.025f;
				if (num3 > 1f)
				{
					num3 = 1f;
				}
			}
			if (num3 >= 0.5f)
			{
				Main.shimmerDarken = MathHelper.Clamp(Main.shimmerDarken + 0.025f, 0f, 1f);
				Main.shimmerBrightenDelay = 4f;
			}
		}
		else if (num3 > 0f)
		{
			Main.shimmerDarken = MathHelper.Clamp(Main.shimmerDarken - 0.05f, 0f, 1f);
			if (Main.shimmerDarken == 0f && Main.shimmerBrightenDelay > 0f)
			{
				Main.shimmerBrightenDelay -= 1f;
			}
			if (Main.shimmerBrightenDelay == 0f)
			{
				num3 -= 0.05f;
			}
			if (num3 < 0f)
			{
				num3 = 0f;
			}
		}
		Main.shimmerAlpha = num3;
		if (Main.getGoodWorld)
		{
			bool flag8 = false;
			int num4 = NPC.FindFirstNPC(245);
			if (num4 >= 0 && Vector2.Distance(base.Center, Main.npc[num4].Center) < 2000f)
			{
				flag8 = true;
			}
			if (flag8)
			{
				num *= 0.6f;
				num2 *= 0.6f;
			}
			else if (ZoneLihzhardTemple)
			{
				num *= 0.88f;
				num2 *= 0.88f;
			}
			else if (ZoneDungeon)
			{
				num *= 0.94f;
				num2 *= 0.94f;
			}
		}
		if (num != airLightDecay)
		{
			if (airLightDecay >= num)
			{
				airLightDecay -= 0.005f;
				if (airLightDecay < num)
				{
					airLightDecay = num;
				}
			}
			else
			{
				airLightDecay += 0.005f;
				if (airLightDecay > num)
				{
					airLightDecay = num;
				}
			}
		}
		if (num2 != solidLightDecay)
		{
			if (solidLightDecay >= num2)
			{
				solidLightDecay -= 0.005f;
				if (solidLightDecay < num2)
				{
					solidLightDecay = num2;
				}
			}
			else
			{
				solidLightDecay += 0.005f;
				if (solidLightDecay > num2)
				{
					solidLightDecay = num2;
				}
			}
		}
		bool flag9 = ZoneRain && ZoneSnow;
		if (Main.remixWorld)
		{
			flag9 = (double)(position.Y / 16f) > Main.worldSurface && Main.raining && ZoneSnow;
		}
		bool flag10 = val.Y > Main.maxTilesY - 320;
		bool flag11 = ZoneOverworldHeight && (val.X < 380 || val.X > Main.maxTilesX - 380);
		LoaderManager.Get<BiomeLoader>().UpdateBiomes(this);
		ManageSpecialBiomeVisuals("Stardust", ZoneTowerStardust, val5 - new Vector2(0f, 10f));
		ManageSpecialBiomeVisuals("Nebula", ZoneTowerNebula, val4 - new Vector2(0f, 10f));
		ManageSpecialBiomeVisuals("Vortex", ZoneTowerVortex, val3 - new Vector2(0f, 10f));
		ManageSpecialBiomeVisuals("Solar", ZoneTowerSolar, val2 - new Vector2(0f, 10f));
		ManageSpecialBiomeVisuals("MoonLord", NPC.AnyNPCs(398));
		ManageSpecialBiomeVisuals("BloodMoon", Main.bloodMoon || Main.SceneMetrics.BloodMoonMonolith || bloodMoonMonolithShader);
		ManageSpecialBiomeVisuals("Blizzard", Main.UseStormEffects && flag9);
		ManageSpecialBiomeVisuals("HeatDistortion", Main.UseHeatDistortion && (flag10 || ((double)val.Y < Main.worldSurface && ZoneDesert && !flag11 && !Main.raining && !Filters.Scene["Sandstorm"].IsActive())));
		if (Main.GraveyardVisualIntensity > 0f)
		{
			if (!Filters.Scene["Graveyard"].IsActive())
			{
				Filters.Scene.Activate("Graveyard", default(Vector2));
			}
			else
			{
				Filters.Scene["Graveyard"].GetShader().UseTargetPosition(base.Center);
				float progress = MathHelper.Lerp(0f, 0.75f, Main.GraveyardVisualIntensity);
				Filters.Scene["Graveyard"].GetShader().UseProgress(progress);
				Filters.Scene["Graveyard"].GetShader().UseIntensity(1.2f);
			}
		}
		else if (Filters.Scene["Graveyard"].IsActive())
		{
			Filters.Scene.Deactivate("Graveyard");
		}
		if (!Filters.Scene["Sepia"].IsActive() && dontStarveShader)
		{
			Filters.Scene.Activate("Sepia", default(Vector2));
		}
		else if (Filters.Scene["Sepia"].IsActive() && !dontStarveShader)
		{
			Filters.Scene.Deactivate("Sepia");
		}
		if (!Filters.Scene["WaterDistortion"].IsActive() && Main.WaveQuality > 0)
		{
			Filters.Scene.Activate("WaterDistortion", default(Vector2));
		}
		else if (Filters.Scene["WaterDistortion"].IsActive() && Main.WaveQuality == 0)
		{
			Filters.Scene.Deactivate("WaterDistortion");
		}
		if (Filters.Scene["WaterDistortion"].IsActive())
		{
			float num5 = (float)Main.maxTilesX * 0.5f - Math.Abs((float)val.X - (float)Main.maxTilesX * 0.5f);
			float num6 = 1f;
			float num7 = Math.Abs(Main.windSpeedCurrent);
			num6 += num7 * 1.25f;
			float num8 = MathHelper.Clamp(Main.maxRaining, 0f, 1f);
			num6 += num8 * 1.25f;
			float num9 = 0f - (MathHelper.Clamp((num5 - 380f) / 100f, 0f, 1f) * 0.5f - 0.25f);
			num6 += num9;
			float num10 = 1f - MathHelper.Clamp(3f * ((float)((double)val.Y - Main.worldSurface) / (float)(Main.rockLayer - Main.worldSurface)), 0f, 1f);
			num6 *= num10;
			float num11 = 0.9f - MathHelper.Clamp((float)(Main.maxTilesY - val.Y - 200) / 300f, 0f, 1f) * 0.9f;
			num6 += num11;
			num6 += (1f - num10) * 0.75f;
			num6 = MathHelper.Clamp(num6, 0f, 2.5f);
			Filters.Scene["WaterDistortion"].GetShader().UseIntensity(num6);
		}
		if (flag10)
		{
			float val6 = (float)(val.Y - (Main.maxTilesY - 320)) / 120f;
			val6 = Math.Min(1f, val6) * 2f;
			Filters.Scene["HeatDistortion"].GetShader().UseIntensity(val6);
		}
		_shaderObstructionInternalValue = Utils.Clamp(_shaderObstructionInternalValue + (float)behindBackWall.ToDirectionInt() * -0.005f, -0.1f, 1.1f);
		_stormShaderObstruction = Utils.Clamp(_shaderObstructionInternalValue, 0f, 1f);
		if (Filters.Scene["Sandstorm"].IsActive())
		{
			Filters.Scene["Sandstorm"].GetShader().UseIntensity(_stormShaderObstruction * 0.4f * Math.Min(1f, Sandstorm.Severity));
			Filters.Scene["Sandstorm"].GetShader().UseOpacity(Math.Min(1f, Sandstorm.Severity * 1.5f) * _stormShaderObstruction);
			((SimpleOverlay)Overlays.Scene["Sandstorm"]).GetShader().UseOpacity(Math.Min(1f, Sandstorm.Severity * 1.5f) * (1f - _stormShaderObstruction));
		}
		else if (ZoneDesert && !flag11 && !Main.raining && !flag10)
		{
			Vector3 val7 = ((Color)(ref Main.tileColor)).ToVector3();
			float num12 = (val7.X + val7.Y + val7.Z) / 3f;
			float num13 = _stormShaderObstruction * 4f * Math.Max(0f, 0.5f - Main.cloudAlpha) * num12;
			Filters.Scene["HeatDistortion"].GetShader().UseIntensity(num13);
			if (num13 <= 0f)
			{
				Filters.Scene["HeatDistortion"].IsHidden = true;
			}
			else
			{
				Filters.Scene["HeatDistortion"].IsHidden = false;
			}
		}
		if (!disabledBlizzardGraphic)
		{
			try
			{
				if (flag9)
				{
					float cloudAlpha = Main.cloudAlpha;
					if (Main.remixWorld)
					{
						Main.cloudAlpha = 0.4f;
					}
					bool value = NPC.IsADeerclopsNearScreen();
					_deerclopsBlizzardSmoothedEffect = MathHelper.Clamp(_deerclopsBlizzardSmoothedEffect + (float)value.ToDirectionInt() * 0.0033333334f, 0f, 1f);
					float num14 = Math.Min(1f, Main.cloudAlpha * 2f) * _stormShaderObstruction;
					float num15 = _stormShaderObstruction * 0.4f * Math.Min(1f, Main.cloudAlpha * 2f) * 0.9f + 0.1f;
					num15 = MathHelper.Lerp(num15, num15 * 0.5f, _deerclopsBlizzardSmoothedEffect);
					num14 = MathHelper.Lerp(num14, num14 * 0.5f, _deerclopsBlizzardSmoothedEffect);
					Filters.Scene["Blizzard"].GetShader().UseIntensity(num15);
					Filters.Scene["Blizzard"].GetShader().UseOpacity(num14);
					((SimpleOverlay)Overlays.Scene["Blizzard"]).GetShader().UseOpacity(1f - num14);
					if (Main.remixWorld)
					{
						Main.cloudAlpha = cloudAlpha;
					}
				}
			}
			catch
			{
				disabledBlizzardGraphic = true;
			}
		}
		if (!disabledBlizzardSound)
		{
			try
			{
				if (flag9)
				{
					ActiveSound? activeSound = SoundEngine.GetActiveSound(_strongBlizzardSound);
					ActiveSound activeSound2 = SoundEngine.GetActiveSound(_insideBlizzardSound);
					if (activeSound == null)
					{
						_strongBlizzardSound = SoundEngine.PlayTrackedSound(in SoundID.BlizzardStrongLoop);
					}
					if (activeSound2 == null)
					{
						_insideBlizzardSound = SoundEngine.PlayTrackedSound(in SoundID.BlizzardInsideBuildingLoop);
					}
					SoundEngine.GetActiveSound(_strongBlizzardSound);
					activeSound2 = SoundEngine.GetActiveSound(_insideBlizzardSound);
				}
				if (flag9)
				{
					_blizzardSoundVolume = Math.Min(_blizzardSoundVolume + 0.01f, 1f);
				}
				else
				{
					_blizzardSoundVolume = Math.Max(_blizzardSoundVolume - 0.01f, 0f);
				}
				float num16 = Math.Min(1f, Main.cloudAlpha * 2f) * _stormShaderObstruction;
				ActiveSound activeSound3 = SoundEngine.GetActiveSound(_strongBlizzardSound);
				ActiveSound activeSound4 = SoundEngine.GetActiveSound(_insideBlizzardSound);
				if (_blizzardSoundVolume > 0f)
				{
					if (activeSound3 == null)
					{
						_strongBlizzardSound = SoundEngine.PlayTrackedSound(in SoundID.BlizzardStrongLoop);
						activeSound3 = SoundEngine.GetActiveSound(_strongBlizzardSound);
					}
					activeSound3.Volume = num16 * _blizzardSoundVolume;
					if (activeSound4 == null)
					{
						_insideBlizzardSound = SoundEngine.PlayTrackedSound(in SoundID.BlizzardInsideBuildingLoop);
						activeSound4 = SoundEngine.GetActiveSound(_insideBlizzardSound);
					}
					activeSound4.Volume = (1f - num16) * _blizzardSoundVolume;
				}
				else
				{
					if (activeSound3 != null)
					{
						activeSound3.Volume = 0f;
					}
					else
					{
						_strongBlizzardSound = SlotId.Invalid;
					}
					if (activeSound4 != null)
					{
						activeSound4.Volume = 0f;
					}
					else
					{
						_insideBlizzardSound = SlotId.Invalid;
					}
				}
			}
			catch
			{
				disabledBlizzardSound = true;
			}
		}
		ZonePurity = InZonePurity();
		if (!dead)
		{
			Point val8 = base.Center.ToTileCoordinates();
			if (WorldGen.InWorld(val8.X, val8.Y, 1))
			{
				int num17 = 0;
				if (Main.tile[val8.X, val8.Y] != null)
				{
					num17 = Main.tile[val8.X, val8.Y].wall;
				}
				switch (num17)
				{
				case 86:
					AchievementsHelper.HandleSpecialEvent(this, 12);
					break;
				case 62:
					AchievementsHelper.HandleSpecialEvent(this, 13);
					break;
				}
			}
			if (_funkytownAchievementCheckCooldown > 0)
			{
				_funkytownAchievementCheckCooldown--;
			}
			if (Main.specialSeedWorld)
			{
				AchievementsHelper.HandleSpecialEvent(this, 26);
			}
			if (position.Y / 16f > (float)Main.UnderworldLayer)
			{
				AchievementsHelper.HandleSpecialEvent(this, 14);
			}
			else if (_funkytownAchievementCheckCooldown == 0 && (double)(position.Y / 16f) < Main.worldSurface && ZoneGlowshroom)
			{
				AchievementsHelper.HandleSpecialEvent(this, 15);
			}
			else if (_funkytownAchievementCheckCooldown == 0 && ZoneGraveyard)
			{
				AchievementsHelper.HandleSpecialEvent(this, 18);
			}
		}
		else
		{
			_funkytownAchievementCheckCooldown = 100;
		}
		LoaderManager.Get<SceneEffectLoader>().UpdateSceneEffect(this);
	}

	private void TrySpawningFaelings()
	{
		if (!_wasInShimmerZone && ZoneShimmer && Main.netMode != 1)
		{
			NPC.SpawnFaelings(whoAmI);
		}
		_wasInShimmerZone = ZoneShimmer;
	}

	public void ManageSpecialBiomeVisuals(string biomeName, bool inZone, Vector2 activationSource = default(Vector2))
	{
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		if (SkyManager.Instance[biomeName] != null && inZone != SkyManager.Instance[biomeName].IsActive())
		{
			if (inZone)
			{
				SkyManager.Instance.Activate(biomeName, activationSource);
			}
			else
			{
				SkyManager.Instance.Deactivate(biomeName);
			}
		}
		if (inZone != Filters.Scene[biomeName].IsActive())
		{
			if (inZone)
			{
				Filters.Scene.Activate(biomeName, activationSource);
			}
			else
			{
				Filters.Scene[biomeName].Deactivate();
			}
		}
		else if (inZone)
		{
			Filters.Scene[biomeName].GetShader().UseTargetPosition(activationSource);
		}
		if (Overlays.Scene[biomeName] != null && inZone != (Overlays.Scene[biomeName].Mode != OverlayMode.Inactive))
		{
			if (inZone)
			{
				Overlays.Scene.Activate(biomeName, activationSource);
			}
			else
			{
				Overlays.Scene[biomeName].Deactivate();
			}
		}
	}

	public void GetHairSettings(out bool fullHair, out bool hatHair, out bool hideHair, out bool backHairDraw, out bool drawsBackHairWithoutHeadgear)
	{
		fullHair = head >= 0 && ArmorIDs.Head.Sets.DrawFullHair[head];
		hatHair = head >= 0 && ArmorIDs.Head.Sets.DrawHatHair[head];
		hideHair = (face >= 0 && ArmorIDs.Face.Sets.PreventHairDraw[face]) || (faceHead >= 0 && head != 0);
		backHairDraw = hair >= 0 && HairID.Sets.DrawBackHair[hair];
		drawsBackHairWithoutHeadgear = head >= 0 && ArmorIDs.Head.Sets.DrawsBackHairWithoutHeadgear[head];
	}

	public void UpdateDead()
	{
		//IL_02cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_02dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_02fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0301: Unknown result type (might be due to invalid IL or missing references)
		//IL_0306: Unknown result type (might be due to invalid IL or missing references)
		//IL_030b: Unknown result type (might be due to invalid IL or missing references)
		shimmerUnstuckHelper.Clear();
		timeShimmering = 0;
		forcedGravity = 0;
		_portalPhysicsTime = 0;
		MountFishronSpecialCounter = 0f;
		gem = -1;
		ownedLargeGems = (byte)0;
		brainOfConfusionDodgeAnimationCounter = 0;
		ResetFloorFlags();
		wings = 0;
		wingsLogic = 0;
		equippedWings = null;
		selectItemOnNextUse = false;
		ResetVisibleAccessories();
		poisoned = false;
		venom = false;
		onFire = false;
		dripping = false;
		drippingSlime = false;
		drippingSparkleSlime = false;
		hungry = false;
		heartyMeal = false;
		starving = false;
		burned = false;
		suffocating = false;
		onFire2 = false;
		onFire3 = false;
		onFrostBurn = false;
		onFrostBurn2 = false;
		shimmering = false;
		blind = false;
		blackout = false;
		loveStruck = false;
		dryadWard = false;
		stinky = false;
		resistCold = false;
		electrified = false;
		moonLeech = false;
		headcovered = false;
		vortexDebuff = false;
		windPushed = false;
		setForbidden = false;
		setMonkT3 = false;
		setHuntressT3 = false;
		setApprenticeT3 = false;
		setSquireT3 = false;
		setForbiddenCooldownLocked = false;
		setSolar = (setVortex = (setNebula = (setStardust = false)));
		nebulaLevelDamage = (nebulaLevelLife = (nebulaLevelMana = 0));
		trapDebuffSource = false;
		yoraiz0rEye = 0;
		yoraiz0rDarkness = false;
		hasFloatingTube = false;
		hasUnicornHorn = false;
		hasAngelHalo = false;
		hasRainbowCursor = false;
		leinforsHair = false;
		overrideFishingBobber = -1;
		gravDir = 1f;
		PlayerLoader.UpdateDead(this);
		for (int i = 0; i < maxBuffs; i++)
		{
			if (buffType[i] <= 0 || !Main.persistentBuff[buffType[i]])
			{
				buffTime[i] = 0;
				buffType[i] = 0;
			}
		}
		if (whoAmI == Main.myPlayer)
		{
			Main.npcChatText = "";
			Main.editSign = false;
			Main.npcChatCornerItem = 0;
		}
		numMinions = 0;
		grappling[0] = -1;
		grappling[1] = -1;
		grappling[2] = -1;
		sign = -1;
		SetTalkNPC(-1);
		statLife = 0;
		channel = false;
		potionDelay = 0;
		chest = -1;
		tileEntityAnchor.Clear();
		changeItem = -1;
		itemAnimation = 0;
		immuneAlpha += 2;
		if (immuneAlpha > 255)
		{
			immuneAlpha = 255;
		}
		headPosition += headVelocity;
		bodyPosition += bodyVelocity;
		legPosition += legVelocity;
		headRotation += headVelocity.X * 0.1f;
		bodyRotation += bodyVelocity.X * 0.1f;
		legRotation += legVelocity.X * 0.1f;
		headVelocity.Y += 0.1f;
		bodyVelocity.Y += 0.1f;
		legVelocity.Y += 0.1f;
		headVelocity.X *= 0.99f;
		bodyVelocity.X *= 0.99f;
		legVelocity.X *= 0.99f;
		for (int j = 0; j < npcTypeNoAggro.Length; j++)
		{
			npcTypeNoAggro[j] = false;
		}
		if (difficulty == 2)
		{
			if (respawnTimer > 0)
			{
				respawnTimer = Utils.Clamp(respawnTimer - 1, 0, 3600);
			}
			else if (whoAmI == Main.myPlayer || Main.netMode == 2)
			{
				ghost = true;
			}
		}
		else
		{
			respawnTimer = Utils.Clamp(respawnTimer - 1, 0, 3600);
			if (respawnTimer <= 0 && Main.myPlayer == whoAmI)
			{
				if (Main.mouseItem.type > 0)
				{
					Main.playerInventory = true;
				}
				Spawn(PlayerSpawnContext.ReviveFromDeath);
			}
		}
		if (whoAmI == Main.myPlayer && !Main.drawingPlayerChat && !Main.editSign && !Main.editChest && !Main.blockInput)
		{
			PlayerInput.Triggers.Current.CopyInto(this);
			TryOpeningInGameOptionsBasedOnInput();
		}
	}

	private void TryOpeningInGameOptionsBasedOnInput()
	{
		if (controlInv)
		{
			if (releaseInventory)
			{
				releaseInventory = false;
				if (Main.ingameOptionsWindow)
				{
					IngameOptions.Close();
				}
				else
				{
					IngameOptions.Open();
				}
			}
		}
		else
		{
			releaseInventory = true;
		}
	}

	public void UpdatePet(int i)
	{
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		if (i == Main.myPlayer && miscEquips[0].buffType >= 1 && miscEquips[0].stack >= 1)
		{
			int num = miscEquips[0].buffType;
			if ((Main.vanityPet[num] || Main.lightPet[num]) && !hideMisc[0] && (miscEquips[0].type != 603 || Main.runningCollectorsEdition) && FindBuffIndex(num) == -1)
			{
				AddBuff(num, 3600);
				SoundEngine.PlaySound(miscEquips[0].UseSound, position);
			}
		}
	}

	public void UpdatePetLight(int i)
	{
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		if (i != Main.myPlayer || miscEquips[1].buffType < 1 || miscEquips[1].stack < 1)
		{
			return;
		}
		int num = miscEquips[1].buffType;
		if ((!Main.vanityPet[num] && !Main.lightPet[num]) || hideMisc[1] || (miscEquips[1].type == 603 && !Main.runningCollectorsEdition))
		{
			return;
		}
		int num2 = FindBuffIndex(num);
		if (num == 27 && num2 == -1)
		{
			num2 = FindBuffIndex(102);
		}
		if (num == 27 && num2 == -1)
		{
			num2 = FindBuffIndex(101);
		}
		if (num2 == -1)
		{
			if (num == 27)
			{
				num = Utils.SelectRandom<int>(Main.rand, 27, 102, 101);
			}
			AddBuff(num, 3600);
			SoundEngine.PlaySound(miscEquips[1].UseSound, position);
		}
	}

	public void TogglePet()
	{
		hideMisc[0] = !hideMisc[0];
		if (hideMisc[0])
		{
			ClearBuff(miscEquips[0].buffType);
		}
	}

	public void ToggleLight()
	{
		hideMisc[1] = !hideMisc[1];
		if (hideMisc[1])
		{
			ClearBuff(miscEquips[1].buffType);
			if (miscEquips[1].buffType == 27)
			{
				ClearBuff(102);
				ClearBuff(101);
			}
		}
	}

	public bool IsWithinSnappngRangeToTile(int x, int y, int distanceInPixels)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		Vector2 val = new Vector2((float)(x * 16 + 8), (float)(y * 16 + 8)) - new Vector2(base.Center.X, base.Bottom.Y - 16f);
		if (((Vector2)(ref val)).Length() <= (float)distanceInPixels)
		{
			return true;
		}
		return false;
	}

	public void SmartInteractLookup()
	{
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		Main.ClearSmartInteract();
		if (UILinkPointNavigator.InUse || (PlayerInput.UsingGamepad && Main.HoveringOverAnNPC))
		{
			Main.SmartInteractTileCoordsSelected.Clear();
		}
		bool showGamepadHints = PlayerInput.SettingsForUI.ShowGamepadHints;
		bool flag = showGamepadHints || Main.SmartCursorIsUsed;
		if (!flag && !showGamepadHints)
		{
			_smartInteractSys.Clear();
			return;
		}
		SmartInteractLookup_PrepareCommonlyUsedInfo(out var mousevec, out var LX, out var HX, out var LY, out var HY);
		_smartInteractSys.RunQuery(new SmartInteractScanSettings
		{
			DemandOnlyZeroDistanceTargets = (PlayerInput.SettingsForUI.ShowGamepadHints && !Main.SmartCursorIsUsed),
			FullInteraction = flag,
			HX = HX,
			HY = HY,
			LX = LX,
			LY = LY,
			mousevec = mousevec,
			player = this
		});
	}

	private void SmartInteractLookup_PrepareCommonlyUsedInfo(out Vector2 mousevec, out int LX, out int HX, out int LY, out int HY)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		mousevec = Main.ReverseGravitySupport(Main.MouseScreen) + Main.screenPosition;
		int num = 0;
		LX = (int)(position.X / 16f) - tileRangeX - num + 1;
		HX = (int)((position.X + (float)width) / 16f) + tileRangeX + num - 1;
		LY = (int)(position.Y / 16f) - tileRangeY - num + 1;
		HY = (int)((position.Y + (float)height) / 16f) + tileRangeY + num - 2;
		LX = Utils.Clamp(LX, 10, Main.maxTilesX - 10);
		HX = Utils.Clamp(HX, 10, Main.maxTilesX - 10);
		LY = Utils.Clamp(LY, 10, Main.maxTilesY - 10);
		HY = Utils.Clamp(HY, 10, Main.maxTilesY - 10);
	}

	public void SmartSelectLookup()
	{
		if (selectedItem == 58)
		{
			return;
		}
		if (mouseInterface)
		{
			controlTorch = false;
		}
		if (controlTorch && itemAnimation == 0)
		{
			PlayerInput.smartSelectPointer.SmartSelectLookup_GetTargetTile(this, out var tX, out var tY);
			SmartSelect_GetToolStrategy(tX, tY, out var toolStrategy, out var wetTile);
			if (PlayerInput.UsingGamepad && _lastSmartCursorToolStrategy != -1)
			{
				toolStrategy = _lastSmartCursorToolStrategy;
			}
			if (toolStrategy == 0 || toolStrategy == 4)
			{
				float num = Math.Abs((float)Main.mouseX + Main.screenPosition.X - (position.X + (float)(width / 2)));
				float num2 = Math.Abs((float)Main.mouseY + Main.screenPosition.Y - (position.Y + (float)(height / 2))) * 1.3f;
				if ((float)Math.Sqrt(num * num + num2 * num2) > 200f)
				{
					toolStrategy = 5;
				}
			}
			int num3 = TileLoader.AutoSelect(tX, tY, this);
			if (num3 >= 0)
			{
				SmartSelect_SelectItem(num3);
				return;
			}
			SmartSelect_PickToolForStrategy(tX, tY, toolStrategy, wetTile);
			_lastSmartCursorToolStrategy = toolStrategy;
		}
		else if (itemAnimation == 0 && DpadRadial.SelectedItem != -1 && inventory[DpadRadial.SelectedItem].stack > 0)
		{
			if (nonTorch == -1)
			{
				nonTorch = selectedItem;
			}
			selectedItem = DpadRadial.SelectedItem;
			_lastSmartCursorToolStrategy = -1;
		}
		else if (itemAnimation == 0 && CircularRadial.SelectedItem != -1 && inventory[CircularRadial.SelectedItem].stack > 0)
		{
			if (nonTorch == -1)
			{
				nonTorch = selectedItem;
			}
			selectedItem = CircularRadial.SelectedItem;
			_lastSmartCursorToolStrategy = -1;
		}
		else if (nonTorch > -1 && itemAnimation == 0)
		{
			selectedItem = nonTorch;
			nonTorch = -1;
			_lastSmartCursorToolStrategy = -1;
		}
	}

	private void SmartSelectLookup_GetTargetTile(out int tX, out int tY)
	{
		tX = (int)(((float)Main.mouseX + Main.screenPosition.X) / 16f);
		tY = (int)(((float)Main.mouseY + Main.screenPosition.Y) / 16f);
		if (gravDir == -1f)
		{
			tY = (int)((Main.screenPosition.Y + (float)Main.screenHeight - (float)Main.mouseY) / 16f);
		}
	}

	private void SmartSelect_PickToolForStrategy(int tX, int tY, int toolStrategy, bool wetTile)
	{
		for (int i = 0; i < 50; i++)
		{
			int type = inventory[i].type;
			switch (toolStrategy)
			{
			case 0:
				if (ItemID.Sets.Torches[type])
				{
					SmartSelect_SelectItem(i);
					return;
				}
				if (ItemID.Sets.Glowsticks[type])
				{
					SmartSelect_SelectItem(i);
				}
				break;
			case 1:
				if (inventory[i].hammer > 0)
				{
					SmartSelect_SelectItem(i);
					return;
				}
				break;
			case 2:
				if (inventory[i].axe > 0)
				{
					SmartSelect_SelectItem(i);
					return;
				}
				break;
			case 3:
				if (inventory[i].pick > 0)
				{
					SmartSelect_SelectItem(i);
					return;
				}
				break;
			case 4:
				if (inventory[i].type != 930 && ItemID.Sets.Torches[type] && !ItemID.Sets.WaterTorches[type] && !ItemID.Sets.Glowsticks[type])
				{
					if (nonTorch == -1)
					{
						nonTorch = selectedItem;
					}
					if (inventory[selectedItem].createTile < 0 || !TileID.Sets.Torch[inventory[selectedItem].createTile])
					{
						selectedItem = i;
					}
					break;
				}
				if (ItemID.Sets.Glowsticks[type] && wetTile)
				{
					SmartSelect_SelectItem(i);
					return;
				}
				if (type == 930 && wetTile)
				{
					bool flag2 = false;
					for (int num3 = 57; num3 >= 0; num3--)
					{
						if (inventory[num3].ammo == inventory[i].useAmmo && inventory[num3].stack > 0)
						{
							flag2 = true;
							break;
						}
					}
					if (!flag2 && !ItemLoader.NeedsAmmo(inventory[i], this))
					{
						flag2 = true;
					}
					if (flag2)
					{
						SmartSelect_SelectItem(i);
						return;
					}
				}
				else if (ItemID.Sets.WaterTorches[type])
				{
					SmartSelect_SelectItem(i);
					return;
				}
				break;
			case 5:
			{
				if (ItemID.Sets.Torches[type])
				{
					if (nonTorch == -1)
					{
						nonTorch = selectedItem;
					}
					if (inventory[selectedItem].createTile < 0 || !TileID.Sets.Torch[inventory[selectedItem].createTile])
					{
						selectedItem = i;
					}
					break;
				}
				int num = type;
				switch (num)
				{
				case 930:
				{
					bool flag = false;
					for (int num2 = 57; num2 >= 0; num2--)
					{
						if (inventory[num2].ammo == inventory[i].useAmmo && inventory[num2].stack > 0)
						{
							flag = true;
							break;
						}
					}
					if (flag)
					{
						SmartSelect_SelectItem(i);
						return;
					}
					goto end_IL_0016;
				}
				default:
					if (!ItemID.Sets.Glowsticks[num])
					{
						goto end_IL_0016;
					}
					break;
				case 282:
				case 286:
				case 3002:
				case 3112:
				case 4776:
					break;
				}
				SmartSelect_SelectItem(i);
				return;
			}
			case 6:
			{
				int num4 = Main.tile[tX, tY].frameX / 72;
				int num5 = -1;
				switch (num4)
				{
				case 0:
					num5 = 929;
					break;
				case 1:
					num5 = 1338;
					break;
				case 2:
					num5 = 1345;
					break;
				}
				if (type == num5)
				{
					SmartSelect_SelectItem(i);
					return;
				}
				break;
			}
			case 7:
			{
				ItemTrader itemTrader = TryGettingItemTraderFromBlock(Main.tile[tX, tY]);
				if (itemTrader != null && itemTrader.TryGetTradeOption(inventory[i], out var _))
				{
					SmartSelect_SelectItem(i);
					return;
				}
				if (ItemID.Sets.ExtractinatorMode[type] >= 0)
				{
					SmartSelect_SelectItem(i);
					return;
				}
				break;
			}
			case 8:
				{
					if (ItemID.Sets.IsPaintScraper[type])
					{
						SmartSelect_SelectItem(i);
						return;
					}
					break;
				}
				end_IL_0016:
				break;
			}
		}
	}

	private void SmartSelect_SelectItem(int t)
	{
		if (nonTorch == -1)
		{
			nonTorch = selectedItem;
		}
		selectedItem = t;
	}

	private void SmartSelect_GetToolStrategy(int tX, int tY, out int toolStrategy, out bool wetTile)
	{
		toolStrategy = 0;
		bool flag = false;
		wetTile = false;
		try
		{
			int num = 0;
			int num2 = 0;
			if (position.X / 16f >= (float)tX)
			{
				num = (int)(position.X / 16f) - tX;
			}
			if ((position.X + (float)width) / 16f <= (float)tX)
			{
				num = tX - (int)((position.X + (float)width) / 16f);
			}
			if (position.Y / 16f >= (float)tY)
			{
				num2 = (int)(position.Y / 16f) - tY;
			}
			if ((position.Y + (float)height) / 16f <= (float)tY)
			{
				num2 = tY - (int)((position.Y + (float)height) / 16f);
			}
			SmartSelect_GetAvailableToolRanges(out var pickRange, out var axeRange, out var hammerRange, out var cannonRange, out var extractItemRange, out var paintScraperRange);
			wetTile = Main.tile[tX, tY].liquid > 0;
			if (Main.tile[tX, tY].active())
			{
				int type = Main.tile[tX, tY].type;
				if ((type == 219 || type == 642) && num <= extractItemRange + tileRangeX && num2 <= extractItemRange + tileRangeY)
				{
					toolStrategy = 7;
					flag = true;
				}
				else if (type == 209 && num <= cannonRange + tileRangeX && num2 <= cannonRange + tileRangeY)
				{
					toolStrategy = 6;
					flag = true;
				}
				else if (Main.tileHammer[type] && num <= hammerRange + tileRangeX && num2 <= hammerRange + tileRangeY)
				{
					toolStrategy = 1;
					flag = true;
				}
				else if (Main.tileAxe[type] && num <= axeRange + tileRangeX && num2 <= axeRange + tileRangeY)
				{
					toolStrategy = 2;
					flag = true;
				}
				else if (type == 184 && num <= paintScraperRange + tileRangeX && num2 <= paintScraperRange + tileRangeY)
				{
					toolStrategy = 8;
					flag = true;
				}
				else if (num <= pickRange + tileRangeX && num2 <= pickRange + tileRangeY)
				{
					toolStrategy = 3;
					flag = true;
				}
			}
			else if (wetTile && wet)
			{
				toolStrategy = 4;
				flag = true;
			}
		}
		catch
		{
		}
		if (!flag && wet)
		{
			toolStrategy = 4;
		}
	}

	private void SmartSelect_GetAvailableToolRanges(out int pickRange, out int axeRange, out int hammerRange, out int cannonRange, out int extractItemRange, out int paintScraperRange)
	{
		pickRange = -10;
		axeRange = -10;
		hammerRange = -10;
		cannonRange = -10;
		extractItemRange = -10;
		paintScraperRange = -10;
		for (int i = 0; i < 50; i++)
		{
			if (inventory[i].pick > 0 && pickRange == -10)
			{
				pickRange = inventory[i].tileBoost;
			}
			if (inventory[i].axe > 0 && axeRange == -10)
			{
				axeRange = inventory[i].tileBoost;
			}
			if (inventory[i].hammer > 0 && hammerRange == -10)
			{
				hammerRange = inventory[i].tileBoost;
			}
			if ((inventory[i].type == 929 || inventory[i].type == 1338 || inventory[i].type == 1345) && cannonRange == -10)
			{
				cannonRange = inventory[i].tileBoost;
			}
			if (ItemID.Sets.IsPaintScraper[inventory[i].type] && paintScraperRange == -10)
			{
				paintScraperRange = inventory[i].tileBoost;
			}
			if (ItemID.Sets.ExtractinatorMode[inventory[i].type] != -1 && extractItemRange == -10)
			{
				extractItemRange = inventory[i].tileBoost;
			}
		}
	}

	private void EndOngoingTorchGodEvent()
	{
		if (happyFunTorchTime)
		{
			RelightTorches();
			happyFunTorchTime = false;
			if (Main.netMode == 1)
			{
				NetMessage.SendData(4, -1, -1, null, whoAmI);
			}
		}
	}

	private void TryRecalculatingTorchLuck()
	{
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fc: Unknown result type (might be due to invalid IL or missing references)
		if (happyFunTorchTime)
		{
			luckyTorchCounter = 0;
			TorchAttack();
			return;
		}
		if (torchGodCooldown > 0)
		{
			torchGodCooldown--;
		}
		Vector2 nextTorchLuckCheckCenter = _nextTorchLuckCheckCenter;
		if (((double)nextTorchLuckCheckCenter.Y < Main.worldSurface * 16.0) | dead)
		{
			UpdateTorchLuck_ConsumeCountersAndCalculate();
			return;
		}
		int num = 1;
		int num2 = 40;
		int num3 = (int)nextTorchLuckCheckCenter.Y / 16 - num2;
		int value = (int)nextTorchLuckCheckCenter.X / 16 - num2;
		int value2 = (int)nextTorchLuckCheckCenter.X / 16 + num2;
		value = Utils.Clamp(value, 10, Main.maxTilesX - 10);
		value2 = Utils.Clamp(value2, 10, Main.maxTilesX - 10);
		for (int i = 0; i < num; i++)
		{
			int num4 = num3 + i + luckyTorchCounter * num;
			if (num4 < 10 || num4 > Main.maxTilesY - 10)
			{
				continue;
			}
			for (int j = value; j <= value2; j++)
			{
				Tile tile = Main.tile[j, num4];
				if (tile == null)
				{
					return;
				}
				if (tile.type >= TileID.Count)
				{
					if (tile.active() && TileID.Sets.Torch[tile.type])
					{
						NearbyModTorch.Add(tile.type);
						if (tile.frameX < 66)
						{
							nearbyTorches++;
						}
					}
				}
				else
				{
					if (!tile.active() || tile.type != 4 || tile.frameX < 0 || tile.frameY < 0)
					{
						continue;
					}
					if (tile.frameX < 66)
					{
						nearbyTorches++;
					}
					int num5 = tile.frameY / 22;
					if (num5 < TorchID.Count)
					{
						nearbyTorch[num5] = true;
						if (num5 == 17 && (tile.liquid == 0 || tile.liquidType() != 0))
						{
							dryCoralTorch = true;
						}
					}
				}
			}
			if (num4 >= (int)nextTorchLuckCheckCenter.Y / 16 + num2)
			{
				UpdateTorchLuck_ConsumeCountersAndCalculate();
				return;
			}
		}
		luckyTorchCounter++;
	}

	private void RelightTorches()
	{
		torchGodCooldown = 3600;
		for (int i = 0; i < numberOfTorchAttacksMade; i++)
		{
			int num = unlitTorchX[i];
			int num2 = unlitTorchY[i];
			bool[] torch = TileID.Sets.Torch;
			Tile tile = Main.tile[num, num2];
			if (torch[tile.type])
			{
				tile = Main.tile[num, num2];
				if (tile.frameX >= 66)
				{
					tile = Main.tile[num, num2];
					tile.frameX -= 66;
					NetMessage.SendTileSquare(-1, num, num2);
				}
			}
		}
	}

	private void TorchAttack()
	{
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_0358: Unknown result type (might be due to invalid IL or missing references)
		//IL_035d: Unknown result type (might be due to invalid IL or missing references)
		//IL_035f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0364: Unknown result type (might be due to invalid IL or missing references)
		//IL_0376: Unknown result type (might be due to invalid IL or missing references)
		//IL_037a: Unknown result type (might be due to invalid IL or missing references)
		//IL_037f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0389: Unknown result type (might be due to invalid IL or missing references)
		//IL_038b: Unknown result type (might be due to invalid IL or missing references)
		if (whoAmI != Main.myPlayer)
		{
			return;
		}
		if ((double)position.Y < Main.worldSurface * 16.0)
		{
			EndOngoingTorchGodEvent();
			return;
		}
		AddBuff(80, 2);
		torchFunTimer++;
		if (torchFunTimer <= 20)
		{
			return;
		}
		torchFunTimer = 0;
		int num = 0;
		int num2 = 100;
		int value = (int)base.Center.X / 16 - num2;
		int value2 = (int)base.Center.X / 16 + num2;
		int value3 = (int)base.Center.Y / 16 - num2;
		int value4 = (int)base.Center.Y / 16 + num2;
		int num3 = Utils.Clamp(value, 10, Main.maxTilesX - 10);
		value2 = Utils.Clamp(value2, 10, Main.maxTilesX - 10);
		value3 = Utils.Clamp(value3, 10, Main.maxTilesY - 10);
		value4 = Utils.Clamp(value4, 10, Main.maxTilesY - 10);
		for (int i = num3; i <= value2; i++)
		{
			for (int j = value3; j <= value4; j++)
			{
				Tile tile = Main.tile[i, j];
				if (tile != null && (tile.active() & TileID.Sets.Torch[tile.type]) && tile.frameX < 66)
				{
					_torchAttackPosX[num] = i;
					_torchAttackPosY[num] = j;
					num++;
					if (num >= _torchAttackPosX.Length)
					{
						break;
					}
				}
			}
			if (num >= _torchAttackPosX.Length)
			{
				break;
			}
		}
		if (num == 0 || numberOfTorchAttacksMade >= maxTorchAttacks)
		{
			RelightTorches();
			happyFunTorchTime = false;
			if (Main.netMode == 1)
			{
				NetMessage.SendData(4, -1, -1, null, whoAmI);
			}
			if (numberOfTorchAttacksMade >= 95)
			{
				int number = Item.NewItem(GetItemSource_Misc(6), (int)position.X, (int)position.Y, width, height, 5043);
				if (Main.netMode == 1)
				{
					NetMessage.SendData(21, -1, -1, null, number, 1f);
				}
			}
		}
		else
		{
			if (num <= 0)
			{
				return;
			}
			int num4 = Main.rand.Next(num);
			int num5 = _torchAttackPosX[num4];
			int num6 = _torchAttackPosY[num4];
			bool[] torch = TileID.Sets.Torch;
			Tile tile2 = Main.tile[num5, num6];
			if (!torch[tile2.type])
			{
				return;
			}
			tile2 = Main.tile[num5, num6];
			if (tile2.frameX < 66)
			{
				float num7 = 8f;
				int num8 = 20;
				if (num8 < 10)
				{
					num8 = 10;
				}
				tile2 = Main.tile[num5, num6];
				int num9 = (int)MathHelper.Clamp((float)(tile2.frameY / 22), 0f, (float)(TorchID.Count - 1));
				num9 = TorchID.Dust[num9];
				tile2 = Main.tile[num5, num6];
				tile2.frameX += 66;
				unlitTorchX[numberOfTorchAttacksMade] = num5;
				unlitTorchY[numberOfTorchAttacksMade] = num6;
				numberOfTorchAttacksMade++;
				NetMessage.SendTileSquare(-1, num5, num6);
				Vector2 val = default(Vector2);
				((Vector2)(ref val))..ctor((float)(num5 * 16 + 8), (float)(num6 * 16));
				Vector2 val2 = base.Center - val;
				float num10 = ((Vector2)(ref val2)).Length();
				((Vector2)(ref val2)).Normalize();
				val2 *= num7;
				int num11 = Projectile.NewProjectile(GetProjectileSource_Misc(10), val, val2, 949, num8, 1f, whoAmI, num9, num10);
				Main.projectile[num11].ai[0] = num9;
				Main.projectile[num11].ai[1] = num10;
				Main.projectile[num11].netUpdate = true;
				if ((num == 1 && numberOfTorchAttacksMade >= 95) || numberOfTorchAttacksMade >= maxTorchAttacks)
				{
					torchFunTimer = -180;
				}
			}
		}
	}

	private void UpdateTorchLuck_ConsumeCountersAndCalculate()
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_0128: Unknown result type (might be due to invalid IL or missing references)
		luckyTorchCounter = 0;
		torchLuck = 0f;
		_nextTorchLuckCheckCenter = base.Center;
		if (inventory[selectedItem].createTile == 4 && inventory[selectedItem].placeStyle < TorchID.Count)
		{
			nearbyTorch[inventory[selectedItem].placeStyle] = true;
		}
		ModTile tile = TileLoader.GetTile(inventory[selectedItem].createTile);
		if (tile != null && TileID.Sets.Torch[tile.Type])
		{
			NearbyModTorch.Add(tile.Type);
		}
		float negativeLuck = 0f;
		float positiveLuck = 0f;
		if (!ZoneDungeon && !ZoneLihzhardTemple)
		{
			if (nearbyTorch[9])
			{
				if (ZoneSnow)
				{
					positiveLuck += 1f;
				}
				else
				{
					negativeLuck += 1f;
				}
			}
			if (nearbyTorch[16])
			{
				if (ZoneDesert)
				{
					positiveLuck += 1f;
				}
				else
				{
					negativeLuck += 1f;
				}
			}
			if (nearbyTorch[17])
			{
				if (WorldGen.oceanDepths((int)base.Center.X / 16, (int)base.Center.Y / 16))
				{
					positiveLuck += 1f;
				}
				else if (dryCoralTorch)
				{
					negativeLuck += 1f;
				}
			}
			if (nearbyTorch[21])
			{
				if (ZoneJungle)
				{
					positiveLuck += 1f;
				}
				else
				{
					negativeLuck += 1f;
				}
			}
			if (nearbyTorch[22])
			{
				if (ZoneGlowshroom)
				{
					positiveLuck += 1f;
				}
				else
				{
					negativeLuck += 1f;
				}
			}
			if (nearbyTorch[18])
			{
				if (ZoneCorrupt)
				{
					positiveLuck += 1f;
				}
				else
				{
					negativeLuck += 1f;
				}
			}
			if (nearbyTorch[8] && ZoneCorrupt)
			{
				positiveLuck += 1f;
			}
			if (nearbyTorch[19])
			{
				if (ZoneCrimson)
				{
					positiveLuck += 1f;
				}
				else
				{
					negativeLuck += 1f;
				}
			}
			if (nearbyTorch[11] && ZoneCrimson)
			{
				positiveLuck += 1f;
			}
			if (nearbyTorch[20])
			{
				if (ZoneHallow)
				{
					positiveLuck += 1f;
				}
				else
				{
					negativeLuck += 1f;
				}
			}
			if (nearbyTorch[13] && !ZoneSnow && !ZoneDesert && !ZoneCorrupt && !ZoneCrimson && !ZoneHallow && !ZoneJungle)
			{
				positiveLuck += 0.5f;
			}
			if (nearbyTorch[0])
			{
				if (ZoneSnow)
				{
					negativeLuck += 2f;
				}
				else if (ZoneDesert || ZoneCorrupt || ZoneCrimson || ZoneHallow)
				{
					negativeLuck += 0.5f;
				}
			}
		}
		TileLoader.ModifyTorchLuck(this, ref positiveLuck, ref negativeLuck);
		if (positiveLuck >= 1f)
		{
			torchLuck += 1f;
		}
		else if (positiveLuck > 0f)
		{
			torchLuck += 0.5f;
		}
		if (negativeLuck >= 2f)
		{
			torchLuck += -1.5f;
		}
		else if (negativeLuck >= 1f)
		{
			torchLuck += -1f;
		}
		else if (negativeLuck > 0f)
		{
			torchLuck += -0.5f;
		}
		dryCoralTorch = false;
		for (int i = 0; i < TorchID.Count; i++)
		{
			nearbyTorch[i] = false;
		}
		NearbyModTorch.Clear();
		if (torchLuck < 0f)
		{
			torchLuck = 0f;
		}
		if (torchGodCooldown <= 0 && !unlockedBiomeTorches && nearbyTorches > 100 && !happyFunTorchTime && (double)position.Y > Main.worldSurface * 16.0)
		{
			bool flag = false;
			for (int j = 0; j < inventory.Length; j++)
			{
				if (inventory[j].type == 5043)
				{
					flag = true;
					break;
				}
			}
			if (!flag)
			{
				happyFunTorchTime = true;
				numberOfTorchAttacksMade = 0;
			}
		}
		nearbyTorches = 0;
	}

	public void AddCoinLuck(Vector2 coinPosition, int coinAmount)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		if (!dead && Vector2.Distance(coinPosition, base.Center) < 1000f)
		{
			coinLuck += coinAmount;
			if (coinLuck > 1000000f)
			{
				coinLuck = 1000000f;
			}
			luckNeedsSync = true;
		}
	}

	private void UpdateCoinLuck()
	{
		if (!(coinLuck <= 0f))
		{
			coinLuck *= 0.9999f;
			if ((double)coinLuck < 0.25)
			{
				coinLuck = 0f;
			}
		}
	}

	private float CalculateCoinLuck()
	{
		if (coinLuck == 0f)
		{
			return 0f;
		}
		if (coinLuck > 249000f)
		{
			return 0.2f;
		}
		if (coinLuck > 24900f)
		{
			return 0.175f;
		}
		if (coinLuck > 24900f)
		{
			return 0.175f;
		}
		if (coinLuck > 2490f)
		{
			return 0.15f;
		}
		if (coinLuck > 249f)
		{
			return 0.125f;
		}
		if ((double)coinLuck > 24.9)
		{
			return 0.1f;
		}
		if ((double)coinLuck > 2.49)
		{
			return 0.075f;
		}
		if ((double)coinLuck > 0.249)
		{
			return 0.05f;
		}
		return 0.025f;
	}

	private float GetLadyBugLuck()
	{
		if (ladyBugLuckTimeLeft > 0.0)
		{
			return (float)ladyBugLuckTimeLeft / (float)NPC.ladyBugGoodLuckTime;
		}
		if (ladyBugLuckTimeLeft < 0.0)
		{
			return (0f - (float)ladyBugLuckTimeLeft) / (float)NPC.ladyBugBadLuckTime;
		}
		return 0f;
	}

	public static float GetClosestPlayersLuck(Point Position)
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		return Main.player[FindClosest(new Vector2((float)(Position.X * 16), (float)(Position.Y * 16)), 1, 1)].luck;
	}

	public static float GetClosestPlayersLuck(Vector2 Position)
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		return Main.player[FindClosest(Position, 1, 1)].luck;
	}

	public int RollLuck(int range)
	{
		if (luck > 0f && Main.rand.NextFloat() < luck)
		{
			return Main.rand.Next(Main.rand.Next(range / 2, range));
		}
		if (luck < 0f && Main.rand.NextFloat() < 0f - luck)
		{
			return Main.rand.Next(Main.rand.Next(range, range * 2));
		}
		return Main.rand.Next(range);
	}

	public static float GetClosestRollLuck(Vector2 position, int range)
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		return Main.player[FindClosest(position, 1, 1)].RollLuck(range);
	}

	public static float GetClosestRollLuck(int x, int y, int range)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		return Main.player[FindClosest(new Vector2((float)(x * 16), (float)(y * 16)), 1, 1)].RollLuck(range);
	}

	public void ResetEffects()
	{
		if (extraAccessory && (Main.expertMode || Main.gameMenu))
		{
			extraAccessorySlots = 1;
		}
		else
		{
			extraAccessorySlots = 0;
		}
		if (shimmering)
		{
			shimmerTransparency += 0.015f;
			if (shimmerTransparency > 0.8f)
			{
				shimmerTransparency = 0.8f;
			}
		}
		else if (shimmerTransparency > 0f)
		{
			if (shimmerTransparency == 0.8f)
			{
				SoundEngine.PlaySound(19, (int)position.X, (int)position.Y, 3);
			}
			shimmerTransparency -= 0.015f;
			if (shimmerTransparency < 0f)
			{
				shimmerTransparency = 0f;
			}
		}
		shimmering = false;
		fairyBoots = false;
		hellfireTreads = false;
		moonLordLegs = false;
		flowerBoots = false;
		arcticDivingGear = false;
		noBuilding = false;
		strongBees = false;
		ashWoodBonus = false;
		shroomiteStealth = false;
		statDefense = DefenseStat.Default;
		DefenseEffectiveness = MultipliableFloat.One * VanillaBaseDefenseEffectiveness();
		accWatch = 0;
		accCompass = 0;
		accDepthMeter = 0;
		accDivingHelm = false;
		canFloatInWater = false;
		lifeRegen = 0;
		manaCost = 1f;
		hasFootball = false;
		drawingFootball = false;
		minionKB = 0f;
		moveSpeed = 1f;
		boneArmor = false;
		honey = false;
		frostArmor = false;
		rocketBoots = 0;
		vanityRocketBoots = 0;
		fireWalk = false;
		noKnockback = false;
		jumpBoost = false;
		frogLegJumpBoost = false;
		skyStoneEffects = false;
		noFallDmg = false;
		spawnMax = false;
		spaceGun = false;
		killGuide = false;
		killClothier = false;
		lavaImmune = false;
		gills = false;
		slowFall = false;
		findTreasure = false;
		biomeSight = false;
		invis = false;
		nightVision = false;
		enemySpawns = false;
		hasTitaniumStormBuff = false;
		thorns = 0f;
		aggro = 0;
		waterWalk = false;
		waterWalk2 = false;
		detectCreature = false;
		gravControl = false;
		if (forcedGravity > 0)
		{
			forcedGravity--;
		}
		honeyCombItem = null;
		gravControl2 = false;
		PlayerLoader.ModifyMaxStats(this);
		statLifeMax2 = statLifeMax;
		statManaMax2 = statManaMax;
		chloroAmmoCost80 = false;
		huntressAmmoCost90 = false;
		ammoCost80 = false;
		ammoCost75 = false;
		ThrownCost50 = false;
		ThrownCost33 = false;
		ThrownVelocity = 1f;
		manaRegenBuff = false;
		hasCreditsSceneMusicBox = false;
		arrowDamage = StatModifier.Default;
		bulletDamage = StatModifier.Default;
		specialistDamage = StatModifier.Default;
		coolWhipBuff = false;
		yoraiz0rEye = 0;
		yoraiz0rDarkness = false;
		hasFloatingTube = false;
		hasUnicornHorn = false;
		hasAngelHalo = false;
		hasRainbowCursor = false;
		leinforsHair = false;
		overrideFishingBobber = -1;
		suspiciouslookingTentacle = false;
		crimsonHeart = false;
		lightOrb = false;
		blueFairy = false;
		redFairy = false;
		greenFairy = false;
		wisp = false;
		bunny = false;
		turtle = false;
		eater = false;
		trident = false;
		skeletron = false;
		hornet = false;
		zephyrfish = false;
		tiki = false;
		lizard = false;
		parrot = false;
		sapling = false;
		cSapling = false;
		truffle = false;
		yoyoGlove = false;
		counterWeight = 0;
		stringColor = 0;
		yoyoString = false;
		shadowDodge = false;
		palladiumRegen = false;
		chaosState = false;
		onHitDodge = false;
		onHitRegen = false;
		onHitPetal = false;
		iceBarrier = false;
		onHitTitaniumStorm = false;
		maxMinions = 1;
		maxTurrets = 1;
		ammoBox = false;
		ammoPotion = false;
		penguin = false;
		sporeSac = false;
		shinyStone = false;
		empressBrooch = false;
		volatileGelatin = false;
		hasMagiluminescence = false;
		shadowArmor = false;
		if (Main.dontStarveWorld && Main.remixWorld)
		{
			dontStarveShader = false;
		}
		else
		{
			dontStarveShader = Main.dontStarveWorld;
		}
		eyebrellaCloud = false;
		stardustMonolithShader = false;
		nebulaMonolithShader = false;
		vortexMonolithShader = false;
		solarMonolithShader = false;
		moonLordMonolithShader = false;
		bloodMoonMonolithShader = false;
		shimmerMonolithShader = false;
		dd2Accessory = false;
		magicLantern = false;
		rabid = false;
		sunflower = false;
		wellFed = false;
		inferno = false;
		manaMagnet = false;
		lifeMagnet = false;
		treasureMagnet = false;
		chiselSpeed = false;
		lifeForce = false;
		dangerSense = false;
		endurance = 0f;
		whipRangeMultiplier = 1f;
		calmed = false;
		beetleOrbs = 0;
		beetleBuff = false;
		miniMinotaur = false;
		goldRing = false;
		solarShields = 0;
		GoingDownWithGrapple = false;
		fishingSkill = 0;
		cratePotion = false;
		sonarPotion = false;
		accTackleBox = false;
		accFishingBobber = false;
		accFishingLine = false;
		accLavaFishing = false;
		accFishFinder = false;
		accWeatherRadio = false;
		accThirdEye = false;
		InfoAccMechShowWires = false;
		accJarOfSouls = false;
		accCalendar = false;
		accStopwatch = false;
		accOreFinder = false;
		accCritterGuide = false;
		accDreamCatcher = false;
		wallSpeed = 1f;
		tileSpeed = 1f;
		autoPaint = false;
		autoActuator = false;
		petFlagKingSlimePet = false;
		petFlagEyeOfCthulhuPet = false;
		petFlagEaterOfWorldsPet = false;
		petFlagBrainOfCthulhuPet = false;
		petFlagSkeletronPet = false;
		petFlagQueenBeePet = false;
		petFlagDestroyerPet = false;
		petFlagTwinsPet = false;
		petFlagSkeletronPrimePet = false;
		petFlagPlanteraPet = false;
		petFlagGolemPet = false;
		petFlagDukeFishronPet = false;
		petFlagLunaticCultistPet = false;
		petFlagMoonLordPet = false;
		petFlagFairyQueenPet = false;
		petFlagPumpkingPet = false;
		petFlagEverscreamPet = false;
		petFlagIceQueenPet = false;
		petFlagMartianPet = false;
		petFlagDD2OgrePet = false;
		petFlagDD2BetsyPet = false;
		petFlagQueenSlimePet = false;
		petFlagVoltBunny = false;
		petFlagShadowMimic = false;
		petFlagBabyWerewolf = false;
		petFlagDynamiteKitten = false;
		petFlagPlantero = false;
		petFlagBabyRedPanda = false;
		petFlagLilHarpy = false;
		petFlagFennecFox = false;
		petFlagGlitteryButterfly = false;
		petFlagBabyImp = false;
		petFlagBabyShark = false;
		petFlagUpbeatStar = false;
		petFlagDD2Gato = false;
		petFlagDD2Dragon = false;
		petFlagDD2Ghost = false;
		petFlagBerniePet = false;
		petFlagGlommerPet = false;
		petFlagDeerclopsPet = false;
		petFlagPigPet = false;
		petFlagChesterPet = false;
		petFlagJunimoPet = false;
		petFlagBlueChickenPet = false;
		petFlagSpiffo = false;
		petFlagCaveling = false;
		petFlagDirtiestBlock = false;
		companionCube = false;
		petFlagSugarGlider = false;
		babyFaceMonster = false;
		manaSick = false;
		puppy = false;
		grinch = false;
		blackCat = false;
		spider = false;
		squashling = false;
		magicCuffs = false;
		coldDash = false;
		desertDash = false;
		desertBoots = false;
		sailDash = false;
		cordage = false;
		magicQuiver = false;
		shimmerImmune = false;
		hasMoltenQuiver = false;
		magmaStone = false;
		hasRaisableShield = false;
		lavaRose = false;
		eyeSpring = false;
		snowman = false;
		scope = false;
		panic = false;
		brainOfConfusionItem = null;
		dino = false;
		crystalLeaf = false;
		pygmy = false;
		raven = false;
		slime = false;
		hornetMinion = false;
		impMinion = false;
		twinsMinion = false;
		spiderMinion = false;
		pirateMinion = false;
		sharknadoMinion = false;
		stardustMinion = false;
		batsOfLight = false;
		babyBird = false;
		stormTiger = false;
		flinxMinion = false;
		abigailMinion = false;
		smolstar = false;
		empressBlade = false;
		stardustGuardian = false;
		stardustDragon = false;
		UFOMinion = false;
		DeadlySphereMinion = false;
		chilled = false;
		tipsy = false;
		dazed = false;
		frozen = false;
		stoned = false;
		webbed = false;
		ichor = false;
		manaRegenBonus = 0;
		manaRegenDelayBonus = 0f;
		carpet = false;
		iceSkate = false;
		dashType = 0;
		spikedBoots = 0;
		blackBelt = false;
		breathMax = 200;
		breathEffectiveness = StatModifier.Default;
		lavaMax = 0;
		archery = false;
		poisoned = false;
		venom = false;
		blind = false;
		blackout = false;
		onFire = false;
		dripping = false;
		hungry = false;
		heartyMeal = false;
		starving = false;
		drippingSlime = false;
		drippingSparkleSlime = false;
		burned = false;
		suffocating = false;
		onFire2 = false;
		onFire3 = false;
		onFrostBurn = false;
		onFrostBurn2 = false;
		frostBurn = false;
		noItems = false;
		cursed = false;
		blockRange = 0;
		pickSpeed = 1f;
		wereWolf = false;
		rulerGrid = false;
		rulerLine = true;
		bleed = false;
		confused = false;
		witheredArmor = false;
		witheredWeapon = false;
		parryDamageBuff = false;
		slowOgreSpit = false;
		hasGemRobe = false;
		wings = 0;
		wingsLogic = 0;
		equippedWings = null;
		wingTimeMax = 0;
		brokenArmor = false;
		silence = false;
		slow = false;
		gross = false;
		tongued = false;
		kbGlove = false;
		autoReuseGlove = false;
		meleeScaleGlove = false;
		remoteVisionForDrone = false;
		kbBuff = false;
		starCloakItem = null;
		starCloakItem_manaCloakOverrideItem = null;
		starCloakItem_starVeilOverrideItem = null;
		starCloakItem_beeCloakOverrideItem = null;
		longInvince = false;
		pStone = false;
		manaFlower = false;
		crimsonRegen = false;
		ghostHeal = false;
		ghostHurt = false;
		turtleArmor = false;
		turtleThorns = false;
		cactusThorns = false;
		spiderArmor = false;
		anglerSetSpawnReduction = false;
		loveStruck = false;
		stinky = false;
		dryadWard = false;
		resistCold = false;
		electrified = false;
		moonLeech = false;
		headcovered = false;
		vortexDebuff = false;
		windPushed = false;
		ballistaPanic = false;
		vampireFrog = false;
		CanSeeInvisibleBlocks = false;
		setVortex = (setNebula = (setStardust = false));
		setForbidden = false;
		setHuntressT3 = false;
		setSquireT3 = false;
		setMonkT3 = false;
		setApprenticeT3 = false;
		setHuntressT2 = false;
		setSquireT2 = false;
		setMonkT2 = false;
		setApprenticeT2 = false;
		setForbiddenCooldownLocked = false;
		nebulaLevelDamage = (nebulaLevelLife = (nebulaLevelMana = 0));
		ignoreWater = false;
		meleeEnchant = 0;
		discountEquipped = false;
		hasLuckyCoin = false;
		boneGloveItem = null;
		hasLuck_LuckyCoin = false;
		hasLuck_LuckyHorseshoe = false;
		blockExtraJumps = false;
		ExtraJumpLoader.ResetEnableFlags(this);
		defendedByPaladin = false;
		hasPaladinShield = false;
		hasLucyTheAxe = false;
		preventAllItemPickups = false;
		dontHurtCritters = false;
		dontHurtNature = false;
		portableStoolInfo.Reset();
		ResizeHitbox();
		autoJump = false;
		justJumped = false;
		jumpSpeedBoost = 0f;
		extraFall = 0;
		creativeGodMode = false;
		if (phantasmTime > 0)
		{
			phantasmTime--;
		}
		if (brainOfConfusionDodgeAnimationCounter > 0)
		{
			brainOfConfusionDodgeAnimationCounter--;
		}
		if (wireOperationsCooldown > 0)
		{
			wireOperationsCooldown--;
		}
		if (releaseUseItem)
		{
			ActuationRodLock = false;
		}
		for (int i = 0; i < npcTypeNoAggro.Length; i++)
		{
			npcTypeNoAggro[i] = false;
		}
		ResetProjectileCaches();
		if (whoAmI == Main.myPlayer && !isDisplayDollOrInanimate)
		{
			equipmentBasedLuckBonus = 0f;
			luckPotion = 0;
			tileRangeX = 5;
			tileRangeY = 4;
			if (Main.GameModeInfo.IsJourneyMode)
			{
				CreativePowers.FarPlacementRangePower power = CreativePowerManager.Instance.GetPower<CreativePowers.FarPlacementRangePower>();
				if (power.GetIsUnlocked() && power.IsEnabledForPlayer(whoAmI))
				{
					tileRangeX *= 2;
					tileRangeY *= 2;
					tileRangeX += 8;
					tileRangeY += 8;
				}
			}
		}
		ResetDamageClassData();
		mount.CheckMountBuff(this);
		PlayerLoader.ResetEffects(this);
		PlayerLoader.ResetInfoAccessories(this);
	}

	private void UpdateLadyBugLuckTime()
	{
		if (ladyBugLuckTimeLeft > 0.0)
		{
			ladyBugLuckTimeLeft -= Main.desiredWorldEventsUpdateRate;
			if (ladyBugLuckTimeLeft < 0.0)
			{
				ladyBugLuckTimeLeft = 0.0;
			}
		}
		else if (ladyBugLuckTimeLeft < 0.0)
		{
			ladyBugLuckTimeLeft += Main.desiredWorldEventsUpdateRate;
			if (ladyBugLuckTimeLeft > 0.0)
			{
				ladyBugLuckTimeLeft = 0.0;
			}
		}
	}

	public void UpdateImmunity()
	{
		if (immune)
		{
			immuneTime--;
			if (immuneTime <= 0)
			{
				immune = false;
				immuneNoBlink = false;
			}
			if (immuneNoBlink)
			{
				immuneAlpha = 0;
			}
			else
			{
				immuneAlpha += immuneAlphaDirection * 50;
				if (immuneAlpha <= 50)
				{
					immuneAlphaDirection = 1;
				}
				else if (immuneAlpha >= 205)
				{
					immuneAlphaDirection = -1;
				}
			}
		}
		else
		{
			immuneAlpha = 0;
		}
		for (int i = 0; i < hurtCooldowns.Length; i++)
		{
			if (hurtCooldowns[i] > 0)
			{
				hurtCooldowns[i]--;
			}
		}
	}

	private void TryToPoop()
	{
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		if (whoAmI != Main.myPlayer || !wellFed)
		{
			return;
		}
		int maxValue = 600;
		if (Main.rand.Next(maxValue) != 0)
		{
			return;
		}
		int num = 3;
		int num2 = FindBuffIndex(207);
		if (num2 == -1)
		{
			num = 2;
			num2 = FindBuffIndex(206);
		}
		if (num2 == -1)
		{
			num = 1;
			num2 = FindBuffIndex(26);
		}
		if (num2 != -1)
		{
			int num3 = buffTime[num2];
			DelBuff(num2);
			int stack = Utils.Clamp(num3 / 3600 * num, num, 999);
			Vector2 mountedCenter = MountedCenter;
			ParticleOrchestrator.RequestParticleSpawn(clientOnly: false, ParticleOrchestraType.Digestion, new ParticleOrchestraSettings
			{
				PositionInWorld = mountedCenter,
				MovementVector = new Vector2((float)(-direction), 0f)
			}, whoAmI);
			int num4 = Item.NewItem(GetItemSource_Misc(9), mountedCenter, Vector2.Zero, 5395, stack, noBroadcast: false, 0, noGrabDelay: true);
			if (Main.netMode == 0)
			{
				Main.item[num4].noGrabDelay = 100;
			}
			if (Main.netMode == 1)
			{
				NetMessage.SendData(21, -1, -1, null, num4);
			}
		}
	}

	public void UpdateLifeRegen()
	{
		//IL_0a81: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a86: Unknown result type (might be due to invalid IL or missing references)
		//IL_07a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_07cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_07d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_07f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0800: Unknown result type (might be due to invalid IL or missing references)
		//IL_0805: Unknown result type (might be due to invalid IL or missing references)
		//IL_0848: Unknown result type (might be due to invalid IL or missing references)
		//IL_085f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0864: Unknown result type (might be due to invalid IL or missing references)
		//IL_086e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0870: Unknown result type (might be due to invalid IL or missing references)
		//IL_087c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0883: Unknown result type (might be due to invalid IL or missing references)
		//IL_0888: Unknown result type (might be due to invalid IL or missing references)
		//IL_0893: Unknown result type (might be due to invalid IL or missing references)
		//IL_0898: Unknown result type (might be due to invalid IL or missing references)
		//IL_089a: Unknown result type (might be due to invalid IL or missing references)
		//IL_089f: Unknown result type (might be due to invalid IL or missing references)
		//IL_08eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_090e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0914: Unknown result type (might be due to invalid IL or missing references)
		//IL_0939: Unknown result type (might be due to invalid IL or missing references)
		//IL_0943: Unknown result type (might be due to invalid IL or missing references)
		//IL_0948: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c41: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c46: Unknown result type (might be due to invalid IL or missing references)
		//IL_0caa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0caf: Unknown result type (might be due to invalid IL or missing references)
		//IL_0d69: Unknown result type (might be due to invalid IL or missing references)
		//IL_0d6e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0d13: Unknown result type (might be due to invalid IL or missing references)
		//IL_0d18: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b9e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0ba3: Unknown result type (might be due to invalid IL or missing references)
		bool flag = false;
		if (shinyStone && IsStandingStillForSpecialEffects && itemAnimation == 0)
		{
			flag = true;
		}
		if (poisoned)
		{
			if (lifeRegen > 0)
			{
				lifeRegen = 0;
			}
			lifeRegenTime = 0f;
			lifeRegen -= 4;
		}
		if (venom)
		{
			if (lifeRegen > 0)
			{
				lifeRegen = 0;
			}
			lifeRegenTime = 0f;
			lifeRegen -= 30;
		}
		if (onFire)
		{
			if (lifeRegen > 0)
			{
				lifeRegen = 0;
			}
			lifeRegenTime = 0f;
			lifeRegen -= 8;
		}
		if (onFire3)
		{
			if (lifeRegen > 0)
			{
				lifeRegen = 0;
			}
			lifeRegenTime = 0f;
			lifeRegen -= 8;
		}
		if (onFrostBurn)
		{
			if (lifeRegen > 0)
			{
				lifeRegen = 0;
			}
			lifeRegenTime = 0f;
			lifeRegen -= 16;
		}
		if (onFrostBurn2)
		{
			if (lifeRegen > 0)
			{
				lifeRegen = 0;
			}
			lifeRegenTime = 0f;
			lifeRegen -= 16;
		}
		if (onFire2)
		{
			if (lifeRegen > 0)
			{
				lifeRegen = 0;
			}
			lifeRegenTime = 0f;
			lifeRegen -= 24;
		}
		if (burned)
		{
			if (lifeRegen > 0)
			{
				lifeRegen = 0;
			}
			lifeRegenTime = 0f;
			lifeRegen -= 60;
			moveSpeed *= 0.5f;
		}
		if (suffocating)
		{
			if (lifeRegen > 0)
			{
				lifeRegen = 0;
			}
			lifeRegenTime = 0f;
			lifeRegen -= 40;
		}
		if (electrified)
		{
			if (lifeRegen > 0)
			{
				lifeRegen = 0;
			}
			lifeRegenTime = 0f;
			lifeRegen -= 8;
			if (controlLeft || controlRight)
			{
				lifeRegen -= 32;
			}
		}
		if (tongued && Main.expertMode)
		{
			if (lifeRegen > 0)
			{
				lifeRegen = 0;
			}
			lifeRegenTime = 0f;
			lifeRegen -= 100;
		}
		PlayerLoader.UpdateBadLifeRegen(this);
		if (honey && lifeRegen < 0)
		{
			lifeRegen += 4;
			if (lifeRegen > 0)
			{
				lifeRegen = 0;
			}
		}
		if (lifeRegen < 0 && nebulaLevelLife > 0)
		{
			lifeRegen = 0;
		}
		if (flag && lifeRegen < 0)
		{
			lifeRegen /= 2;
		}
		lifeRegenTime += 1f;
		if (usedAegisCrystal)
		{
			lifeRegenTime += 0.2f;
		}
		if (crimsonRegen)
		{
			lifeRegenTime += 1f;
		}
		if (soulDrain > 0)
		{
			lifeRegenTime += 2f;
		}
		if (flag)
		{
			if (lifeRegenTime > 90f && lifeRegenTime < 1800f)
			{
				lifeRegenTime = 1800f;
			}
			lifeRegenTime += 4f;
			lifeRegen += 4;
		}
		if (honey)
		{
			lifeRegenTime += 2f;
			lifeRegen += 2;
		}
		if (starving)
		{
			if (lifeRegen > 0)
			{
				lifeRegen = 0;
			}
			if (lifeRegenCount > 0)
			{
				lifeRegenCount = 0;
			}
			if (lifeRegenTime > 0f)
			{
				lifeRegenTime = 0f;
			}
			int num = 3000;
			int num2 = 120 * statLifeMax2 / num;
			if (num2 < 4)
			{
				num2 = 4;
			}
			lifeRegen = -num2;
		}
		if (soulDrain > 0)
		{
			int num3 = (5 + soulDrain) / 2;
			lifeRegenTime += num3;
			lifeRegen += num3;
		}
		if (heartyMeal)
		{
			int num4 = 6;
			lifeRegen += num4;
		}
		if (whoAmI == Main.myPlayer && Main.SceneMetrics.HasCampfire)
		{
			lifeRegen++;
		}
		if (whoAmI == Main.myPlayer && Main.SceneMetrics.HasHeartLantern)
		{
			lifeRegen += 2;
		}
		PlayerLoader.UpdateLifeRegen(this);
		if (bleed)
		{
			lifeRegenTime = 0f;
		}
		float num5 = 0f;
		if (lifeRegenTime >= 300f)
		{
			num5 += 1f;
		}
		if (lifeRegenTime >= 600f)
		{
			num5 += 1f;
		}
		if (lifeRegenTime >= 900f)
		{
			num5 += 1f;
		}
		if (lifeRegenTime >= 1200f)
		{
			num5 += 1f;
		}
		if (lifeRegenTime >= 1500f)
		{
			num5 += 1f;
		}
		if (lifeRegenTime >= 1800f)
		{
			num5 += 1f;
		}
		if (lifeRegenTime >= 2400f)
		{
			num5 += 1f;
		}
		if (lifeRegenTime >= 3000f)
		{
			num5 += 1f;
		}
		if (flag)
		{
			float num6 = lifeRegenTime - 3000f;
			num6 /= 300f;
			if (num6 > 0f)
			{
				if (num6 > 30f)
				{
					num6 = 30f;
				}
				num5 += num6;
			}
		}
		else if (lifeRegenTime >= 3600f)
		{
			num5 += 1f;
			lifeRegenTime = 3600f;
		}
		if (sitting.isSitting || sleeping.isSleeping)
		{
			lifeRegenTime += 3f;
			num5 *= 1.3f;
		}
		if (sitting.isSitting && sitting.details.IsAToilet)
		{
			TryToPoop();
		}
		num5 = ((velocity.X != 0f && grappling[0] <= 0) ? (num5 * 0.5f) : (num5 * 1.25f));
		if (crimsonRegen)
		{
			num5 *= 1.5f;
		}
		if (shinyStone)
		{
			num5 *= 1.1f;
		}
		if (whoAmI == Main.myPlayer && Main.SceneMetrics.HasCampfire)
		{
			num5 *= 1.1f;
		}
		if (Main.expertMode && !wellFed)
		{
			num5 = ((!shinyStone) ? (num5 / 2f) : (num5 * 0.75f));
		}
		if (rabid)
		{
			num5 = ((!shinyStone) ? (num5 / 2f) : (num5 * 0.75f));
		}
		PlayerLoader.NaturalLifeRegen(this, ref num5);
		float num7 = (float)statLifeMax2 / 400f * 0.85f + 0.15f;
		num5 *= num7;
		lifeRegen += (int)Math.Round(num5);
		lifeRegenCount += lifeRegen;
		if (palladiumRegen)
		{
			lifeRegenCount += 4;
		}
		if (flag && lifeRegen > 0 && statLife < statLifeMax2)
		{
			lifeRegenCount++;
			if (flag && ((float)Main.rand.Next(30000) < lifeRegenTime || Main.rand.Next(30) == 0))
			{
				int num8 = Dust.NewDust(position, width, height, 55, 0f, 0f, 200, default(Color), 0.5f);
				Main.dust[num8].noGravity = true;
				Dust obj = Main.dust[num8];
				obj.velocity *= 0.75f;
				Main.dust[num8].fadeIn = 1.3f;
				Vector2 val = default(Vector2);
				((Vector2)(ref val))..ctor((float)Main.rand.Next(-100, 101), (float)Main.rand.Next(-100, 101));
				((Vector2)(ref val)).Normalize();
				val *= (float)Main.rand.Next(50, 100) * 0.04f;
				Main.dust[num8].velocity = val;
				((Vector2)(ref val)).Normalize();
				val *= 34f;
				Main.dust[num8].position = base.Center - val;
			}
		}
		while (lifeRegenCount >= 120)
		{
			lifeRegenCount -= 120;
			if (statLife < statLifeMax2)
			{
				statLife++;
				if (crimsonRegen)
				{
					for (int i = 0; i < 10; i++)
					{
						int num9 = Dust.NewDust(position, width, height, 5, 0f, 0f, 175, default(Color), 1.75f);
						Main.dust[num9].noGravity = true;
						Dust obj2 = Main.dust[num9];
						obj2.velocity *= 0.75f;
						int num10 = Main.rand.Next(-40, 41);
						int num11 = Main.rand.Next(-40, 41);
						Main.dust[num9].position.X += num10;
						Main.dust[num9].position.Y += num11;
						Main.dust[num9].velocity.X = (float)(-num10) * 0.075f;
						Main.dust[num9].velocity.Y = (float)(-num11) * 0.075f;
					}
				}
			}
			if (statLife > statLifeMax2)
			{
				statLife = statLifeMax2;
			}
		}
		if (burned || suffocating || (tongued && Main.expertMode))
		{
			while (lifeRegenCount <= -600)
			{
				lifeRegenCount += 600;
				statLife -= 5;
				CombatText.NewText(new Rectangle((int)position.X, (int)position.Y, width, height), CombatText.LifeRegen, 5, dramatic: false, dot: true);
				if (statLife <= 0 && whoAmI == Main.myPlayer)
				{
					if (suffocating)
					{
						KillMe(PlayerDeathReason.ByOther(7), 10.0, 0);
					}
					else if (tongued)
					{
						KillMe(PlayerDeathReason.ByOther(12), 10.0, 0);
					}
					else
					{
						KillMe(PlayerDeathReason.ByOther(8), 10.0, 0);
					}
				}
			}
			return;
		}
		if (starving)
		{
			int num12 = statLifeMax2 / 50;
			if (num12 < 2)
			{
				num12 = 2;
			}
			int num13 = ((ZoneDesert || ZoneSnow) ? (num12 * 2) : num12);
			int num14 = 120 * num12;
			while (lifeRegenCount <= -num14)
			{
				lifeRegenCount += num14;
				statLife -= num13;
				CombatText.NewText(new Rectangle((int)position.X, (int)position.Y, width, height), CombatText.LifeRegen, num13, dramatic: false, dot: true);
				if (statLife <= 0 && whoAmI == Main.myPlayer)
				{
					KillMe(PlayerDeathReason.ByOther(18), 10.0, 0);
				}
			}
			return;
		}
		while (lifeRegenCount <= -120)
		{
			if (lifeRegenCount <= -480)
			{
				lifeRegenCount += 480;
				statLife -= 4;
				CombatText.NewText(new Rectangle((int)position.X, (int)position.Y, width, height), CombatText.LifeRegen, 4, dramatic: false, dot: true);
			}
			else if (lifeRegenCount <= -360)
			{
				lifeRegenCount += 360;
				statLife -= 3;
				CombatText.NewText(new Rectangle((int)position.X, (int)position.Y, width, height), CombatText.LifeRegen, 3, dramatic: false, dot: true);
			}
			else if (lifeRegenCount <= -240)
			{
				lifeRegenCount += 240;
				statLife -= 2;
				CombatText.NewText(new Rectangle((int)position.X, (int)position.Y, width, height), CombatText.LifeRegen, 2, dramatic: false, dot: true);
			}
			else
			{
				lifeRegenCount += 120;
				statLife--;
				CombatText.NewText(new Rectangle((int)position.X, (int)position.Y, width, height), CombatText.LifeRegen, 1, dramatic: false, dot: true);
			}
			if (statLife <= 0 && whoAmI == Main.myPlayer)
			{
				if (poisoned || venom)
				{
					KillMe(PlayerDeathReason.ByOther(9), 10.0, 0);
				}
				else if (electrified)
				{
					KillMe(PlayerDeathReason.ByOther(10), 10.0, 0);
				}
				else
				{
					KillMe(PlayerDeathReason.ByOther(8), 10.0, 0);
				}
			}
		}
	}

	public void UpdateManaRegen()
	{
		//IL_0256: Unknown result type (might be due to invalid IL or missing references)
		//IL_027a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0280: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d2: Unknown result type (might be due to invalid IL or missing references)
		if (nebulaLevelMana > 0)
		{
			int num = 6;
			nebulaManaCounter += nebulaLevelMana;
			if (nebulaManaCounter >= num)
			{
				nebulaManaCounter -= num;
				statMana++;
				if (statMana >= statManaMax2)
				{
					statMana = statManaMax2;
				}
			}
		}
		else
		{
			nebulaManaCounter = 0;
		}
		if (manaRegenDelay > 0f)
		{
			manaRegenDelay -= 1f;
			manaRegenDelay -= manaRegenDelayBonus;
			if (IsStandingStillForSpecialEffects || grappling[0] >= 0 || manaRegenBuff)
			{
				manaRegenDelay -= 1f;
			}
			if (usedArcaneCrystal)
			{
				manaRegenDelay -= 0.05f;
			}
		}
		if (manaRegenBuff && manaRegenDelay > 20f)
		{
			manaRegenDelay = 20f;
		}
		if (manaRegenDelay <= 0f)
		{
			manaRegenDelay = 0f;
			manaRegen = statManaMax2 / 3 + 1 + manaRegenBonus;
			if (IsStandingStillForSpecialEffects || grappling[0] >= 0 || manaRegenBuff)
			{
				manaRegen += statManaMax2 / 3;
			}
			if (usedArcaneCrystal)
			{
				manaRegen += statManaMax2 / 50;
			}
			float num2 = (float)statMana / (float)statManaMax2 * 0.8f + 0.2f;
			if (manaRegenBuff)
			{
				num2 = 1f;
			}
			manaRegen = (int)((double)((float)manaRegen * num2) * 1.15);
		}
		else
		{
			manaRegen = 0;
		}
		manaRegenCount += manaRegen;
		while (manaRegenCount >= 120)
		{
			bool flag = false;
			manaRegenCount -= 120;
			if (statMana < statManaMax2)
			{
				statMana++;
				flag = true;
			}
			if (statMana < statManaMax2)
			{
				continue;
			}
			if (whoAmI == Main.myPlayer && flag)
			{
				SoundEngine.PlaySound(25);
				for (int i = 0; i < 5; i++)
				{
					int num3 = Dust.NewDust(position, width, height, 45, 0f, 0f, 255, default(Color), (float)Main.rand.Next(20, 26) * 0.1f);
					Main.dust[num3].noLight = true;
					Main.dust[num3].noGravity = true;
					Dust obj = Main.dust[num3];
					obj.velocity *= 0.5f;
				}
			}
			statMana = statManaMax2;
		}
	}

	public void UpdateJumpHeight()
	{
		if (mount.Active)
		{
			jumpHeight = mount.JumpHeight(this, velocity.X);
			jumpSpeed = mount.JumpSpeed(this, velocity.X);
		}
		else
		{
			if (jumpBoost)
			{
				jumpHeight = 20;
				jumpSpeed = 6.51f;
			}
			if (empressBrooch)
			{
				jumpSpeedBoost += 1.8f;
			}
			if (frogLegJumpBoost)
			{
				jumpSpeedBoost += 2.4f;
				extraFall += 15;
			}
			if (moonLordLegs)
			{
				jumpSpeedBoost += 1.8f;
				extraFall += 10;
				jumpHeight++;
			}
			if (wereWolf)
			{
				jumpHeight += 2;
				jumpSpeed += 0.2f;
			}
			if (portableStoolInfo.IsInUse)
			{
				jumpHeight += 5;
			}
			jumpSpeed += jumpSpeedBoost;
		}
		if (sticky)
		{
			jumpHeight /= 10;
			jumpSpeed /= 5f;
		}
		if (dazed)
		{
			jumpHeight /= 5;
			jumpSpeed /= 2f;
		}
	}

	public void FindPulley()
	{
		//IL_0252: Unknown result type (might be due to invalid IL or missing references)
		//IL_02fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a4: Unknown result type (might be due to invalid IL or missing references)
		if (portableStoolInfo.IsInUse || (!controlUp && !controlDown))
		{
			return;
		}
		int num = (int)(position.X + (float)(width / 2)) / 16;
		int num2 = (int)(position.Y - 8f) / 16;
		if (!WorldGen.IsRope(num, num2))
		{
			return;
		}
		float num3 = position.Y;
		if (Main.tile[num, num2 - 1] == null)
		{
			Main.tile[num, num2 - 1] = default(Tile);
		}
		if (Main.tile[num, num2 + 1] == null)
		{
			Main.tile[num, num2 + 1] = default(Tile);
		}
		if ((!Main.tile[num, num2 - 1].active() || !Main.tileRope[Main.tile[num, num2 - 1].type]) && (!Main.tile[num, num2 + 1].active() || !Main.tileRope[Main.tile[num, num2 + 1].type]))
		{
			num3 = num2 * 16 + 22;
		}
		float num4 = num * 16 + 8 - width / 2 + 6 * direction;
		int num5 = num * 16 + 8 - width / 2 + 6;
		int num6 = num * 16 + 8 - width / 2;
		int num7 = num * 16 + 8 - width / 2 + -6;
		int num8 = 1;
		float num9 = Math.Abs(position.X - (float)num5);
		if (Math.Abs(position.X - (float)num6) < num9)
		{
			num8 = 2;
			num9 = Math.Abs(position.X - (float)num6);
		}
		if (Math.Abs(position.X - (float)num7) < num9)
		{
			num8 = 3;
			num9 = Math.Abs(position.X - (float)num7);
		}
		if (num8 == 1)
		{
			num4 = num5;
			pulleyDir = 2;
			direction = 1;
		}
		if (num8 == 2)
		{
			num4 = num6;
			pulleyDir = 1;
		}
		if (num8 == 3)
		{
			num4 = num7;
			pulleyDir = 2;
			direction = -1;
		}
		if (!Collision.SolidCollision(new Vector2(num4, position.Y), width, height))
		{
			if (whoAmI == Main.myPlayer)
			{
				Main.cameraX = Main.cameraX + position.X - num4;
			}
			pulley = true;
			position.X = num4;
			gfxOffY = position.Y - num3;
			stepSpeed = 2.5f;
			position.Y = num3;
			velocity.X = 0f;
			return;
		}
		num4 = num5;
		pulleyDir = 2;
		direction = 1;
		if (!Collision.SolidCollision(new Vector2(num4, position.Y), width, height))
		{
			if (whoAmI == Main.myPlayer)
			{
				Main.cameraX = Main.cameraX + position.X - num4;
			}
			pulley = true;
			position.X = num4;
			gfxOffY = position.Y - num3;
			stepSpeed = 2.5f;
			position.Y = num3;
			velocity.X = 0f;
			return;
		}
		num4 = num7;
		pulleyDir = 2;
		direction = -1;
		if (!Collision.SolidCollision(new Vector2(num4, position.Y), width, height))
		{
			if (whoAmI == Main.myPlayer)
			{
				Main.cameraX = Main.cameraX + position.X - num4;
			}
			pulley = true;
			position.X = num4;
			gfxOffY = position.Y - num3;
			stepSpeed = 2.5f;
			position.Y = num3;
			velocity.X = 0f;
		}
	}

	public void HorizontalMovement()
	{
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_040f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0414: Unknown result type (might be due to invalid IL or missing references)
		//IL_07b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_07bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_1193: Unknown result type (might be due to invalid IL or missing references)
		//IL_1198: Unknown result type (might be due to invalid IL or missing references)
		//IL_05d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_045e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0464: Unknown result type (might be due to invalid IL or missing references)
		//IL_046e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0473: Unknown result type (might be due to invalid IL or missing references)
		//IL_124a: Unknown result type (might be due to invalid IL or missing references)
		//IL_124f: Unknown result type (might be due to invalid IL or missing references)
		//IL_11ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_10bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_10c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0979: Unknown result type (might be due to invalid IL or missing references)
		//IL_0807: Unknown result type (might be due to invalid IL or missing references)
		//IL_080d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0817: Unknown result type (might be due to invalid IL or missing references)
		//IL_081c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0556: Unknown result type (might be due to invalid IL or missing references)
		//IL_055c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0566: Unknown result type (might be due to invalid IL or missing references)
		//IL_056b: Unknown result type (might be due to invalid IL or missing references)
		//IL_04a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_04ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_04b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_04bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_1301: Unknown result type (might be due to invalid IL or missing references)
		//IL_1306: Unknown result type (might be due to invalid IL or missing references)
		//IL_12a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_08ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0905: Unknown result type (might be due to invalid IL or missing references)
		//IL_090f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0914: Unknown result type (might be due to invalid IL or missing references)
		//IL_0851: Unknown result type (might be due to invalid IL or missing references)
		//IL_0857: Unknown result type (might be due to invalid IL or missing references)
		//IL_0861: Unknown result type (might be due to invalid IL or missing references)
		//IL_0866: Unknown result type (might be due to invalid IL or missing references)
		//IL_05a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_04f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_13b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_13bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_135d: Unknown result type (might be due to invalid IL or missing references)
		//IL_094c: Unknown result type (might be due to invalid IL or missing references)
		//IL_089e: Unknown result type (might be due to invalid IL or missing references)
		//IL_1415: Unknown result type (might be due to invalid IL or missing references)
		//IL_112c: Unknown result type (might be due to invalid IL or missing references)
		if (chilled)
		{
			accRunSpeed = maxRunSpeed;
		}
		bool flag = (itemAnimation == 0 || inventory[selectedItem].useTurn) && mount.AllowDirectionChange;
		bool flag2 = controlLeft || controlRight;
		float num = (accRunSpeed + maxRunSpeed) / 2f;
		float num2 = 0f;
		bool flag3 = false;
		if (flag2 && mount.Active && mount.Type == 43 && velocity.Y == 0f && !controlJump)
		{
			SoundEngine.PlaySound(in SoundID.Item168, base.Center);
			float num3 = jumpSpeed * gravDir * 0.5f;
			if (num3 < 2f)
			{
				num3 = 2f;
			}
			num3 += 0.01f;
			velocity.Y = 0f - num3;
			jump = jumpHeight;
			fullRotation = 0f;
			return;
		}
		if (windPushed && !isLockedToATile && !(mount.Active && velocity.Y == 0f && flag2))
		{
			num2 = (float)Math.Sign(Main.windSpeedCurrent) * 0.06f;
			if (Math.Abs(Main.windSpeedCurrent) > 0.5f)
			{
				num2 *= 1.37f;
			}
			if (velocity.Y != 0f)
			{
				num2 *= 1.5f;
			}
			if (flag2)
			{
				num2 *= 0.8f;
				float num4 = 0.072f;
				num2 = MathHelper.Clamp(num2, 0f - num4, num4);
			}
			flag3 = true;
			if (Math.Sign(direction) != Math.Sign(num2))
			{
				num -= Math.Abs(num2) * 40f;
			}
		}
		if (trackBoost != 0f)
		{
			velocity.X += trackBoost;
			trackBoost = 0f;
			if (velocity.X < 0f)
			{
				if (velocity.X < 0f - maxRunSpeed)
				{
					velocity.X = 0f - maxRunSpeed;
				}
			}
			else if (velocity.X > maxRunSpeed)
			{
				velocity.X = maxRunSpeed;
			}
		}
		if (controlLeft && velocity.X > 0f - maxRunSpeed)
		{
			if (!mount.Active || !mount.Cart || velocity.Y == 0f)
			{
				if (velocity.X > runSlowdown)
				{
					velocity.X -= runSlowdown;
				}
				velocity.X -= runAcceleration;
			}
			if (onWrongGround)
			{
				if (velocity.X < 0f - runSlowdown)
				{
					velocity.X += runSlowdown;
				}
				else
				{
					velocity.X = 0f;
				}
			}
			if (mount.Active && mount.Cart && !onWrongGround)
			{
				if (velocity.X < 0f && flag)
				{
					direction = -1;
				}
				else if (itemAnimation <= 0 && velocity.Y == 0f)
				{
					SoundEngine.PlaySound(SoundID.Item55, (int)position.X + width / 2, (int)position.Y + height / 2);
					DelegateMethods.Minecart.rotation = fullRotation;
					DelegateMethods.Minecart.rotationOrigin = fullRotationOrigin;
					if ((double)Math.Abs(velocity.X) > (double)maxRunSpeed * 0.66)
					{
						if (Main.rand.Next(2) == 0)
						{
							Minecart.WheelSparks(mount.Delegations.MinecartDust, position + velocity * 0.66f, width, height, 1);
						}
						if (Main.rand.Next(2) == 0)
						{
							Minecart.WheelSparks(mount.Delegations.MinecartDust, position + velocity * 0.33f, width, height, 1);
						}
						if (Main.rand.Next(2) == 0)
						{
							Minecart.WheelSparks(mount.Delegations.MinecartDust, position, width, height, 1);
						}
					}
					else if ((double)Math.Abs(velocity.X) > (double)maxRunSpeed * 0.33)
					{
						if (Main.rand.Next(3) != 0)
						{
							Minecart.WheelSparks(mount.Delegations.MinecartDust, position + velocity * 0.5f, width, height, 1);
						}
						if (Main.rand.Next(3) != 0)
						{
							Minecart.WheelSparks(mount.Delegations.MinecartDust, position, width, height, 1);
						}
					}
					else
					{
						Minecart.WheelSparks(mount.Delegations.MinecartDust, position, width, height, 1);
					}
				}
			}
			else if (!sandStorm && (itemAnimation == 0 || inventory[selectedItem].useTurn) && mount.AllowDirectionChange)
			{
				direction = -1;
			}
		}
		else if (controlRight && velocity.X < maxRunSpeed)
		{
			if (!mount.Active || !mount.Cart || velocity.Y == 0f)
			{
				if (velocity.X < 0f - runSlowdown)
				{
					velocity.X += runSlowdown;
				}
				velocity.X += runAcceleration;
			}
			if (onWrongGround)
			{
				if (velocity.X > runSlowdown)
				{
					velocity.X -= runSlowdown;
				}
				else
				{
					velocity.X = 0f;
				}
			}
			if (mount.Active && mount.Cart && !onWrongGround)
			{
				if (velocity.X > 0f && flag)
				{
					direction = 1;
				}
				else if (itemAnimation <= 0 && velocity.Y == 0f)
				{
					SoundEngine.PlaySound(SoundID.Item55, (int)position.X + width / 2, (int)position.Y + height / 2);
					DelegateMethods.Minecart.rotation = fullRotation;
					DelegateMethods.Minecart.rotationOrigin = fullRotationOrigin;
					if ((double)Math.Abs(velocity.X) > (double)maxRunSpeed * 0.66)
					{
						if (Main.rand.Next(2) == 0)
						{
							Minecart.WheelSparks(mount.Delegations.MinecartDust, position + velocity * 0.66f, width, height, 1);
						}
						if (Main.rand.Next(2) == 0)
						{
							Minecart.WheelSparks(mount.Delegations.MinecartDust, position + velocity * 0.33f, width, height, 1);
						}
						if (Main.rand.Next(2) == 0)
						{
							Minecart.WheelSparks(mount.Delegations.MinecartDust, position, width, height, 1);
						}
					}
					else if ((double)Math.Abs(velocity.X) > (double)maxRunSpeed * 0.33)
					{
						if (Main.rand.Next(3) != 0)
						{
							Minecart.WheelSparks(mount.Delegations.MinecartDust, position + velocity * 0.5f, width, height, 1);
						}
						if (Main.rand.Next(3) != 0)
						{
							Minecart.WheelSparks(mount.Delegations.MinecartDust, position, width, height, 1);
						}
					}
					else
					{
						Minecart.WheelSparks(mount.Delegations.MinecartDust, position, width, height, 1);
					}
				}
			}
			else if (!sandStorm && (itemAnimation == 0 || inventory[selectedItem].useTurn) && mount.AllowDirectionChange)
			{
				direction = 1;
			}
		}
		else if (controlLeft && velocity.X > 0f - accRunSpeed && dashDelay >= 0)
		{
			if (mount.Active && mount.Cart)
			{
				if (velocity.X < 0f)
				{
					direction = -1;
				}
			}
			else if ((itemAnimation == 0 || inventory[selectedItem].useTurn) && mount.AllowDirectionChange)
			{
				direction = -1;
			}
			if (velocity.Y == 0f || wingsLogic > 0 || mount.CanFly())
			{
				if (velocity.X > runSlowdown)
				{
					velocity.X -= runSlowdown;
				}
				velocity.X -= runAcceleration * 0.2f;
				if (wingsLogic > 0)
				{
					velocity.X -= runAcceleration * 0.2f;
				}
			}
			if (onWrongGround)
			{
				if (velocity.X < runSlowdown)
				{
					velocity.X += runSlowdown;
				}
				else
				{
					velocity.X = 0f;
				}
			}
			if (velocity.X < 0f - num && velocity.Y == 0f && !mount.Active)
			{
				SpawnFastRunParticles();
			}
		}
		else if (controlRight && velocity.X < accRunSpeed && dashDelay >= 0)
		{
			if (mount.Active && mount.Cart)
			{
				if (velocity.X > 0f)
				{
					direction = -1;
				}
			}
			else if ((itemAnimation == 0 || inventory[selectedItem].useTurn) && mount.AllowDirectionChange)
			{
				direction = 1;
			}
			if (velocity.Y == 0f || wingsLogic > 0 || mount.CanFly())
			{
				if (velocity.X < 0f - runSlowdown)
				{
					velocity.X += runSlowdown;
				}
				velocity.X += runAcceleration * 0.2f;
				if (wingsLogic > 0)
				{
					velocity.X += runAcceleration * 0.2f;
				}
			}
			if (onWrongGround)
			{
				if (velocity.X > runSlowdown)
				{
					velocity.X -= runSlowdown;
				}
				else
				{
					velocity.X = 0f;
				}
			}
			if (velocity.X > num && velocity.Y == 0f && !mount.Active)
			{
				SpawnFastRunParticles();
			}
		}
		else if (mount.Active && mount.Cart && Math.Abs(velocity.X) >= 1f)
		{
			if (onWrongGround)
			{
				if (velocity.X > 0f)
				{
					if (velocity.X > runSlowdown)
					{
						velocity.X -= runSlowdown;
					}
					else
					{
						velocity.X = 0f;
					}
				}
				else if (velocity.X < 0f)
				{
					if (velocity.X < 0f - runSlowdown)
					{
						velocity.X += runSlowdown;
					}
					else
					{
						velocity.X = 0f;
					}
				}
			}
			if (velocity.X > maxRunSpeed)
			{
				velocity.X = maxRunSpeed;
			}
			if (velocity.X < 0f - maxRunSpeed)
			{
				velocity.X = 0f - maxRunSpeed;
			}
		}
		else if (velocity.Y == 0f)
		{
			if (velocity.X > runSlowdown)
			{
				velocity.X -= runSlowdown;
			}
			else if (velocity.X < 0f - runSlowdown)
			{
				velocity.X += runSlowdown;
			}
			else
			{
				velocity.X = 0f;
			}
		}
		else if (!PortalPhysicsEnabled)
		{
			if ((double)velocity.X > (double)runSlowdown * 0.5)
			{
				velocity.X -= runSlowdown * 0.5f;
			}
			else if ((double)velocity.X < (double)(0f - runSlowdown) * 0.5)
			{
				velocity.X += runSlowdown * 0.5f;
			}
			else
			{
				velocity.X = 0f;
			}
		}
		if (flag3)
		{
			if (num2 < 0f && velocity.X > num2)
			{
				velocity.X += num2;
				if (velocity.X < num2)
				{
					velocity.X = num2;
				}
			}
			if (num2 > 0f && velocity.X < num2)
			{
				velocity.X += num2;
				if (velocity.X > num2)
				{
					velocity.X = num2;
				}
			}
		}
		bool flag4 = mount.Type == 40 || mount.Type == 41 || mount.Type == 42;
		if (mount.Active && (mount.Type == 10 || mount.Type == 47 || flag4) && Math.Abs(velocity.X) > mount.DashSpeed - mount.RunSpeed / 2f)
		{
			Rectangle rect = getRect();
			if (direction == 1)
			{
				((Rectangle)(ref rect)).Offset(width - 1, 0);
			}
			rect.Width = 2;
			((Rectangle)(ref rect)).Inflate(6, 12);
			int num5 = 60;
			if (flag4)
			{
				num5 = 30;
			}
			float damage = GetTotalDamage(DamageClass.Summon).ApplyTo(num5);
			float knockback = 10f;
			if (flag4)
			{
				knockback = 7f;
			}
			int nPCImmuneTime = 30;
			int playerImmuneTime = 6;
			CollideWithNPCs(rect, damage, knockback, nPCImmuneTime, playerImmuneTime, DamageClass.Summon);
		}
		if (mount.Active && mount.Type == 44 && Math.Abs(velocity.X) > mount.DashSpeed - mount.RunSpeed / 4f)
		{
			Rectangle rect2 = getRect();
			if (direction == 1)
			{
				((Rectangle)(ref rect2)).Offset(width - 1, 0);
			}
			rect2.Width = 2;
			((Rectangle)(ref rect2)).Inflate(6, 12);
			float damage2 = GetTotalDamage(DamageClass.Summon).ApplyTo(100f);
			float knockback2 = 12f;
			int nPCImmuneTime2 = 30;
			int playerImmuneTime2 = 6;
			CollideWithNPCs(rect2, damage2, knockback2, nPCImmuneTime2, playerImmuneTime2, DamageClass.Summon);
		}
		if (mount.Active && mount.Type == 45 && Math.Abs(velocity.X) > mount.DashSpeed * 0.9f)
		{
			Rectangle rect3 = getRect();
			if (direction == 1)
			{
				((Rectangle)(ref rect3)).Offset(width - 1, 0);
			}
			rect3.Width = 2;
			((Rectangle)(ref rect3)).Inflate(6, 12);
			float damage3 = GetTotalDamage(DamageClass.Summon).ApplyTo(120f);
			float knockback3 = 12f;
			int nPCImmuneTime3 = 30;
			int playerImmuneTime3 = 6;
			CollideWithNPCs(rect3, damage3, knockback3, nPCImmuneTime3, playerImmuneTime3, DamageClass.Summon);
		}
		if (mount.Active && mount.Type == 14 && Math.Abs(velocity.X) > mount.RunSpeed / 2f)
		{
			Rectangle rect4 = getRect();
			if (direction == 1)
			{
				((Rectangle)(ref rect4)).Offset(width - 1, 0);
			}
			rect4.Width = 2;
			((Rectangle)(ref rect4)).Inflate(6, 12);
			float damage4 = GetTotalDamage(DamageClass.Summon).ApplyTo(90f);
			float knockback4 = 10f;
			int nPCImmuneTime4 = 30;
			int playerImmuneTime4 = 6;
			CollideWithNPCs(rect4, damage4, knockback4, nPCImmuneTime4, playerImmuneTime4, DamageClass.Summon);
		}
		if (mount.Active && mount.Type == 17 && Math.Abs(velocity.X) > mount.RunSpeed / 2f)
		{
			Rectangle rect5 = getRect();
			if (direction == 1)
			{
				((Rectangle)(ref rect5)).Offset(width - 1, 0);
			}
			rect5.Width = 2;
			((Rectangle)(ref rect5)).Inflate(6, 12);
			float damage5 = GetTotalDamage(DamageClass.Summon).ApplyTo(40f);
			float knockback5 = 10f;
			int nPCImmuneTime5 = 30;
			int playerImmuneTime5 = 12;
			CollideWithNPCs(rect5, damage5, knockback5, nPCImmuneTime5, playerImmuneTime5, DamageClass.Summon);
		}
		TryUsingDiggerCart();
		if (HeldItem.type == 4049 && whoAmI == Main.myPlayer)
		{
			MowTheLawn();
		}
	}

	private void TryUsingDiggerCart()
	{
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0142: Unknown result type (might be due to invalid IL or missing references)
		if (whoAmI == Main.myPlayer && mount.Active && mount.Type == 39 && velocity.Y == 0f)
		{
			int num = 12;
			int num2 = 20;
			Vector2 val = default(Vector2);
			((Vector2)(ref val))..ctor(0f, gravDir * 10f);
			Vector2 val2 = RotatedRelativePoint(base.Center + new Vector2((float)(num * direction), gravDir * (float)num2));
			val2 += val;
			Tile tileSafely = Framing.GetTileSafely(val2);
			if (!tileSafely.active() || tileSafely.type != 314)
			{
				val2 = RotatedRelativePoint(base.Center + new Vector2((float)(num * direction) * 0.5f, gravDir * (float)num2));
				val2 += val;
			}
			int digDirectionY = controlDown.ToInt() - controlUp.ToInt();
			if (controlUp.ToInt() + controlDown.ToInt() + controlLeft.ToInt() + controlRight.ToInt() > 0)
			{
				MinecartDiggerHelper.Instance.TryDigging(this, val2, direction, digDirectionY);
			}
		}
	}

	private void SpawnFastRunParticles()
	{
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0143: Unknown result type (might be due to invalid IL or missing references)
		//IL_0182: Unknown result type (might be due to invalid IL or missing references)
		//IL_0188: Unknown result type (might be due to invalid IL or missing references)
		//IL_019c: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0381: Unknown result type (might be due to invalid IL or missing references)
		//IL_03bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_03cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_03de: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0240: Unknown result type (might be due to invalid IL or missing references)
		//IL_0246: Unknown result type (might be due to invalid IL or missing references)
		//IL_0327: Unknown result type (might be due to invalid IL or missing references)
		//IL_033c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0341: Unknown result type (might be due to invalid IL or missing references)
		//IL_0811: Unknown result type (might be due to invalid IL or missing references)
		//IL_084d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0853: Unknown result type (might be due to invalid IL or missing references)
		//IL_070b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0746: Unknown result type (might be due to invalid IL or missing references)
		//IL_074c: Unknown result type (might be due to invalid IL or missing references)
		//IL_04b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_04cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_04d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0451: Unknown result type (might be due to invalid IL or missing references)
		//IL_046e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0474: Unknown result type (might be due to invalid IL or missing references)
		//IL_05fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0639: Unknown result type (might be due to invalid IL or missing references)
		//IL_063f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0652: Unknown result type (might be due to invalid IL or missing references)
		//IL_065c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0661: Unknown result type (might be due to invalid IL or missing references)
		//IL_0534: Unknown result type (might be due to invalid IL or missing references)
		//IL_053e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0543: Unknown result type (might be due to invalid IL or missing references)
		//IL_0674: Unknown result type (might be due to invalid IL or missing references)
		//IL_0681: Unknown result type (might be due to invalid IL or missing references)
		//IL_0686: Unknown result type (might be due to invalid IL or missing references)
		//IL_068b: Unknown result type (might be due to invalid IL or missing references)
		int num = 0;
		if (gravDir == -1f)
		{
			num -= height;
		}
		if (runSoundDelay == 0 && velocity.Y == 0f)
		{
			SoundEngine.PlaySound(hermesStepSound.Style, position);
			runSoundDelay = hermesStepSound.IntendedCooldown;
		}
		if (wings == 3)
		{
			int num2 = Dust.NewDust(new Vector2(position.X - 4f, position.Y + (float)height + (float)num), width + 8, 4, 186, (0f - velocity.X) * 0.5f, velocity.Y * 0.5f, 50, default(Color), 1.5f);
			Dust obj = Main.dust[num2];
			obj.velocity *= 0.025f;
			Main.dust[num2].shader = GameShaders.Armor.GetSecondaryShader(cWings, this);
			num2 = Dust.NewDust(new Vector2(position.X - 4f, position.Y + (float)height + (float)num), width + 8, 4, 186, (0f - velocity.X) * 0.5f, velocity.Y * 0.5f, 50, default(Color), 1.5f);
			Dust obj2 = Main.dust[num2];
			obj2.velocity *= 0.2f;
			Main.dust[num2].shader = GameShaders.Armor.GetSecondaryShader(cWings, this);
		}
		else if (sailDash)
		{
			Vector2 val = default(Vector2);
			for (int i = 0; i < 4; i++)
			{
				int num3 = Dust.NewDust(new Vector2(position.X - 4f, position.Y), width + 8, height, 253, (0f - velocity.X) * 0.5f, velocity.Y * 0.5f, 100, default(Color), 1.5f);
				Main.dust[num3].noGravity = true;
				Main.dust[num3].velocity.X = Main.dust[num3].velocity.X * 0.2f;
				Main.dust[num3].velocity.Y = Main.dust[num3].velocity.Y * 0.2f;
				Main.dust[num3].shader = GameShaders.Armor.GetSecondaryShader(cShoe, this);
				Main.dust[num3].scale += (float)Main.rand.Next(-5, 3) * 0.1f;
				((Vector2)(ref val))..ctor((float)Main.rand.Next(-100, 101), (float)Main.rand.Next(-100, 101));
				((Vector2)(ref val)).Normalize();
				val *= (float)Main.rand.Next(81) * 0.1f;
			}
		}
		else if (desertDash)
		{
			Dust dust = Dust.NewDustDirect(new Vector2(position.X - 4f, position.Y + (float)height + (float)num), width + 8, 4, 32, (0f - velocity.X) * 0.5f, velocity.Y * 0.5f);
			dust.velocity *= 0.2f;
			dust.velocity.Y -= gravDir * 2f;
			dust.shader = GameShaders.Armor.GetSecondaryShader(cShoe, this);
		}
		else if (coldDash)
		{
			for (int j = 0; j < 2; j++)
			{
				int num4 = ((j != 0) ? Dust.NewDust(new Vector2(position.X + (float)(width / 2), position.Y + (float)height + gfxOffY), width / 2, 6, 76, 0f, 0f, 0, default(Color), 1.35f) : Dust.NewDust(new Vector2(position.X, position.Y + (float)height + gfxOffY), width / 2, 6, 76, 0f, 0f, 0, default(Color), 1.35f));
				Main.dust[num4].scale *= 1f + (float)Main.rand.Next(20, 40) * 0.01f;
				Main.dust[num4].noGravity = true;
				Main.dust[num4].noLight = true;
				Dust obj3 = Main.dust[num4];
				obj3.velocity *= 0.001f;
				Main.dust[num4].velocity.Y -= 0.003f;
				Main.dust[num4].shader = GameShaders.Armor.GetSecondaryShader(cShoe, this);
			}
		}
		else if (fairyBoots)
		{
			int type = Main.rand.NextFromList(new short[6] { 61, 61, 61, 242, 64, 63 });
			int alpha = 0;
			for (int k = 1; k < 3; k++)
			{
				float scale = 1.5f;
				if (k == 2)
				{
					scale = 1f;
				}
				int num5 = Dust.NewDust(new Vector2(position.X - 4f, position.Y + (float)height + (float)num), width + 8, 4, type, (0f - velocity.X) * 0.5f, velocity.Y * 0.5f, alpha, default(Color), scale);
				Dust obj4 = Main.dust[num5];
				obj4.velocity *= 1.5f;
				if (k == 2)
				{
					Dust obj5 = Main.dust[num5];
					obj5.position += Main.dust[num5].velocity;
				}
				Main.dust[num5].noGravity = true;
				Main.dust[num5].noLightEmittence = true;
				Main.dust[num5].shader = GameShaders.Armor.GetSecondaryShader(cShoe, this);
			}
		}
		else if (hellfireTreads)
		{
			int num6 = Dust.NewDust(new Vector2(position.X - 4f, position.Y + (float)height + (float)num), width + 8, 4, 6, (0f - velocity.X) * 0.5f, velocity.Y * 0.5f, 50, default(Color), 2f);
			Main.dust[num6].velocity.X = Main.dust[num6].velocity.X * 0.2f;
			Main.dust[num6].velocity.Y = -1.5f - Main.rand.NextFloat() * 0.5f;
			Main.dust[num6].fadeIn = 0.5f;
			Main.dust[num6].noGravity = true;
			Main.dust[num6].shader = GameShaders.Armor.GetSecondaryShader(cShoe, this);
		}
		else
		{
			int num7 = Dust.NewDust(new Vector2(position.X - 4f, position.Y + (float)height + (float)num), width + 8, 4, 16, (0f - velocity.X) * 0.5f, velocity.Y * 0.5f, 50, default(Color), 1.5f);
			Main.dust[num7].velocity.X = Main.dust[num7].velocity.X * 0.2f;
			Main.dust[num7].velocity.Y = Main.dust[num7].velocity.Y * 0.2f;
			Main.dust[num7].shader = GameShaders.Armor.GetSecondaryShader(cShoe, this);
		}
	}

	private void MowTheLawn()
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0128: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0132: Unknown result type (might be due to invalid IL or missing references)
		//IL_015f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0169: Unknown result type (might be due to invalid IL or missing references)
		//IL_016e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0173: Unknown result type (might be due to invalid IL or missing references)
		//IL_017e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0183: Unknown result type (might be due to invalid IL or missing references)
		//IL_0188: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_0236: Unknown result type (might be due to invalid IL or missing references)
		//IL_0240: Unknown result type (might be due to invalid IL or missing references)
		//IL_0246: Unknown result type (might be due to invalid IL or missing references)
		//IL_0247: Unknown result type (might be due to invalid IL or missing references)
		//IL_0259: Unknown result type (might be due to invalid IL or missing references)
		//IL_026b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0270: Unknown result type (might be due to invalid IL or missing references)
		if (miscCounter % 2 != 0 || velocity.Y != 0f || grappling[0] != -1 || itemAnimation < 1)
		{
			return;
		}
		Vector2 val = base.Center + new Vector2((float)(direction * 38), (float)(height / 2 + 4) * gravDir);
		float num = 1f - (float)itemAnimation / (float)itemAnimationMax;
		num *= 2f;
		num = ((!(num < 1f)) ? (num - 1f) : (1f - num));
		Vector2 val2 = val + new Vector2((float)(direction * -16), gravDir * -4f);
		Vector2 val3 = val + new Vector2((float)(direction * -6), gravDir * -4f);
		Dust dust = Dust.NewDustDirect(Vector2.Lerp(val2, val3, num), 0, 0, 31, 0f, (0f - gravDir) * 0.25f, 127);
		dust.scale = 0.9f;
		dust.position -= new Vector2(4f);
		if (dust.velocity.Y > 0f)
		{
			dust.velocity.Y *= -1f;
		}
		dust.velocity *= 0.25f;
		Rectangle val4 = Utils.CenteredRectangle(val, new Vector2(8f, 20f));
		if (velocity.X * (float)direction > 0f || velocity.Y * gravDir > 0f)
		{
			Rectangle myRect = val4;
			myRect.Height -= 4;
			myRect.Y += 2;
			float damage = 8f;
			float knockback = 2f;
			int nPCImmuneTime = 12;
			int playerImmuneTime = 6;
			CollideWithNPCs(myRect, damage, knockback, nPCImmuneTime, playerImmuneTime);
		}
		val4.X -= direction * 10;
		if (whoAmI == Main.myPlayer)
		{
			bool[] shouldIgnore = ItemCheck_GetTileCutIgnoreList(HeldItem);
			ItemCheck_CutTiles(HeldItem, val4, shouldIgnore);
			MowGrassTile(val);
			if (!WorldGen.SolidTile(Framing.GetTileSafely(val.ToTileCoordinates())))
			{
				MowGrassTile(val + new Vector2(0f, 16f * gravDir));
			}
		}
	}

	private void MowGrassTile(Vector2 thePos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		Point val = thePos.ToTileCoordinates();
		Tile tile = Main.tile[val.X, val.Y];
		if (tile == null || !WorldGen.CanKillTile(val.X, val.Y, WorldGen.SpecialKillTileContext.MowingTheGrass))
		{
			return;
		}
		ushort num = 0;
		switch (tile.type)
		{
		case 2:
			num = 477;
			break;
		case 109:
			num = 492;
			break;
		}
		if (num != 0)
		{
			int num2 = WorldGen.KillTile_GetTileDustAmount(fail: true, tile, val.X, val.Y);
			for (int i = 0; i < num2; i++)
			{
				WorldGen.KillTile_MakeTileDust(val.X, val.Y, tile);
			}
			tile.type = num;
			if (Main.netMode == 1)
			{
				NetMessage.SendTileSquare(-1, val.X, val.Y);
			}
		}
	}

	public int CollideWithNPCs(Rectangle myRect, float Damage, float Knockback, int NPCImmuneTime, int PlayerImmuneTime, DamageClass? damageType = null)
	{
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		int num = 0;
		for (int i = 0; i < 200; i++)
		{
			NPC nPC = Main.npc[i];
			if (!nPC.active || nPC.dontTakeDamage || nPC.friendly || nPC.immune[whoAmI] != 0 || !CanNPCBeHitByPlayerOrPlayerProjectile(nPC))
			{
				continue;
			}
			Rectangle rect = nPC.getRect();
			if (((Rectangle)(ref myRect)).Intersects(rect) && (nPC.noTileCollide || Collision.CanHit(position, width, height, nPC.position, nPC.width, nPC.height)))
			{
				int num2 = direction;
				if (velocity.X < 0f)
				{
					num2 = -1;
				}
				if (velocity.X > 0f)
				{
					num2 = 1;
				}
				if (whoAmI == Main.myPlayer)
				{
					ApplyDamageToNPC(nPC, (int)Damage, Knockback, num2, crit: false, damageType);
				}
				nPC.immune[whoAmI] = NPCImmuneTime;
				GiveImmuneTimeForCollisionAttack(PlayerImmuneTime);
				num++;
				break;
			}
		}
		return num;
	}

	public void ApplyBannerOffenseBuff(NPC npc, ref NPC.HitModifiers modifiers)
	{
		ApplyBannerOffenseBuff(Item.NPCtoBanner(npc.BannerID()), ref modifiers);
	}

	public void ApplyBannerOffenseBuff(int bannerId, ref NPC.HitModifiers modifiers)
	{
		if (HasNPCBannerBuff(bannerId))
		{
			ItemID.BannerEffect bannerEffect = ItemID.Sets.BannerStrength[Item.BannerToItem(bannerId)];
			modifiers.TargetDamageMultiplier *= (Main.expertMode ? bannerEffect.ExpertDamageDealt : bannerEffect.NormalDamageDealt);
		}
	}

	public void ApplyBannerDefenseBuff(NPC npc, ref HurtModifiers modifiers)
	{
		ApplyBannerDefenseBuff(Item.NPCtoBanner(npc.BannerID()), ref modifiers);
	}

	public void ApplyBannerDefenseBuff(int bannerId, ref HurtModifiers modifiers)
	{
		if (HasNPCBannerBuff(bannerId))
		{
			ItemID.BannerEffect bannerEffect = ItemID.Sets.BannerStrength[Item.BannerToItem(bannerId)];
			modifiers.IncomingDamageMultiplier *= (Main.expertMode ? bannerEffect.ExpertDamageReceived : bannerEffect.NormalDamageReceived);
		}
	}

	/// <summary>
	/// Deals damage to an NPC (and syncs the hit in multiplayer). <br />
	/// The damage will be affected by modifiers, armor pen, enemy resistances etc. <br />
	/// Will not apply damage class modifiers/knockback. Use <see cref="M:Terraria.Player.GetTotalDamage``1" /> to adjust the damage before calling if necessary. <br />
	/// Will apply damage class based armor penetration. <br />
	/// Will exit early with no effect if <see cref="M:Terraria.ModLoader.PlayerLoader.CanHitNPC(Terraria.Player,Terraria.NPC)" /> returns false.
	/// </summary>
	/// <param name="npc">The NPC to strike</param>
	/// <param name="damage">The damage to deal to the NPC, before modifications, defense, resistances etc</param>
	/// <param name="knockback">The amount of knockback to apply</param>
	/// <param name="direction">The hit direction of the resulting strike (1 or -1)</param>
	/// <param name="crit">Whether or not the strike is a crit</param>
	/// <param name="damageType">Defaults to <see cref="P:Terraria.ModLoader.DamageClass.Default" /></param>
	/// <param name="damageVariation">Whether to apply damage variation. Defaults to false.</param>
	public void ApplyDamageToNPC(NPC npc, int damage, float knockback, int direction, bool crit = false, DamageClass? damageType = null, bool damageVariation = false)
	{
		if (PlayerLoader.CanHitNPC(this, npc))
		{
			NPC.HitModifiers modifiers = npc.GetIncomingStrikeModifiers(damageType ?? DamageClass.Default, direction);
			PlayerLoader.ModifyHitNPC(this, npc, ref modifiers);
			ApplyBannerOffenseBuff(npc, ref modifiers);
			modifiers.ArmorPenetration += GetTotalArmorPenetration(damageType ?? DamageClass.Generic);
			StrikeNPCDirect(npc, modifiers.ToHitInfo(damage, crit, knockback, damageVariation, luck));
		}
	}

	/// <summary>
	/// Applies a hit to an NPC via <see cref="M:Terraria.NPC.StrikeNPC(Terraria.NPC.HitInfo,System.Boolean,System.Boolean)" />. <br />
	/// Also calls player based OnHit and OnKill hooks, tracks dps and net syncs the strike
	/// </summary>
	/// <param name="npc">The NPC to strike</param>
	/// <param name="hit">The hit to apply</param>
	public void StrikeNPCDirect(NPC npc, NPC.HitInfo hit)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		OnHit(npc.Center.X, npc.Center.Y, npc);
		NPCKillAttempt attempt = new NPCKillAttempt(npc);
		int num = npc.StrikeNPC(hit);
		PlayerLoader.OnHitNPC(this, npc, in hit, num);
		if (accDreamCatcher && !npc.HideStrikeDamage)
		{
			addDPS(num);
		}
		if (Main.netMode != 0)
		{
			NetMessage.SendStrikeNPC(npc, in hit);
		}
		int num2 = Item.NPCtoBanner(npc.BannerID());
		if (num2 >= 0)
		{
			lastCreatureHit = num2;
		}
		if (attempt.DidNPCDie())
		{
			OnKillNPC(ref attempt, null);
		}
	}

	public void OnKillNPC(ref NPCKillAttempt attempt, object externalKillingBlowSource)
	{
		if (Main.myPlayer == whoAmI && externalKillingBlowSource is Item { type: 5096 })
		{
			AddBuff(336, 420, quiet: false);
		}
	}

	public void GiveImmuneTimeForCollisionAttack(int time)
	{
		if (_timeSinceLastImmuneGet <= 20)
		{
			_immuneStrikes++;
		}
		else
		{
			_immuneStrikes = 1;
		}
		_timeSinceLastImmuneGet = 0;
		if (_immuneStrikes < 3 && (!immune || immuneTime <= time))
		{
			immune = true;
			immuneNoBlink = true;
			immuneTime = time;
		}
	}

	public bool CanNPCBeHitByPlayerOrPlayerProjectile(NPC npc, Projectile projectile = null)
	{
		bool flag = dontHurtCritters || (projectile != null && (projectile.minion || ProjectileID.Sets.MinionShot[projectile.type] || projectile.sentry || ProjectileID.Sets.SentryShot[projectile.type]));
		if (NPCID.Sets.CountsAsCritter[npc.type] && flag)
		{
			return false;
		}
		return true;
	}

	public void JumpMovement()
	{
		//IL_01e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0269: Unknown result type (might be due to invalid IL or missing references)
		//IL_026e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0272: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0288: Unknown result type (might be due to invalid IL or missing references)
		//IL_029b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_05a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_05ac: Unknown result type (might be due to invalid IL or missing references)
		if (mount.Active && mount.IsConsideredASlimeMount && wetSlime == 0 && velocity.Y > 0f)
		{
			Rectangle rect = getRect();
			((Rectangle)(ref rect)).Offset(0, height - 1);
			rect.Height = 2;
			((Rectangle)(ref rect)).Inflate(12, 6);
			for (int i = 0; i < 200; i++)
			{
				NPC nPC = Main.npc[i];
				if (!nPC.active || nPC.dontTakeDamage || nPC.friendly || nPC.immune[whoAmI] != 0 || !CanNPCBeHitByPlayerOrPlayerProjectile(nPC))
				{
					continue;
				}
				Rectangle rect2 = nPC.getRect();
				if (((Rectangle)(ref rect)).Intersects(rect2) && (nPC.noTileCollide || Collision.CanHit(position, width, height, nPC.position, nPC.width, nPC.height)))
				{
					float num = GetTotalDamage(DamageClass.Summon).ApplyTo(40f);
					float knockback = 5f;
					int num2 = direction;
					if (velocity.X < 0f)
					{
						num2 = -1;
					}
					if (velocity.X > 0f)
					{
						num2 = 1;
					}
					if (whoAmI == Main.myPlayer)
					{
						ApplyDamageToNPC(nPC, (int)num, knockback, num2, crit: false, DamageClass.Summon);
					}
					nPC.immune[whoAmI] = 10;
					velocity.Y = -10f;
					GiveImmuneTimeForCollisionAttack(6);
					break;
				}
			}
		}
		if (mount.Active && mount.Type == 17 && velocity.Y > 0f)
		{
			Rectangle rect3 = getRect();
			((Rectangle)(ref rect3)).Offset(0, height - 1);
			rect3.Height = 2;
			((Rectangle)(ref rect3)).Inflate(12, 6);
			for (int j = 0; j < 200; j++)
			{
				NPC nPC2 = Main.npc[j];
				if (!nPC2.active || nPC2.dontTakeDamage || nPC2.friendly || nPC2.immune[whoAmI] != 0 || !CanNPCBeHitByPlayerOrPlayerProjectile(nPC2))
				{
					continue;
				}
				Rectangle rect4 = nPC2.getRect();
				if (((Rectangle)(ref rect3)).Intersects(rect4) && (nPC2.noTileCollide || Collision.CanHit(position, width, height, nPC2.position, nPC2.width, nPC2.height)))
				{
					float num3 = 40f;
					float knockback2 = 5f;
					int num4 = direction;
					if (velocity.X < 0f)
					{
						num4 = -1;
					}
					if (velocity.X > 0f)
					{
						num4 = 1;
					}
					if (whoAmI == Main.myPlayer)
					{
						ApplyDamageToNPC(nPC2, (int)num3, knockback2, num4);
					}
					nPC2.immune[whoAmI] = 12;
					GiveImmuneTimeForCollisionAttack(12);
					break;
				}
			}
		}
		if (controlJump)
		{
			if (sliding)
			{
				autoJump = false;
			}
			bool flag = false;
			if (mount.Active && mount.IsConsideredASlimeMount && wetSlime > 0)
			{
				wetSlime = 0;
				flag = true;
			}
			if (mount.Active && mount.Type == 43 && releaseJump && velocity.Y != 0f)
			{
				isPerformingPogostickTricks = true;
			}
			if (jump > 0)
			{
				if (velocity.Y == 0f)
				{
					jump = 0;
				}
				else
				{
					velocity.Y = (0f - jumpSpeed) * gravDir;
					if (merman && (!mount.Active || !mount.Cart))
					{
						if (swimTime <= 10)
						{
							swimTime = 30;
						}
					}
					else
					{
						jump--;
					}
				}
			}
			else if ((sliding || velocity.Y == 0f || flag || AnyExtraJumpUsable()) && (releaseJump || (autoJump && (velocity.Y == 0f || sliding))))
			{
				if (mount.Active && MountID.Sets.Cart[mount.Type])
				{
					position.Y -= 0.001f;
				}
				if (sliding || velocity.Y == 0f)
				{
					justJumped = true;
				}
				bool flag2 = false;
				bool flag3 = !flag;
				canRocket = false;
				rocketRelease = false;
				if (velocity.Y == 0f || sliding || (autoJump && justJumped))
				{
					RefreshDoubleJumps();
				}
				if (velocity.Y == 0f || flag2 || sliding || flag)
				{
					if (mount.Active && mount.Type == 43)
					{
						SoundEngine.PlaySound(in SoundID.Item168, base.Center);
					}
					velocity.Y = (0f - jumpSpeed) * gravDir;
					jump = jumpHeight;
					if (portableStoolInfo.IsInUse)
					{
						position.Y -= portableStoolInfo.HeightBoost;
						gfxOffY += portableStoolInfo.HeightBoost;
					}
					if (sliding)
					{
						velocity.X = 3 * -slideDir;
					}
				}
				else if (flag3 && !blockExtraJumps)
				{
					ExtraJumpLoader.ProcessJumps(this);
				}
			}
			releaseJump = false;
		}
		else
		{
			jump = 0;
			releaseJump = true;
			rocketRelease = true;
		}
	}

	public void DashMovement()
	{
		//IL_0cde: Unknown result type (might be due to invalid IL or missing references)
		//IL_0d13: Unknown result type (might be due to invalid IL or missing references)
		//IL_0d18: Unknown result type (might be due to invalid IL or missing references)
		//IL_0d1d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0d22: Unknown result type (might be due to invalid IL or missing references)
		//IL_0d25: Unknown result type (might be due to invalid IL or missing references)
		//IL_0d3d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0d42: Unknown result type (might be due to invalid IL or missing references)
		//IL_0d47: Unknown result type (might be due to invalid IL or missing references)
		//IL_0d4c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0d4e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0d55: Unknown result type (might be due to invalid IL or missing references)
		//IL_0629: Unknown result type (might be due to invalid IL or missing references)
		//IL_0646: Unknown result type (might be due to invalid IL or missing references)
		//IL_064c: Unknown result type (might be due to invalid IL or missing references)
		//IL_05d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_05ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_05f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_1053: Unknown result type (might be due to invalid IL or missing references)
		//IL_1088: Unknown result type (might be due to invalid IL or missing references)
		//IL_108d: Unknown result type (might be due to invalid IL or missing references)
		//IL_1092: Unknown result type (might be due to invalid IL or missing references)
		//IL_1097: Unknown result type (might be due to invalid IL or missing references)
		//IL_109a: Unknown result type (might be due to invalid IL or missing references)
		//IL_10b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_10b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_10bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_10c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_10c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_10ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_0d63: Unknown result type (might be due to invalid IL or missing references)
		//IL_0d6a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0827: Unknown result type (might be due to invalid IL or missing references)
		//IL_0849: Unknown result type (might be due to invalid IL or missing references)
		//IL_084f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0866: Unknown result type (might be due to invalid IL or missing references)
		//IL_0870: Unknown result type (might be due to invalid IL or missing references)
		//IL_0875: Unknown result type (might be due to invalid IL or missing references)
		//IL_0757: Unknown result type (might be due to invalid IL or missing references)
		//IL_0774: Unknown result type (might be due to invalid IL or missing references)
		//IL_077a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0701: Unknown result type (might be due to invalid IL or missing references)
		//IL_071d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0723: Unknown result type (might be due to invalid IL or missing references)
		//IL_0663: Unknown result type (might be due to invalid IL or missing references)
		//IL_066d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0672: Unknown result type (might be due to invalid IL or missing references)
		//IL_1246: Unknown result type (might be due to invalid IL or missing references)
		//IL_127b: Unknown result type (might be due to invalid IL or missing references)
		//IL_1280: Unknown result type (might be due to invalid IL or missing references)
		//IL_1285: Unknown result type (might be due to invalid IL or missing references)
		//IL_128a: Unknown result type (might be due to invalid IL or missing references)
		//IL_128d: Unknown result type (might be due to invalid IL or missing references)
		//IL_12a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_12aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_12af: Unknown result type (might be due to invalid IL or missing references)
		//IL_12b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_12b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_12bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_10d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_10df: Unknown result type (might be due to invalid IL or missing references)
		//IL_145d: Unknown result type (might be due to invalid IL or missing references)
		//IL_1492: Unknown result type (might be due to invalid IL or missing references)
		//IL_1497: Unknown result type (might be due to invalid IL or missing references)
		//IL_149c: Unknown result type (might be due to invalid IL or missing references)
		//IL_14a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_14a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_14bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_14c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_14c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_14cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_14cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_14d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_094e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0974: Unknown result type (might be due to invalid IL or missing references)
		//IL_097a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0991: Unknown result type (might be due to invalid IL or missing references)
		//IL_099b: Unknown result type (might be due to invalid IL or missing references)
		//IL_09a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0791: Unknown result type (might be due to invalid IL or missing references)
		//IL_079b: Unknown result type (might be due to invalid IL or missing references)
		//IL_07a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		//IL_12cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_12d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_14e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_14e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0db1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0dd2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0dd8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0e37: Unknown result type (might be due to invalid IL or missing references)
		//IL_0e41: Unknown result type (might be due to invalid IL or missing references)
		//IL_0e46: Unknown result type (might be due to invalid IL or missing references)
		//IL_0ebd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0ec4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0eca: Unknown result type (might be due to invalid IL or missing references)
		//IL_0f3d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0f47: Unknown result type (might be due to invalid IL or missing references)
		//IL_0f4c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0f87: Unknown result type (might be due to invalid IL or missing references)
		//IL_0f8e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0f94: Unknown result type (might be due to invalid IL or missing references)
		//IL_1007: Unknown result type (might be due to invalid IL or missing references)
		//IL_1011: Unknown result type (might be due to invalid IL or missing references)
		//IL_1016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0adc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0af9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0aff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a86: Unknown result type (might be due to invalid IL or missing references)
		//IL_0aa2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0aa8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0399: Unknown result type (might be due to invalid IL or missing references)
		//IL_039e: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_112e: Unknown result type (might be due to invalid IL or missing references)
		//IL_114f: Unknown result type (might be due to invalid IL or missing references)
		//IL_1155: Unknown result type (might be due to invalid IL or missing references)
		//IL_11b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_11be: Unknown result type (might be due to invalid IL or missing references)
		//IL_11c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b16: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b20: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b25: Unknown result type (might be due to invalid IL or missing references)
		//IL_1319: Unknown result type (might be due to invalid IL or missing references)
		//IL_1339: Unknown result type (might be due to invalid IL or missing references)
		//IL_133f: Unknown result type (might be due to invalid IL or missing references)
		//IL_139e: Unknown result type (might be due to invalid IL or missing references)
		//IL_13a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_13ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_154d: Unknown result type (might be due to invalid IL or missing references)
		//IL_156e: Unknown result type (might be due to invalid IL or missing references)
		//IL_1574: Unknown result type (might be due to invalid IL or missing references)
		//IL_15db: Unknown result type (might be due to invalid IL or missing references)
		//IL_15e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_15ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_15ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_0490: Unknown result type (might be due to invalid IL or missing references)
		//IL_049b: Unknown result type (might be due to invalid IL or missing references)
		if (dashDelay == 0)
		{
			dash = dashType;
		}
		if (dash == 0)
		{
			dashTime = 0;
			dashDelay = 0;
		}
		if (dash == 2 && eocDash > 0)
		{
			if (eocHit < 0)
			{
				Rectangle val = default(Rectangle);
				((Rectangle)(ref val))..ctor((int)((double)position.X + (double)velocity.X * 0.5 - 4.0), (int)((double)position.Y + (double)velocity.Y * 0.5 - 4.0), width + 8, height + 8);
				for (int i = 0; i < 200; i++)
				{
					NPC nPC = Main.npc[i];
					if (!nPC.active || nPC.dontTakeDamage || nPC.friendly || (nPC.aiStyle == 112 && !(nPC.ai[2] <= 1f)) || !CanNPCBeHitByPlayerOrPlayerProjectile(nPC))
					{
						continue;
					}
					Rectangle rect = nPC.getRect();
					if (((Rectangle)(ref val)).Intersects(rect) && (nPC.noTileCollide || CanHit(nPC)))
					{
						float num = GetTotalDamage(DamageClass.Melee).ApplyTo(30f);
						float knockback = GetTotalKnockback(DamageClass.Melee).ApplyTo(9f);
						bool crit = false;
						if ((float)Main.rand.Next(100) < GetTotalCritChance(DamageClass.Melee))
						{
							crit = true;
						}
						int num2 = direction;
						if (velocity.X < 0f)
						{
							num2 = -1;
						}
						if (velocity.X > 0f)
						{
							num2 = 1;
						}
						if (whoAmI == Main.myPlayer)
						{
							ApplyDamageToNPC(nPC, (int)num, knockback, num2, crit, DamageClass.Melee);
						}
						eocDash = 10;
						dashDelay = 30;
						velocity.X = -num2 * 9;
						velocity.Y = -4f;
						GiveImmuneTimeForCollisionAttack(4);
						eocHit = i;
					}
				}
			}
			else if ((!controlLeft || !(velocity.X < 0f)) && (!controlRight || !(velocity.X > 0f)))
			{
				velocity.X *= 0.95f;
			}
		}
		if (dash == 3 && dashDelay < 0 && whoAmI == Main.myPlayer)
		{
			Rectangle val2 = default(Rectangle);
			((Rectangle)(ref val2))..ctor((int)((double)position.X + (double)velocity.X * 0.5 - 4.0), (int)((double)position.Y + (double)velocity.Y * 0.5 - 4.0), width + 8, height + 8);
			for (int j = 0; j < 200; j++)
			{
				NPC nPC2 = Main.npc[j];
				if (!nPC2.active || nPC2.dontTakeDamage || nPC2.friendly || nPC2.immune[whoAmI] > 0 || (nPC2.aiStyle == 112 && !(nPC2.ai[2] <= 1f)) || !CanNPCBeHitByPlayerOrPlayerProjectile(nPC2))
				{
					continue;
				}
				Rectangle rect2 = nPC2.getRect();
				if (((Rectangle)(ref val2)).Intersects(rect2) && (nPC2.noTileCollide || CanHit(nPC2)))
				{
					if (!solarDashConsumedFlare)
					{
						solarDashConsumedFlare = true;
						ConsumeSolarFlare();
					}
					float num3 = GetTotalDamage(DamageClass.Melee).ApplyTo(150f);
					float knockback2 = GetTotalKnockback(DamageClass.Melee).ApplyTo(9f);
					bool crit2 = false;
					if ((float)Main.rand.Next(100) < GetTotalCritChance(DamageClass.Melee))
					{
						crit2 = true;
					}
					int num4 = direction;
					if (velocity.X < 0f)
					{
						num4 = -1;
					}
					if (velocity.X > 0f)
					{
						num4 = 1;
					}
					if (whoAmI == Main.myPlayer)
					{
						ApplyDamageToNPC(nPC2, (int)num3, knockback2, num4, crit2, DamageClass.Melee);
						int num5 = Projectile.NewProjectile(GetProjectileSource_OnHit(nPC2, 2), base.Center.X, base.Center.Y, 0f, 0f, 608, (int)num3, 15f, Main.myPlayer);
						Main.projectile[num5].Kill();
					}
					nPC2.immune[whoAmI] = 6;
					GiveImmuneTimeForCollisionAttack(4);
				}
			}
		}
		if (dashDelay > 0)
		{
			if (eocDash > 0)
			{
				eocDash--;
			}
			if (eocDash == 0)
			{
				eocHit = -1;
			}
			dashDelay--;
		}
		else if (dashDelay < 0)
		{
			StopVanityActions();
			float num6 = 12f;
			float num7 = 0.992f;
			float num8 = Math.Max(accRunSpeed, maxRunSpeed);
			float num9 = 0.96f;
			int num10 = 20;
			if (dash == 1)
			{
				for (int k = 0; k < 2; k++)
				{
					int num11 = ((velocity.Y != 0f) ? Dust.NewDust(new Vector2(position.X, position.Y + (float)(height / 2) - 8f), width, 16, 31, 0f, 0f, 100, default(Color), 1.4f) : Dust.NewDust(new Vector2(position.X, position.Y + (float)height - 4f), width, 8, 31, 0f, 0f, 100, default(Color), 1.4f));
					Dust obj = Main.dust[num11];
					obj.velocity *= 0.1f;
					Main.dust[num11].scale *= 1f + (float)Main.rand.Next(20) * 0.01f;
				}
			}
			else if (dash == 2)
			{
				for (int l = 0; l < 0; l++)
				{
					int num12 = ((velocity.Y != 0f) ? Dust.NewDust(new Vector2(position.X, position.Y + (float)(height / 2) - 8f), width, 16, 31, 0f, 0f, 100, default(Color), 1.4f) : Dust.NewDust(new Vector2(position.X, position.Y + (float)height - 4f), width, 8, 31, 0f, 0f, 100, default(Color), 1.4f));
					Dust obj2 = Main.dust[num12];
					obj2.velocity *= 0.1f;
					Main.dust[num12].scale *= 1f + (float)Main.rand.Next(20) * 0.01f;
				}
				num7 = 0.985f;
				num9 = 0.94f;
				num10 = 30;
			}
			else if (dash == 3)
			{
				for (int m = 0; m < 4; m++)
				{
					int num13 = Dust.NewDust(new Vector2(position.X, position.Y + 4f), width, height - 8, 6, 0f, 0f, 100, default(Color), 1.7f);
					Dust obj3 = Main.dust[num13];
					obj3.velocity *= 0.1f;
					Main.dust[num13].scale *= 1f + (float)Main.rand.Next(20) * 0.01f;
					Main.dust[num13].shader = GameShaders.Armor.GetSecondaryShader(ArmorSetDye(), this);
					Main.dust[num13].noGravity = true;
					if (Main.rand.Next(2) == 0)
					{
						Main.dust[num13].fadeIn = 0.5f;
					}
				}
				num6 = 14f;
				num7 = 0.985f;
				num9 = 0.94f;
				num10 = 20;
			}
			else if (dash == 4)
			{
				for (int n = 0; n < 2; n++)
				{
					int num14 = Dust.NewDust(new Vector2(position.X, position.Y + 4f), width, height - 8, 229, 0f, 0f, 100, default(Color), 1.2f);
					Dust obj4 = Main.dust[num14];
					obj4.velocity *= 0.1f;
					Main.dust[num14].scale *= 1f + (float)Main.rand.Next(20) * 0.01f;
					Main.dust[num14].noGravity = true;
					if (Main.rand.Next(2) == 0)
					{
						Main.dust[num14].fadeIn = 0.3f;
					}
				}
				num7 = 0.985f;
				num9 = 0.94f;
				num10 = 20;
			}
			if (dash == 5)
			{
				for (int num15 = 0; num15 < 2; num15++)
				{
					int type = Main.rand.NextFromList(new short[3] { 68, 69, 70 });
					int num16 = ((velocity.Y != 0f) ? Dust.NewDust(new Vector2(position.X, position.Y + (float)(height / 2) - 8f), width, 16, type, 0f, 0f, 100) : Dust.NewDust(new Vector2(position.X, position.Y + (float)height - 4f), width, 8, type, 0f, 0f, 100));
					Dust obj5 = Main.dust[num16];
					obj5.velocity *= 0.2f;
					Main.dust[num16].scale *= 1f + (float)Main.rand.Next(20) * 0.01f;
					Main.dust[num16].fadeIn = 0.5f + (float)Main.rand.Next(20) * 0.01f;
					Main.dust[num16].noGravity = true;
					Main.dust[num16].shader = GameShaders.Armor.GetSecondaryShader(ArmorSetDye(), this);
				}
			}
			if (dash <= 0)
			{
				return;
			}
			doorHelper.AllowOpeningDoorsByVelocityAloneForATime(num10 * 3);
			vortexStealthActive = false;
			if (velocity.X > num6 || velocity.X < 0f - num6)
			{
				velocity.X *= num7;
				return;
			}
			if (velocity.X > num8 || velocity.X < 0f - num8)
			{
				velocity.X *= num9;
				return;
			}
			dashDelay = num10;
			if (velocity.X < 0f)
			{
				velocity.X = 0f - num8;
			}
			else if (velocity.X > 0f)
			{
				velocity.X = num8;
			}
		}
		else
		{
			if (dash <= 0 || mount.Active)
			{
				return;
			}
			if (dash == 1)
			{
				DoCommonDashHandle(out var dir, out var dashing);
				if (dashing)
				{
					velocity.X = 16.9f * (float)dir;
					Point val3 = (base.Center + new Vector2((float)(dir * width / 2 + 2), gravDir * (float)(-height) / 2f + gravDir * 2f)).ToTileCoordinates();
					Point val4 = (base.Center + new Vector2((float)(dir * width / 2 + 2), 0f)).ToTileCoordinates();
					if (WorldGen.SolidOrSlopedTile(val3.X, val3.Y) || WorldGen.SolidOrSlopedTile(val4.X, val4.Y))
					{
						velocity.X /= 2f;
					}
					dashDelay = -1;
					for (int num17 = 0; num17 < 20; num17++)
					{
						int num18 = Dust.NewDust(new Vector2(position.X, position.Y), width, height, 31, 0f, 0f, 100, default(Color), 2f);
						Main.dust[num18].position.X += Main.rand.Next(-5, 6);
						Main.dust[num18].position.Y += Main.rand.Next(-5, 6);
						Dust obj6 = Main.dust[num18];
						obj6.velocity *= 0.2f;
						Main.dust[num18].scale *= 1f + (float)Main.rand.Next(20) * 0.01f;
					}
					int num19 = Gore.NewGore(new Vector2(position.X + (float)(width / 2) - 24f, position.Y + (float)(height / 2) - 34f), default(Vector2), Main.rand.Next(61, 64));
					Main.gore[num19].velocity.X = (float)Main.rand.Next(-50, 51) * 0.01f;
					Main.gore[num19].velocity.Y = (float)Main.rand.Next(-50, 51) * 0.01f;
					Gore obj7 = Main.gore[num19];
					obj7.velocity *= 0.4f;
					num19 = Gore.NewGore(new Vector2(position.X + (float)(width / 2) - 24f, position.Y + (float)(height / 2) - 14f), default(Vector2), Main.rand.Next(61, 64));
					Main.gore[num19].velocity.X = (float)Main.rand.Next(-50, 51) * 0.01f;
					Main.gore[num19].velocity.Y = (float)Main.rand.Next(-50, 51) * 0.01f;
					Gore obj8 = Main.gore[num19];
					obj8.velocity *= 0.4f;
				}
			}
			else if (dash == 2)
			{
				DoCommonDashHandle(out var dir2, out var dashing2);
				if (dashing2)
				{
					velocity.X = 14.5f * (float)dir2;
					Point val5 = (base.Center + new Vector2((float)(dir2 * width / 2 + 2), gravDir * (float)(-height) / 2f + gravDir * 2f)).ToTileCoordinates();
					Point val6 = (base.Center + new Vector2((float)(dir2 * width / 2 + 2), 0f)).ToTileCoordinates();
					if (WorldGen.SolidOrSlopedTile(val5.X, val5.Y) || WorldGen.SolidOrSlopedTile(val6.X, val6.Y))
					{
						velocity.X /= 2f;
					}
					dashDelay = -1;
					eocDash = 15;
					for (int num20 = 0; num20 < 0; num20++)
					{
						int num21 = Dust.NewDust(new Vector2(position.X, position.Y), width, height, 31, 0f, 0f, 100, default(Color), 2f);
						Main.dust[num21].position.X += Main.rand.Next(-5, 6);
						Main.dust[num21].position.Y += Main.rand.Next(-5, 6);
						Dust obj9 = Main.dust[num21];
						obj9.velocity *= 0.2f;
						Main.dust[num21].scale *= 1f + (float)Main.rand.Next(20) * 0.01f;
					}
				}
			}
			else if (dash == 3)
			{
				DoCommonDashHandle(out var dir3, out var dashing3, SolarDashStart);
				if (dashing3)
				{
					velocity.X = 21.9f * (float)dir3;
					Point val7 = (base.Center + new Vector2((float)(dir3 * width / 2 + 2), gravDir * (float)(-height) / 2f + gravDir * 2f)).ToTileCoordinates();
					Point val8 = (base.Center + new Vector2((float)(dir3 * width / 2 + 2), 0f)).ToTileCoordinates();
					if (WorldGen.SolidOrSlopedTile(val7.X, val7.Y) || WorldGen.SolidOrSlopedTile(val8.X, val8.Y))
					{
						velocity.X /= 2f;
					}
					dashDelay = -1;
					for (int num22 = 0; num22 < 20; num22++)
					{
						int num23 = Dust.NewDust(new Vector2(position.X, position.Y), width, height, 6, 0f, 0f, 100, default(Color), 2f);
						Main.dust[num23].position.X += Main.rand.Next(-5, 6);
						Main.dust[num23].position.Y += Main.rand.Next(-5, 6);
						Dust obj10 = Main.dust[num23];
						obj10.velocity *= 0.2f;
						Main.dust[num23].scale *= 1f + (float)Main.rand.Next(20) * 0.01f;
						Main.dust[num23].shader = GameShaders.Armor.GetSecondaryShader(ArmorSetDye(), this);
						Main.dust[num23].noGravity = true;
						Main.dust[num23].fadeIn = 0.5f;
					}
				}
			}
			if (dash != 5)
			{
				return;
			}
			DoCommonDashHandle(out var dir4, out var dashing4);
			if (dashing4)
			{
				velocity.X = 16.9f * (float)dir4;
				Point val9 = (base.Center + new Vector2((float)(dir4 * width / 2 + 2), gravDir * (float)(-height) / 2f + gravDir * 2f)).ToTileCoordinates();
				Point val10 = (base.Center + new Vector2((float)(dir4 * width / 2 + 2), 0f)).ToTileCoordinates();
				if (WorldGen.SolidOrSlopedTile(val9.X, val9.Y) || WorldGen.SolidOrSlopedTile(val10.X, val10.Y))
				{
					velocity.X /= 2f;
				}
				dashDelay = -1;
				for (int num24 = 0; num24 < 20; num24++)
				{
					int type2 = Main.rand.NextFromList(new short[3] { 68, 69, 70 });
					int num25 = Dust.NewDust(new Vector2(position.X, position.Y), width, height, type2, 0f, 0f, 100, default(Color), 1.5f);
					Main.dust[num25].position.X += Main.rand.Next(-5, 6);
					Main.dust[num25].position.Y += Main.rand.Next(-5, 6);
					Main.dust[num25].velocity = DirectionTo(Main.dust[num25].position) * 2f;
					Main.dust[num25].scale *= 1f + (float)Main.rand.Next(20) * 0.01f;
					Main.dust[num25].fadeIn = 0.5f + (float)Main.rand.Next(20) * 0.01f;
					Main.dust[num25].noGravity = true;
					Main.dust[num25].shader = GameShaders.Armor.GetSecondaryShader(ArmorSetDye(), this);
				}
			}
		}
	}

	private void SolarDashStart(int dashDirection)
	{
		solarDashing = true;
		solarDashConsumedFlare = false;
	}

	private void DoCommonDashHandle(out int dir, out bool dashing, DashStartAction dashStartAction = null)
	{
		dir = 0;
		dashing = false;
		if (dashTime > 0)
		{
			dashTime--;
		}
		if (dashTime < 0)
		{
			dashTime++;
		}
		if (controlRight && releaseRight)
		{
			if (dashTime > 0)
			{
				dir = 1;
				dashing = true;
				dashTime = 0;
				timeSinceLastDashStarted = 0;
				dashStartAction?.Invoke(dir);
			}
			else
			{
				dashTime = 15;
			}
		}
		else if (controlLeft && releaseLeft)
		{
			if (dashTime < 0)
			{
				dir = -1;
				dashing = true;
				dashTime = 0;
				timeSinceLastDashStarted = 0;
				dashStartAction?.Invoke(dir);
			}
			else
			{
				dashTime = -15;
			}
		}
	}

	public void WallslideMovement()
	{
		//IL_043d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0453: Unknown result type (might be due to invalid IL or missing references)
		//IL_0459: Unknown result type (might be due to invalid IL or missing references)
		//IL_0216: Unknown result type (might be due to invalid IL or missing references)
		//IL_022c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0232: Unknown result type (might be due to invalid IL or missing references)
		//IL_04bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_04c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_04cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0295: Unknown result type (might be due to invalid IL or missing references)
		//IL_029f: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a4: Unknown result type (might be due to invalid IL or missing references)
		sliding = false;
		if (slideDir == 0 || spikedBoots <= 0 || mount.Active || ((!controlLeft || slideDir != -1) && (!controlRight || slideDir != 1)))
		{
			return;
		}
		bool flag = false;
		float num = position.X;
		if (slideDir == 1)
		{
			num += (float)width;
		}
		num += (float)slideDir;
		float num2 = position.Y + (float)height + 1f;
		if (gravDir < 0f)
		{
			num2 = position.Y - 1f;
		}
		num /= 16f;
		num2 /= 16f;
		if (WorldGen.SolidTile((int)num, (int)num2) && WorldGen.SolidTile((int)num, (int)num2 - 1))
		{
			flag = true;
		}
		if (spikedBoots >= 2)
		{
			if (!flag || ((!(velocity.Y > 0f) || gravDir != 1f) && (!(velocity.Y < gravity) || gravDir != -1f)))
			{
				return;
			}
			float num3 = gravity;
			if (slowFall)
			{
				num3 = ((!TryingToHoverUp) ? (gravity / 3f * gravDir) : (gravity / 10f * gravDir));
			}
			fallStart = (int)(position.Y / 16f);
			if ((controlDown && gravDir == 1f) || (controlUp && gravDir == -1f))
			{
				velocity.Y = 4f * gravDir;
				int num4 = Dust.NewDust(new Vector2(position.X + (float)(width / 2) + (float)((width / 2 - 4) * slideDir), position.Y + (float)(height / 2) + (float)(height / 2 - 4) * gravDir), 8, 8, 31);
				if (slideDir < 0)
				{
					Main.dust[num4].position.X -= 10f;
				}
				if (gravDir < 0f)
				{
					Main.dust[num4].position.Y -= 12f;
				}
				Dust obj = Main.dust[num4];
				obj.velocity *= 0.1f;
				Main.dust[num4].scale *= 1.2f;
				Main.dust[num4].noGravity = true;
				Main.dust[num4].shader = GameShaders.Armor.GetSecondaryShader(cShoe, this);
			}
			else if (gravDir == -1f)
			{
				velocity.Y = (0f - num3 + 1E-05f) * gravDir;
			}
			else
			{
				velocity.Y = (0f - num3 + 1E-05f) * gravDir;
			}
			sliding = true;
		}
		else if ((flag && (double)velocity.Y > 0.5 && gravDir == 1f) || ((double)velocity.Y < -0.5 && gravDir == -1f))
		{
			fallStart = (int)(position.Y / 16f);
			if (controlDown)
			{
				velocity.Y = 4f * gravDir;
			}
			else
			{
				velocity.Y = 0.5f * gravDir;
			}
			sliding = true;
			int num5 = Dust.NewDust(new Vector2(position.X + (float)(width / 2) + (float)((width / 2 - 4) * slideDir), position.Y + (float)(height / 2) + (float)(height / 2 - 4) * gravDir), 8, 8, 31);
			if (slideDir < 0)
			{
				Main.dust[num5].position.X -= 10f;
			}
			if (gravDir < 0f)
			{
				Main.dust[num5].position.Y -= 12f;
			}
			Dust obj2 = Main.dust[num5];
			obj2.velocity *= 0.1f;
			Main.dust[num5].scale *= 1.2f;
			Main.dust[num5].noGravity = true;
			Main.dust[num5].shader = GameShaders.Armor.GetSecondaryShader(cShoe, this);
		}
	}

	public void CarpetMovement()
	{
		bool flag = false;
		if (grappling[0] == -1 && carpet && !AnyExtraJumpUsable() && jump == 0 && velocity.Y != 0f && rocketTime == 0 && wingTime == 0f && !mount.Active)
		{
			if (controlJump && canCarpet)
			{
				canCarpet = false;
				carpetTime = 300;
			}
			if (carpetTime > 0 && controlJump)
			{
				fallStart = (int)(position.Y / 16f);
				flag = true;
				carpetTime--;
				float num = gravity;
				if (gravDir == 1f && velocity.Y > 0f - num)
				{
					velocity.Y = 0f - (num + 1E-06f);
				}
				else if (gravDir == -1f && velocity.Y < num)
				{
					velocity.Y = num + 1E-06f;
				}
				carpetFrameCounter += 1f + Math.Abs(velocity.X * 0.5f);
				if (carpetFrameCounter > 8f)
				{
					carpetFrameCounter = 0f;
					carpetFrame++;
				}
				if (carpetFrame < 0)
				{
					carpetFrame = 0;
				}
				if (carpetFrame > 5)
				{
					carpetFrame = 0;
				}
			}
		}
		if (!flag)
		{
			carpetFrame = -1;
		}
		else
		{
			slowFall = false;
		}
	}

	public void DoubleJumpVisuals()
	{
		ExtraJumpLoader.JumpVisuals(this);
	}

	public void WingMovement()
	{
		if (wingsLogic == 4 && TryingToHoverUp)
		{
			velocity.Y -= 0.2f * gravDir;
			if (gravDir == 1f)
			{
				if (velocity.Y > 0f)
				{
					velocity.Y -= 1f;
				}
				else if (velocity.Y > 0f - jumpSpeed)
				{
					velocity.Y -= 0.2f;
				}
				if (velocity.Y < (0f - jumpSpeed) * 3f)
				{
					velocity.Y = (0f - jumpSpeed) * 3f;
				}
			}
			else
			{
				if (velocity.Y < 0f)
				{
					velocity.Y += 1f;
				}
				else if (velocity.Y < jumpSpeed)
				{
					velocity.Y += 0.2f;
				}
				if (velocity.Y > jumpSpeed * 3f)
				{
					velocity.Y = jumpSpeed * 3f;
				}
			}
			wingTime -= 2f;
		}
		else
		{
			float constantAscend = 0.1f;
			float ascentWhenFalling = 0.5f;
			float maxAscentMultiplier = 1.5f;
			float maxCanAscendMultiplier = 0.5f;
			float ascentWhenRising = 0.1f;
			if (wingsLogic == 26)
			{
				ascentWhenFalling = 0.75f;
				ascentWhenRising = 0.15f;
				maxCanAscendMultiplier = 1f;
				maxAscentMultiplier = 2.5f;
				constantAscend = 0.125f;
			}
			if (wingsLogic == 8 || wingsLogic == 11 || wingsLogic == 24 || wingsLogic == 27 || wingsLogic == 22)
			{
				maxAscentMultiplier = 1.66f;
			}
			if (wingsLogic == 21 || wingsLogic == 12 || wingsLogic == 20 || wingsLogic == 23)
			{
				maxAscentMultiplier = 1.805f;
			}
			if (wingsLogic == 37)
			{
				ascentWhenFalling = 0.75f;
				ascentWhenRising = 0.15f;
				maxCanAscendMultiplier = 1f;
				maxAscentMultiplier = 2.5f;
				constantAscend = 0.125f;
			}
			if (wingsLogic == 44)
			{
				ascentWhenFalling = 0.85f;
				ascentWhenRising = 0.15f;
				maxCanAscendMultiplier = 1f;
				maxAscentMultiplier = 2.75f;
				constantAscend = 0.125f;
				if (TryingToHoverUp)
				{
					velocity.Y -= 0.4f * gravDir;
					if (gravDir == 1f)
					{
						if (velocity.Y > 0f)
						{
							velocity.Y -= 1f;
						}
						else if (velocity.Y > 0f - jumpSpeed)
						{
							velocity.Y -= 0.2f;
						}
						if (velocity.Y < (0f - jumpSpeed) * 3f)
						{
							velocity.Y = (0f - jumpSpeed) * 3f;
						}
					}
					else
					{
						if (velocity.Y < 0f)
						{
							velocity.Y += 1f;
						}
						else if (velocity.Y < jumpSpeed)
						{
							velocity.Y += 0.2f;
						}
						if (velocity.Y > jumpSpeed * 3f)
						{
							velocity.Y = jumpSpeed * 3f;
						}
					}
				}
				if (TryingToHoverDown && !controlJump && velocity.Y != 0f)
				{
					velocity.Y += 0.4f;
				}
			}
			if (wingsLogic == 45)
			{
				ascentWhenFalling = 0.95f;
				ascentWhenRising = 0.15f;
				maxCanAscendMultiplier = 1f;
				maxAscentMultiplier = 4.5f;
				if (TryingToHoverUp)
				{
					velocity.Y -= 0.4f * gravDir;
					if (gravDir == 1f)
					{
						if (velocity.Y > 0f)
						{
							velocity.Y -= 1f;
						}
						else if (velocity.Y > 0f - jumpSpeed)
						{
							velocity.Y -= 0.2f;
						}
						if (velocity.Y < (0f - jumpSpeed) * 3f)
						{
							velocity.Y = (0f - jumpSpeed) * 3f;
						}
					}
					else
					{
						if (velocity.Y < 0f)
						{
							velocity.Y += 1f;
						}
						else if (velocity.Y < jumpSpeed)
						{
							velocity.Y += 0.2f;
						}
						if (velocity.Y > jumpSpeed * 3f)
						{
							velocity.Y = jumpSpeed * 3f;
						}
					}
				}
				if (TryingToHoverDown && !controlJump && velocity.Y != 0f)
				{
					velocity.Y += 0.4f;
				}
			}
			if (wingsLogic == 29 || wingsLogic == 32)
			{
				ascentWhenFalling = 0.85f;
				ascentWhenRising = 0.15f;
				maxCanAscendMultiplier = 1f;
				maxAscentMultiplier = 3f;
				constantAscend = 0.135f;
			}
			if (wingsLogic == 30 || wingsLogic == 31)
			{
				maxCanAscendMultiplier = 1f;
				maxAscentMultiplier = 2.45f;
				if (!TryingToHoverDown)
				{
					constantAscend = 0.15f;
				}
			}
			ItemLoader.VerticalWingSpeeds(this, ref ascentWhenFalling, ref ascentWhenRising, ref maxCanAscendMultiplier, ref maxAscentMultiplier, ref constantAscend);
			velocity.Y -= constantAscend * gravDir;
			if (gravDir == 1f)
			{
				if (velocity.Y > 0f)
				{
					velocity.Y -= ascentWhenFalling;
				}
				else if (velocity.Y > (0f - jumpSpeed) * maxCanAscendMultiplier)
				{
					velocity.Y -= ascentWhenRising;
				}
				if (velocity.Y < (0f - jumpSpeed) * maxAscentMultiplier)
				{
					velocity.Y = (0f - jumpSpeed) * maxAscentMultiplier;
				}
			}
			else
			{
				if (velocity.Y < 0f)
				{
					velocity.Y += ascentWhenFalling;
				}
				else if (velocity.Y < jumpSpeed * maxCanAscendMultiplier)
				{
					velocity.Y += ascentWhenRising;
				}
				if (velocity.Y > jumpSpeed * maxAscentMultiplier)
				{
					velocity.Y = jumpSpeed * maxAscentMultiplier;
				}
			}
			if ((wingsLogic == 22 || wingsLogic == 28 || wingsLogic == 30 || wingsLogic == 31 || wingsLogic == 37 || wingsLogic == 45) && TryingToHoverDown && !controlLeft && !controlRight)
			{
				wingTime -= 0.5f;
			}
			else
			{
				wingTime -= 1f;
			}
		}
		if (empressBrooch && wingTime != 0f)
		{
			wingTime = wingTimeMax;
		}
	}

	public void MoonLeechRope()
	{
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		int num = -1;
		for (int i = 0; i < 1000; i++)
		{
			if (Main.projectile[i].active && Main.projectile[i].type == 456 && Main.projectile[i].ai[1] == (float)whoAmI)
			{
				num = i;
				break;
			}
		}
		if (num != -1 && !(Main.projectile[num].ai[0] < 0f))
		{
			Projectile projectile = Main.projectile[num];
			Vector2 val = default(Vector2);
			((Vector2)(ref val))..ctor(0f, 216f);
			Vector2 val2 = Main.npc[(int)Math.Abs(projectile.ai[0]) - 1].Center - base.Center + val;
			if (((Vector2)(ref val2)).Length() > 200f)
			{
				Vector2 val3 = Vector2.Normalize(val2);
				position += val3 * (((Vector2)(ref val2)).Length() - 200f);
			}
		}
	}

	public void WOFTongue()
	{
		//IL_02bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_031c: Unknown result type (might be due to invalid IL or missing references)
		if (Main.wofNPCIndex < 0 || !Main.npc[Main.wofNPCIndex].active)
		{
			return;
		}
		float num = Main.npc[Main.wofNPCIndex].position.X + 40f;
		if (Main.npc[Main.wofNPCIndex].direction > 0)
		{
			num -= 96f;
		}
		if (position.X + (float)width > num && position.X < num + 140f && gross)
		{
			noKnockback = false;
			int attackDamage_ScaledByStrength = Main.npc[Main.wofNPCIndex].GetAttackDamage_ScaledByStrength(50f);
			Hurt(PlayerDeathReason.LegacyDefault(), attackDamage_ScaledByStrength, Main.npc[Main.wofNPCIndex].direction);
		}
		if (!gross && position.Y > (float)((Main.maxTilesY - 250) * 16) && position.X > num - 1920f && position.X < num + 1920f)
		{
			AddBuff(37, 10);
			SoundEngine.PlaySound(4, (int)Main.npc[Main.wofNPCIndex].position.X, (int)Main.npc[Main.wofNPCIndex].position.Y, 10);
		}
		if (gross)
		{
			if (position.Y < (float)(Main.UnderworldLayer * 16))
			{
				AddBuff(38, 10);
			}
			if (Main.npc[Main.wofNPCIndex].direction < 0)
			{
				if (position.X + (float)(width / 2) > Main.npc[Main.wofNPCIndex].position.X + (float)(Main.npc[Main.wofNPCIndex].width / 2) + 40f)
				{
					AddBuff(38, 10);
				}
			}
			else if (position.X + (float)(width / 2) < Main.npc[Main.wofNPCIndex].position.X + (float)(Main.npc[Main.wofNPCIndex].width / 2) - 40f)
			{
				AddBuff(38, 10);
			}
		}
		if (!tongued)
		{
			return;
		}
		controlHook = false;
		controlUseItem = false;
		for (int i = 0; i < 1000; i++)
		{
			if (Main.projectile[i].active && Main.projectile[i].owner == Main.myPlayer && Main.projectile[i].aiStyle == 7)
			{
				Main.projectile[i].Kill();
			}
		}
		Vector2 center = base.Center;
		float num2 = Main.npc[Main.wofNPCIndex].position.X + (float)(Main.npc[Main.wofNPCIndex].width / 2) - center.X;
		float num3 = Main.npc[Main.wofNPCIndex].position.Y + (float)(Main.npc[Main.wofNPCIndex].height / 2) - center.Y;
		if ((float)Math.Sqrt(num2 * num2 + num3 * num3) > 3000f)
		{
			KillMe(PlayerDeathReason.ByOther(11), 1000.0, 0);
		}
		else if (Main.npc[Main.wofNPCIndex].position.X < 608f || Main.npc[Main.wofNPCIndex].position.X > (float)((Main.maxTilesX - 38) * 16))
		{
			KillMe(PlayerDeathReason.ByOther(12), 1000.0, 0);
		}
	}

	public void StatusFromNPC(NPC npc)
	{
		if (Main.expertMode && ((npc.type == 266 && Main.rand.Next(3) == 0) || npc.type == 267))
		{
			int num = Main.rand.Next(9);
			if (num == 2 || num == 4)
			{
				num = Main.rand.Next(9);
			}
			float num2 = (float)Main.rand.Next(75, 150) * 0.01f;
			switch (num)
			{
			case 0:
				AddBuff(20, (int)(60f * num2 * 3.5f));
				break;
			case 1:
				AddBuff(22, (int)(60f * num2 * 2f));
				break;
			case 2:
				AddBuff(23, (int)(60f * num2 * 0.5f));
				break;
			case 3:
				AddBuff(30, (int)(60f * num2 * 5f));
				break;
			case 4:
				AddBuff(31, (int)(60f * num2 * 1f));
				break;
			case 5:
				AddBuff(32, (int)(60f * num2 * 3.5f));
				break;
			case 6:
				AddBuff(33, (int)(60f * num2 * 7.5f));
				break;
			case 7:
				AddBuff(35, (int)(60f * num2 * 1f));
				break;
			case 8:
				AddBuff(36, (int)((double)(60f * num2) * 6.5));
				break;
			}
		}
		if (npc.type == 530 || npc.type == 531)
		{
			AddBuff(70, Main.rand.Next(240, 241));
		}
		if (npc.type == 159 || npc.type == 158)
		{
			AddBuff(30, Main.rand.Next(300, 600));
		}
		if (npc.type == 525)
		{
			AddBuff(39, 240);
		}
		if (npc.type == 526)
		{
			AddBuff(69, 420);
		}
		if (npc.type == 527)
		{
			AddBuff(31, 840);
		}
		if (Main.expertMode && (npc.type == 49 || npc.type == 93 || npc.type == 51 || npc.type == 152 || npc.type == 634) && Main.rand.Next(10) == 0)
		{
			AddBuff(148, Main.rand.Next(1800, 5400));
		}
		if (Main.expertMode && npc.type == 222)
		{
			AddBuff(20, Main.rand.Next(60, 240));
		}
		if (Main.expertMode && (npc.type == 210 || npc.type == 211))
		{
			AddBuff(20, Main.rand.Next(60, 180));
		}
		if (Main.expertMode && npc.type == 35)
		{
			AddBuff(30, Main.rand.Next(180, 300));
		}
		if (Main.expertMode && npc.type == 36 && Main.rand.Next(2) == 0)
		{
			AddBuff(32, Main.rand.Next(30, 60));
		}
		if (npc.type >= 269 && npc.type <= 272)
		{
			if (Main.rand.Next(3) == 0)
			{
				AddBuff(30, 600);
			}
			else if (Main.rand.Next(3) == 0)
			{
				AddBuff(32, 300);
			}
		}
		if (npc.type >= 273 && npc.type <= 276 && Main.rand.Next(2) == 0)
		{
			AddBuff(36, 600);
		}
		if (npc.type >= 277 && npc.type <= 280)
		{
			AddBuff(24, 600);
		}
		if (npc.type == 371)
		{
			AddBuff(103, 60 * Main.rand.Next(3, 8));
		}
		if (npc.type == 370 && Main.expertMode)
		{
			int num3 = Utils.SelectRandom<int>(Main.rand, 0, 148, 30);
			if (num3 != 0)
			{
				AddBuff(num3, 60 * Main.rand.Next(3, 11));
			}
		}
		if (((npc.type == 1 && npc.netID == -6) || npc.type == 81 || npc.type == 79 || npc.type == 183 || npc.type == 630) && Main.rand.Next(4) == 0)
		{
			AddBuff(22, 900);
		}
		if ((npc.type == 23 || npc.type == 25) && Main.rand.Next(3) == 0)
		{
			AddBuff(24, 420);
		}
		if ((npc.type == 34 || npc.type == 83 || npc.type == 84 || npc.type == 179 || npc.type == 289) && Main.rand.Next(3) == 0)
		{
			AddBuff(23, 240);
		}
		if ((npc.type == 104 || npc.type == 102) && Main.rand.Next(8) == 0)
		{
			AddBuff(30, 2700);
		}
		if (npc.type == 75 && Main.rand.Next(10) == 0)
		{
			AddBuff(35, 420);
		}
		if ((npc.type == 163 || npc.type == 238 || npc.type == 236 || npc.type == 237) && Main.rand.Next(10) == 0)
		{
			AddBuff(70, 240);
		}
		if ((npc.type == 79 || npc.type == 103 || npc.type == 630) && Main.rand.Next(5) == 0)
		{
			AddBuff(35, 420);
		}
		if ((npc.type == 75 || npc.type == 78 || npc.type == 82) && Main.rand.Next(8) == 0)
		{
			AddBuff(32, 900);
		}
		if ((npc.type == 93 || npc.type == 109 || npc.type == 80) && Main.rand.Next(14) == 0)
		{
			AddBuff(31, 300);
		}
		if (npc.type >= 305 && npc.type <= 314 && Main.rand.Next(10) == 0)
		{
			AddBuff(33, 3600);
		}
		if (npc.type == 77 && Main.rand.Next(6) == 0)
		{
			AddBuff(36, 7200);
		}
		if (npc.type == 112 && Main.rand.Next(20) == 0)
		{
			AddBuff(33, 18000);
		}
		if (npc.type == 182 && Main.rand.Next(25) == 0)
		{
			AddBuff(33, 7200);
		}
		if (npc.type == 141 && Main.rand.Next(2) == 0)
		{
			AddBuff(20, 600);
		}
		if (npc.type == 147 && !frozen && Main.rand.Next(12) == 0)
		{
			AddBuff(46, 600);
		}
		if (npc.type == 150)
		{
			if (Main.rand.Next(2) == 0)
			{
				AddBuff(46, 900);
			}
			if (!frozen && Main.rand.Next(35) == 0)
			{
				AddBuff(47, 60);
			}
			else if (!frozen && Main.expertMode && Main.rand.Next(35) == 0)
			{
				AddBuff(47, 60);
			}
		}
		if (npc.type == 184)
		{
			AddBuff(46, 1200);
			if (!frozen && Main.rand.Next(15) == 0)
			{
				AddBuff(47, 60);
			}
			else if (!frozen && Main.expertMode && Main.rand.Next(25) == 0)
			{
				AddBuff(47, 60);
			}
		}
	}

	public void GrappleMovement()
	{
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_0244: Unknown result type (might be due to invalid IL or missing references)
		//IL_0249: Unknown result type (might be due to invalid IL or missing references)
		//IL_0272: Unknown result type (might be due to invalid IL or missing references)
		//IL_0367: Unknown result type (might be due to invalid IL or missing references)
		//IL_037c: Unknown result type (might be due to invalid IL or missing references)
		//IL_037e: Unknown result type (might be due to invalid IL or missing references)
		//IL_038f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0394: Unknown result type (might be due to invalid IL or missing references)
		//IL_03be: Unknown result type (might be due to invalid IL or missing references)
		if (grappling[0] < 0)
		{
			return;
		}
		StopVanityActions();
		if (Main.myPlayer == whoAmI && mount.Active)
		{
			mount.Dismount(this);
		}
		canCarpet = true;
		carpetFrame = -1;
		wingFrame = 1;
		if (velocity.Y == 0f || (wet && (double)velocity.Y > -0.02 && (double)velocity.Y < 0.02))
		{
			wingFrame = 0;
		}
		if (wings == 4)
		{
			wingFrame = 3;
		}
		if (wings == 30)
		{
			wingFrame = 0;
		}
		RefreshMovementAbilities();
		rocketFrame = false;
		canRocket = false;
		rocketRelease = false;
		fallStart = (int)(position.Y / 16f);
		int num = -1;
		for (int i = 0; i < grapCount; i++)
		{
			if (Main.projectile[grappling[i]].type == 403)
			{
				num = i;
			}
		}
		GetGrapplingForces(base.Center, out var preferredPlayerDirectionToSet, out var preferedPlayerVelocityX, out var preferedPlayerVelocityY);
		if (preferedPlayerVelocityY > 0f)
		{
			GoingDownWithGrapple = true;
		}
		velocity.X = preferedPlayerVelocityX;
		velocity.Y = preferedPlayerVelocityY;
		if (num != -1)
		{
			Projectile projectile = Main.projectile[grappling[num]];
			if (projectile.position.X < position.X + (float)width && projectile.position.X + (float)projectile.width >= position.X && projectile.position.Y < position.Y + (float)height && projectile.position.Y + (float)projectile.height >= position.Y)
			{
				int num2 = (int)(projectile.position.X + (float)(projectile.width / 2)) / 16;
				int num3 = (int)(projectile.position.Y + (float)(projectile.height / 2)) / 16;
				velocity = Vector2.Zero;
				if (Main.tile[num2, num3].type == 314)
				{
					Vector2 Position = new Vector2
					{
						X = projectile.position.X + (float)(projectile.width / 2) - (float)(width / 2),
						Y = projectile.position.Y + (float)(projectile.height / 2) - (float)(height / 2)
					};
					RemoveAllGrapplingHooks();
					int num4 = 13;
					if (miscEquips[2].stack > 0 && miscEquips[2].mountType >= 0 && MountID.Sets.Cart[miscEquips[2].mountType] && (!miscEquips[2].expertOnly || Main.expertMode) && (!miscEquips[2].masterOnly || Main.masterMode))
					{
						num4 = miscEquips[2].mountType;
					}
					int num5 = height + Mount.GetHeightBoost(num4);
					if (Minecart.GetOnTrack(num2, num3, ref Position, width, num5) && !Collision.SolidCollision(Position, width, num5 - 20))
					{
						position = Position;
						DelegateMethods.Minecart.rotation = fullRotation;
						DelegateMethods.Minecart.rotationOrigin = fullRotationOrigin;
						mount.SetMount(num4, this, minecartLeft);
						Minecart.WheelSparks(mount.Delegations.MinecartDust, position, width, height, 25);
					}
				}
			}
		}
		if (itemAnimation == 0)
		{
			if (velocity.X == 0f && preferredPlayerDirectionToSet.HasValue)
			{
				ChangeDir(preferredPlayerDirectionToSet.Value);
			}
			if (velocity.X > 0f)
			{
				ChangeDir(1);
			}
			if (velocity.X < 0f)
			{
				ChangeDir(-1);
			}
		}
		if (controlJump)
		{
			if (releaseJump)
			{
				if ((velocity.Y == 0f || (wet && (double)velocity.Y > -0.02 && (double)velocity.Y < 0.02)) && !controlDown)
				{
					velocity.Y = 0f - jumpSpeed;
					jump = jumpHeight / 2;
					releaseJump = false;
				}
				else
				{
					velocity.Y += 0.01f;
					releaseJump = false;
				}
				RefreshDoubleJumps();
				RemoveAllGrapplingHooks();
			}
		}
		else
		{
			releaseJump = true;
		}
	}

	public void DoQueenSlimeHookTeleport(Vector2 targetPosition)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		int num = 150;
		Vector2 val = position;
		Vector2 val2 = velocity;
		for (int i = 0; i < num; i++)
		{
			val2 = (val + base.Size / 2f).DirectionTo(targetPosition).SafeNormalize(Vector2.Zero) * 12f;
			Vector2 val3 = Collision.TileCollision(val, val2, width, height, fallThrough: true, fall2: true, (int)gravDir);
			val += val3;
		}
		int num2 = 10;
		_ = val - position;
		Teleport(val, num2);
		NetMessage.SendData(65, -1, -1, null, 0, whoAmI, val.X, val.Y, num2);
	}

	private void GetGrapplingForces(Vector2 fromPosition, out int? preferredPlayerDirectionToSet, out float preferedPlayerVelocityX, out float preferedPlayerVelocityY)
	{
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0363: Unknown result type (might be due to invalid IL or missing references)
		//IL_0364: Unknown result type (might be due to invalid IL or missing references)
		//IL_0368: Unknown result type (might be due to invalid IL or missing references)
		//IL_0375: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01de: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0200: Unknown result type (might be due to invalid IL or missing references)
		//IL_0205: Unknown result type (might be due to invalid IL or missing references)
		//IL_020a: Unknown result type (might be due to invalid IL or missing references)
		//IL_020c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0211: Unknown result type (might be due to invalid IL or missing references)
		//IL_0213: Unknown result type (might be due to invalid IL or missing references)
		//IL_0215: Unknown result type (might be due to invalid IL or missing references)
		//IL_0128: Unknown result type (might be due to invalid IL or missing references)
		//IL_012f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		//IL_0137: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0143: Unknown result type (might be due to invalid IL or missing references)
		//IL_0148: Unknown result type (might be due to invalid IL or missing references)
		//IL_014a: Unknown result type (might be due to invalid IL or missing references)
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		//IL_0156: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_023a: Unknown result type (might be due to invalid IL or missing references)
		//IL_023c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0221: Unknown result type (might be due to invalid IL or missing references)
		//IL_0223: Unknown result type (might be due to invalid IL or missing references)
		//IL_0225: Unknown result type (might be due to invalid IL or missing references)
		//IL_022c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0231: Unknown result type (might be due to invalid IL or missing references)
		//IL_0173: Unknown result type (might be due to invalid IL or missing references)
		//IL_0180: Unknown result type (might be due to invalid IL or missing references)
		//IL_015f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0164: Unknown result type (might be due to invalid IL or missing references)
		//IL_0169: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0265: Unknown result type (might be due to invalid IL or missing references)
		//IL_026d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0280: Unknown result type (might be due to invalid IL or missing references)
		//IL_0288: Unknown result type (might be due to invalid IL or missing references)
		float grappleX = 0f;
		float grappleY = 0f;
		preferredPlayerDirectionToSet = null;
		int num = 0;
		Vector2 val = default(Vector2);
		for (int i = 0; i < grapCount; i++)
		{
			Projectile projectile = Main.projectile[grappling[i]];
			if (projectile.ai[0] != 2f || projectile.position.HasNaNs())
			{
				continue;
			}
			int type = projectile.type;
			int num2;
			if (projectile.ModProjectile != null)
			{
				num2 = ((projectile.ModProjectile.AIType > 0) ? 1 : 0);
				if (num2 != 0)
				{
					projectile.type = projectile.ModProjectile.AIType;
				}
			}
			else
			{
				num2 = 0;
			}
			grappleX += projectile.position.X + (float)(projectile.width / 2);
			grappleY += projectile.position.Y + (float)(projectile.height / 2);
			num++;
			if (projectile.type == 446)
			{
				((Vector2)(ref val))..ctor((float)(controlRight.ToInt() - controlLeft.ToInt()), (float)(controlDown.ToInt() - controlUp.ToInt()) * gravDir);
				if (val != Vector2.Zero)
				{
					((Vector2)(ref val)).Normalize();
				}
				val *= 100f;
				Vector2 val2 = Vector2.Normalize(base.Center - projectile.Center + val);
				if (val2.HasNaNs())
				{
					val2 = -Vector2.UnitY;
				}
				float num3 = 200f;
				grappleX += val2.X * num3;
				grappleY += val2.Y * num3;
			}
			else if (projectile.type == 652)
			{
				Vector2 val3 = Utils.SafeNormalize(new Vector2((float)(controlRight.ToInt() - controlLeft.ToInt()), (float)(controlDown.ToInt() - controlUp.ToInt()) * gravDir), Vector2.Zero);
				Vector2 val4 = projectile.Center - base.Center;
				Vector2 val5 = val4.SafeNormalize(Vector2.Zero);
				Vector2 val6 = Vector2.Zero;
				if (val3 != Vector2.Zero)
				{
					val6 = val5 * Vector2.Dot(val5, val3);
				}
				float num4 = 6f;
				if (Vector2.Dot(val6, val4) < 0f && ((Vector2)(ref val4)).Length() >= 600f)
				{
					num4 = 0f;
				}
				grappleX += 0f - val4.X + val6.X * num4;
				grappleY += 0f - val4.Y + val6.Y * num4;
			}
			else if (projectile.type == 865)
			{
				Vector2 val7 = (projectile.rotation - (float)Math.PI / 2f).ToRotationVector2().SafeNormalize(Vector2.UnitY);
				Vector2 val8 = -val7 * 28f;
				grappleX += val8.X;
				grappleY += val8.Y;
				if (val7.X != 0f)
				{
					preferredPlayerDirectionToSet = Math.Sign(val7.X);
				}
			}
			if (num2 != 0)
			{
				projectile.type = type;
			}
			ProjectileLoader.GrappleTargetPoint(projectile, this, ref grappleX, ref grappleY);
		}
		if (num == 0)
		{
			preferedPlayerVelocityX = velocity.X;
			preferedPlayerVelocityY = velocity.Y;
			return;
		}
		float num5 = grappleX / (float)num;
		float num6 = grappleY / (float)num;
		preferedPlayerVelocityX = num5 - fromPosition.X;
		preferedPlayerVelocityY = num6 - fromPosition.Y;
		float num7 = (float)Math.Sqrt(preferedPlayerVelocityX * preferedPlayerVelocityX + preferedPlayerVelocityY * preferedPlayerVelocityY);
		float speed = 11f;
		if (Main.projectile[grappling[0]].type == 315)
		{
			speed = 14f;
		}
		if (Main.projectile[grappling[0]].type == 487)
		{
			speed = 12f;
		}
		if (Main.projectile[grappling[0]].type >= 646 && Main.projectile[grappling[0]].type <= 649)
		{
			speed = 16f;
		}
		ProjectileLoader.GrapplePullSpeed(Main.projectile[grappling[0]], this, ref speed);
		float num8 = num7;
		num8 = ((!(num7 > speed)) ? 1f : (speed / num7));
		preferedPlayerVelocityX *= num8;
		preferedPlayerVelocityY *= num8;
	}

	public void RefreshMovementAbilities(bool doubleJumps = true)
	{
		wingTime = wingTimeMax;
		rocketTime = rocketTimeMax;
		rocketDelay = 0;
		if (doubleJumps)
		{
			RefreshDoubleJumps();
		}
	}

	private void RefreshDoubleJumps()
	{
		RefreshExtraJumps();
	}

	/// <summary>
	/// For each extra jump that is <see cref="P:Terraria.DataStructures.ExtraJumpState.Enabled" />, its <see cref="P:Terraria.DataStructures.ExtraJumpState.Available" /> property set to <see langword="true" />, allowing the extra jump to be used again.<br />
	/// Vanilla calls this method when the player is grounded and when jumping off of a grappling hook.
	/// </summary>
	public void RefreshExtraJumps()
	{
		ExtraJumpLoader.RefreshJumps(this);
	}

	/// <summary>
	/// Sets the <see cref="P:Terraria.DataStructures.ExtraJumpState.Available" /> flag for all extra jumps to <see langword="false" />.<br />
	/// If you want to disable an extra jump, use <see cref="M:Terraria.DataStructures.ExtraJumpState.Disable" /> instead.<br />
	/// If you want to disable <b>all</b> extra jumps, but not prevent them once the disabling factor is removed, use <see cref="F:Terraria.Player.blockExtraJumps" /> instead.
	/// </summary>
	public void ConsumeAllExtraJumps()
	{
		ExtraJumpLoader.ConsumeAllJumps(this);
	}

	public void StickyMovement()
	{
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_04b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_04cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_04d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0510: Unknown result type (might be due to invalid IL or missing references)
		//IL_051a: Unknown result type (might be due to invalid IL or missing references)
		//IL_051f: Unknown result type (might be due to invalid IL or missing references)
		//IL_040c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0427: Unknown result type (might be due to invalid IL or missing references)
		//IL_042d: Unknown result type (might be due to invalid IL or missing references)
		//IL_046b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0475: Unknown result type (might be due to invalid IL or missing references)
		//IL_047a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0673: Unknown result type (might be due to invalid IL or missing references)
		//IL_068e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0694: Unknown result type (might be due to invalid IL or missing references)
		//IL_06d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_06dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_06e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_05cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_05e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_05ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_062a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0634: Unknown result type (might be due to invalid IL or missing references)
		//IL_0639: Unknown result type (might be due to invalid IL or missing references)
		//IL_0831: Unknown result type (might be due to invalid IL or missing references)
		//IL_084c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0852: Unknown result type (might be due to invalid IL or missing references)
		//IL_0890: Unknown result type (might be due to invalid IL or missing references)
		//IL_089a: Unknown result type (might be due to invalid IL or missing references)
		//IL_089f: Unknown result type (might be due to invalid IL or missing references)
		//IL_078d: Unknown result type (might be due to invalid IL or missing references)
		//IL_07a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_07ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_07ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_07f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_07fb: Unknown result type (might be due to invalid IL or missing references)
		if (shimmering)
		{
			return;
		}
		bool flag = false;
		if (mount.Type > 0 && MountID.Sets.Cart[mount.Type] && Math.Abs(velocity.X) > 5f)
		{
			flag = true;
		}
		int num = width / 2;
		int num2 = height / 2;
		new Vector2(position.X + (float)(width / 2) - (float)(num / 2), position.Y + (float)(height / 2) - (float)(num2 / 2));
		Vector2 val = Collision.StickyTiles(position, velocity, width, height);
		if (val.Y != -1f && val.X != -1f)
		{
			int num3 = (int)val.X;
			int num4 = (int)val.Y;
			int type = Main.tile[num3, num4].type;
			if (whoAmI == Main.myPlayer && type == 51 && (velocity.X != 0f || velocity.Y != 0f))
			{
				stickyBreak++;
				if (stickyBreak > Main.rand.Next(20, 100) || flag)
				{
					stickyBreak = 0;
					WorldGen.KillTile(num3, num4);
					if (Main.netMode == 1 && !Main.tile[num3, num4].active() && Main.netMode == 1)
					{
						NetMessage.SendData(17, -1, -1, null, 0, num3, num4);
					}
				}
			}
			if (flag)
			{
				return;
			}
			fallStart = (int)(position.Y / 16f);
			if (type != 229)
			{
				jump = 0;
			}
			if (velocity.X > 1f)
			{
				velocity.X = 1f;
			}
			if (velocity.X < -1f)
			{
				velocity.X = -1f;
			}
			if ((double)velocity.X > 0.75 || (double)velocity.X < -0.75)
			{
				velocity.X *= 0.85f;
			}
			else
			{
				velocity.X *= 0.6f;
			}
			if (gravDir == -1f)
			{
				if (velocity.Y < -1f)
				{
					velocity.Y = -1f;
				}
				if (velocity.Y > 5f)
				{
					velocity.Y = 5f;
				}
				if (velocity.Y > 0f)
				{
					velocity.Y *= 0.96f;
				}
				else
				{
					velocity.Y *= 0.3f;
				}
			}
			else
			{
				if (velocity.Y > 1f)
				{
					velocity.Y = 1f;
				}
				if (velocity.Y < -5f)
				{
					velocity.Y = -5f;
				}
				if (velocity.Y < 0f)
				{
					velocity.Y *= 0.96f;
				}
				else
				{
					velocity.Y *= 0.3f;
				}
			}
			if (type != 229 || Main.rand.Next(5) != 0 || (!((double)velocity.Y > 0.15) && !(velocity.Y < 0f)))
			{
				return;
			}
			if ((float)(num3 * 16) < position.X + (float)(width / 2))
			{
				int num5 = Dust.NewDust(new Vector2(position.X - 4f, (float)(num4 * 16)), 4, 16, 153, 0f, 0f, 50);
				Main.dust[num5].scale += (float)Main.rand.Next(0, 6) * 0.1f;
				Dust obj = Main.dust[num5];
				obj.velocity *= 0.1f;
				Main.dust[num5].noGravity = true;
			}
			else
			{
				int num6 = Dust.NewDust(new Vector2(position.X + (float)width - 2f, (float)(num4 * 16)), 4, 16, 153, 0f, 0f, 50);
				Main.dust[num6].scale += (float)Main.rand.Next(0, 6) * 0.1f;
				Dust obj2 = Main.dust[num6];
				obj2.velocity *= 0.1f;
				Main.dust[num6].noGravity = true;
			}
			if (Main.tile[num3, num4 + 1] != null && Main.tile[num3, num4 + 1].type == 229 && position.Y + (float)height > (float)((num4 + 1) * 16))
			{
				if ((float)(num3 * 16) < position.X + (float)(width / 2))
				{
					int num7 = Dust.NewDust(new Vector2(position.X - 4f, (float)(num4 * 16 + 16)), 4, 16, 153, 0f, 0f, 50);
					Main.dust[num7].scale += (float)Main.rand.Next(0, 6) * 0.1f;
					Dust obj3 = Main.dust[num7];
					obj3.velocity *= 0.1f;
					Main.dust[num7].noGravity = true;
				}
				else
				{
					int num8 = Dust.NewDust(new Vector2(position.X + (float)width - 2f, (float)(num4 * 16 + 16)), 4, 16, 153, 0f, 0f, 50);
					Main.dust[num8].scale += (float)Main.rand.Next(0, 6) * 0.1f;
					Dust obj4 = Main.dust[num8];
					obj4.velocity *= 0.1f;
					Main.dust[num8].noGravity = true;
				}
			}
			if (Main.tile[num3, num4 + 2] != null && Main.tile[num3, num4 + 2].type == 229 && position.Y + (float)height > (float)((num4 + 2) * 16))
			{
				if ((float)(num3 * 16) < position.X + (float)(width / 2))
				{
					int num9 = Dust.NewDust(new Vector2(position.X - 4f, (float)(num4 * 16 + 32)), 4, 16, 153, 0f, 0f, 50);
					Main.dust[num9].scale += (float)Main.rand.Next(0, 6) * 0.1f;
					Dust obj5 = Main.dust[num9];
					obj5.velocity *= 0.1f;
					Main.dust[num9].noGravity = true;
				}
				else
				{
					int num10 = Dust.NewDust(new Vector2(position.X + (float)width - 2f, (float)(num4 * 16 + 32)), 4, 16, 153, 0f, 0f, 50);
					Main.dust[num10].scale += (float)Main.rand.Next(0, 6) * 0.1f;
					Dust obj6 = Main.dust[num10];
					obj6.velocity *= 0.1f;
					Main.dust[num10].noGravity = true;
				}
			}
		}
		else
		{
			stickyBreak = 0;
		}
	}

	public bool HasLockedInventory()
	{
		return IsStackingItems();
	}

	public bool IsStackingItems()
	{
		for (int i = 0; i < inventoryChestStack.Length; i++)
		{
			if (inventoryChestStack[i])
			{
				if (inventory[i].type != 0 && inventory[i].stack != 0)
				{
					return true;
				}
				inventoryChestStack[i] = false;
			}
		}
		if (disableVoidBag >= 0)
		{
			return true;
		}
		return false;
	}

	public List<int> GetNearbyContainerProjectilesList()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		List<int> list = new List<int>();
		Vector2 center = base.Center;
		for (int i = 0; i < 1000; i++)
		{
			Projectile projectile = Main.projectile[i];
			if (!projectile.active)
			{
				continue;
			}
			int containerIndex = -1;
			if (projectile.TryGetContainerIndex(out containerIndex))
			{
				Point val = projectile.Hitbox.ClosestPointInRect(center).ToTileCoordinates();
				if (IsInTileInteractionRange(val.X, val.Y, TileReachCheckSettings.QuickStackToNearbyChests))
				{
					list.Add(i);
				}
			}
		}
		return list;
	}

	public void UpdateNearbyInteractibleProjectilesList()
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		List<int> projectilesToInteractWith = _projectilesToInteractWith;
		projectilesToInteractWith.Clear();
		if (!Main.CurrentFrameFlags.HadAnActiveInteractibleProjectile)
		{
			return;
		}
		Vector2 compareSpot = base.Center;
		for (int i = 0; i < 1000; i++)
		{
			Projectile proj = Main.projectile[i];
			if (IsProjectileInteractibleAndInInteractionRange(proj, ref compareSpot))
			{
				projectilesToInteractWith.Add(i);
			}
		}
	}

	public bool IsProjectileInteractibleAndInInteractionRange(Projectile proj, ref Vector2 compareSpot)
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		if (!proj.active)
		{
			return false;
		}
		if (!proj.IsInteractible())
		{
			return false;
		}
		Point val = proj.Hitbox.ClosestPointInRect(compareSpot).ToTileCoordinates();
		if (!IsInTileInteractionRange(val.X, val.Y, TileReachCheckSettings.Simple))
		{
			return false;
		}
		return true;
	}

	public bool useVoidBag()
	{
		for (int i = 0; i < 58; i++)
		{
			if (inventory[i].stack > 0 && inventory[i].type == 4131)
			{
				return true;
			}
		}
		return false;
	}

	public void QuickStackAllChests()
	{
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_041e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0182: Unknown result type (might be due to invalid IL or missing references)
		//IL_0188: Unknown result type (might be due to invalid IL or missing references)
		//IL_018d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0192: Unknown result type (might be due to invalid IL or missing references)
		//IL_050e: Unknown result type (might be due to invalid IL or missing references)
		if (HasLockedInventory())
		{
			return;
		}
		List<int> nearbyContainerProjectilesList = GetNearbyContainerProjectilesList();
		for (int i = 0; i < nearbyContainerProjectilesList.Count; i++)
		{
			Projectile projectile = Main.projectile[nearbyContainerProjectilesList[i]];
			if (projectile.TryGetContainerIndex(out var containerIndex))
			{
				ContainerTransferContext context = ContainerTransferContext.FromProjectile(projectile);
				int num = chest;
				chest = containerIndex;
				ChestUI.QuickStack(context);
				if (useVoidBag())
				{
					ChestUI.QuickStack(context, voidStack: true);
				}
				chest = num;
			}
		}
		int num2 = 39;
		int num3 = (int)(base.Center.X / 16f);
		int num4 = (int)(base.Center.Y / 16f);
		for (int j = num3 - num2; j <= num3 + num2; j++)
		{
			if (j < 0 || j >= Main.maxTilesX)
			{
				continue;
			}
			for (int k = num4 - num2; k <= num4 + num2; k++)
			{
				if (k < 0 || k >= Main.maxTilesY)
				{
					continue;
				}
				int num5 = 0;
				if (Main.tile[j, k].type == 29)
				{
					num5 = -2;
				}
				else if (Main.tile[j, k].type == 97)
				{
					num5 = -3;
				}
				else if (Main.tile[j, k].type == 463)
				{
					num5 = -4;
				}
				else if (Main.tile[j, k].type == 491)
				{
					num5 = -5;
				}
				if (num5 >= 0)
				{
					continue;
				}
				Vector2 val = new Vector2((float)(j * 16 + 8), (float)(k * 16 + 8)) - base.Center;
				if (((Vector2)(ref val)).Length() < 600f)
				{
					ContainerTransferContext context2 = ContainerTransferContext.FromBlockPosition(j, k);
					int num6 = chest;
					chest = num5;
					ChestUI.QuickStack(context2);
					if (useVoidBag())
					{
						ChestUI.QuickStack(context2, voidStack: true);
					}
					chest = num6;
				}
			}
		}
		if (Main.netMode == 1)
		{
			for (int l = 10; l < 50; l++)
			{
				if (inventory[l].type > 0 && inventory[l].stack > 0 && !inventory[l].favorited && !inventory[l].IsACoin)
				{
					NetMessage.SendData(5, -1, -1, null, whoAmI, PlayerItemSlotID.Inventory0 + l, inventory[l].prefix);
					NetMessage.SendData(85, -1, -1, null, PlayerItemSlotID.Inventory0 + l);
					inventoryChestStack[l] = true;
				}
			}
			if (!useVoidBag())
			{
				return;
			}
			for (int m = 0; m < 40; m++)
			{
				if (bank4.item[m].type > 0 && bank4.item[m].stack > 0 && !bank4.item[m].favorited && !bank4.item[m].IsACoin)
				{
					NetMessage.SendData(5, -1, -1, null, whoAmI, PlayerItemSlotID.Bank4_0 + m, bank4.item[m].prefix);
					NetMessage.SendData(85, -1, -1, null, PlayerItemSlotID.Bank4_0 + m);
					disableVoidBag = m;
				}
			}
			return;
		}
		for (int n = 10; n < 50; n++)
		{
			if (inventory[n].type > 0 && inventory[n].stack > 0 && !inventory[n].favorited && !inventory[n].IsACoin)
			{
				int type = inventory[n].type;
				_ = inventory[n].stack;
				inventory[n] = Chest.PutItemInNearbyChest(inventory[n], base.Center);
				if (inventory[n].type == type)
				{
					_ = inventory[n].stack;
				}
			}
		}
		if (!useVoidBag())
		{
			return;
		}
		for (int num7 = 0; num7 < 40; num7++)
		{
			if (bank4.item[num7].type > 0 && bank4.item[num7].stack > 0 && !bank4.item[num7].favorited && !bank4.item[num7].IsACoin)
			{
				int type2 = bank4.item[num7].type;
				_ = bank4.item[num7].stack;
				bank4.item[num7] = Chest.PutItemInNearbyChest(bank4.item[num7], base.Center);
				if (bank4.item[num7].type == type2)
				{
					_ = bank4.item[num7].stack;
				}
			}
		}
	}

	public void CheckDrowning()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_03df: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_035f: Unknown result type (might be due to invalid IL or missing references)
		//IL_037c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0382: Unknown result type (might be due to invalid IL or missing references)
		bool flag = Collision.DrownCollision(position, width, height, gravDir);
		if (armor[0].type == 250 || armor[0].type == 4275)
		{
			flag = true;
		}
		if (inventory[selectedItem].type == 186 && itemAnimation == 0)
		{
			try
			{
				int x = (int)((position.X + (float)(width / 2) + (float)(6 * direction)) / 16f);
				int num = 0;
				if (gravDir == -1f)
				{
					num = height;
				}
				int y = (int)((position.Y + (float)num - 44f * gravDir) / 16f);
				if (Main.tile[x, y] != null && Main.tile[x, y].liquid < 128)
				{
					if (Main.tile[x, y] == null)
					{
						Main.tile[x, y] = default(Tile);
					}
					if (!Main.tile[x, y].active() || !Main.tileSolid[Main.tile[x, y].type] || Main.tileSolidTop[Main.tile[x, y].type])
					{
						flag = false;
					}
				}
			}
			catch
			{
			}
		}
		if (gills)
		{
			flag = Main.getGoodWorld && !flag;
		}
		if (shimmering)
		{
			flag = false;
		}
		if (mount.Active && mount.Type == 4)
		{
			flag = false;
		}
		if (Main.myPlayer == whoAmI)
		{
			if (accMerman)
			{
				if (flag)
				{
					merman = true;
				}
				flag = false;
			}
			if (flag)
			{
				breathCD++;
				if (breathCD >= breathCDMax)
				{
					breathCD = 0;
					breath--;
					if (breath == 0)
					{
						SoundEngine.PlaySound(23);
					}
					if (breath <= 0)
					{
						lifeRegenTime = 0f;
						breath = 0;
						statLife -= 2;
						if (statLife <= 0)
						{
							statLife = 0;
							KillMe(PlayerDeathReason.ByOther(1), 10.0, 0);
						}
					}
				}
			}
			else
			{
				breath += 3;
				if (breath > breathMax)
				{
					breath = breathMax;
				}
				breathCD = 0;
			}
		}
		if (flag && Main.rand.Next(20) == 0 && !lavaWet && !honeyWet)
		{
			int num2 = 0;
			if (gravDir == -1f)
			{
				num2 += height - 12;
			}
			if (inventory[selectedItem].type == 186)
			{
				Dust.NewDust(new Vector2(position.X + (float)(10 * direction) + 4f, position.Y + (float)num2 - 54f * gravDir), width - 8, 8, 34, 0f, 0f, 0, default(Color), 1.2f);
			}
			else
			{
				Dust.NewDust(new Vector2(position.X + (float)(12 * direction), position.Y + (float)num2 + 4f * gravDir), width - 8, 8, 34, 0f, 0f, 0, default(Color), 1.2f);
			}
		}
	}

	public void CheckCrackedBrickBreak()
	{
		//IL_016e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0174: Unknown result type (might be due to invalid IL or missing references)
		//IL_0179: Unknown result type (might be due to invalid IL or missing references)
		//IL_017e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0181: Unknown result type (might be due to invalid IL or missing references)
		//IL_018f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0128: Unknown result type (might be due to invalid IL or missing references)
		//IL_012f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		//IL_010f: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_0147: Unknown result type (might be due to invalid IL or missing references)
		//IL_014e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0244: Unknown result type (might be due to invalid IL or missing references)
		//IL_0249: Unknown result type (might be due to invalid IL or missing references)
		//IL_024d: Unknown result type (might be due to invalid IL or missing references)
		if (shimmering)
		{
			return;
		}
		bool flag = false;
		if ((float)Main.rand.Next(2, 12) < Math.Abs(velocity.X))
		{
			flag = true;
		}
		if ((float)Main.rand.Next(2, 12) < velocity.Y)
		{
			flag = true;
		}
		if (flag && velocity.Y < 1f)
		{
			Point val = (base.Bottom + Vector2.UnitY).ToTileCoordinates();
			Point val2 = (base.BottomLeft + Vector2.UnitY).ToTileCoordinates();
			Point val3 = (base.BottomRight + Vector2.UnitY).ToTileCoordinates();
			if ((WorldGen.SolidTileAllowBottomSlope(val.X, val.Y) && !TileID.Sets.CrackedBricks[Main.tile[val.X, val.Y].type]) || (WorldGen.SolidTileAllowBottomSlope(val2.X, val2.Y) && !TileID.Sets.CrackedBricks[Main.tile[val2.X, val2.Y].type]) || (WorldGen.SolidTileAllowBottomSlope(val3.X, val3.Y) && !TileID.Sets.CrackedBricks[Main.tile[val3.X, val3.Y].type]))
			{
				flag = false;
			}
		}
		if (!flag)
		{
			return;
		}
		Vector2 val4 = position + velocity;
		flag = false;
		int num = (int)(val4.X / 16f);
		int num2 = (int)((val4.X + (float)width) / 16f);
		int num3 = (int)((position.Y + (float)height + 1f) / 16f);
		Rectangle rect = getRect();
		((Rectangle)(ref rect)).Inflate(1, 1);
		for (int i = num; i <= num2; i++)
		{
			for (int j = num3; j <= num3 + 1 && Main.tile[i, j] != null; j++)
			{
				if (!Main.tile[i, j].nactive() || WorldGen.SolidTile(i, j - 1) || !TileID.Sets.CrackedBricks[Main.tile[i, j].type])
				{
					continue;
				}
				Rectangle val5 = new Rectangle(i * 16, j * 16, 16, 16);
				if (((Rectangle)(ref val5)).Intersects(rect))
				{
					flag = true;
					if (velocity.Y > 1f)
					{
						velocity.Y = 1f;
					}
					NetMessage.SendData(13, -1, -1, null, whoAmI);
				}
			}
		}
		if (!flag)
		{
			return;
		}
		num = (int)((val4.X - 16f - 8f) / 16f);
		num2 = (int)((val4.X + (float)width + 16f + 8f) / 16f);
		for (int k = num; k <= num2; k++)
		{
			for (int l = num3; l <= num3 + 2; l++)
			{
				if (Main.tile[k, l].nactive() && !WorldGen.SolidTile(k, l - 1) && TileID.Sets.CrackedBricks[Main.tile[k, l].type])
				{
					WorldGen.KillTile(k, l);
					if (Main.netMode == 1)
					{
						NetMessage.SendData(17, -1, -1, null, 20, k, l);
					}
				}
			}
		}
	}

	public void CheckIceBreak()
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		if (!(velocity.Y > 7f))
		{
			return;
		}
		Vector2 val = position + velocity;
		int num = (int)(val.X / 16f);
		int num2 = (int)((val.X + (float)width) / 16f);
		int num3 = (int)((position.Y + (float)height + 1f) / 16f);
		for (int i = num; i <= num2; i++)
		{
			for (int j = num3; j <= num3 + 1 && Main.tile[i, j] != null; j++)
			{
				if (Main.tile[i, j].nactive() && Main.tile[i, j].type == 162 && !WorldGen.SolidTile(i, j - 1))
				{
					WorldGen.KillTile(i, j);
					if (Main.netMode == 1)
					{
						NetMessage.SendData(17, -1, -1, null, 0, i, j);
					}
				}
			}
		}
	}

	public void SlopeDownMovement()
	{
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		sloping = false;
		if (!mount.Active || mount.Type != 48)
		{
			float y = velocity.Y;
			Vector4 val = Collision.WalkDownSlope(position, velocity, width, height, gravity * gravDir);
			position.X = val.X;
			position.Y = val.Y;
			velocity.X = val.Z;
			velocity.Y = val.W;
			if (velocity.Y != y)
			{
				sloping = true;
			}
		}
	}

	public void ShimmerCollision(bool fallThrough, bool ignorePlats, bool noCollision)
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		int num = ((!onTrack) ? height : (height - 20));
		Vector2 val = velocity;
		if (!noCollision)
		{
			velocity = Collision.TileCollision(position, velocity, width, num, fallThrough, ignorePlats, (int)gravDir);
		}
		Vector2 val2 = velocity * 0.375f;
		if (velocity.X != val.X)
		{
			val2.X = velocity.X;
		}
		if (velocity.Y != val.Y)
		{
			val2.Y = velocity.Y;
		}
		position += val2;
		if (shimmerImmune && !noCollision)
		{
			TryFloatingInFluid();
		}
	}

	public void HoneyCollision(bool fallThrough, bool ignorePlats)
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		int num = ((!onTrack) ? height : (height - 20));
		Vector2 val = velocity;
		velocity = Collision.TileCollision(position, velocity, width, num, fallThrough, ignorePlats, (int)gravDir);
		Vector2 val2 = velocity * 0.25f;
		if (velocity.X != val.X)
		{
			val2.X = velocity.X;
		}
		if (velocity.Y != val.Y)
		{
			val2.Y = velocity.Y;
		}
		position += val2;
		TryFloatingInFluid();
	}

	public void WaterCollision(bool fallThrough, bool ignorePlats)
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		int num = ((!onTrack) ? height : (height - 20));
		Vector2 val = velocity;
		velocity = Collision.TileCollision(position, velocity, width, num, fallThrough, ignorePlats, (int)gravDir);
		Vector2 val2 = velocity * 0.5f;
		if (velocity.X != val.X)
		{
			val2.X = velocity.X;
		}
		if (velocity.Y != val.Y)
		{
			val2.Y = velocity.Y;
		}
		position += val2;
		TryFloatingInFluid();
	}

	private void TryFloatingInFluid()
	{
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		if (!ShouldFloatInWater)
		{
			return;
		}
		if (whoAmI == Main.myPlayer && sitting.isSitting)
		{
			sitting.SitUp(this);
		}
		if (Collision.GetWaterLine(base.Center.ToTileCoordinates(), out var waterLineHeight))
		{
			float num = base.Center.Y;
			if (mount.Active && mount.Type == 37)
			{
				num -= 6f;
			}
			float num2 = num + 8f;
			if (num2 + velocity.Y < waterLineHeight)
			{
				return;
			}
			if (num > waterLineHeight)
			{
				velocity.Y -= 0.4f;
				if (velocity.Y < -6f)
				{
					velocity.Y = -6f;
				}
				return;
			}
			velocity.Y = waterLineHeight - num2;
			if (velocity.Y < -3f)
			{
				velocity.Y = -3f;
			}
			if (velocity.Y == 0f)
			{
				velocity.Y = float.Epsilon;
			}
		}
		else
		{
			velocity.Y -= 0.4f;
		}
	}

	public void DryCollision(bool fallThrough, bool ignorePlats)
	{
		//IL_0396: Unknown result type (might be due to invalid IL or missing references)
		//IL_039c: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_040d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0412: Unknown result type (might be due to invalid IL or missing references)
		//IL_0418: Unknown result type (might be due to invalid IL or missing references)
		//IL_043e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0444: Unknown result type (might be due to invalid IL or missing references)
		//IL_0449: Unknown result type (might be due to invalid IL or missing references)
		//IL_044e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_038d: Unknown result type (might be due to invalid IL or missing references)
		//IL_038e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_0269: Unknown result type (might be due to invalid IL or missing references)
		//IL_026e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0280: Unknown result type (might be due to invalid IL or missing references)
		//IL_0285: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02be: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0302: Unknown result type (might be due to invalid IL or missing references)
		//IL_0307: Unknown result type (might be due to invalid IL or missing references)
		//IL_0309: Unknown result type (might be due to invalid IL or missing references)
		//IL_030e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0316: Unknown result type (might be due to invalid IL or missing references)
		//IL_0328: Unknown result type (might be due to invalid IL or missing references)
		//IL_0341: Unknown result type (might be due to invalid IL or missing references)
		//IL_0343: Unknown result type (might be due to invalid IL or missing references)
		//IL_0371: Unknown result type (might be due to invalid IL or missing references)
		//IL_0376: Unknown result type (might be due to invalid IL or missing references)
		//IL_0378: Unknown result type (might be due to invalid IL or missing references)
		//IL_0379: Unknown result type (might be due to invalid IL or missing references)
		//IL_037b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0380: Unknown result type (might be due to invalid IL or missing references)
		int num = ((!onTrack) ? height : (height - 10));
		if (((Vector2)(ref velocity)).Length() > 16f)
		{
			Vector2 val = Collision.TileCollision(position, velocity, width, num, fallThrough, ignorePlats, (int)gravDir);
			float num2 = ((Vector2)(ref velocity)).Length();
			Vector2 val2 = Vector2.Normalize(velocity);
			if (val.Y == 0f)
			{
				val2.Y = 0f;
			}
			Vector2 val3 = Vector2.Zero;
			bool flag = mount.Type == 7 || mount.Type == 8 || mount.Type == 12 || mount.Type == 44 || mount.Type == 49;
			_ = Vector2.Zero;
			while (num2 > 0f)
			{
				float num3 = num2;
				if (num3 > 16f)
				{
					num3 = 16f;
				}
				num2 -= num3;
				Vector2 val4 = val2 * num3;
				velocity = val4;
				SlopeDownMovement();
				val4 = velocity;
				if (velocity.Y == gravity && (!mount.Active || (!mount.Cart && mount.Type != 48 && !flag)))
				{
					Collision.StepDown(ref position, ref val4, width, height, ref stepSpeed, ref gfxOffY, (int)gravDir, waterWalk || waterWalk2);
				}
				if (gravDir == -1f)
				{
					if ((carpetFrame != -1 || velocity.Y <= gravity) && !controlUp)
					{
						Collision.StepUp(ref position, ref val4, width, height, ref stepSpeed, ref gfxOffY, (int)gravDir, controlUp);
					}
				}
				else if (flag || ((carpetFrame != -1 || velocity.Y >= gravity) && !controlDown && !mount.Cart))
				{
					Collision.StepUp(ref position, ref val4, width, height, ref stepSpeed, ref gfxOffY, (int)gravDir, controlUp);
				}
				Vector2 val5 = Collision.TileCollision(position, val4, width, num, fallThrough, ignorePlats, (int)gravDir);
				if (Collision.up && gravDir == 1f)
				{
					jump = 0;
				}
				if (waterWalk || waterWalk2)
				{
					Vector2 val6 = velocity;
					val5 = Collision.WaterCollision(position, val5, width, height, fallThrough, fall2: false, waterWalk);
					if (val6 != velocity)
					{
						fallStart = (int)(position.Y / 16f);
					}
				}
				position += val5;
				bool falling = false;
				if (val5.Y > gravity)
				{
					falling = true;
				}
				if (val5.Y < 0f - gravity)
				{
					falling = true;
				}
				velocity = val5;
				UpdateTouchingTiles();
				TryBouncingBlocks(falling);
				TryLandingOnDetonator();
				SlopingCollision(fallThrough, ignorePlats);
				Collision.StepConveyorBelt(this, gravDir);
				val5 = velocity;
				val3 += val5;
			}
			velocity = val3;
			return;
		}
		velocity = Collision.TileCollision(position, velocity, width, num, fallThrough, ignorePlats, (int)gravDir);
		if (Collision.up && gravDir == 1f)
		{
			jump = 0;
		}
		if (waterWalk || waterWalk2)
		{
			Vector2 val7 = velocity;
			velocity = Collision.WaterCollision(position, velocity, width, height, fallThrough, fall2: false, waterWalk);
			if (val7 != velocity)
			{
				fallStart = (int)(position.Y / 16f);
			}
		}
		position += velocity;
	}

	private bool TouchBlockSurfaceCenter(int x, int y, Tile tile, out int exitNormalX, out int exitNormalY, out Vector2 surfaceCenter)
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0130: Unknown result type (might be due to invalid IL or missing references)
		//IL_0137: Unknown result type (might be due to invalid IL or missing references)
		//IL_013c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0143: Unknown result type (might be due to invalid IL or missing references)
		//IL_0148: Unknown result type (might be due to invalid IL or missing references)
		//IL_014c: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0153: Unknown result type (might be due to invalid IL or missing references)
		//IL_0158: Unknown result type (might be due to invalid IL or missing references)
		//IL_0164: Unknown result type (might be due to invalid IL or missing references)
		//IL_0168: Unknown result type (might be due to invalid IL or missing references)
		//IL_0183: Unknown result type (might be due to invalid IL or missing references)
		//IL_0184: Unknown result type (might be due to invalid IL or missing references)
		//IL_018a: Unknown result type (might be due to invalid IL or missing references)
		//IL_018f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0194: Unknown result type (might be due to invalid IL or missing references)
		//IL_0198: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0200: Unknown result type (might be due to invalid IL or missing references)
		//IL_0205: Unknown result type (might be due to invalid IL or missing references)
		//IL_0209: Unknown result type (might be due to invalid IL or missing references)
		exitNormalX = (exitNormalY = 0);
		Vector2 val = default(Vector2);
		((Vector2)(ref val))..ctor((float)(x * 16), (float)(y * 16));
		Vector2 val2 = default(Vector2);
		((Vector2)(ref val2))..ctor(val.X + 16f, val.Y);
		Vector2 val3 = default(Vector2);
		((Vector2)(ref val3))..ctor(val.X, val.Y + 16f);
		Vector2 val4 = default(Vector2);
		((Vector2)(ref val4))..ctor(val.X + 16f, val.Y + 16f);
		int num = 0;
		int num2 = 0;
		switch (tile.blockType())
		{
		case 1:
			val.Y += 8f;
			val2.Y += 8f;
			break;
		case 3:
			val.Y += 16f;
			num = -1;
			break;
		case 2:
			val2.Y += 16f;
			num = 1;
			break;
		case 5:
			val3.Y -= 16f;
			num2 = -1;
			break;
		case 4:
			val4.Y -= 16f;
			num2 = 1;
			break;
		}
		Vector2 val5 = default(Vector2);
		((Vector2)(ref val5))..ctor(0.0001f);
		_ = position - val5;
		_ = base.Size + val5 * 2f;
		Rectangle hitbox = base.Hitbox;
		surfaceCenter = Vector2.Lerp(val, val2, 0.5f);
		float num3 = 4f;
		if (hitbox.Distance(surfaceCenter) <= num3)
		{
			exitNormalX = num;
			exitNormalY = -1;
			return true;
		}
		surfaceCenter = Vector2.Lerp(val3, val4, 0.5f);
		if (hitbox.Distance(surfaceCenter) <= num3)
		{
			exitNormalX = num2;
			exitNormalY = 1;
			return true;
		}
		if (val != val3)
		{
			surfaceCenter = Vector2.Lerp(val, val3, 0.5f);
			if (hitbox.Distance(surfaceCenter) <= num3)
			{
				exitNormalX = -1;
				exitNormalY = 0;
				return true;
			}
		}
		if (val2 != val4)
		{
			surfaceCenter = Vector2.Lerp(val2, val4, 0.5f);
			if (hitbox.Distance(surfaceCenter) <= num3)
			{
				exitNormalX = 1;
				exitNormalY = 0;
				return true;
			}
		}
		return false;
	}

	public void SlopingCollision(bool fallThrough, bool ignorePlats)
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_010e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		if (ignorePlats || controlDown || grappling[0] >= 0 || gravDir == -1f)
		{
			stairFall = true;
		}
		Vector4 val = Collision.SlopeCollision(position, velocity, width, height, gravity, stairFall);
		if (Collision.stairFall)
		{
			stairFall = true;
		}
		else if (!fallThrough)
		{
			stairFall = false;
		}
		if (Collision.stair && Math.Abs(val.Y - position.Y) > 8f + Math.Abs(velocity.X))
		{
			gfxOffY -= val.Y - position.Y;
			stepSpeed = 4f;
		}
		_ = velocity;
		position.X = val.X;
		position.Y = val.Y;
		velocity.X = val.Z;
		velocity.Y = val.W;
		if (gravDir == -1f && velocity.Y == 0.0101f)
		{
			velocity.Y = 0f;
		}
	}

	public void FloorVisuals(bool Falling)
	{
		int num = (int)((position.X + (float)(width / 2)) / 16f);
		int y = (int)((position.Y + (float)height) / 16f);
		if (gravDir == -1f)
		{
			y = (int)(position.Y - 0.1f) / 16;
		}
		Tile? floorTile = GetFloorTile(num, y);
		int num2 = -1;
		if (floorTile.HasValue)
		{
			num2 = floorTile.Value.type;
		}
		if (num2 <= -1)
		{
			ResetFloorFlags();
			return;
		}
		sticky = num2 == 229;
		slippy = TileID.Sets.IceSkateSlippery[num2];
		slippy2 = num2 == 197;
		powerrun = num2 == 198;
		runningOnSand = TileID.Sets.Conversion.Sand[num2] || TileID.Sets.Conversion.Sandstone[num2] || TileID.Sets.Conversion.HardenedSand[num2];
		if (num2 == 666 && whoAmI == Main.myPlayer)
		{
			AddBuff(120, 180);
		}
		TileLoader.FloorVisuals(num2, this);
		if (Main.tile[num - 1, y].slope() != 0 || Main.tile[num, y].slope() != 0 || Main.tile[num + 1, y].slope() != 0)
		{
			num2 = -1;
		}
		if (!wet && !mount.Cart)
		{
			MakeFloorDust(Falling, num2, floorTile.Value.color());
		}
	}

	public void ResetFloorFlags()
	{
		slippy = false;
		slippy2 = false;
		sticky = false;
		powerrun = false;
		runningOnSand = false;
	}

	/// <summary>
	/// Gets a solid, unactuated tile at the tile coordinates provided. Will fallback to the tile to the left or right if necessary. Returns null if no suitable tile is found. Typically used to retrieve the tile a player is standing on by passing in the tile coordinates directly below the player.
	/// </summary>
	public static Tile? GetFloorTile(int x, int y)
	{
		Tile? result = null;
		if (Main.tile[x - 1, y] == null)
		{
			Main.tile[x - 1, y] = default(Tile);
		}
		if (Main.tile[x + 1, y] == null)
		{
			Main.tile[x + 1, y] = default(Tile);
		}
		if (Main.tile[x, y] == null)
		{
			Main.tile[x, y] = default(Tile);
		}
		if (Main.tile[x, y].nactive() && Main.tileSolid[Main.tile[x, y].type])
		{
			result = Main.tile[x, y];
		}
		else if (Main.tile[x - 1, y].nactive() && Main.tileSolid[Main.tile[x - 1, y].type])
		{
			result = Main.tile[x - 1, y];
		}
		else if (Main.tile[x + 1, y].nactive() && Main.tileSolid[Main.tile[x + 1, y].type])
		{
			result = Main.tile[x + 1, y];
		}
		return result;
	}

	public static int GetFloorTileType(int x, int y)
	{
		Tile? floorTile = GetFloorTile(x, y);
		return ((int?)(floorTile.HasValue ? new ushort?(floorTile.GetValueOrDefault().type) : ((ushort?)null))) ?? (-1);
	}

	private void MakeFloorDust(bool Falling, int type, int paintColor)
	{
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0322: Unknown result type (might be due to invalid IL or missing references)
		//IL_0431: Unknown result type (might be due to invalid IL or missing references)
		//IL_044b: Unknown result type (might be due to invalid IL or missing references)
		//IL_06f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_06fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0701: Unknown result type (might be due to invalid IL or missing references)
		//IL_061b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0625: Unknown result type (might be due to invalid IL or missing references)
		//IL_062a: Unknown result type (might be due to invalid IL or missing references)
		if (type == 659 || type == 667)
		{
			bool flag = true;
			if (!Falling)
			{
				float num = Math.Abs(velocity.X) / 3f;
				if ((float)Main.rand.Next(100) > num * 50f)
				{
					flag = false;
				}
			}
			if (!flag)
			{
				return;
			}
			Vector2 positionInWorld = new Vector2(position.X, position.Y + (float)height - 2f) + new Vector2((float)width * Main.rand.NextFloat(), 6f * Main.rand.NextFloat());
			Vector2 val = Main.rand.NextVector2Circular(0.8f, 0.8f);
			if (val.Y > 0f)
			{
				val.Y *= -1f;
			}
			ParticleOrchestrator.RequestParticleSpawn(clientOnly: true, ParticleOrchestraType.ShimmerBlock, new ParticleOrchestraSettings
			{
				PositionInWorld = positionInWorld,
				MovementVector = val
			}, whoAmI);
		}
		if (!TileLoader.HasWalkDust(type) && type != 147 && type != 25 && type != 53 && type != 189 && type != 0 && type != 123 && type != 57 && type != 112 && type != 116 && type != 196 && type != 193 && type != 195 && type != 197 && type != 199 && type != 229 && type != 234 && type != 371 && type != 460 && type != 666)
		{
			return;
		}
		int num2 = 1;
		if (Falling)
		{
			num2 = 20;
			if (type == 666)
			{
				SoundEngine.PlaySound(SoundID.Item177, (int)base.Center.X, (int)base.Bottom.Y);
			}
		}
		for (int i = 0; i < num2; i++)
		{
			bool makeDust = true;
			int dustType = 76;
			if (type == 666)
			{
				if (paintColor != 0)
				{
					break;
				}
				dustType = 322;
			}
			if (type == 53)
			{
				dustType = 32;
			}
			if (type == 189)
			{
				dustType = 16;
			}
			if (type == 0)
			{
				dustType = 0;
			}
			if (type == 123)
			{
				dustType = 53;
			}
			if (type == 57)
			{
				dustType = 36;
			}
			if (type == 112)
			{
				dustType = 14;
			}
			if (type == 234)
			{
				dustType = 122;
			}
			if (type == 116)
			{
				dustType = 51;
			}
			if (type == 196)
			{
				dustType = 108;
			}
			if (type == 193)
			{
				dustType = 4;
			}
			if (type == 195 || type == 199)
			{
				dustType = 5;
			}
			if (type == 197)
			{
				dustType = 4;
			}
			if (type == 229)
			{
				dustType = 153;
			}
			if (type == 371)
			{
				dustType = 243;
			}
			if (type == 460)
			{
				dustType = 108;
			}
			if (type == 25)
			{
				dustType = 37;
			}
			if (dustType == 32 && Main.rand.Next(2) == 0)
			{
				makeDust = false;
			}
			if (dustType == 14 && Main.rand.Next(2) == 0)
			{
				makeDust = false;
			}
			if (dustType == 51 && Main.rand.Next(2) == 0)
			{
				makeDust = false;
			}
			if (dustType == 36 && Main.rand.Next(2) == 0)
			{
				makeDust = false;
			}
			if (dustType == 0 && Main.rand.Next(3) != 0)
			{
				makeDust = false;
			}
			if (dustType == 53 && Main.rand.Next(3) != 0)
			{
				makeDust = false;
			}
			Color color = default(Color);
			if (type == 193)
			{
				((Color)(ref color))..ctor(30, 100, 255, 100);
			}
			if (type == 197)
			{
				((Color)(ref color))..ctor(97, 200, 255, 100);
			}
			if (type == 460)
			{
				((Color)(ref color))..ctor(100, 150, 130, 100);
			}
			TileLoader.WalkDust(type, ref dustType, ref makeDust, ref color);
			if (!Falling)
			{
				float num3 = Math.Abs(velocity.X) / 3f;
				if ((float)Main.rand.Next(100) > num3 * 100f)
				{
					makeDust = false;
				}
			}
			if (!makeDust)
			{
				continue;
			}
			float num4 = velocity.X;
			if (num4 > 6f)
			{
				num4 = 6f;
			}
			if (num4 < -6f)
			{
				num4 = -6f;
			}
			if (!(velocity.X != 0f || Falling))
			{
				continue;
			}
			int num5 = Dust.NewDust(new Vector2(position.X, position.Y + (float)height - 2f), width, 6, dustType, 0f, 0f, 50, color);
			if (gravDir == -1f)
			{
				Main.dust[num5].position.Y -= height + 4;
			}
			if (dustType == 76)
			{
				Main.dust[num5].scale += (float)Main.rand.Next(3) * 0.1f;
				Main.dust[num5].noLight = true;
			}
			if (dustType == 16 || dustType == 108 || dustType == 153)
			{
				Main.dust[num5].scale += (float)Main.rand.Next(6) * 0.1f;
			}
			if (dustType == 37)
			{
				Main.dust[num5].scale += 0.25f;
				Main.dust[num5].alpha = 50;
			}
			if (dustType == 5)
			{
				Main.dust[num5].scale += (float)Main.rand.Next(2, 8) * 0.1f;
			}
			Main.dust[num5].noGravity = true;
			if (dustType == 322)
			{
				if (Main.rand.Next(4) == 0)
				{
					Main.dust[num5].noGravity = false;
					Main.dust[num5].scale *= 1.1f;
				}
				else
				{
					Main.dust[num5].scale *= 1.2f;
				}
			}
			if (num2 > 1)
			{
				Main.dust[num5].velocity.X *= 1.2f;
				Main.dust[num5].velocity.Y *= 0.8f;
				Main.dust[num5].velocity.Y -= 1f;
				Dust obj = Main.dust[num5];
				obj.velocity *= 0.8f;
				Main.dust[num5].scale += (float)Main.rand.Next(3) * 0.1f;
				Main.dust[num5].velocity.X = (Main.dust[num5].position.X - (position.X + (float)(width / 2))) * 0.2f;
				if (Main.dust[num5].velocity.Y > 0f)
				{
					Main.dust[num5].velocity.Y *= -1f;
				}
				Main.dust[num5].velocity.X += num4 * 0.3f;
			}
			else
			{
				Dust obj2 = Main.dust[num5];
				obj2.velocity *= 0.2f;
			}
			Main.dust[num5].position.X -= num4 * 1f;
			if (gravDir == -1f)
			{
				Main.dust[num5].velocity.Y *= -1f;
			}
		}
	}

	public void BordersMovement()
	{
		if (position.X < Main.leftWorld + 640f + 16f)
		{
			Main.cameraX = 0f;
			position.X = Main.leftWorld + 640f + 16f;
			velocity.X = 0f;
		}
		if (position.X + (float)width > Main.rightWorld - 640f - 32f)
		{
			Main.cameraX = 0f;
			position.X = Main.rightWorld - 640f - 32f - (float)width;
			velocity.X = 0f;
		}
		if (position.Y < Main.topWorld + 640f + 16f)
		{
			if (Main.remixWorld || forcedGravity > 0)
			{
				if (position.Y < Main.topWorld + 640f + 16f - (float)height && !dead)
				{
					KillMe(PlayerDeathReason.ByOther(19), 10.0, 0);
				}
				if (position.Y < Main.topWorld + 320f + 16f)
				{
					position.Y = Main.topWorld + 320f + 16f;
					if (velocity.Y < 0f)
					{
						velocity.Y = 0f;
					}
					gravDir = 1f;
				}
			}
			else
			{
				position.Y = Main.topWorld + 640f + 16f;
				if ((double)velocity.Y < 0.11)
				{
					velocity.Y = 0.11f;
				}
				gravDir = 1f;
			}
			AchievementsHelper.HandleSpecialEvent(this, 11);
		}
		if (position.Y > Main.bottomWorld - 640f - 32f - (float)height)
		{
			position.Y = Main.bottomWorld - 640f - 32f - (float)height;
			velocity.Y = 0f;
		}
		if (position.Y > Main.bottomWorld - 640f - 150f - (float)height)
		{
			AchievementsHelper.HandleSpecialEvent(this, 10);
		}
	}

	public void CollectTaxes()
	{
		int num = Item.buyPrice(0, 0, 0, 50);
		int num2 = Item.buyPrice(0, 25);
		if (Main.tenthAnniversaryWorld)
		{
			num2 *= 2;
			num *= 2;
		}
		if (!NPC.taxCollector || taxMoney >= num2)
		{
			return;
		}
		int num3 = 0;
		for (int i = 0; i < 200; i++)
		{
			if (Main.npc[i].active && !Main.npc[i].homeless && !NPCID.Sets.IsTownPet[Main.npc[i].type] && NPC.TypeToDefaultHeadIndex(Main.npc[i].type) > 0)
			{
				num3++;
			}
		}
		taxMoney += num * num3;
		if (taxMoney > num2)
		{
			taxMoney = num2;
		}
	}

	public void GamepadEnableGrappleCooldown()
	{
		_quickGrappleCooldown = 3;
	}

	public void TryInterruptingItemUsage()
	{
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0130: Unknown result type (might be due to invalid IL or missing references)
		bool flag = false;
		if (heldProj > -1 && Main.projectile[heldProj].IsInterruptible(this))
		{
			flag = true;
		}
		if (!flag)
		{
			return;
		}
		bool flag2 = false;
		if (PlayerInput.Triggers.Current.Hotbar1)
		{
			flag2 = true;
		}
		if (PlayerInput.Triggers.Current.Hotbar2)
		{
			flag2 = true;
		}
		if (PlayerInput.Triggers.Current.Hotbar3)
		{
			flag2 = true;
		}
		if (PlayerInput.Triggers.Current.Hotbar4)
		{
			flag2 = true;
		}
		if (PlayerInput.Triggers.Current.Hotbar5)
		{
			flag2 = true;
		}
		if (PlayerInput.Triggers.Current.Hotbar6)
		{
			flag2 = true;
		}
		if (PlayerInput.Triggers.Current.Hotbar7)
		{
			flag2 = true;
		}
		if (PlayerInput.Triggers.Current.Hotbar8)
		{
			flag2 = true;
		}
		if (PlayerInput.Triggers.Current.Hotbar9)
		{
			flag2 = true;
		}
		if (PlayerInput.Triggers.Current.Hotbar10)
		{
			flag2 = true;
		}
		bool flag3 = Main.hairWindow;
		if (flag3)
		{
			int num = Main.screenHeight / 2 + 60;
			Rectangle val = new Rectangle(Main.screenWidth / 2 - TextureAssets.HairStyleBack.Width() / 2, num, TextureAssets.HairStyleBack.Width(), TextureAssets.HairStyleBack.Height());
			flag3 = ((Rectangle)(ref val)).Contains(Main.MouseScreen.ToPoint());
		}
		if (!Main.mapFullscreen && !CaptureManager.Instance.Active && !flag3 && !Main.playerInventory)
		{
			int num2 = PlayerInput.Triggers.Current.HotbarPlus.ToInt() - PlayerInput.Triggers.Current.HotbarMinus.ToInt();
			if (PlayerInput.CurrentProfile.HotbarRadialHoldTimeRequired != -1)
			{
				num2 = PlayerInput.Triggers.JustReleased.HotbarPlus.ToInt() - PlayerInput.Triggers.JustReleased.HotbarMinus.ToInt();
			}
			if (PlayerInput.Triggers.Current.HotbarScrollCD != 0)
			{
				num2 = 0;
			}
			if (!Main.inFancyUI && !Main.ingameOptionsWindow)
			{
				num2 += PlayerInput.ScrollWheelDelta / -120;
			}
			if (num2 != 0)
			{
				num2 = ClampHotbarOffset(num2);
				_ = selectedItem;
				flag2 = true;
			}
		}
		if (flag2 && heldProj > -1)
		{
			Main.projectile[heldProj].Interrupt(this);
		}
	}

	private bool CanMoveForwardOnRope(int dir, int x, int y)
	{
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		int num = x + dir;
		if (Main.tile[num, y] != null && Main.tile[num, y].active() && Main.tileRope[Main.tile[num, y].type])
		{
			int num2 = num * 16 + 8 - width / 2;
			float y2 = position.Y;
			y2 = y * 16 + 22;
			if ((!Main.tile[num, y - 1].active() || !Main.tileRope[Main.tile[num, y - 1].type]) && (!Main.tile[num, y + 1].active() || !Main.tileRope[Main.tile[num, y + 1].type]))
			{
				y2 = y * 16 + 22;
			}
			if (Collision.SolidCollision(new Vector2((float)num2, y2), width, height))
			{
				return false;
			}
			return true;
		}
		return false;
	}

	public void UpdateHairDyeDust()
	{
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0225: Unknown result type (might be due to invalid IL or missing references)
		//IL_022b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0348: Unknown result type (might be due to invalid IL or missing references)
		//IL_034e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0358: Unknown result type (might be due to invalid IL or missing references)
		//IL_035d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0362: Unknown result type (might be due to invalid IL or missing references)
		if (Main.netMode != 2 && !Main.gamePaused && !dead && !ghost && !stoned && !frozen && hairDye == ContentSamples.CommonlyUsedContentSamples.TeamDyeShaderIndex)
		{
			if (Main.rand.Next(45) == 0)
			{
				int type = Main.rand.Next(139, 143);
				int num = Dust.NewDust(position, width, 8, type, 0f, 0f, 0, default(Color), 1.2f);
				Main.dust[num].velocity.X *= 1f + (float)Main.rand.Next(-50, 51) * 0.01f;
				Main.dust[num].velocity.Y *= 1f + (float)Main.rand.Next(-50, 51) * 0.01f;
				Main.dust[num].velocity.X += (float)Main.rand.Next(-50, 51) * 0.01f;
				Main.dust[num].velocity.Y += (float)Main.rand.Next(-50, 51) * 0.01f;
				Main.dust[num].velocity.Y -= 1f;
				Main.dust[num].scale *= 0.7f + (float)Main.rand.Next(-30, 31) * 0.01f;
				Dust obj = Main.dust[num];
				obj.velocity += velocity * 0.2f;
			}
			if (Main.rand.Next(225) == 0)
			{
				int type2 = Main.rand.Next(276, 283);
				int num2 = Gore.NewGore(new Vector2(position.X + (float)Main.rand.Next(width), position.Y + (float)Main.rand.Next(8)), velocity, type2);
				Main.gore[num2].velocity.X *= 1f + (float)Main.rand.Next(-50, 51) * 0.01f;
				Main.gore[num2].velocity.Y *= 1f + (float)Main.rand.Next(-50, 51) * 0.01f;
				Main.gore[num2].scale *= 1f + (float)Main.rand.Next(-20, 21) * 0.01f;
				Main.gore[num2].velocity.X += (float)Main.rand.Next(-50, 51) * 0.01f;
				Main.gore[num2].velocity.Y += (float)Main.rand.Next(-50, 51) * 0.01f;
				Main.gore[num2].velocity.Y -= 1f;
				Gore obj2 = Main.gore[num2];
				obj2.velocity += velocity * 0.2f;
			}
		}
	}

	public void Update(int i)
	{
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_6c3e: Unknown result type (might be due to invalid IL or missing references)
		//IL_69fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_6d96: Unknown result type (might be due to invalid IL or missing references)
		//IL_6df4: Unknown result type (might be due to invalid IL or missing references)
		//IL_78c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_78e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_78ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_74fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_751f: Unknown result type (might be due to invalid IL or missing references)
		//IL_7525: Unknown result type (might be due to invalid IL or missing references)
		//IL_7343: Unknown result type (might be due to invalid IL or missing references)
		//IL_7362: Unknown result type (might be due to invalid IL or missing references)
		//IL_7368: Unknown result type (might be due to invalid IL or missing references)
		//IL_0657: Unknown result type (might be due to invalid IL or missing references)
		//IL_067b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0681: Unknown result type (might be due to invalid IL or missing references)
		//IL_06ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_06b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_06bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_77bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_77dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_77e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_76b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_76d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_76db: Unknown result type (might be due to invalid IL or missing references)
		//IL_75c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_75c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_75e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_75ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_7608: Unknown result type (might be due to invalid IL or missing references)
		//IL_760d: Unknown result type (might be due to invalid IL or missing references)
		//IL_6f71: Unknown result type (might be due to invalid IL or missing references)
		//IL_6f93: Unknown result type (might be due to invalid IL or missing references)
		//IL_6f99: Unknown result type (might be due to invalid IL or missing references)
		//IL_762b: Unknown result type (might be due to invalid IL or missing references)
		//IL_7630: Unknown result type (might be due to invalid IL or missing references)
		//IL_7235: Unknown result type (might be due to invalid IL or missing references)
		//IL_7257: Unknown result type (might be due to invalid IL or missing references)
		//IL_725d: Unknown result type (might be due to invalid IL or missing references)
		//IL_7127: Unknown result type (might be due to invalid IL or missing references)
		//IL_7149: Unknown result type (might be due to invalid IL or missing references)
		//IL_714f: Unknown result type (might be due to invalid IL or missing references)
		//IL_7036: Unknown result type (might be due to invalid IL or missing references)
		//IL_703b: Unknown result type (might be due to invalid IL or missing references)
		//IL_7059: Unknown result type (might be due to invalid IL or missing references)
		//IL_705e: Unknown result type (might be due to invalid IL or missing references)
		//IL_707c: Unknown result type (might be due to invalid IL or missing references)
		//IL_7081: Unknown result type (might be due to invalid IL or missing references)
		//IL_709f: Unknown result type (might be due to invalid IL or missing references)
		//IL_70a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_7dbb: Unknown result type (might be due to invalid IL or missing references)
		//IL_7dc0: Unknown result type (might be due to invalid IL or missing references)
		//IL_7e07: Unknown result type (might be due to invalid IL or missing references)
		//IL_7e0c: Unknown result type (might be due to invalid IL or missing references)
		//IL_81aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_81af: Unknown result type (might be due to invalid IL or missing references)
		//IL_81d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_7f4f: Unknown result type (might be due to invalid IL or missing references)
		//IL_7f56: Unknown result type (might be due to invalid IL or missing references)
		//IL_7f5b: Unknown result type (might be due to invalid IL or missing references)
		//IL_7f6c: Unknown result type (might be due to invalid IL or missing references)
		//IL_7f71: Unknown result type (might be due to invalid IL or missing references)
		//IL_8216: Unknown result type (might be due to invalid IL or missing references)
		//IL_821c: Unknown result type (might be due to invalid IL or missing references)
		//IL_8221: Unknown result type (might be due to invalid IL or missing references)
		//IL_8226: Unknown result type (might be due to invalid IL or missing references)
		//IL_7fd4: Unknown result type (might be due to invalid IL or missing references)
		//IL_7fda: Unknown result type (might be due to invalid IL or missing references)
		//IL_7fdf: Unknown result type (might be due to invalid IL or missing references)
		//IL_8022: Unknown result type (might be due to invalid IL or missing references)
		//IL_8027: Unknown result type (might be due to invalid IL or missing references)
		//IL_80f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_80fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_80ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_804a: Unknown result type (might be due to invalid IL or missing references)
		//IL_19a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_2dbc: Unknown result type (might be due to invalid IL or missing references)
		//IL_2dca: Unknown result type (might be due to invalid IL or missing references)
		//IL_2dcf: Unknown result type (might be due to invalid IL or missing references)
		//IL_2dd7: Unknown result type (might be due to invalid IL or missing references)
		//IL_2ddc: Unknown result type (might be due to invalid IL or missing references)
		//IL_2de3: Unknown result type (might be due to invalid IL or missing references)
		//IL_2de8: Unknown result type (might be due to invalid IL or missing references)
		//IL_2e01: Unknown result type (might be due to invalid IL or missing references)
		//IL_2e07: Unknown result type (might be due to invalid IL or missing references)
		//IL_2e1d: Unknown result type (might be due to invalid IL or missing references)
		//IL_2e22: Unknown result type (might be due to invalid IL or missing references)
		//IL_2e32: Unknown result type (might be due to invalid IL or missing references)
		//IL_2e37: Unknown result type (might be due to invalid IL or missing references)
		//IL_2e3c: Unknown result type (might be due to invalid IL or missing references)
		//IL_2e42: Unknown result type (might be due to invalid IL or missing references)
		//IL_2e4f: Unknown result type (might be due to invalid IL or missing references)
		//IL_2e55: Unknown result type (might be due to invalid IL or missing references)
		//IL_2e57: Unknown result type (might be due to invalid IL or missing references)
		//IL_2e61: Unknown result type (might be due to invalid IL or missing references)
		//IL_2e66: Unknown result type (might be due to invalid IL or missing references)
		//IL_1785: Unknown result type (might be due to invalid IL or missing references)
		//IL_17a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_17aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_2e9b: Unknown result type (might be due to invalid IL or missing references)
		//IL_2ea9: Unknown result type (might be due to invalid IL or missing references)
		//IL_2eae: Unknown result type (might be due to invalid IL or missing references)
		//IL_2eb6: Unknown result type (might be due to invalid IL or missing references)
		//IL_2ebb: Unknown result type (might be due to invalid IL or missing references)
		//IL_2ec2: Unknown result type (might be due to invalid IL or missing references)
		//IL_2ec7: Unknown result type (might be due to invalid IL or missing references)
		//IL_2ee0: Unknown result type (might be due to invalid IL or missing references)
		//IL_2ee6: Unknown result type (might be due to invalid IL or missing references)
		//IL_2efc: Unknown result type (might be due to invalid IL or missing references)
		//IL_2f01: Unknown result type (might be due to invalid IL or missing references)
		//IL_2f08: Unknown result type (might be due to invalid IL or missing references)
		//IL_2f0d: Unknown result type (might be due to invalid IL or missing references)
		//IL_2f12: Unknown result type (might be due to invalid IL or missing references)
		//IL_2f18: Unknown result type (might be due to invalid IL or missing references)
		//IL_2f25: Unknown result type (might be due to invalid IL or missing references)
		//IL_2f2b: Unknown result type (might be due to invalid IL or missing references)
		//IL_2f2d: Unknown result type (might be due to invalid IL or missing references)
		//IL_2f37: Unknown result type (might be due to invalid IL or missing references)
		//IL_2f3c: Unknown result type (might be due to invalid IL or missing references)
		//IL_8441: Unknown result type (might be due to invalid IL or missing references)
		//IL_842b: Unknown result type (might be due to invalid IL or missing references)
		//IL_83dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_30fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_8455: Unknown result type (might be due to invalid IL or missing references)
		//IL_846c: Unknown result type (might be due to invalid IL or missing references)
		//IL_80db: Unknown result type (might be due to invalid IL or missing references)
		//IL_8347: Unknown result type (might be due to invalid IL or missing references)
		//IL_834c: Unknown result type (might be due to invalid IL or missing references)
		//IL_836e: Unknown result type (might be due to invalid IL or missing references)
		//IL_82e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_82ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_830c: Unknown result type (might be due to invalid IL or missing references)
		//IL_8525: Unknown result type (might be due to invalid IL or missing references)
		//IL_8537: Unknown result type (might be due to invalid IL or missing references)
		//IL_1377: Unknown result type (might be due to invalid IL or missing references)
		//IL_137c: Unknown result type (might be due to invalid IL or missing references)
		//IL_1380: Unknown result type (might be due to invalid IL or missing references)
		//IL_1385: Unknown result type (might be due to invalid IL or missing references)
		//IL_14d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_14dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_14e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_14e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_398e: Unknown result type (might be due to invalid IL or missing references)
		//IL_399e: Unknown result type (might be due to invalid IL or missing references)
		//IL_353d: Unknown result type (might be due to invalid IL or missing references)
		//IL_3596: Unknown result type (might be due to invalid IL or missing references)
		//IL_3b16: Unknown result type (might be due to invalid IL or missing references)
		//IL_6454: Unknown result type (might be due to invalid IL or missing references)
		//IL_646f: Unknown result type (might be due to invalid IL or missing references)
		//IL_647c: Unknown result type (might be due to invalid IL or missing references)
		//IL_6481: Unknown result type (might be due to invalid IL or missing references)
		//IL_6483: Unknown result type (might be due to invalid IL or missing references)
		//IL_648f: Unknown result type (might be due to invalid IL or missing references)
		//IL_3d18: Unknown result type (might be due to invalid IL or missing references)
		//IL_3b4a: Unknown result type (might be due to invalid IL or missing references)
		//IL_3d65: Unknown result type (might be due to invalid IL or missing references)
		//IL_3be6: Unknown result type (might be due to invalid IL or missing references)
		//IL_3e01: Unknown result type (might be due to invalid IL or missing references)
		//IL_666d: Unknown result type (might be due to invalid IL or missing references)
		//IL_6780: Unknown result type (might be due to invalid IL or missing references)
		//IL_6785: Unknown result type (might be due to invalid IL or missing references)
		//IL_6789: Unknown result type (might be due to invalid IL or missing references)
		//IL_3751: Unknown result type (might be due to invalid IL or missing references)
		//IL_45ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_4724: Unknown result type (might be due to invalid IL or missing references)
		//IL_472f: Unknown result type (might be due to invalid IL or missing references)
		//IL_46de: Unknown result type (might be due to invalid IL or missing references)
		//IL_46e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_47de: Unknown result type (might be due to invalid IL or missing references)
		//IL_47e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_479b: Unknown result type (might be due to invalid IL or missing references)
		//IL_47a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_4bf8: Unknown result type (might be due to invalid IL or missing references)
		//IL_4c03: Unknown result type (might be due to invalid IL or missing references)
		//IL_4d50: Unknown result type (might be due to invalid IL or missing references)
		//IL_4d5b: Unknown result type (might be due to invalid IL or missing references)
		//IL_4d8c: Unknown result type (might be due to invalid IL or missing references)
		//IL_4d97: Unknown result type (might be due to invalid IL or missing references)
		//IL_52df: Unknown result type (might be due to invalid IL or missing references)
		//IL_52f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_52fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_5343: Unknown result type (might be due to invalid IL or missing references)
		//IL_534d: Unknown result type (might be due to invalid IL or missing references)
		//IL_5352: Unknown result type (might be due to invalid IL or missing references)
		//IL_53e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_53fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_5403: Unknown result type (might be due to invalid IL or missing references)
		//IL_5457: Unknown result type (might be due to invalid IL or missing references)
		//IL_5461: Unknown result type (might be due to invalid IL or missing references)
		//IL_5466: Unknown result type (might be due to invalid IL or missing references)
		//IL_550c: Unknown result type (might be due to invalid IL or missing references)
		//IL_5527: Unknown result type (might be due to invalid IL or missing references)
		//IL_552d: Unknown result type (might be due to invalid IL or missing references)
		//IL_5552: Unknown result type (might be due to invalid IL or missing references)
		//IL_555c: Unknown result type (might be due to invalid IL or missing references)
		//IL_5561: Unknown result type (might be due to invalid IL or missing references)
		//IL_55f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_560c: Unknown result type (might be due to invalid IL or missing references)
		//IL_5612: Unknown result type (might be due to invalid IL or missing references)
		//IL_5637: Unknown result type (might be due to invalid IL or missing references)
		//IL_5641: Unknown result type (might be due to invalid IL or missing references)
		//IL_5646: Unknown result type (might be due to invalid IL or missing references)
		//IL_56f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_5715: Unknown result type (might be due to invalid IL or missing references)
		//IL_571b: Unknown result type (might be due to invalid IL or missing references)
		//IL_5741: Unknown result type (might be due to invalid IL or missing references)
		//IL_574b: Unknown result type (might be due to invalid IL or missing references)
		//IL_5750: Unknown result type (might be due to invalid IL or missing references)
		//IL_57c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_57e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_57ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_5805: Unknown result type (might be due to invalid IL or missing references)
		//IL_580f: Unknown result type (might be due to invalid IL or missing references)
		//IL_5814: Unknown result type (might be due to invalid IL or missing references)
		//IL_5876: Unknown result type (might be due to invalid IL or missing references)
		//IL_5881: Unknown result type (might be due to invalid IL or missing references)
		//IL_595a: Unknown result type (might be due to invalid IL or missing references)
		//IL_5971: Unknown result type (might be due to invalid IL or missing references)
		//IL_5977: Unknown result type (might be due to invalid IL or missing references)
		//IL_5d68: Unknown result type (might be due to invalid IL or missing references)
		//IL_5d6d: Unknown result type (might be due to invalid IL or missing references)
		//IL_5d7c: Unknown result type (might be due to invalid IL or missing references)
		//IL_5d81: Unknown result type (might be due to invalid IL or missing references)
		//IL_5b97: Unknown result type (might be due to invalid IL or missing references)
		//IL_5bb7: Unknown result type (might be due to invalid IL or missing references)
		//IL_5bbd: Unknown result type (might be due to invalid IL or missing references)
		//IL_5bf0: Unknown result type (might be due to invalid IL or missing references)
		//IL_5bfa: Unknown result type (might be due to invalid IL or missing references)
		//IL_5bff: Unknown result type (might be due to invalid IL or missing references)
		//IL_5c0d: Unknown result type (might be due to invalid IL or missing references)
		//IL_5c13: Unknown result type (might be due to invalid IL or missing references)
		//IL_5c18: Unknown result type (might be due to invalid IL or missing references)
		//IL_5c1d: Unknown result type (might be due to invalid IL or missing references)
		//IL_5db7: Unknown result type (might be due to invalid IL or missing references)
		//IL_5ded: Unknown result type (might be due to invalid IL or missing references)
		//IL_5df3: Unknown result type (might be due to invalid IL or missing references)
		//IL_5e26: Unknown result type (might be due to invalid IL or missing references)
		//IL_5e30: Unknown result type (might be due to invalid IL or missing references)
		//IL_5e35: Unknown result type (might be due to invalid IL or missing references)
		//IL_5e43: Unknown result type (might be due to invalid IL or missing references)
		//IL_5e49: Unknown result type (might be due to invalid IL or missing references)
		//IL_5e4e: Unknown result type (might be due to invalid IL or missing references)
		//IL_5e53: Unknown result type (might be due to invalid IL or missing references)
		//IL_5e8f: Unknown result type (might be due to invalid IL or missing references)
		//IL_5e91: Unknown result type (might be due to invalid IL or missing references)
		//IL_5ca4: Unknown result type (might be due to invalid IL or missing references)
		//IL_5cc6: Unknown result type (might be due to invalid IL or missing references)
		//IL_5ccc: Unknown result type (might be due to invalid IL or missing references)
		//IL_5cff: Unknown result type (might be due to invalid IL or missing references)
		//IL_5d09: Unknown result type (might be due to invalid IL or missing references)
		//IL_5d0e: Unknown result type (might be due to invalid IL or missing references)
		//IL_5d1c: Unknown result type (might be due to invalid IL or missing references)
		//IL_5d22: Unknown result type (might be due to invalid IL or missing references)
		//IL_5d27: Unknown result type (might be due to invalid IL or missing references)
		//IL_5d2c: Unknown result type (might be due to invalid IL or missing references)
		//IL_5efa: Unknown result type (might be due to invalid IL or missing references)
		//IL_5f35: Unknown result type (might be due to invalid IL or missing references)
		//IL_5f3b: Unknown result type (might be due to invalid IL or missing references)
		//IL_5f6e: Unknown result type (might be due to invalid IL or missing references)
		//IL_5f78: Unknown result type (might be due to invalid IL or missing references)
		//IL_5f7d: Unknown result type (might be due to invalid IL or missing references)
		//IL_5f8b: Unknown result type (might be due to invalid IL or missing references)
		//IL_5f91: Unknown result type (might be due to invalid IL or missing references)
		//IL_5f96: Unknown result type (might be due to invalid IL or missing references)
		//IL_5f9b: Unknown result type (might be due to invalid IL or missing references)
		//IL_5fd7: Unknown result type (might be due to invalid IL or missing references)
		//IL_5fd9: Unknown result type (might be due to invalid IL or missing references)
		using (new Main.CurrentPlayerOverride(this))
		{
			if (i == Main.myPlayer && Main.netMode != 2)
			{
				LockOnHelper.Update();
			}
			if (i == Main.myPlayer && Main.dontStarveWorld)
			{
				DontStarveDarknessDamageDealer.Update(this);
			}
			maxFallSpeed = 10f;
			gravity = defaultGravity;
			jumpHeight = 15;
			jumpSpeed = 5.01f;
			maxRunSpeed = 3f;
			runAcceleration = 0.08f;
			runSlowdown = 0.2f;
			accRunSpeed = maxRunSpeed;
			if (!mount.Active || !mount.Cart)
			{
				onWrongGround = false;
			}
			heldProj = -1;
			instantMovementAccumulatedThisFrame = Vector2.Zero;
			if (PortalPhysicsEnabled)
			{
				maxFallSpeed = 35f;
			}
			if (shimmerWet || shimmering)
			{
				if (shimmering)
				{
					gravity *= 0.9f;
					maxFallSpeed *= 0.9f;
				}
				else
				{
					gravity = 0.15f;
					jumpHeight = 23;
					jumpSpeed = 5.51f;
				}
			}
			else if (wet)
			{
				if (honeyWet)
				{
					gravity = 0.1f;
					maxFallSpeed = 3f;
				}
				else if (merman)
				{
					gravity = 0.3f;
					maxFallSpeed = 7f;
				}
				else if (trident && !lavaWet)
				{
					gravity = 0.25f;
					maxFallSpeed = 6f;
					jumpHeight = 25;
					jumpSpeed = 5.51f;
					if (controlUp)
					{
						gravity = 0.1f;
						maxFallSpeed = 2f;
					}
				}
				else
				{
					gravity = 0.2f;
					maxFallSpeed = 5f;
					jumpHeight = 30;
					jumpSpeed = 6.01f;
				}
			}
			if (vortexDebuff)
			{
				gravity = 0f;
			}
			maxFallSpeed += 0.01f;
			bool flag = false;
			if (Main.myPlayer == i)
			{
				if (Main.mapFullscreen)
				{
					GamepadEnableGrappleCooldown();
				}
				else if (_quickGrappleCooldown > 0)
				{
					_quickGrappleCooldown--;
				}
				TileObject.objectPreview.Reset();
				if (DD2Event.DownedInvasionAnyDifficulty)
				{
					downedDD2EventAnyDifficulty = true;
				}
				autoReuseAllWeapons = Main.SettingsEnabled_AutoReuseAllItems;
			}
			if (NPC.freeCake && talkNPC >= 0 && Main.npc[talkNPC].type == 208)
			{
				NPC.freeCake = false;
				if (Main.netMode != 1)
				{
					Item.NewItem(new EntitySource_Gift(Main.npc[talkNPC]), (int)position.X, (int)position.Y, width, height, 3750);
				}
			}
			if (emoteTime > 0)
			{
				emoteTime--;
			}
			if (ghostDmg > 0f)
			{
				ghostDmg -= 6.6666665f;
			}
			if (ghostDmg < 0f)
			{
				ghostDmg = 0f;
			}
			if (Main.expertMode)
			{
				if (lifeSteal < 70f)
				{
					lifeSteal += 0.5f;
				}
				if (lifeSteal > 70f)
				{
					lifeSteal = 70f;
				}
			}
			else
			{
				if (lifeSteal < 80f)
				{
					lifeSteal += 0.6f;
				}
				if (lifeSteal > 80f)
				{
					lifeSteal = 80f;
				}
			}
			ResizeHitbox();
			if (mount.Active && mount.Type == 0)
			{
				int num = (int)(position.X + (float)(width / 2)) / 16;
				int j = (int)(position.Y + (float)(height / 2) - 14f) / 16;
				Lighting.AddLight(num, j, 0.5f, 0.2f, 0.05f);
				Lighting.AddLight(num + direction, j, 0.5f, 0.2f, 0.05f);
				Lighting.AddLight(num + direction * 2, j, 0.5f, 0.2f, 0.05f);
			}
			outOfRange = false;
			if (whoAmI != Main.myPlayer)
			{
				int num2 = (int)(position.X + (float)(width / 2)) / 16;
				int num3 = (int)(position.Y + (float)(height / 2)) / 16;
				if (Main.netMode == 1 && !Main.sectionManager.TilesLoaded(num2 - 3, num3 - 3, num2 + 3, num3 + 3))
				{
					flag = true;
				}
				if (flag)
				{
					outOfRange = true;
					numMinions = 0;
					slotsMinions = 0f;
					itemAnimation = 0;
					UpdateBuffs(i);
					PlayerFrame();
				}
			}
			if (tankPet >= 0)
			{
				if (!tankPetReset)
				{
					tankPetReset = true;
				}
				else
				{
					tankPet = -1;
				}
			}
			if (i == Main.myPlayer)
			{
				IsVoidVaultEnabled = HasItem(4131);
			}
			if (chatOverhead.timeLeft > 0)
			{
				chatOverhead.timeLeft--;
			}
			if (snowBallLauncherInteractionCooldown > 0)
			{
				snowBallLauncherInteractionCooldown--;
			}
			environmentBuffImmunityTimer = Math.Max(0, environmentBuffImmunityTimer - 1);
			if (flag)
			{
				return;
			}
			UpdateHairDyeDust();
			UpdateMiscCounter();
			PlayerLoader.PreUpdate(this);
			infernoCounter++;
			if (infernoCounter >= 180)
			{
				infernoCounter = 0;
			}
			timeSinceLastDashStarted++;
			if (timeSinceLastDashStarted >= 300)
			{
				timeSinceLastDashStarted = 300;
			}
			_framesLeftEligibleForDeadmansChestDeathAchievement--;
			if (_framesLeftEligibleForDeadmansChestDeathAchievement < 0)
			{
				_framesLeftEligibleForDeadmansChestDeathAchievement = 0;
			}
			if (titaniumStormCooldown > 0)
			{
				titaniumStormCooldown--;
			}
			if (starCloakCooldown > 0)
			{
				starCloakCooldown--;
				if (Main.rand.Next(5) == 0)
				{
					for (int k = 0; k < 2; k++)
					{
						Dust dust = Dust.NewDustDirect(position, width, height, 45, 0f, 0f, 255, default(Color), (float)Main.rand.Next(20, 26) * 0.1f);
						dust.noLight = true;
						dust.noGravity = true;
						dust.velocity *= 0.5f;
						dust.velocity.X = 0f;
						dust.velocity.Y -= 0.5f;
					}
				}
				if (starCloakCooldown == 0)
				{
					SoundEngine.PlaySound(25);
				}
			}
			_timeSinceLastImmuneGet++;
			if (_timeSinceLastImmuneGet >= 10000)
			{
				_timeSinceLastImmuneGet = 10000;
			}
			float num4 = (float)Main.maxTilesX / 4200f;
			num4 *= num4;
			float num5 = (float)((double)(position.Y / 16f - (60f + 10f * num4)) / (Main.worldSurface / 6.0));
			if (Main.remixWorld)
			{
				num5 = (float)((double)(position.Y / 16f - (60f + 10f * num4)) / (Main.worldSurface / 1.0));
			}
			if (Main.remixWorld)
			{
				if ((double)num5 < 0.1)
				{
					num5 = 0.1f;
				}
			}
			else if ((double)num5 < 0.25)
			{
				num5 = 0.25f;
			}
			if (num5 > 1f)
			{
				num5 = 1f;
			}
			gravity *= num5;
			maxRegenDelay = (1f - (float)statMana / (float)statManaMax2) * 60f * 4f + 45f;
			maxRegenDelay *= 0.7f;
			UpdateSocialShadow();
			UpdateTeleportVisuals();
			whoAmI = i;
			if (whoAmI == Main.myPlayer)
			{
				if (!DD2Event.Ongoing)
				{
					PurgeDD2EnergyCrystals();
				}
				TryPortalJumping();
				if (whoAmI == Main.myPlayer)
				{
					doorHelper.Update(this);
				}
			}
			if (runSoundDelay > 0)
			{
				runSoundDelay--;
			}
			if (attackCD > 0)
			{
				attackCD--;
			}
			if (itemAnimation == 0)
			{
				attackCD = 0;
			}
			if (potionDelay > 0)
			{
				potionDelay--;
			}
			if (i == Main.myPlayer)
			{
				if (trashItem.type >= 1522 && trashItem.type <= 1527)
				{
					trashItem.SetDefaults();
				}
				if (trashItem.type == 3643)
				{
					trashItem.SetDefaults();
				}
				UpdateBiomes();
				UpdateMinionTarget();
			}
			if (ghost)
			{
				Ghost();
				return;
			}
			if (dead)
			{
				UpdateDead();
				ResetProjectileCaches();
				UpdateProjectileCaches(i);
				return;
			}
			TrySpawningFaelings();
			if (i == Main.myPlayer && hasLucyTheAxe)
			{
				LucyAxeMessage.TryPlayingIdleMessage();
			}
			if (velocity.Y == 0f)
			{
				mount.FatigueRecovery();
			}
			Rectangle val;
			if (i == Main.myPlayer && !isControlledByFilm)
			{
				ResetControls();
				if (Main.hasFocus)
				{
					if (!Main.drawingPlayerChat && !Main.editSign && !Main.editChest && !Main.blockInput)
					{
						PlayerInput.Triggers.Current.CopyInto(this);
						LocalInputCache = new DirectionalInputSyncCache(this);
						if (Main.mapFullscreen)
						{
							if (controlUp)
							{
								Main.mapFullscreenPos.Y -= 1f * (16f / Main.mapFullscreenScale);
							}
							if (controlDown)
							{
								Main.mapFullscreenPos.Y += 1f * (16f / Main.mapFullscreenScale);
							}
							if (controlLeft)
							{
								Main.mapFullscreenPos.X -= 1f * (16f / Main.mapFullscreenScale);
							}
							if (controlRight)
							{
								Main.mapFullscreenPos.X += 1f * (16f / Main.mapFullscreenScale);
							}
							controlUp = false;
							controlLeft = false;
							controlDown = false;
							controlRight = false;
							controlJump = false;
							controlUseItem = false;
							controlUseTile = false;
							controlThrow = false;
							controlHook = false;
							controlTorch = false;
							controlSmart = false;
							controlMount = false;
						}
						if (isOperatingAnotherEntity)
						{
							controlUp = (controlDown = (controlLeft = (controlRight = (controlJump = false))));
						}
						if (controlQuickHeal)
						{
							if (releaseQuickHeal)
							{
								QuickHeal();
							}
							releaseQuickHeal = false;
						}
						else
						{
							releaseQuickHeal = true;
						}
						if (controlQuickMana)
						{
							if (releaseQuickMana)
							{
								QuickMana();
							}
							releaseQuickMana = false;
						}
						else
						{
							releaseQuickMana = true;
						}
						if (controlCreativeMenu)
						{
							if (releaseCreativeMenu)
							{
								ToggleCreativeMenu();
							}
							releaseCreativeMenu = false;
						}
						else
						{
							releaseCreativeMenu = true;
						}
						if (controlLeft && controlRight)
						{
							controlLeft = false;
							controlRight = false;
						}
						if (PlayerInput.UsingGamepad || !mouseInterface || !ItemSlot.Options.DisableLeftShiftTrashCan)
						{
							if (PlayerInput.SteamDeckIsUsed && PlayerInput.SettingsForUI.CurrentCursorMode == CursorMode.Mouse)
							{
								TryToToggleSmartCursor(ref Main.SmartCursorWanted_Mouse);
							}
							else if (PlayerInput.UsingGamepad)
							{
								TryToToggleSmartCursor(ref Main.SmartCursorWanted_GamePad);
							}
							else
							{
								TryToToggleSmartCursor(ref Main.SmartCursorWanted_Mouse);
							}
						}
						if (controlSmart)
						{
							releaseSmart = false;
						}
						else
						{
							releaseSmart = true;
						}
						if (controlMount)
						{
							if (releaseMount)
							{
								QuickMount();
							}
							releaseMount = false;
						}
						else
						{
							releaseMount = true;
						}
						if (Main.mapFullscreen)
						{
							if (mapZoomIn)
							{
								Main.mapFullscreenScale *= 1.05f;
							}
							if (mapZoomOut)
							{
								Main.mapFullscreenScale *= 0.95f;
							}
						}
						else
						{
							if (Main.mapStyle == 1)
							{
								if (mapZoomIn)
								{
									Main.mapMinimapScale *= 1.025f;
								}
								if (mapZoomOut)
								{
									Main.mapMinimapScale *= 0.975f;
								}
								if (mapAlphaUp)
								{
									Main.mapMinimapAlpha += 0.015f;
								}
								if (mapAlphaDown)
								{
									Main.mapMinimapAlpha -= 0.015f;
								}
							}
							else if (Main.mapStyle == 2)
							{
								if (mapZoomIn)
								{
									Main.mapOverlayScale *= 1.05f;
								}
								if (mapZoomOut)
								{
									Main.mapOverlayScale *= 0.95f;
								}
								if (mapAlphaUp)
								{
									Main.mapOverlayAlpha += 0.015f;
								}
								if (mapAlphaDown)
								{
									Main.mapOverlayAlpha -= 0.015f;
								}
							}
							if (mapStyle)
							{
								if (releaseMapStyle)
								{
									SoundEngine.PlaySound(12);
									Main.mapStyle++;
									if (Main.mapStyle > 2)
									{
										Main.mapStyle = 0;
									}
								}
								releaseMapStyle = false;
							}
							else
							{
								releaseMapStyle = true;
							}
						}
						if (mapFullScreen)
						{
							if (releaseMapFullscreen)
							{
								if (Main.mapFullscreen)
								{
									SoundEngine.PlaySound(11);
									Main.mapFullscreen = false;
								}
								else
								{
									TryOpeningFullscreenMap();
								}
							}
							releaseMapFullscreen = false;
						}
						else
						{
							releaseMapFullscreen = true;
						}
					}
					else if (!PlayerInput.UsingGamepad && !Main.editSign && !Main.editChest && !Main.blockInput)
					{
						PlayerInput.Triggers.Current.CopyIntoDuringChat(this);
					}
					if (confused)
					{
						bool flag2 = controlLeft;
						bool flag3 = controlUp;
						controlLeft = controlRight;
						controlRight = flag2;
						controlUp = controlRight;
						controlDown = flag3;
					}
					else if (cartFlip)
					{
						if (controlRight || controlLeft)
						{
							bool flag4 = controlLeft;
							controlLeft = controlRight;
							controlRight = flag4;
						}
						else
						{
							cartFlip = false;
						}
					}
					for (int l = 0; l < doubleTapCardinalTimer.Length; l++)
					{
						doubleTapCardinalTimer[l]--;
						if (doubleTapCardinalTimer[l] < 0)
						{
							doubleTapCardinalTimer[l] = 0;
						}
					}
					for (int m = 0; m < 4; m++)
					{
						bool flag5 = false;
						bool flag6 = false;
						switch (m)
						{
						case 0:
							flag5 = controlDown && releaseDown;
							flag6 = controlDown;
							break;
						case 1:
							flag5 = controlUp && releaseUp;
							flag6 = controlUp;
							break;
						case 2:
							flag5 = controlRight && releaseRight;
							flag6 = controlRight;
							break;
						case 3:
							flag5 = controlLeft && releaseLeft;
							flag6 = controlLeft;
							break;
						}
						if (flag5)
						{
							if (doubleTapCardinalTimer[m] > 0)
							{
								KeyDoubleTap(m);
							}
							else
							{
								doubleTapCardinalTimer[m] = 15;
							}
						}
						if (flag6)
						{
							holdDownCardinalTimer[m]++;
							KeyHoldDown(m, holdDownCardinalTimer[m]);
						}
						else
						{
							holdDownCardinalTimer[m] = 0;
						}
					}
					controlDownHold = holdDownCardinalTimer[0] >= 45;
					PlayerLoader.SetControls(this);
					if (controlInv)
					{
						if (releaseInventory)
						{
							ToggleInv();
						}
						releaseInventory = false;
					}
					else
					{
						releaseInventory = true;
					}
					if (delayUseItem)
					{
						if (!controlUseItem)
						{
							delayUseItem = false;
						}
						controlUseItem = false;
					}
					if (itemAnimation == 0 && ItemTimeIsZero && reuseDelay == 0)
					{
						dropItemCheck();
						int num6 = selectedItem;
						bool flag7 = false;
						if (!Main.drawingPlayerChat && selectedItem != 58 && !Main.editSign && !Main.editChest)
						{
							if (PlayerInput.Triggers.Current.Hotbar1)
							{
								selectedItem = 0;
								flag7 = true;
							}
							if (PlayerInput.Triggers.Current.Hotbar2)
							{
								selectedItem = 1;
								flag7 = true;
							}
							if (PlayerInput.Triggers.Current.Hotbar3)
							{
								selectedItem = 2;
								flag7 = true;
							}
							if (PlayerInput.Triggers.Current.Hotbar4)
							{
								selectedItem = 3;
								flag7 = true;
							}
							if (PlayerInput.Triggers.Current.Hotbar5)
							{
								selectedItem = 4;
								flag7 = true;
							}
							if (PlayerInput.Triggers.Current.Hotbar6)
							{
								selectedItem = 5;
								flag7 = true;
							}
							if (PlayerInput.Triggers.Current.Hotbar7)
							{
								selectedItem = 6;
								flag7 = true;
							}
							if (PlayerInput.Triggers.Current.Hotbar8)
							{
								selectedItem = 7;
								flag7 = true;
							}
							if (PlayerInput.Triggers.Current.Hotbar9)
							{
								selectedItem = 8;
								flag7 = true;
							}
							if (PlayerInput.Triggers.Current.Hotbar10)
							{
								selectedItem = 9;
								flag7 = true;
							}
							int selectedBinding = DpadRadial.SelectedBinding;
							int selectedBinding2 = CircularRadial.SelectedBinding;
							_ = QuicksRadial.SelectedBinding;
							DpadRadial.Update();
							CircularRadial.Update();
							QuicksRadial.Update();
							if (CircularRadial.SelectedBinding >= 0 && selectedBinding2 != CircularRadial.SelectedBinding)
							{
								DpadRadial.ChangeSelection(-1);
							}
							if (DpadRadial.SelectedBinding >= 0 && selectedBinding != DpadRadial.SelectedBinding)
							{
								CircularRadial.ChangeSelection(-1);
							}
							if (QuicksRadial.SelectedBinding != -1 && PlayerInput.Triggers.JustReleased.RadialQuickbar && !PlayerInput.MiscSettingsTEMP.HotbarRadialShouldBeUsed)
							{
								switch (QuicksRadial.SelectedBinding)
								{
								case 0:
									QuickMount();
									break;
								case 1:
									QuickHeal();
									break;
								case 2:
									QuickBuff();
									break;
								case 3:
									QuickMana();
									break;
								}
							}
							if (controlTorch || flag7)
							{
								DpadRadial.ChangeSelection(-1);
								CircularRadial.ChangeSelection(-1);
							}
							if (nonTorch != -1 && flag7)
							{
								if (selectedItem != nonTorch)
								{
									SoundEngine.PlaySound(12);
								}
								nonTorch = selectedItem;
								selectedItem = num6;
								flag7 = false;
							}
						}
						bool flag8 = Main.hairWindow;
						if (flag8)
						{
							int num7 = Main.screenHeight / 2 + 60;
							val = new Rectangle(Main.screenWidth / 2 - TextureAssets.HairStyleBack.Width() / 2, num7, TextureAssets.HairStyleBack.Width(), TextureAssets.HairStyleBack.Height());
							flag8 = ((Rectangle)(ref val)).Contains(Main.MouseScreen.ToPoint());
						}
						if (flag7 && CaptureManager.Instance.Active)
						{
							CaptureManager.Instance.Active = false;
						}
						if (num6 != selectedItem)
						{
							SoundEngine.PlaySound(12);
						}
						if (Main.mapFullscreen)
						{
							float num8 = PlayerInput.ScrollWheelDelta / 120;
							if (PlayerInput.UsingGamepad)
							{
								num8 += (float)(PlayerInput.Triggers.Current.HotbarPlus.ToInt() - PlayerInput.Triggers.Current.HotbarMinus.ToInt()) * 0.1f;
							}
							Main.mapFullscreenScale *= 1f + num8 * 0.3f;
						}
						else if (CaptureManager.Instance.Active)
						{
							CaptureManager.Instance.Scrolling();
						}
						else if (!flag8)
						{
							if (PlayerInput.MouseInModdedUI.Count <= 0)
							{
								if (!Main.playerInventory)
								{
									HandleHotbar();
								}
								else
								{
									int num9 = GetMouseScrollDelta();
									bool flag9 = true;
									if (Main.recBigList)
									{
										int num10 = 42;
										int num11 = 340;
										int num12 = 310;
										PlayerInput.SetZoom_UI();
										int num13 = (Main.screenWidth - num12 - 280) / num10;
										int num14 = (Main.screenHeight - num11 - 20) / num10;
										val = new Rectangle(num12, num11, num13 * num10, num14 * num10);
										if (((Rectangle)(ref val)).Contains(Main.MouseScreen.ToPoint()))
										{
											num9 *= -1;
											int num15 = Math.Sign(num9);
											while (num9 != 0)
											{
												if (num9 < 0)
												{
													Main.recStart -= num13;
													if (Main.recStart < 0)
													{
														Main.recStart = 0;
													}
												}
												else
												{
													Main.recStart += num13;
													if (Main.recStart > Main.numAvailableRecipes - num13)
													{
														Main.recStart = Main.numAvailableRecipes - num13;
													}
												}
												num9 -= num15;
											}
										}
										PlayerInput.SetZoom_World();
									}
									if (flag9)
									{
										Main.focusRecipe += num9;
										if (Main.focusRecipe > Main.numAvailableRecipes - 1)
										{
											Main.focusRecipe = Main.numAvailableRecipes - 1;
										}
										if (Main.focusRecipe < 0)
										{
											Main.focusRecipe = 0;
										}
									}
								}
							}
							PlayerInput.MouseInModdedUI.Clear();
						}
					}
					else
					{
						bool flag10 = false;
						if (!Main.drawingPlayerChat && selectedItem != 58 && !Main.editSign && !Main.editChest)
						{
							int num16 = -1;
							if (PlayerInput.Triggers.Current.Hotbar1)
							{
								num16 = 0;
								flag10 = true;
							}
							if (PlayerInput.Triggers.Current.Hotbar2)
							{
								num16 = 1;
								flag10 = true;
							}
							if (PlayerInput.Triggers.Current.Hotbar3)
							{
								num16 = 2;
								flag10 = true;
							}
							if (PlayerInput.Triggers.Current.Hotbar4)
							{
								num16 = 3;
								flag10 = true;
							}
							if (PlayerInput.Triggers.Current.Hotbar5)
							{
								num16 = 4;
								flag10 = true;
							}
							if (PlayerInput.Triggers.Current.Hotbar6)
							{
								num16 = 5;
								flag10 = true;
							}
							if (PlayerInput.Triggers.Current.Hotbar7)
							{
								num16 = 6;
								flag10 = true;
							}
							if (PlayerInput.Triggers.Current.Hotbar8)
							{
								num16 = 7;
								flag10 = true;
							}
							if (PlayerInput.Triggers.Current.Hotbar9)
							{
								num16 = 8;
								flag10 = true;
							}
							if (PlayerInput.Triggers.Current.Hotbar10)
							{
								num16 = 9;
								flag10 = true;
							}
							if (flag10)
							{
								if (num16 != nonTorch)
								{
									SoundEngine.PlaySound(12);
								}
								selectItemOnNextUse = true;
								nonTorch = num16;
							}
						}
					}
				}
				if (stoned != lastStoned)
				{
					if (whoAmI == Main.myPlayer && stoned)
					{
						int damage = (int)(20.0 * (double)Main.GameModeInfo.EnemyDamageMultiplier);
						Hurt(PlayerDeathReason.ByOther(5), damage, 0);
					}
					SoundEngine.PlaySound(0, (int)position.X, (int)position.Y);
					for (int n = 0; n < 20; n++)
					{
						int num17 = Dust.NewDust(position, width, height, 1);
						if (Main.rand.Next(2) == 0)
						{
							Main.dust[num17].noGravity = true;
						}
					}
				}
				lastStoned = stoned;
				if (frozen || webbed || stoned)
				{
					controlJump = false;
					controlDown = false;
					controlLeft = false;
					controlRight = false;
					controlUp = false;
					controlUseItem = false;
					controlUseTile = false;
					controlThrow = false;
					gravDir = 1f;
				}
				if (!controlThrow)
				{
					releaseThrow = true;
				}
				else
				{
					releaseThrow = false;
				}
				if (controlDown && releaseDown)
				{
					if (tryKeepingHoveringUp)
					{
						tryKeepingHoveringUp = false;
					}
					else
					{
						tryKeepingHoveringDown = true;
					}
				}
				if (controlUp && releaseUp)
				{
					if (tryKeepingHoveringDown)
					{
						tryKeepingHoveringDown = false;
					}
					else
					{
						tryKeepingHoveringUp = true;
					}
				}
				if (velocity.Y == 0f)
				{
					tryKeepingHoveringUp = false;
					tryKeepingHoveringDown = false;
				}
				if (Settings.HoverControl == Settings.HoverControlMode.Hold)
				{
					tryKeepingHoveringUp = false;
					tryKeepingHoveringDown = false;
				}
				TrySyncingInput();
				if (Main.playerInventory)
				{
					AdjTiles();
				}
				HandleBeingInChestRange();
				tileEntityAnchor.GetTileEntity()?.OnPlayerUpdate(this);
			}
			if (i == Main.myPlayer)
			{
				if (velocity.Y <= 0f)
				{
					fallStart2 = (int)(position.Y / 16f);
				}
				if (velocity.Y == 0f)
				{
					int num18 = 25;
					num18 += extraFall;
					int num19 = (int)(position.Y / 16f) - fallStart;
					if (mount.CanFly())
					{
						num19 = 0;
					}
					if (mount.Cart && Minecart.OnTrack(position, width, height))
					{
						num19 = 0;
					}
					if (mount.Type == 1)
					{
						num19 = 0;
					}
					if (num19 > 0 || (gravDir == -1f && num19 < 0))
					{
						int num20 = (int)(position.X / 16f);
						int num21 = (int)((position.X + (float)width) / 16f);
						int y = (int)((position.Y + (float)height + 1f) / 16f);
						if (gravDir == -1f)
						{
							y = (int)((position.Y - 1f) / 16f);
						}
						for (int num22 = num20; num22 <= num21; num22++)
						{
							if (Main.tile[num22, y] != null && Main.tile[num22, y].active() && TileID.Sets.NegatesFallDamage[Main.tile[num22, y].type])
							{
								num19 = 0;
								break;
							}
						}
					}
					bool flag11 = equippedWings != null;
					if (stoned)
					{
						int num23 = (int)(((float)num19 * gravDir - 2f) * 20f);
						if (num23 > 0)
						{
							Hurt(PlayerDeathReason.ByOther(5), num23, 0);
							immune = false;
						}
					}
					else if (((gravDir == 1f && num19 > num18) || (gravDir == -1f && num19 < -num18)) && !noFallDmg && !flag11)
					{
						immune = false;
						int num24 = (int)((float)num19 * gravDir - (float)num18) * 10;
						if (mount.Active)
						{
							num24 = (int)((float)num24 * mount.FallDamage);
						}
						Hurt(PlayerDeathReason.ByOther(0), num24, 0);
						if (!dead && statLife <= statLifeMax2 / 10)
						{
							AchievementsHelper.HandleSpecialEvent(this, 8);
						}
					}
					fallStart = (int)(position.Y / 16f);
				}
				if (jump > 0 || rocketDelay > 0 || wet || slowFall || (double)num5 < 0.8 || tongued)
				{
					fallStart = (int)(position.Y / 16f);
				}
			}
			if (Main.netMode != 1)
			{
				if (chest == -1 && lastChest >= 0 && Main.chest[lastChest] != null)
				{
					int x = Main.chest[lastChest].x;
					int y2 = Main.chest[lastChest].y;
					NPC.BigMimicSummonCheck(x, y2, this);
				}
				if (lastChest != chest && chest >= 0 && Main.chest[chest] != null)
				{
					int x2 = Main.chest[chest].x;
					int y3 = Main.chest[chest].y;
					Projectile.GasTrapCheck(x2, y3, this);
					ItemSlot.forceClearGlowsOnChest = true;
				}
				lastChest = chest;
			}
			if (mouseInterface)
			{
				delayUseItem = true;
			}
			tileTargetX = (int)(((float)Main.mouseX + Main.screenPosition.X) / 16f);
			tileTargetY = (int)(((float)Main.mouseY + Main.screenPosition.Y) / 16f);
			if (gravDir == -1f)
			{
				tileTargetY = (int)((Main.screenPosition.Y + (float)Main.screenHeight - (float)Main.mouseY) / 16f);
			}
			if (tileTargetX >= Main.maxTilesX - 5)
			{
				tileTargetX = Main.maxTilesX - 5;
			}
			if (tileTargetY >= Main.maxTilesY - 5)
			{
				tileTargetY = Main.maxTilesY - 5;
			}
			if (tileTargetX < 5)
			{
				tileTargetX = 5;
			}
			if (tileTargetY < 5)
			{
				tileTargetY = 5;
			}
			if (Main.tile[tileTargetX - 1, tileTargetY] == null)
			{
				Main.tile[tileTargetX - 1, tileTargetY] = default(Tile);
			}
			if (Main.tile[tileTargetX + 1, tileTargetY] == null)
			{
				Main.tile[tileTargetX + 1, tileTargetY] = default(Tile);
			}
			if (Main.tile[tileTargetX, tileTargetY] == null)
			{
				Main.tile[tileTargetX, tileTargetY] = default(Tile);
			}
			if (inventory[selectedItem].axe > 0 && !Main.tile[tileTargetX, tileTargetY].active() && inventory[selectedItem].createWall <= 0 && (inventory[selectedItem].hammer <= 0 || inventory[selectedItem].axe != 0))
			{
				if (Main.tile[tileTargetX - 1, tileTargetY].active() && Main.tile[tileTargetX - 1, tileTargetY].type == 323)
				{
					if (Main.tile[tileTargetX - 1, tileTargetY].frameY > 4)
					{
						tileTargetX--;
					}
				}
				else if (Main.tile[tileTargetX + 1, tileTargetY].active() && Main.tile[tileTargetX + 1, tileTargetY].type == 323 && Main.tile[tileTargetX + 1, tileTargetY].frameY < -4)
				{
					tileTargetX++;
				}
			}
			if (i == Main.myPlayer)
			{
				UpdateNearbyInteractibleProjectilesList();
			}
			try
			{
				if (whoAmI == Main.myPlayer && ((Game)Main.instance).IsActive)
				{
					SmartCursorHelper.SmartCursorLookup(this);
					SmartInteractLookup();
				}
			}
			catch
			{
				Main.SmartCursorWanted_GamePad = false;
				Main.SmartCursorWanted_Mouse = false;
			}
			UpdateImmunity();
			if (petalTimer > 0)
			{
				petalTimer--;
			}
			if (shadowDodgeTimer > 0)
			{
				shadowDodgeTimer--;
			}
			if (boneGloveTimer > 0)
			{
				boneGloveTimer--;
			}
			if (crystalLeafCooldown > 0)
			{
				crystalLeafCooldown--;
			}
			if (jump > 0 || velocity.Y != 0f)
			{
				ResetFloorFlags();
			}
			StatModifier potionDelayModifier = PotionDelayModifier;
			potionDelayTime = Item.potionDelay;
			restorationDelayTime = Item.restorationDelay;
			mushroomDelayTime = Item.mushroomDelay;
			PotionDelayModifier = StatModifier.Default;
			if (pStone)
			{
				PotionDelayModifier *= PhilosopherStoneDurationMultiplier;
			}
			if (yoraiz0rEye > 0)
			{
				Yoraiz0rEye();
			}
			ResetEffects();
			UpdateDyes();
			if (CreativePowerManager.Instance.GetPower<CreativePowers.GodmodePower>().IsEnabledForPlayer(whoAmI))
			{
				creativeGodMode = true;
			}
			if (IsStandingStillForSpecialEffects && itemAnimation == 0)
			{
				afkCounter++;
			}
			else
			{
				afkCounter = 0;
			}
			if (whoAmI == Main.myPlayer)
			{
				Main.musicBox2 = -1;
				if (Main.SceneMetrics.WaterCandleCount > 0)
				{
					AddBuff(86, 2, quiet: false);
				}
				if (Main.SceneMetrics.PeaceCandleCount > 0)
				{
					AddBuff(157, 2, quiet: false);
				}
				if (Main.SceneMetrics.ShadowCandleCount > 0)
				{
					AddBuff(350, 2, quiet: false);
				}
				if (Main.SceneMetrics.HasCampfire)
				{
					AddBuff(87, 2, quiet: false);
				}
				if (Main.SceneMetrics.HasCatBast)
				{
					AddBuff(215, 2, quiet: false);
				}
				if (Main.SceneMetrics.HasStarInBottle)
				{
					AddBuff(158, 2, quiet: false);
				}
				if (Main.SceneMetrics.HasHeartLantern)
				{
					AddBuff(89, 2, quiet: false);
				}
				if (Main.SceneMetrics.HasSunflower)
				{
					AddBuff(146, 2, quiet: false);
				}
				if (Main.SceneMetrics.hasBanner)
				{
					AddBuff(147, 2, quiet: false);
				}
				if (!behindBackWall && ZoneSandstorm)
				{
					AddBuff(194, 2, quiet: false);
				}
			}
			PlayerLoader.PreUpdateBuffs(this);
			for (int num25 = 0; num25 < BuffLoader.BuffCount; num25++)
			{
				buffImmune[num25] = false;
			}
			UpdateProjectileCaches(i);
			UpdateBuffs(i);
			PlayerLoader.PostUpdateBuffs(this);
			if (kbBuff)
			{
				allKB *= 1.5f;
			}
			if (whoAmI == Main.myPlayer)
			{
				if (!onFire && !poisoned)
				{
					trapDebuffSource = false;
				}
				UpdatePet(i);
				UpdatePetLight(i);
				isOperatingAnotherEntity = ownedProjectileCounts[1020] > 0;
			}
			bool flag12 = wet && !lavaWet && (!mount.Active || !mount.IsConsideredASlimeMount);
			if (accMerman && flag12)
			{
				releaseJump = true;
				wings = 0;
				merman = true;
				accFlipper = true;
				AddBuff(34, 2);
			}
			else
			{
				merman = false;
			}
			if (!flag12 && forceWerewolf)
			{
				forceMerman = false;
			}
			if (forceMerman && flag12)
			{
				wings = 0;
			}
			accMerman = false;
			hideMerman = false;
			forceMerman = false;
			if (wolfAcc && !merman && !Main.dayTime && !wereWolf)
			{
				AddBuff(28, 60);
			}
			wolfAcc = false;
			hideWolf = false;
			forceWerewolf = false;
			if (whoAmI == Main.myPlayer)
			{
				for (int num26 = 0; num26 < maxBuffs; num26++)
				{
					if (buffType[num26] > 0 && buffTime[num26] <= 0)
					{
						DelBuff(num26);
					}
				}
			}
			beetleDefense = false;
			beetleOffense = false;
			setSolar = false;
			head = armor[0].headSlot;
			body = armor[1].bodySlot;
			legs = armor[2].legSlot;
			ResetVisibleAccessories();
			if (MountFishronSpecialCounter > 0f)
			{
				MountFishronSpecialCounter -= 1f;
			}
			if (_portalPhysicsTime > 0)
			{
				_portalPhysicsTime--;
			}
			UpdateEquips(i);
			if (Main.npcShop <= 0)
			{
				discountAvailable = discountEquipped;
			}
			if (potionDelayModifier != PotionDelayModifier)
			{
				AdjustRemainingPotionSickness(potionDelayModifier);
			}
			UpdatePermanentBoosters();
			UpdateLuck();
			shimmerUnstuckHelper.Update(this);
			UpdatePortableStoolUsage();
			if (velocity.Y == 0f || controlJump)
			{
				portalPhysicsFlag = false;
			}
			if (inventory[selectedItem].type == 3384 || portalPhysicsFlag)
			{
				_portalPhysicsTime = 30;
			}
			if (mount.Active)
			{
				mount.UpdateEffects(this);
			}
			gemCount++;
			if (gemCount >= 10)
			{
				gem = -1;
				ownedLargeGems = (byte)0;
				gemCount = 0;
				for (int num27 = 0; num27 <= 58; num27++)
				{
					if (inventory[num27].type == 0 || inventory[num27].stack == 0)
					{
						inventory[num27].TurnToAir();
					}
					if (inventory[num27].type >= 1522 && inventory[num27].type <= 1527)
					{
						gem = inventory[num27].type - 1522;
						ownedLargeGems[gem] = true;
					}
					if (inventory[num27].type == 3643)
					{
						gem = 6;
						ownedLargeGems[gem] = true;
					}
				}
			}
			UpdateArmorLights();
			UpdateArmorSets(i);
			if (shadowDodge && !onHitDodge)
			{
				ClearBuff(59);
			}
			PlayerLoader.PostUpdateEquips(this);
			if (maxTurretsOld != maxTurrets)
			{
				UpdateMaxTurrets();
				maxTurretsOld = maxTurrets;
			}
			if (shieldRaised)
			{
				statDefense += 20;
			}
			if ((merman || forceMerman) && flag12)
			{
				wings = 0;
			}
			if (invis)
			{
				if (itemAnimation == 0 && aggro > -750)
				{
					aggro = -750;
				}
				else if (aggro > -250)
				{
					aggro = -250;
				}
			}
			if (inventory[selectedItem].type == 3106)
			{
				if (itemAnimation > 0)
				{
					stealthTimer = 15;
					if (stealth > 0f)
					{
						stealth += 0.1f;
					}
				}
				else if ((double)velocity.X > -0.1 && (double)velocity.X < 0.1 && (double)velocity.Y > -0.1 && (double)velocity.Y < 0.1 && !mount.Active)
				{
					if (stealthTimer == 0 && stealth > 0f)
					{
						stealth -= 0.02f;
						if ((double)stealth <= 0.0)
						{
							stealth = 0f;
							if (Main.netMode == 1)
							{
								NetMessage.SendData(84, -1, -1, null, whoAmI);
							}
						}
					}
				}
				else
				{
					if (stealth > 0f)
					{
						stealth += 0.1f;
					}
					if (mount.Active)
					{
						stealth = 1f;
					}
				}
				if (stealth > 1f)
				{
					stealth = 1f;
				}
				meleeDamage += (1f - stealth) * 3f;
				meleeCrit += (int)((1f - stealth) * 30f);
				GetKnockback(DamageClass.Melee) *= 1f + (1f - stealth);
				aggro -= (int)((1f - stealth) * 750f);
				if (stealthTimer > 0)
				{
					stealthTimer--;
				}
			}
			else if (shroomiteStealth)
			{
				if (itemAnimation > 0)
				{
					stealthTimer = 5;
				}
				if ((double)velocity.X > -0.1 && (double)velocity.X < 0.1 && (double)velocity.Y > -0.1 && (double)velocity.Y < 0.1 && !mount.Active)
				{
					if (stealthTimer == 0 && stealth > 0f)
					{
						stealth -= 0.015f;
						if ((double)stealth <= 0.0)
						{
							stealth = 0f;
							if (Main.netMode == 1)
							{
								NetMessage.SendData(84, -1, -1, null, whoAmI);
							}
						}
					}
				}
				else
				{
					float num28 = Math.Abs(velocity.X) + Math.Abs(velocity.Y);
					stealth += num28 * 0.0075f;
					if (stealth > 1f)
					{
						stealth = 1f;
					}
					if (mount.Active)
					{
						stealth = 1f;
					}
				}
				rangedDamage += (1f - stealth) * 0.6f;
				rangedCrit += (int)((1f - stealth) * 10f);
				GetKnockback(DamageClass.Ranged) *= 1f + (1f - stealth) * 0.5f;
				aggro -= (int)((1f - stealth) * 750f);
				if (stealthTimer > 0)
				{
					stealthTimer--;
				}
			}
			else if (setVortex)
			{
				bool flag13 = false;
				if (vortexStealthActive)
				{
					float num29 = stealth;
					stealth -= 0.04f;
					if (stealth < 0f)
					{
						stealth = 0f;
					}
					else
					{
						flag13 = true;
					}
					if (stealth == 0f && num29 != stealth && Main.netMode == 1)
					{
						NetMessage.SendData(84, -1, -1, null, whoAmI);
					}
					rangedDamage += (1f - stealth) * 0.8f;
					rangedCrit += (int)((1f - stealth) * 20f);
					GetKnockback(DamageClass.Ranged) *= 1f + (1f - stealth) * 0.5f;
					aggro -= (int)((1f - stealth) * 1200f);
					accRunSpeed *= 0.3f;
					maxRunSpeed *= 0.3f;
					if (mount.Active)
					{
						vortexStealthActive = false;
					}
				}
				else
				{
					float num30 = stealth;
					stealth += 0.04f;
					if (stealth > 1f)
					{
						stealth = 1f;
					}
					else
					{
						flag13 = true;
					}
					if (stealth == 1f && num30 != stealth && Main.netMode == 1)
					{
						NetMessage.SendData(84, -1, -1, null, whoAmI);
					}
				}
				if (flag13)
				{
					if (Main.rand.Next(2) == 0)
					{
						Vector2 val2 = Vector2.UnitY.RotatedByRandom(6.2831854820251465);
						Dust obj2 = Main.dust[Dust.NewDust(base.Center - val2 * 30f, 0, 0, 229)];
						obj2.noGravity = true;
						obj2.position = base.Center - val2 * (float)Main.rand.Next(5, 11);
						obj2.velocity = val2.RotatedBy(1.5707963705062866) * 4f;
						obj2.scale = 0.5f + Main.rand.NextFloat();
						obj2.fadeIn = 0.5f;
					}
					if (Main.rand.Next(2) == 0)
					{
						Vector2 val3 = Vector2.UnitY.RotatedByRandom(6.2831854820251465);
						Dust obj3 = Main.dust[Dust.NewDust(base.Center - val3 * 30f, 0, 0, 240)];
						obj3.noGravity = true;
						obj3.position = base.Center - val3 * 12f;
						obj3.velocity = val3.RotatedBy(-1.5707963705062866) * 2f;
						obj3.scale = 0.5f + Main.rand.NextFloat();
						obj3.fadeIn = 0.5f;
					}
				}
			}
			else
			{
				stealth = 1f;
			}
			if (manaSick)
			{
				magicDamage *= 1f - manaSickReduction;
			}
			if (tileSpeed > 3f)
			{
				tileSpeed = 3f;
			}
			tileSpeed = 1f / tileSpeed;
			if (wallSpeed > 3f)
			{
				wallSpeed = 3f;
			}
			wallSpeed = 1f / wallSpeed;
			if (slowOgreSpit)
			{
				moveSpeed /= 3f;
				if (velocity.Y == 0f && Math.Abs(velocity.X) > 1f)
				{
					velocity.X /= 2f;
				}
			}
			else if (dazed)
			{
				moveSpeed /= 3f;
			}
			else if (slow)
			{
				moveSpeed /= 2f;
			}
			else if (chilled)
			{
				moveSpeed *= 0.75f;
			}
			if (shieldRaised)
			{
				moveSpeed /= 3f;
				if (velocity.Y == 0f && Math.Abs(velocity.X) > 3f)
				{
					velocity.X /= 2f;
				}
			}
			if (DD2Event.Ongoing)
			{
				DD2Event.FindArenaHitbox();
				if (DD2Event.ShouldBlockBuilding(base.Center))
				{
					noBuilding = true;
					AddBuff(199, 3);
				}
			}
			if ((double)pickSpeed < 0.3)
			{
				pickSpeed = 0.3f;
			}
			CapAttackSpeeds();
			PlayerLoader.PostUpdateMiscEffects(this);
			UpdateLifeRegen();
			soulDrain = 0;
			UpdateManaRegen();
			if (manaRegenCount < 0)
			{
				manaRegenCount = 0;
			}
			if (statMana > statManaMax2)
			{
				statMana = statManaMax2;
			}
			runAcceleration *= moveSpeed;
			maxRunSpeed *= moveSpeed;
			UpdateJumpHeight();
			for (int num31 = 0; num31 < maxBuffs; num31++)
			{
				if (buffType[num31] > 0 && buffTime[num31] > 0 && buffImmune[buffType[num31]])
				{
					DelBuff(num31);
				}
			}
			if (brokenArmor)
			{
				statDefense /= 2f;
			}
			if (witheredArmor)
			{
				statDefense /= 2f;
			}
			if (witheredWeapon)
			{
				allDamage *= 0.5f;
			}
			lastTileRangeX = tileRangeX;
			lastTileRangeY = tileRangeY;
			if (mount.Active)
			{
				movementAbilitiesCache.CopyFrom(this);
			}
			else
			{
				movementAbilitiesCache.PasteInto(this);
			}
			if (mount.Active && mount.BlockExtraJumps)
			{
				ConsumeAllExtraJumps();
			}
			else if (velocity.Y == 0f || sliding)
			{
				RefreshDoubleJumps();
			}
			else
			{
				ExtraJumpLoader.ConsumeAndStopUnavailableJumps(this);
			}
			if (!carpet)
			{
				canCarpet = false;
				carpetFrame = -1;
			}
			else if (velocity.Y == 0f || sliding)
			{
				canCarpet = true;
				carpetTime = 0;
				carpetFrame = -1;
				carpetFrameCounter = 0f;
			}
			if (gravDir == -1f)
			{
				canCarpet = false;
			}
			if (ropeCount > 0)
			{
				ropeCount--;
			}
			if (!pulley && !frozen && !webbed && !stoned && !controlJump && gravDir == 1f && ropeCount == 0 && grappling[0] == -1 && !tongued && !mount.Active)
			{
				FindPulley();
			}
			UpdatePettingAnimal();
			sitting.UpdateSitting(this);
			sleeping.UpdateState(this);
			eyeHelper.Update(this);
			if (pulley)
			{
				if (mount.Active)
				{
					pulley = false;
				}
				sandStorm = false;
				CancelAllJumpVisualEffects();
				int num32 = (int)(position.X + (float)(width / 2)) / 16;
				int num33 = (int)(position.Y - 8f) / 16;
				bool flag14 = false;
				if (pulleyDir == 0)
				{
					pulleyDir = 1;
				}
				if (pulleyDir == 1)
				{
					if (direction == -1 && controlLeft && (releaseLeft || leftTimer == 0))
					{
						pulleyDir = 2;
						flag14 = true;
					}
					else if ((direction == 1 && controlRight && releaseRight) || rightTimer == 0)
					{
						pulleyDir = 2;
						flag14 = true;
					}
					else
					{
						if (direction == 1 && controlLeft)
						{
							direction = -1;
							flag14 = true;
						}
						if (direction == -1 && controlRight)
						{
							direction = 1;
							flag14 = true;
						}
					}
				}
				else if (pulleyDir == 2)
				{
					if (direction == 1 && controlLeft)
					{
						flag14 = true;
						if (!Collision.SolidCollision(new Vector2((float)(num32 * 16 + 8 - width / 2), position.Y), width, height))
						{
							pulleyDir = 1;
							direction = -1;
							flag14 = true;
						}
					}
					if (direction == -1 && controlRight)
					{
						flag14 = true;
						if (!Collision.SolidCollision(new Vector2((float)(num32 * 16 + 8 - width / 2), position.Y), width, height))
						{
							pulleyDir = 1;
							direction = 1;
							flag14 = true;
						}
					}
				}
				int num34 = 1;
				if (controlLeft)
				{
					num34 = -1;
				}
				bool flag15 = CanMoveForwardOnRope(num34, num32, num33);
				if (controlLeft && direction == -1 && flag15)
				{
					instantMovementAccumulatedThisFrame.X += -1f;
				}
				if (controlRight && direction == 1 && flag15)
				{
					instantMovementAccumulatedThisFrame.X += 1f;
				}
				bool flag16 = false;
				if (!flag14 && ((controlLeft && (releaseLeft || leftTimer == 0)) || (controlRight && (releaseRight || rightTimer == 0))))
				{
					int num35 = num32 + num34;
					if (WorldGen.IsRope(num35, num33))
					{
						pulleyDir = 1;
						direction = num34;
						int num36 = num35 * 16 + 8 - width / 2;
						float y4 = position.Y;
						y4 = num33 * 16 + 22;
						if (Main.tile[num35, num33 - 1] == null)
						{
							Main.tile[num35, num33 - 1] = default(Tile);
						}
						if (Main.tile[num35, num33 + 1] == null)
						{
							Main.tile[num35, num33 + 1] = default(Tile);
						}
						if (WorldGen.IsRope(num35, num33 - 1) || WorldGen.IsRope(num35, num33 + 1))
						{
							y4 = num33 * 16 + 22;
						}
						if (Collision.SolidCollision(new Vector2((float)num36, y4), width, height))
						{
							pulleyDir = 2;
							direction = -num34;
							num36 = ((direction != 1) ? (num35 * 16 + 8 - width / 2 + -6) : (num35 * 16 + 8 - width / 2 + 6));
						}
						if (i == Main.myPlayer)
						{
							Main.cameraX = Main.cameraX + position.X - (float)num36;
						}
						position.X = num36;
						gfxOffY = position.Y - y4;
						position.Y = y4;
						flag16 = true;
					}
				}
				if (!flag16 && !flag14 && !controlUp && ((controlLeft && releaseLeft) || (controlRight && releaseRight)))
				{
					pulley = false;
					if (controlLeft && velocity.X == 0f)
					{
						velocity.X = -1f;
					}
					if (controlRight && velocity.X == 0f)
					{
						velocity.X = 1f;
					}
				}
				if (velocity.X != 0f)
				{
					pulley = false;
				}
				if (Main.tile[num32, num33] == null)
				{
					Main.tile[num32, num33] = default(Tile);
				}
				if (!WorldGen.IsRope(num32, num33))
				{
					pulley = false;
				}
				if (gravDir != 1f)
				{
					pulley = false;
				}
				if (frozen || webbed || stoned)
				{
					pulley = false;
				}
				if (!pulley)
				{
					velocity.Y -= gravity;
				}
				if (controlJump)
				{
					pulley = false;
					jump = jumpHeight;
					velocity.Y = 0f - jumpSpeed;
				}
			}
			if (grapCount > 0)
			{
				pulley = false;
			}
			if (NPC.brainOfGravity >= 0 && NPC.brainOfGravity < 200 && Vector2.Distance(base.Center, Main.npc[NPC.brainOfGravity].Center) < 4000f)
			{
				forcedGravity = 10;
			}
			if (forcedGravity > 0)
			{
				gravDir = -1f;
			}
			if (pulley)
			{
				fallStart = (int)position.Y / 16;
				wingFrame = 0;
				if (wings == 4)
				{
					wingFrame = 3;
				}
				int num37 = (int)(position.X + (float)(width / 2)) / 16;
				int num38 = (int)(position.Y - 16f) / 16;
				int num39 = (int)(position.Y - 8f) / 16;
				bool flag17 = true;
				bool flag18 = false;
				if (WorldGen.IsRope(num37, num39 - 1) || WorldGen.IsRope(num37, num39 + 1))
				{
					flag18 = true;
				}
				if (Main.tile[num37, num38] == null)
				{
					Main.tile[num37, num38] = default(Tile);
				}
				if (!WorldGen.IsRope(num37, num38))
				{
					flag17 = false;
					if (velocity.Y < 0f)
					{
						velocity.Y = 0f;
					}
				}
				if (flag18)
				{
					if (controlUp && flag17)
					{
						float x3 = position.X;
						float num40 = position.Y - Math.Abs(velocity.Y) - 2f;
						if (Collision.SolidCollision(new Vector2(x3, num40), width, height))
						{
							x3 = num37 * 16 + 8 - width / 2 + 6;
							if (!Collision.SolidCollision(new Vector2(x3, num40), width, (int)((float)height + Math.Abs(velocity.Y) + 2f)))
							{
								if (i == Main.myPlayer)
								{
									Main.cameraX = Main.cameraX + position.X - x3;
								}
								pulleyDir = 2;
								direction = 1;
								position.X = x3;
								velocity.X = 0f;
							}
							else
							{
								x3 = num37 * 16 + 8 - width / 2 + -6;
								if (!Collision.SolidCollision(new Vector2(x3, num40), width, (int)((float)height + Math.Abs(velocity.Y) + 2f)))
								{
									if (i == Main.myPlayer)
									{
										Main.cameraX = Main.cameraX + position.X - x3;
									}
									pulleyDir = 2;
									direction = -1;
									position.X = x3;
									velocity.X = 0f;
								}
							}
						}
						if (velocity.Y > 0f)
						{
							velocity.Y *= 0.7f;
						}
						if (velocity.Y > -3f)
						{
							velocity.Y -= 0.2f;
						}
						else
						{
							velocity.Y -= 0.02f;
						}
						if (velocity.Y < -8f)
						{
							velocity.Y = -8f;
						}
					}
					else if (controlDown)
					{
						float x4 = position.X;
						float y5 = position.Y;
						if (Collision.SolidCollision(new Vector2(x4, y5), width, (int)((float)height + Math.Abs(velocity.Y) + 2f)))
						{
							x4 = num37 * 16 + 8 - width / 2 + 6;
							if (!Collision.SolidCollision(new Vector2(x4, y5), width, (int)((float)height + Math.Abs(velocity.Y) + 2f)))
							{
								if (i == Main.myPlayer)
								{
									Main.cameraX = Main.cameraX + position.X - x4;
								}
								pulleyDir = 2;
								direction = 1;
								position.X = x4;
								velocity.X = 0f;
							}
							else
							{
								x4 = num37 * 16 + 8 - width / 2 + -6;
								if (!Collision.SolidCollision(new Vector2(x4, y5), width, (int)((float)height + Math.Abs(velocity.Y) + 2f)))
								{
									if (i == Main.myPlayer)
									{
										Main.cameraX = Main.cameraX + position.X - x4;
									}
									pulleyDir = 2;
									direction = -1;
									position.X = x4;
									velocity.X = 0f;
								}
							}
						}
						if (velocity.Y < 0f)
						{
							velocity.Y *= 0.7f;
						}
						if (velocity.Y < 3f)
						{
							velocity.Y += 0.2f;
						}
						else
						{
							velocity.Y += 0.1f;
						}
						if (velocity.Y > maxFallSpeed)
						{
							velocity.Y = maxFallSpeed;
						}
					}
					else
					{
						velocity.Y *= 0.7f;
						if ((double)velocity.Y > -0.1 && (double)velocity.Y < 0.1)
						{
							velocity.Y = 0f;
						}
					}
				}
				else if (controlDown)
				{
					ropeCount = 10;
					pulley = false;
					velocity.Y = 1f;
				}
				else
				{
					velocity.Y = 0f;
					position.Y = num38 * 16 + 22;
				}
				float num41 = num37 * 16 + 8 - width / 2;
				if (pulleyDir == 1)
				{
					num41 = num37 * 16 + 8 - width / 2;
				}
				if (pulleyDir == 2)
				{
					num41 = num37 * 16 + 8 - width / 2 + 6 * direction;
				}
				if (i == Main.myPlayer)
				{
					Main.cameraX += position.X - num41;
					Main.cameraX = MathHelper.Clamp(Main.cameraX, -32f, 32f);
				}
				position.X = num41;
				pulleyFrameCounter += Math.Abs(velocity.Y * 0.75f);
				if (velocity.Y != 0f)
				{
					pulleyFrameCounter += 0.75f;
				}
				if (pulleyFrameCounter > 10f)
				{
					pulleyFrame++;
					pulleyFrameCounter = 0f;
				}
				if (pulleyFrame > 1)
				{
					pulleyFrame = 0;
				}
				canCarpet = true;
				carpetFrame = -1;
				wingTime = wingTimeMax;
				rocketTime = rocketTimeMax;
				rocketDelay = 0;
				rocketFrame = false;
				canRocket = false;
				rocketRelease = false;
				DashMovement();
				UpdateControlHolds();
			}
			else if (grappling[0] == -1 && !tongued)
			{
				if (wingsLogic > 0 && velocity.Y != 0f && !merman && !mount.Active)
				{
					WingAirLogicTweaks();
				}
				if (empressBrooch)
				{
					runAcceleration *= 1.75f;
				}
				if (hasMagiluminescence && velocity.Y == 0f)
				{
					runAcceleration *= 1.75f;
					maxRunSpeed *= 1.15f;
					accRunSpeed *= 1.15f;
					runSlowdown *= 1.75f;
				}
				if (shadowArmor)
				{
					runAcceleration *= 1.75f;
					maxRunSpeed *= 1.15f;
					accRunSpeed *= 1.15f;
					runSlowdown *= 1.75f;
				}
				if (mount.Active && mount.Type == 43 && velocity.Y != 0f)
				{
					runSlowdown = 0f;
				}
				if (sticky)
				{
					maxRunSpeed *= 0.25f;
					runAcceleration *= 0.25f;
					runSlowdown *= 2f;
					if (velocity.X > maxRunSpeed)
					{
						velocity.X = maxRunSpeed;
					}
					if (velocity.X < 0f - maxRunSpeed)
					{
						velocity.X = 0f - maxRunSpeed;
					}
				}
				else if (powerrun)
				{
					maxRunSpeed *= 3.5f;
					runAcceleration *= 1f;
					runSlowdown *= 2f;
				}
				else if (runningOnSand && desertBoots)
				{
					float num42 = 1.75f;
					maxRunSpeed *= num42;
					accRunSpeed *= num42;
					runAcceleration *= num42;
					runSlowdown *= num42;
				}
				else if (slippy2)
				{
					runAcceleration *= 0.6f;
					runSlowdown = 0f;
					if (iceSkate)
					{
						runAcceleration *= 3.5f;
						maxRunSpeed *= 1.25f;
					}
				}
				else if (slippy)
				{
					runAcceleration *= 0.7f;
					if (iceSkate)
					{
						runAcceleration *= 3.5f;
						maxRunSpeed *= 1.25f;
					}
					else
					{
						runSlowdown *= 0.1f;
					}
				}
				ExtraJumpLoader.UpdateHorizontalSpeeds(this);
				if (carpetFrame != -1)
				{
					runAcceleration *= 1.25f;
					maxRunSpeed *= 1.5f;
				}
				if (inventory[selectedItem].type == 3106 && stealth < 1f)
				{
					float num43 = maxRunSpeed / 2f * (1f - stealth);
					maxRunSpeed -= num43;
					accRunSpeed = maxRunSpeed;
				}
				if (mount.Active)
				{
					rocketBoots = 0;
					vanityRocketBoots = 0;
					wings = 0;
					wingsLogic = 0;
					maxRunSpeed = mount.RunSpeed;
					accRunSpeed = mount.DashSpeed;
					runAcceleration = mount.Acceleration;
					if (mount.Type == 12 && !MountFishronSpecial)
					{
						runAcceleration /= 2f;
						maxRunSpeed /= 2f;
					}
					mount.AbilityRecovery();
					if (mount.Cart && velocity.Y == 0f)
					{
						if (!Minecart.OnTrack(position, width, height))
						{
							fullRotation = 0f;
							onWrongGround = true;
							runSlowdown = 0.2f;
							if ((controlLeft && releaseLeft) || (controlRight && releaseRight))
							{
								mount.Dismount(this);
							}
						}
						else
						{
							runSlowdown = runAcceleration;
							onWrongGround = false;
						}
					}
					if (mount.Type == 8)
					{
						mount.UpdateDrill(this, controlUp, controlDown);
					}
				}
				PlayerLoader.PostUpdateRunSpeeds(this);
				HorizontalMovement();
				bool flag19 = !mount.Active;
				if (forcedGravity > 0)
				{
					gravDir = -1f;
				}
				else if (gravControl && flag19)
				{
					if (controlUp && releaseUp)
					{
						if (gravDir == 1f)
						{
							gravDir = -1f;
							fallStart = (int)(position.Y / 16f);
							jump = 0;
							SoundEngine.PlaySound(in SoundID.Item8, position);
						}
						else
						{
							gravDir = 1f;
							fallStart = (int)(position.Y / 16f);
							jump = 0;
							SoundEngine.PlaySound(in SoundID.Item8, position);
						}
					}
				}
				else if (gravControl2 && flag19)
				{
					if (controlUp && releaseUp)
					{
						if (gravDir == 1f)
						{
							gravDir = -1f;
							fallStart = (int)(position.Y / 16f);
							jump = 0;
							SoundEngine.PlaySound(in SoundID.Item8, position);
						}
						else
						{
							gravDir = 1f;
							fallStart = (int)(position.Y / 16f);
							jump = 0;
							SoundEngine.PlaySound(in SoundID.Item8, position);
						}
					}
				}
				else
				{
					gravDir = 1f;
				}
				if (velocity.Y == 0f && mount.Active && mount.CanHover() && controlUp && releaseUp)
				{
					velocity.Y = 0f - (mount.Acceleration + gravity + 0.001f);
				}
				UpdateControlHolds();
				sandStorm = false;
				JumpMovement();
				if (wingsLogic == 0)
				{
					wingTime = 0f;
				}
				if (rocketBoots == 0)
				{
					rocketTime = 0;
				}
				if (jump == 0)
				{
					CancelAllJumpVisualEffects();
				}
				DashMovement();
				WallslideMovement();
				CarpetMovement();
				DoubleJumpVisuals();
				if (wingsLogic > 0 || mount.Active)
				{
					sandStorm = false;
				}
				if (((gravDir == 1f && velocity.Y > 0f - jumpSpeed) || (gravDir == -1f && velocity.Y < jumpSpeed)) && velocity.Y != 0f)
				{
					canRocket = true;
				}
				bool flag20 = false;
				if (((velocity.Y == 0f || sliding) && releaseJump) || (autoJump && justJumped))
				{
					mount.ResetFlightTime(velocity.X);
					wingTime = wingTimeMax;
				}
				if (wingsLogic > 0 && controlJump && wingTime > 0f && jump == 0 && velocity.Y != 0f)
				{
					flag20 = true;
				}
				if ((wingsLogic == 22 || wingsLogic == 28 || wingsLogic == 30 || wingsLogic == 32 || wingsLogic == 29 || wingsLogic == 33 || wingsLogic == 35 || wingsLogic == 37 || wingsLogic == 45) && controlJump && TryingToHoverDown && wingTime > 0f)
				{
					flag20 = true;
				}
				if (frozen || webbed || stoned)
				{
					if (mount.Active)
					{
						mount.Dismount(this);
					}
					velocity.Y += gravity;
					if (velocity.Y > maxFallSpeed)
					{
						velocity.Y = maxFallSpeed;
					}
					sandStorm = false;
					CancelAllJumpVisualEffects();
				}
				else
				{
					bool flag21 = ItemLoader.WingUpdate(this, flag20);
					if (flag20)
					{
						WingAirVisuals();
						WingMovement();
					}
					WingFrame(flag20, flag21);
					if (wingsLogic > 0 && rocketBoots != 0 && velocity.Y != 0f && rocketTime != 0)
					{
						int num44 = 6;
						int num45 = rocketTime * num44;
						wingTime += num45;
						if (wingTime > (float)(wingTimeMax + num45))
						{
							wingTime = wingTimeMax + num45;
						}
						rocketTime = 0;
					}
					if (!flag21 && flag20 && wings != 4 && wings != 22 && wings != 0 && wings != 24 && wings != 28 && wings != 30 && wings != 33 && wings != 45)
					{
						bool flag22 = wingFrame == 3;
						if (wings == 43 || wings == 44)
						{
							flag22 = wingFrame == 4;
						}
						if (flag22)
						{
							if (!flapSound)
							{
								SoundEngine.PlaySound(in SoundID.Item32, position);
							}
							flapSound = true;
						}
						else
						{
							flapSound = false;
						}
					}
					if (velocity.Y == 0f || sliding || (autoJump && justJumped))
					{
						rocketTime = rocketTimeMax;
					}
					if (empressBrooch)
					{
						rocketTime = rocketTimeMax;
					}
					if ((wingTime == 0f || wingsLogic == 0) && rocketBoots != 0 && controlJump && rocketDelay == 0 && canRocket && rocketRelease && !AnyExtraJumpUsable())
					{
						if (rocketTime > 0)
						{
							rocketTime--;
							rocketDelay = 10;
							if (rocketDelay2 <= 0)
							{
								if (rocketBoots == 1)
								{
									rocketDelay2 = 30;
								}
								else if (rocketBoots == 2 || rocketBoots == 5 || rocketBoots == 3 || rocketBoots == 4)
								{
									rocketDelay2 = 15;
								}
							}
							if (rocketSoundDelay <= 0)
							{
								if (vanityRocketBoots == 1 || vanityRocketBoots == 5)
								{
									rocketSoundDelay = 30;
									SoundEngine.PlaySound(in SoundID.Item13, position);
								}
								else if (vanityRocketBoots == 2 || vanityRocketBoots == 3 || vanityRocketBoots == 4)
								{
									rocketSoundDelay = 15;
									SoundEngine.PlaySound(in SoundID.Item24, position);
								}
							}
						}
						else
						{
							canRocket = false;
						}
					}
					if (rocketSoundDelay > 0)
					{
						rocketSoundDelay--;
					}
					if (rocketDelay2 > 0)
					{
						rocketDelay2--;
					}
					if (rocketDelay == 0)
					{
						rocketFrame = false;
					}
					if (rocketDelay > 0)
					{
						rocketFrame = true;
						RocketBootVisuals();
						if (rocketDelay == 0)
						{
							releaseJump = true;
						}
						rocketDelay--;
						velocity.Y -= 0.1f * gravDir;
						if (gravDir == 1f)
						{
							if (velocity.Y > 0f)
							{
								velocity.Y -= 0.5f;
							}
							else if ((double)velocity.Y > (double)(0f - jumpSpeed) * 0.5)
							{
								velocity.Y -= 0.1f;
							}
							if (velocity.Y < (0f - jumpSpeed) * 1.5f)
							{
								velocity.Y = (0f - jumpSpeed) * 1.5f;
							}
						}
						else
						{
							if (velocity.Y < 0f)
							{
								velocity.Y += 0.5f;
							}
							else if ((double)velocity.Y < (double)jumpSpeed * 0.5)
							{
								velocity.Y += 0.1f;
							}
							if (velocity.Y > jumpSpeed * 1.5f)
							{
								velocity.Y = jumpSpeed * 1.5f;
							}
						}
					}
					else if (!flag20)
					{
						if (mount.CanHover())
						{
							mount.Hover(this);
						}
						else if (mount.CanFly() && controlJump && jump == 0)
						{
							if (mount.Flight())
							{
								if (TryingToHoverDown)
								{
									velocity.Y *= 0.9f;
									if (velocity.Y > -1f && (double)velocity.Y < 0.5)
									{
										velocity.Y = 1E-05f;
									}
								}
								else
								{
									float num46 = jumpSpeed;
									if (mount.Type == 50)
									{
										num46 *= 0.5f;
									}
									if (velocity.Y > 0f)
									{
										velocity.Y -= 0.5f;
									}
									else if ((double)velocity.Y > (double)(0f - num46) * 1.5)
									{
										velocity.Y -= 0.1f;
									}
									if (velocity.Y < (0f - num46) * 1.5f)
									{
										velocity.Y = (0f - num46) * 1.5f;
									}
								}
							}
							else
							{
								velocity.Y += gravity / 3f * gravDir;
								if (gravDir == 1f)
								{
									if (velocity.Y > maxFallSpeed / 3f && !TryingToHoverDown)
									{
										velocity.Y = maxFallSpeed / 3f;
									}
								}
								else if (velocity.Y < (0f - maxFallSpeed) / 3f && !TryingToHoverUp)
								{
									velocity.Y = (0f - maxFallSpeed) / 3f;
								}
							}
						}
						else if (slowFall && !TryingToHoverDown)
						{
							if (TryingToHoverUp)
							{
								gravity = gravity / 10f * gravDir;
							}
							else
							{
								gravity = gravity / 3f * gravDir;
							}
							velocity.Y += gravity;
						}
						else if (wingsLogic > 0 && controlJump && velocity.Y > 0f)
						{
							bool noLightEmittence = wingsLogic != wings;
							fallStart = (int)(position.Y / 16f);
							if (velocity.Y > 0f)
							{
								if (wings == 10 && Main.rand.Next(3) == 0)
								{
									int num47 = 4;
									if (direction == 1)
									{
										num47 = -40;
									}
									int num48 = Dust.NewDust(new Vector2(position.X + (float)(width / 2) + (float)num47, position.Y + (float)(height / 2) - 15f), 30, 30, 76, 0f, 0f, 50, default(Color), 0.6f);
									Main.dust[num48].fadeIn = 1.1f;
									Main.dust[num48].noGravity = true;
									Main.dust[num48].noLight = true;
									Dust obj4 = Main.dust[num48];
									obj4.velocity *= 0.3f;
									Main.dust[num48].shader = GameShaders.Armor.GetSecondaryShader(cWings, this);
								}
								if (wings == 34 && ShouldDrawWingsThatAreAlwaysAnimated() && Main.rand.Next(3) == 0)
								{
									int num49 = 4;
									if (direction == 1)
									{
										num49 = -40;
									}
									int num50 = Dust.NewDust(new Vector2(position.X + (float)(width / 2) + (float)num49, position.Y + (float)(height / 2) - 15f), 30, 30, 261, 0f, 0f, 50, default(Color), 0.6f);
									Main.dust[num50].fadeIn = 1.1f;
									Main.dust[num50].noGravity = true;
									Main.dust[num50].noLight = true;
									Main.dust[num50].noLightEmittence = noLightEmittence;
									Dust obj5 = Main.dust[num50];
									obj5.velocity *= 0.3f;
									Main.dust[num50].shader = GameShaders.Armor.GetSecondaryShader(cWings, this);
								}
								if (wings == 40)
								{
									ShouldDrawWingsThatAreAlwaysAnimated();
								}
								if (wings == 44)
								{
									ShouldDrawWingsThatAreAlwaysAnimated();
								}
								if (wings == 9 && Main.rand.Next(3) == 0)
								{
									int num51 = 8;
									if (direction == 1)
									{
										num51 = -40;
									}
									int num52 = Dust.NewDust(new Vector2(position.X + (float)(width / 2) + (float)num51, position.Y + (float)(height / 2) - 15f), 30, 30, 6, 0f, 0f, 200, default(Color), 2f);
									Main.dust[num52].noGravity = true;
									Dust obj6 = Main.dust[num52];
									obj6.velocity *= 0.3f;
									Main.dust[num52].noLightEmittence = noLightEmittence;
									Main.dust[num52].shader = GameShaders.Armor.GetSecondaryShader(cWings, this);
								}
								if (wings == 29 && Main.rand.Next(3) == 0)
								{
									int num53 = 8;
									if (direction == 1)
									{
										num53 = -40;
									}
									int num54 = Dust.NewDust(new Vector2(position.X + (float)(width / 2) + (float)num53, position.Y + (float)(height / 2) - 15f), 30, 30, 6, 0f, 0f, 100, default(Color), 2.4f);
									Main.dust[num54].noGravity = true;
									Dust obj7 = Main.dust[num54];
									obj7.velocity *= 0.3f;
									Main.dust[num54].noLightEmittence = noLightEmittence;
									if (Main.rand.Next(10) == 0)
									{
										Main.dust[num54].fadeIn = 2f;
									}
									Main.dust[num54].shader = GameShaders.Armor.GetSecondaryShader(cWings, this);
								}
								if (wings == 6)
								{
									if (Main.rand.Next(10) == 0)
									{
										int num55 = 4;
										if (direction == 1)
										{
											num55 = -40;
										}
										int num56 = Dust.NewDust(new Vector2(position.X + (float)(width / 2) + (float)num55, position.Y + (float)(height / 2) - 12f), 30, 20, 55, 0f, 0f, 200);
										Main.dust[num56].noLightEmittence = noLightEmittence;
										Dust obj8 = Main.dust[num56];
										obj8.velocity *= 0.3f;
										Main.dust[num56].shader = GameShaders.Armor.GetSecondaryShader(cWings, this);
									}
								}
								else if (wings == 5 && Main.rand.Next(6) == 0)
								{
									int num57 = 6;
									if (direction == 1)
									{
										num57 = -30;
									}
									int num58 = Dust.NewDust(new Vector2(position.X + (float)(width / 2) + (float)num57, position.Y), 18, height, 58, 0f, 0f, 255, default(Color), 1.2f);
									Dust obj9 = Main.dust[num58];
									obj9.velocity *= 0.3f;
									Main.dust[num58].noLightEmittence = noLightEmittence;
									Main.dust[num58].shader = GameShaders.Armor.GetSecondaryShader(cWings, this);
								}
								if (!flag21)
								{
									if (wings == 4)
									{
										rocketDelay2--;
										if (rocketDelay2 <= 0)
										{
											SoundEngine.PlaySound(in SoundID.Item13, position);
											rocketDelay2 = 60;
										}
										int type = 6;
										float scale = 1.5f;
										int alpha = 100;
										float num59 = position.X + (float)(width / 2) + 16f;
										if (direction > 0)
										{
											num59 = position.X + (float)(width / 2) - 26f;
										}
										float num60 = position.Y + (float)height - 18f;
										if (Main.rand.Next(2) == 1)
										{
											num59 = position.X + (float)(width / 2) + 8f;
											if (direction > 0)
											{
												num59 = position.X + (float)(width / 2) - 20f;
											}
											num60 += 6f;
										}
										int num61 = Dust.NewDust(new Vector2(num59, num60), 8, 8, type, 0f, 0f, alpha, default(Color), scale);
										Main.dust[num61].velocity.X *= 0.3f;
										Main.dust[num61].velocity.Y += 10f;
										Main.dust[num61].noGravity = true;
										Main.dust[num61].noLightEmittence = noLightEmittence;
										Main.dust[num61].shader = GameShaders.Armor.GetSecondaryShader(cWings, this);
										wingFrameCounter++;
										if (wingFrameCounter > 4)
										{
											wingFrame++;
											wingFrameCounter = 0;
											if (wingFrame >= 3)
											{
												wingFrame = 0;
											}
										}
									}
									else if (wings != 22 && wings != 28)
									{
										if (wings == 30)
										{
											wingFrameCounter++;
											int num62 = 5;
											if (wingFrameCounter >= num62 * 3)
											{
												wingFrameCounter = 0;
											}
											wingFrame = 1 + wingFrameCounter / num62;
										}
										else if (wings == 34)
										{
											wingFrameCounter++;
											int num63 = 7;
											if (wingFrameCounter >= num63 * 6)
											{
												wingFrameCounter = 0;
											}
											wingFrame = wingFrameCounter / num63;
										}
										else if (wings != 45)
										{
											if (wings == 40)
											{
												wingFrame = 0;
											}
											else if (wings == 44)
											{
												wingFrame = 2;
											}
											else if (wings == 39)
											{
												wingFrameCounter++;
												int num64 = 12;
												if (wingFrameCounter >= num64 * 6)
												{
													wingFrameCounter = 0;
												}
												wingFrame = wingFrameCounter / num64;
											}
											else if (wings == 26)
											{
												int num65 = 6;
												if (direction == 1)
												{
													num65 = -30;
												}
												int num66 = Dust.NewDust(new Vector2(position.X + (float)(width / 2) + (float)num65, position.Y), 18, height, 217, 0f, 0f, 100, default(Color), 1.4f);
												Main.dust[num66].noGravity = true;
												Main.dust[num66].noLight = true;
												Dust obj10 = Main.dust[num66];
												obj10.velocity /= 4f;
												Dust obj11 = Main.dust[num66];
												obj11.velocity -= velocity;
												Main.dust[num66].shader = GameShaders.Armor.GetSecondaryShader(cWings, this);
												if (Main.rand.Next(2) == 0)
												{
													num65 = -24;
													if (direction == 1)
													{
														num65 = 12;
													}
													float num67 = position.Y;
													if (gravDir == -1f)
													{
														num67 += (float)(height / 2);
													}
													num66 = Dust.NewDust(new Vector2(position.X + (float)(width / 2) + (float)num65, num67), 12, height / 2, 217, 0f, 0f, 100, default(Color), 1.4f);
													Main.dust[num66].noGravity = true;
													Main.dust[num66].noLight = true;
													Dust obj12 = Main.dust[num66];
													obj12.velocity /= 4f;
													Dust obj13 = Main.dust[num66];
													obj13.velocity -= velocity;
													Main.dust[num66].shader = GameShaders.Armor.GetSecondaryShader(cWings, this);
												}
												wingFrame = 2;
											}
											else if (wings == 37)
											{
												Color color = Color.Lerp(Color.Black, Color.White, Main.rand.NextFloat());
												int num68 = 6;
												if (direction == 1)
												{
													num68 = -30;
												}
												int num69 = Dust.NewDust(new Vector2(position.X + (float)(width / 2) + (float)num68, position.Y), 24, height, Utils.SelectRandom<int>(Main.rand, 31, 31, 31), 0f, 0f, 100, default(Color), 0.7f);
												Main.dust[num69].noGravity = true;
												Main.dust[num69].noLight = true;
												Dust obj14 = Main.dust[num69];
												obj14.velocity /= 4f;
												Dust obj15 = Main.dust[num69];
												obj15.velocity -= velocity;
												Main.dust[num69].shader = GameShaders.Armor.GetSecondaryShader(cWings, this);
												if (Main.dust[num69].type == 55)
												{
													Main.dust[num69].color = color;
												}
												if (Main.rand.Next(3) == 0)
												{
													num68 = -24;
													if (direction == 1)
													{
														num68 = 12;
													}
													float num70 = position.Y;
													if (gravDir == -1f)
													{
														num70 += (float)(height / 2);
													}
													num69 = Dust.NewDust(new Vector2(position.X + (float)(width / 2) + (float)num68, num70), 12, height / 2, Utils.SelectRandom<int>(Main.rand, 31, 31, 31), 0f, 0f, 140, default(Color), 0.7f);
													Main.dust[num69].noGravity = true;
													Main.dust[num69].noLight = true;
													Dust obj16 = Main.dust[num69];
													obj16.velocity /= 4f;
													Dust obj17 = Main.dust[num69];
													obj17.velocity -= velocity;
													Main.dust[num69].shader = GameShaders.Armor.GetSecondaryShader(cWings, this);
													if (Main.dust[num69].type == 55)
													{
														Main.dust[num69].color = color;
													}
												}
												wingFrame = 2;
											}
											else if (wings != 24)
											{
												if (wings == 43)
												{
													wingFrame = 1;
												}
												else if (wings == 12)
												{
													wingFrame = 3;
												}
												else
												{
													wingFrame = 2;
												}
											}
										}
									}
								}
							}
							velocity.Y += gravity / 3f * gravDir;
							if (gravDir == 1f)
							{
								if (velocity.Y > maxFallSpeed / 3f && !TryingToHoverDown)
								{
									velocity.Y = maxFallSpeed / 3f;
								}
							}
							else if (velocity.Y < (0f - maxFallSpeed) / 3f && !TryingToHoverUp)
							{
								velocity.Y = (0f - maxFallSpeed) / 3f;
							}
						}
						else if (cartRampTime <= 0)
						{
							velocity.Y += gravity * gravDir;
						}
						else
						{
							cartRampTime--;
						}
					}
					if (!mount.Active || mount.Type != 5)
					{
						if (gravDir == 1f)
						{
							if (velocity.Y > maxFallSpeed)
							{
								velocity.Y = maxFallSpeed;
							}
							if (slowFall && velocity.Y > maxFallSpeed / 3f && !TryingToHoverDown)
							{
								velocity.Y = maxFallSpeed / 3f;
							}
							if (slowFall && velocity.Y > maxFallSpeed / 5f && TryingToHoverUp)
							{
								velocity.Y = maxFallSpeed / 10f;
							}
						}
						else
						{
							if (velocity.Y < 0f - maxFallSpeed)
							{
								velocity.Y = 0f - maxFallSpeed;
							}
							if (slowFall && velocity.Y < (0f - maxFallSpeed) / 3f && !TryingToHoverDown)
							{
								velocity.Y = (0f - maxFallSpeed) / 3f;
							}
							if (slowFall && velocity.Y < (0f - maxFallSpeed) / 5f && TryingToHoverUp)
							{
								velocity.Y = (0f - maxFallSpeed) / 10f;
							}
						}
					}
				}
			}
			else
			{
				UpdateControlHolds();
			}
			if (mount.Active)
			{
				wingFrame = 0;
			}
			if ((wingsLogic == 22 || wingsLogic == 28 || wingsLogic == 30 || wingsLogic == 31 || wingsLogic == 33 || wingsLogic == 35 || wingsLogic == 37 || wingsLogic == 45) && TryingToHoverDown && controlJump && wingTime > 0f && !merman)
			{
				float num71 = 0.9f;
				if (wingsLogic == 45)
				{
					num71 = 0.8f;
				}
				velocity.Y *= num71;
				if (velocity.Y > -2f && velocity.Y < 1f)
				{
					velocity.Y = 1E-05f;
				}
			}
			if (wingsLogic == 37 && TryingToHoverDown && controlJump && wingTime > 0f && !merman)
			{
				velocity.Y *= 0.92f;
				if (velocity.Y > -2f && velocity.Y < 1f)
				{
					velocity.Y = 1E-05f;
				}
			}
			GrabItems(i);
			LookForTileInteractions();
			if (tongued)
			{
				StopVanityActions();
				bool flag23 = false;
				if (Main.wofNPCIndex >= 0)
				{
					NPC nPC = Main.npc[Main.wofNPCIndex];
					float num72 = nPC.Center.X + (float)(nPC.direction * 200);
					float y6 = nPC.Center.Y;
					Vector2 center = base.Center;
					float num73 = num72 - center.X;
					float num74 = y6 - center.Y;
					float num75 = (float)Math.Sqrt(num73 * num73 + num74 * num74);
					float num76 = 11f;
					if (Main.expertMode)
					{
						float num77 = 22f;
						float num78 = Math.Min(1f, ((Vector2)(ref nPC.velocity)).Length() / 5f);
						num76 = MathHelper.Lerp(num76, num77, num78);
					}
					float num79 = num75;
					if (num75 > num76)
					{
						num79 = num76 / num75;
					}
					else
					{
						num79 = 1f;
						flag23 = true;
					}
					num73 *= num79;
					num74 *= num79;
					velocity.X = num73;
					velocity.Y = num74;
				}
				else
				{
					flag23 = true;
				}
				if (flag23 && Main.myPlayer == whoAmI)
				{
					for (int num80 = 0; num80 < maxBuffs; num80++)
					{
						if (buffType[num80] == 38)
						{
							DelBuff(num80);
						}
					}
				}
			}
			if (Main.myPlayer == whoAmI)
			{
				WOFTongue();
				if (controlHook)
				{
					if (releaseHook)
					{
						QuickGrapple();
					}
					releaseHook = false;
				}
				else
				{
					releaseHook = true;
				}
				if (talkNPC >= 0)
				{
					Rectangle val4 = default(Rectangle);
					((Rectangle)(ref val4))..ctor((int)(position.X + (float)(width / 2) - (float)(tileRangeX * 16)), (int)(position.Y + (float)(height / 2) - (float)(tileRangeY * 16)), tileRangeX * 16 * 2, tileRangeY * 16 * 2);
					Rectangle val5 = default(Rectangle);
					((Rectangle)(ref val5))..ctor((int)Main.npc[talkNPC].position.X, (int)Main.npc[talkNPC].position.Y, Main.npc[talkNPC].width, Main.npc[talkNPC].height);
					if (!((Rectangle)(ref val4)).Intersects(val5) || chest != -1 || !Main.npc[talkNPC].active || tileEntityAnchor.InUse)
					{
						if (chest == -1)
						{
							SoundEngine.PlaySound(11);
						}
						SetTalkNPC(-1);
						Main.npcChatCornerItem = 0;
						Main.npcChatText = "";
					}
				}
				if (sign >= 0)
				{
					Rectangle val6 = default(Rectangle);
					((Rectangle)(ref val6))..ctor((int)(position.X + (float)(width / 2) - (float)(tileRangeX * 16)), (int)(position.Y + (float)(height / 2) - (float)(tileRangeY * 16)), tileRangeX * 16 * 2, tileRangeY * 16 * 2);
					try
					{
						bool flag24 = false;
						if (Main.sign[sign] == null)
						{
							flag24 = true;
						}
						if (!flag24)
						{
							val = new Rectangle(Main.sign[sign].x * 16, Main.sign[sign].y * 16, 32, 32);
							if (!((Rectangle)(ref val)).Intersects(val6))
							{
								flag24 = true;
							}
						}
						if (flag24)
						{
							SoundEngine.PlaySound(11);
							sign = -1;
							Main.editSign = false;
							Main.npcChatText = "";
						}
					}
					catch
					{
						SoundEngine.PlaySound(11);
						sign = -1;
						Main.editSign = false;
						Main.npcChatText = "";
					}
				}
				if (Main.editSign)
				{
					if (sign == -1)
					{
						Main.editSign = false;
					}
					else
					{
						Main.InputTextSign();
					}
				}
				else if (Main.editChest)
				{
					Main.InputTextChest();
					if (Main.player[Main.myPlayer].chest == -1)
					{
						Main.editChest = false;
					}
				}
				if (mount.Active && mount.Cart && ((Vector2)(ref velocity)).Length() > 4f)
				{
					Rectangle val7 = default(Rectangle);
					((Rectangle)(ref val7))..ctor((int)position.X, (int)position.Y, width, height);
					if (velocity.X < -1f)
					{
						val7.X -= 15;
					}
					if (velocity.X > 1f)
					{
						val7.Width += 15;
					}
					if (velocity.X < -10f)
					{
						val7.X -= 10;
					}
					if (velocity.X > 10f)
					{
						val7.Width += 10;
					}
					if (velocity.Y < -1f)
					{
						val7.Y -= 10;
					}
					if (velocity.Y > 1f)
					{
						val7.Height += 10;
					}
					for (int num81 = 0; num81 < 200; num81++)
					{
						if (Main.npc[num81].active && !Main.npc[num81].dontTakeDamage && !Main.npc[num81].friendly && Main.npc[num81].immune[i] == 0 && CanNPCBeHitByPlayerOrPlayerProjectile(Main.npc[num81]) && ((Rectangle)(ref val7)).Intersects(new Rectangle((int)Main.npc[num81].position.X, (int)Main.npc[num81].position.Y, Main.npc[num81].width, Main.npc[num81].height)))
						{
							float num82 = DamageClassLoader.DamageClasses.Select((DamageClass t) => GetTotalCritChance(t)).Max();
							bool crit = false;
							if ((float)Main.rand.Next(1, 101) <= num82)
							{
								crit = true;
							}
							float currentSpeed = ((Vector2)(ref velocity)).Length() / maxRunSpeed;
							GetMinecartDamage(currentSpeed, out var damage2, out var knockback);
							int num83 = 1;
							if (velocity.X < 0f)
							{
								num83 = -1;
							}
							if (Main.npc[num81].knockBackResist < 1f && Main.npc[num81].knockBackResist > 0f)
							{
								knockback /= Main.npc[num81].knockBackResist;
							}
							if (whoAmI == Main.myPlayer)
							{
								ApplyDamageToNPC(Main.npc[num81], damage2, knockback, num83, crit);
							}
							Main.npc[num81].immune[i] = 30;
							if (!Main.npc[num81].active)
							{
								AchievementsHelper.HandleSpecialEvent(this, 9);
							}
						}
					}
				}
				Update_NPCCollision();
				if (!shimmering)
				{
					Collision.HurtTile hurtTile = GetHurtTile();
					if (hurtTile.type >= 0)
					{
						ApplyTouchDamage(hurtTile.type, hurtTile.x, hurtTile.y);
					}
				}
				TryToShimmerUnstuck();
			}
			if (controlRight)
			{
				releaseRight = false;
			}
			else
			{
				releaseRight = true;
				rightTimer = 7;
			}
			if (controlLeft)
			{
				releaseLeft = false;
			}
			else
			{
				releaseLeft = true;
				leftTimer = 7;
			}
			releaseDown = !controlDown;
			if (rightTimer > 0)
			{
				rightTimer--;
			}
			else if (controlRight)
			{
				rightTimer = 7;
			}
			if (leftTimer > 0)
			{
				leftTimer--;
			}
			else if (controlLeft)
			{
				leftTimer = 7;
			}
			GrappleMovement();
			StickyMovement();
			CheckDrowning();
			if (gravDir == -1f)
			{
				waterWalk = false;
				waterWalk2 = false;
			}
			int num84 = height;
			if (waterWalk)
			{
				num84 -= 6;
			}
			bool flag25 = false;
			if (!shimmering)
			{
				flag25 = Collision.LavaCollision(position, width, num84);
			}
			if (flag25)
			{
				if (!lavaImmune && Main.myPlayer == i && hurtCooldowns[4] <= 0)
				{
					if (lavaTime > 0)
					{
						lavaTime--;
					}
					else
					{
						int num85 = 80;
						int num86 = 420;
						if (Main.remixWorld)
						{
							num85 = 200;
							num86 = 630;
						}
						if (!ashWoodBonus || !lavaRose)
						{
							if (ashWoodBonus)
							{
								if (Main.remixWorld)
								{
									num85 = 145;
								}
								num85 /= 2;
								num86 -= 210;
							}
							if (lavaRose)
							{
								num85 -= 45;
								num86 -= 210;
							}
							if (num85 > 0)
							{
								Hurt(PlayerDeathReason.ByOther(2), num85, 0, pvp: false, quiet: false, Crit: false, 4);
							}
							if (num86 > 0)
							{
								AddBuff(24, num86);
							}
						}
					}
				}
				lavaWet = true;
			}
			else
			{
				lavaWet = false;
				if (lavaTime < lavaMax)
				{
					lavaTime++;
				}
			}
			if (lavaTime > lavaMax)
			{
				lavaTime = lavaMax;
			}
			if (waterWalk2 && !waterWalk)
			{
				num84 -= 6;
			}
			bool num87 = Collision.WetCollision(position, width, height);
			bool flag26 = Collision.honey;
			bool shimmer = Collision.shimmer;
			if (shimmer)
			{
				shimmerWet = true;
				if (whoAmI == Main.myPlayer && !shimmerImmune && !shimmerUnstuckHelper.ShouldUnstuck)
				{
					int x5 = (int)(base.Center.X / 16f);
					int y7 = (int)((position.Y + 1f) / 16f);
					if (Main.tile[x5, y7] != null && Main.tile[x5, y7].shimmer() && Main.tile[x5, y7].liquid >= 0 && position.Y / 16f < (float)Main.UnderworldLayer)
					{
						AddBuff(353, 60);
					}
				}
			}
			if (flag26 && !shimmering)
			{
				AddBuff(48, 1800);
				honeyWet = true;
			}
			if (num87)
			{
				if ((onFire || onFire3) && !lavaWet)
				{
					for (int num88 = 0; num88 < maxBuffs; num88++)
					{
						int num89 = buffType[num88];
						if (num89 == 24 || num89 == 323)
						{
							DelBuff(num88);
						}
					}
				}
				if (!wet)
				{
					if (wetCount == 0)
					{
						wetCount = 10;
						if (!shimmering)
						{
							if (!flag25)
							{
								if (shimmerWet)
								{
									for (int num90 = 0; num90 < 50; num90++)
									{
										int num91 = Dust.NewDust(new Vector2(position.X - 6f, position.Y + (float)(height / 2)), width + 12, 24, 308);
										Main.dust[num91].velocity.Y -= 4f;
										Main.dust[num91].velocity.X *= 2.5f;
										Main.dust[num91].scale = 0.8f;
										Main.dust[num91].noGravity = true;
										switch (Main.rand.Next(6))
										{
										case 0:
											Main.dust[num91].color = new Color(255, 255, 210);
											break;
										case 1:
											Main.dust[num91].color = new Color(190, 245, 255);
											break;
										case 2:
											Main.dust[num91].color = new Color(255, 150, 255);
											break;
										default:
											Main.dust[num91].color = new Color(190, 175, 255);
											break;
										}
									}
									SoundEngine.PlaySound(19, (int)position.X, (int)position.Y, 2);
								}
								else if (honeyWet)
								{
									for (int num92 = 0; num92 < 20; num92++)
									{
										int num93 = Dust.NewDust(new Vector2(position.X - 6f, position.Y + (float)(height / 2) - 8f), width + 12, 24, 152);
										Main.dust[num93].velocity.Y -= 1f;
										Main.dust[num93].velocity.X *= 2.5f;
										Main.dust[num93].scale = 1.3f;
										Main.dust[num93].alpha = 100;
										Main.dust[num93].noGravity = true;
									}
									SoundEngine.PlaySound(19, (int)position.X, (int)position.Y);
								}
								else
								{
									for (int num94 = 0; num94 < 50; num94++)
									{
										int num95 = Dust.NewDust(new Vector2(position.X - 6f, position.Y + (float)(height / 2) - 8f), width + 12, 24, Dust.dustWater());
										Main.dust[num95].velocity.Y -= 3f;
										Main.dust[num95].velocity.X *= 2.5f;
										Main.dust[num95].scale = 0.8f;
										Main.dust[num95].alpha = 100;
										Main.dust[num95].noGravity = true;
									}
									SoundEngine.PlaySound(19, (int)position.X, (int)position.Y, 0);
								}
							}
							else
							{
								for (int num96 = 0; num96 < 20; num96++)
								{
									int num97 = Dust.NewDust(new Vector2(position.X - 6f, position.Y + (float)(height / 2) - 8f), width + 12, 24, 35);
									Main.dust[num97].velocity.Y -= 1.5f;
									Main.dust[num97].velocity.X *= 2.5f;
									Main.dust[num97].scale = 1.3f;
									Main.dust[num97].alpha = 100;
									Main.dust[num97].noGravity = true;
								}
								SoundEngine.PlaySound(19, (int)position.X, (int)position.Y);
							}
						}
					}
					wet = true;
					if (ShouldFloatInWater)
					{
						velocity.Y /= 2f;
						if (velocity.Y > 3f)
						{
							velocity.Y = 3f;
						}
					}
				}
			}
			else if (wet)
			{
				wet = false;
				if (jump > jumpHeight / 5 && wetSlime == 0)
				{
					jump = jumpHeight / 5;
				}
				if (wetCount == 0)
				{
					wetCount = 10;
					if (!shimmering)
					{
						if (!lavaWet)
						{
							if (shimmerWet)
							{
								for (int num98 = 0; num98 < 50; num98++)
								{
									int num99 = Dust.NewDust(new Vector2(position.X - 6f, position.Y + (float)(height / 2)), width + 12, 24, 308);
									Main.dust[num99].velocity.Y -= 4f;
									Main.dust[num99].velocity.X *= 2.5f;
									Main.dust[num99].scale = 0.75f;
									Main.dust[num99].noGravity = true;
									switch (Main.rand.Next(6))
									{
									case 0:
										Main.dust[num99].color = new Color(255, 255, 210);
										break;
									case 1:
										Main.dust[num99].color = new Color(190, 245, 255);
										break;
									case 2:
										Main.dust[num99].color = new Color(255, 150, 255);
										break;
									default:
										Main.dust[num99].color = new Color(190, 175, 255);
										break;
									}
								}
								SoundEngine.PlaySound(19, (int)position.X, (int)position.Y, 3);
							}
							else if (honeyWet)
							{
								for (int num100 = 0; num100 < 20; num100++)
								{
									int num101 = Dust.NewDust(new Vector2(position.X - 6f, position.Y + (float)(height / 2) - 8f), width + 12, 24, 152);
									Main.dust[num101].velocity.Y -= 1f;
									Main.dust[num101].velocity.X *= 2.5f;
									Main.dust[num101].scale = 1.3f;
									Main.dust[num101].alpha = 100;
									Main.dust[num101].noGravity = true;
								}
								SoundEngine.PlaySound(19, (int)position.X, (int)position.Y);
							}
							else
							{
								for (int num102 = 0; num102 < 50; num102++)
								{
									int num103 = Dust.NewDust(new Vector2(position.X - 6f, position.Y + (float)(height / 2)), width + 12, 24, Dust.dustWater());
									Main.dust[num103].velocity.Y -= 4f;
									Main.dust[num103].velocity.X *= 2.5f;
									Main.dust[num103].scale = 0.8f;
									Main.dust[num103].alpha = 100;
									Main.dust[num103].noGravity = true;
								}
								SoundEngine.PlaySound(19, (int)position.X, (int)position.Y, 0);
							}
						}
						else
						{
							for (int num104 = 0; num104 < 20; num104++)
							{
								int num105 = Dust.NewDust(new Vector2(position.X - 6f, position.Y + (float)(height / 2) - 8f), width + 12, 24, 35);
								Main.dust[num105].velocity.Y -= 1.5f;
								Main.dust[num105].velocity.X *= 2.5f;
								Main.dust[num105].scale = 1.3f;
								Main.dust[num105].alpha = 100;
								Main.dust[num105].noGravity = true;
							}
							SoundEngine.PlaySound(19, (int)position.X, (int)position.Y);
						}
					}
				}
			}
			if (!flag26)
			{
				honeyWet = false;
			}
			if (!shimmer)
			{
				shimmerWet = false;
			}
			if (!wet)
			{
				lavaWet = false;
				honeyWet = false;
				shimmerWet = false;
			}
			if (wetCount > 0)
			{
				wetCount--;
			}
			if (wetSlime > 0)
			{
				wetSlime--;
			}
			if (wet && mount.Active)
			{
				switch (mount.Type)
				{
				case 5:
				case 7:
					if (whoAmI == Main.myPlayer)
					{
						mount.Dismount(this);
					}
					break;
				case 3:
				case 50:
					wetSlime = 30;
					if (velocity.Y > 2f)
					{
						velocity.Y *= 0.9f;
					}
					velocity.Y -= 0.5f;
					if (velocity.Y < -4f)
					{
						velocity.Y = -4f;
					}
					break;
				}
			}
			if (Main.expertMode && ZoneSnow && wet && !lavaWet && !honeyWet && !arcticDivingGear && environmentBuffImmunityTimer == 0)
			{
				AddBuff(46, 150);
			}
			float num106 = 1f + Math.Abs(velocity.X) / 3f;
			if (gfxOffY > 0f)
			{
				gfxOffY -= num106 * stepSpeed;
				if (gfxOffY < 0f)
				{
					gfxOffY = 0f;
				}
			}
			else if (gfxOffY < 0f)
			{
				gfxOffY += num106 * stepSpeed;
				if (gfxOffY > 0f)
				{
					gfxOffY = 0f;
				}
			}
			if (gfxOffY > 32f)
			{
				gfxOffY = 32f;
			}
			if (gfxOffY < -32f)
			{
				gfxOffY = -32f;
			}
			if (Main.myPlayer == i)
			{
				if (!iceSkate)
				{
					CheckIceBreak();
				}
				CheckCrackedBrickBreak();
			}
			if (!shimmering)
			{
				SlopeDownMovement();
				bool flag27 = mount.Type == 7 || mount.Type == 8 || mount.Type == 12 || mount.Type == 44 || mount.Type == 49;
				if (velocity.Y == gravity && (!mount.Active || (!mount.Cart && mount.Type != 48 && !flag27)))
				{
					Collision.StepDown(ref position, ref velocity, width, height, ref stepSpeed, ref gfxOffY, (int)gravDir, waterWalk || waterWalk2);
				}
				if (gravDir == -1f)
				{
					if ((carpetFrame != -1 || velocity.Y <= gravity) && !controlUp)
					{
						Collision.StepUp(ref position, ref velocity, width, height, ref stepSpeed, ref gfxOffY, (int)gravDir, controlUp);
					}
				}
				else if ((carpetFrame != -1 || velocity.Y >= gravity) && !controlDown && !mount.Cart && !flag27 && grappling[0] == -1)
				{
					Collision.StepUp(ref position, ref velocity, width, height, ref stepSpeed, ref gfxOffY, (int)gravDir, controlUp);
				}
			}
			oldPosition = position;
			oldDirection = direction;
			bool falling = false;
			if (velocity.Y > gravity)
			{
				falling = true;
			}
			if (velocity.Y < 0f - gravity)
			{
				falling = true;
			}
			Vector2 val8 = velocity;
			slideDir = 0;
			bool ignorePlats = false;
			bool fallThrough = controlDown;
			if ((gravDir == -1f) | (mount.Active && (mount.Cart || mount.Type == 12 || mount.Type == 7 || mount.Type == 8 || mount.Type == 23 || mount.Type == 44 || mount.Type == 48)) | GoingDownWithGrapple | pulley)
			{
				ignorePlats = true;
				fallThrough = true;
			}
			bool flag28 = onTrack;
			onTrack = false;
			bool flag29 = false;
			if (mount.Active && mount.Cart)
			{
				fartKartCloudDelay = Math.Max(0, fartKartCloudDelay - 1);
				float num107 = ((ignoreWater || merman) ? 1f : (shimmerWet ? 0.25f : (honeyWet ? 0.25f : ((!wet) ? 1f : 0.5f))));
				velocity *= num107;
				DelegateMethods.Minecart.rotation = fullRotation;
				DelegateMethods.Minecart.rotationOrigin = fullRotationOrigin;
				BitsByte bitsByte = Minecart.TrackCollision(this, ref position, ref velocity, ref lastBoost, width, height, controlDown, controlUp, fallStart2, trackOnly: false, mount.Delegations);
				if (bitsByte[0])
				{
					onTrack = true;
					gfxOffY = Minecart.TrackRotation(this, ref fullRotation, position + velocity, width, height, controlDown, controlUp, mount.Delegations);
					fullRotationOrigin = new Vector2((float)(width / 2), (float)height);
				}
				if (flag28 && !onTrack)
				{
					mount.Delegations.MinecartJumpingSound(this, position, width, height);
				}
				if (bitsByte[1])
				{
					if (controlLeft || controlRight)
					{
						if (cartFlip)
						{
							cartFlip = false;
						}
						else
						{
							cartFlip = true;
						}
					}
					if (velocity.X > 0f)
					{
						direction = 1;
					}
					else if (velocity.X < 0f)
					{
						direction = -1;
					}
					mount.Delegations.MinecartBumperSound(this, position, width, height);
				}
				velocity /= num107;
				if (bitsByte[3] && whoAmI == Main.myPlayer)
				{
					flag29 = true;
				}
				if (bitsByte[2])
				{
					cartRampTime = (int)(Math.Abs(velocity.X) / mount.RunSpeed * 20f);
				}
				if (bitsByte[4])
				{
					trackBoost -= 4f;
				}
				if (bitsByte[5])
				{
					trackBoost += 4f;
				}
			}
			bool flag30 = whoAmI == Main.myPlayer && !mount.Active;
			Vector2 val9 = position;
			if (vortexDebuff)
			{
				velocity.Y = velocity.Y * 0.8f + (float)Math.Cos(base.Center.X % 120f / 120f * ((float)Math.PI * 2f)) * 5f * 0.2f;
			}
			PlayerLoader.PreUpdateMovement(this);
			if (tongued)
			{
				position += velocity;
				flag30 = false;
			}
			else if (shimmerWet || shimmering)
			{
				ShimmerCollision(fallThrough, ignorePlats, shimmering);
			}
			else if (honeyWet && !ignoreWater)
			{
				HoneyCollision(fallThrough, ignorePlats);
			}
			else if (wet && !merman && !ignoreWater && !trident)
			{
				WaterCollision(fallThrough, ignorePlats);
			}
			else
			{
				DryCollision(fallThrough, ignorePlats);
				if (mount.Active && mount.IsConsideredASlimeMount && velocity.Y != 0f && !SlimeDontHyperJump)
				{
					Vector2 val10 = velocity;
					velocity.X = 0f;
					DryCollision(fallThrough, ignorePlats);
					velocity.X = val10.X;
				}
				if (mount.Active && mount.Type == 43 && velocity.Y != 0f)
				{
					Vector2 val11 = velocity;
					velocity.X = 0f;
					DryCollision(fallThrough, ignorePlats);
					velocity.X = val11.X;
				}
			}
			UpdateTouchingTiles();
			TryBouncingBlocks(falling);
			TryLandingOnDetonator();
			if (!shimmering && !tongued)
			{
				SlopingCollision(fallThrough, ignorePlats);
				if (!isLockedToATile)
				{
					Collision.StepConveyorBelt(this, gravDir);
				}
			}
			if (flag30 && velocity.Y == 0f)
			{
				AchievementsHelper.HandleRunning(Math.Abs(position.X - val9.X));
			}
			if (flag29)
			{
				NetMessage.SendData(13, -1, -1, null, whoAmI);
				Minecart.HitTrackSwitch(new Vector2(position.X, position.Y), width, height);
			}
			if (val8.X != velocity.X)
			{
				if (val8.X < 0f)
				{
					slideDir = -1;
				}
				else if (val8.X > 0f)
				{
					slideDir = 1;
				}
			}
			if (gravDir == 1f && Collision.up)
			{
				velocity.Y = 0.01f;
				if (!merman)
				{
					jump = 0;
				}
			}
			else if (gravDir == -1f && Collision.down)
			{
				velocity.Y = -0.01f;
				if (!merman)
				{
					jump = 0;
				}
			}
			if (velocity.Y == 0f && grappling[0] == -1)
			{
				FloorVisuals(falling);
			}
			if (whoAmI == Main.myPlayer && !shimmering)
			{
				Collision.SwitchTiles(this, position, width, height, oldPosition, 1);
			}
			PressurePlateHelper.UpdatePlayerPosition(this);
			BordersMovement();
			numMinions = 0;
			slotsMinions = 0f;
			if (Main.netMode != 2 && mount.Type != 8)
			{
				ItemCheck_ManageRightClickFeatures();
			}
			ItemCheckWrapped(i);
			PlayerFrame();
			if (mount.Type == 8)
			{
				mount.UseDrill(this);
			}
			if (statLife > statLifeMax2)
			{
				statLife = statLifeMax2;
			}
			if (statMana > statManaMax2)
			{
				statMana = statManaMax2;
			}
			if (breath > breathMax)
			{
				breath = breathMax;
			}
			grappling[0] = -1;
			grapCount = 0;
			UpdateReleaseUseTile();
			UpdateAdvancedShadows();
			PlayerLoader.PostUpdate(this);
		}
	}

	private void TryToToggleSmartCursor(ref bool smartCursorWanted)
	{
		if (Main.cSmartCursorModeIsToggleAndNotHold)
		{
			if (controlSmart && releaseSmart)
			{
				SoundEngine.PlaySound(12);
				smartCursorWanted = !smartCursorWanted;
			}
			return;
		}
		if (controlSmart && releaseSmart)
		{
			SoundEngine.PlaySound(12);
		}
		if (SmartCursorSettings.SmartCursorHoldCanReleaseMidUse)
		{
			smartCursorWanted = controlSmart;
		}
		else if (smartCursorWanted)
		{
			if (!controlSmart && !controlUseItem)
			{
				smartCursorWanted = false;
			}
		}
		else
		{
			smartCursorWanted = controlSmart;
		}
	}

	private void TryToShimmerUnstuck()
	{
		timeShimmering = Utils.Clamp(timeShimmering + (shimmering ? 1 : (-10)), 0, 7200);
		bool flag = timeShimmering >= 3600;
		if ((LocalInputCache.controlLeft || LocalInputCache.controlRight || LocalInputCache.controlUp || LocalInputCache.controlDown) && timeShimmering >= 1200)
		{
			flag = true;
		}
		if (flag)
		{
			ShimmerUnstuck();
		}
	}

	private void ShimmerUnstuck()
	{
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		timeShimmering = 0;
		Vector2? val = TryFindingShimmerFreeSpot();
		if (val.HasValue)
		{
			velocity = new Vector2(0f, 0.0001f);
			Teleport(val.Value + new Vector2(0f, -2f), 12);
			shimmering = false;
			shimmerWet = false;
			wet = false;
			ClearBuff(353);
			ParticleOrchestrator.BroadcastOrRequestParticleSpawn(ParticleOrchestraType.ShimmerTownNPC, new ParticleOrchestraSettings
			{
				PositionInWorld = base.Bottom
			});
		}
		else
		{
			if (Collision.WetCollision(position, width, height) && Collision.shimmer)
			{
				shimmerUnstuckHelper.StartUnstuck();
			}
			ClearBuff(353);
			ParticleOrchestrator.BroadcastOrRequestParticleSpawn(ParticleOrchestraType.ShimmerTownNPC, new ParticleOrchestraSettings
			{
				PositionInWorld = base.Bottom
			});
		}
	}

	private Vector2? TryFindingShimmerFreeSpot()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		Point val = base.Top.ToTileCoordinates();
		int num = 60;
		Vector2? result = null;
		bool allowSolidTop = true;
		for (int i = 1; i < num; i += 2)
		{
			Vector2? val2 = ShimmerHelper.FindSpotWithoutShimmer(this, val.X, val.Y, i, allowSolidTop);
			if (val2.HasValue)
			{
				result = val2.Value;
				break;
			}
		}
		FindSpawn();
		if (!CheckSpawn(SpawnX, SpawnY))
		{
			SpawnX = -1;
			SpawnY = -1;
		}
		if (!result.HasValue && SpawnX != -1 && SpawnY != -1)
		{
			for (int j = 1; j < num; j += 2)
			{
				Vector2? val3 = ShimmerHelper.FindSpotWithoutShimmer(this, SpawnX, SpawnY, j, allowSolidTop);
				if (val3.HasValue)
				{
					result = val3.Value;
					break;
				}
			}
		}
		if (!result.HasValue)
		{
			for (int k = 1; k < num; k += 2)
			{
				Vector2? val4 = ShimmerHelper.FindSpotWithoutShimmer(this, Main.spawnTileX, Main.spawnTileY, k, allowSolidTop);
				if (val4.HasValue)
				{
					result = val4.Value;
					break;
				}
			}
		}
		return result;
	}

	private void AdjustRemainingPotionSickness(StatModifier oldPotionDelayModifier)
	{
		if (whoAmI != Main.myPlayer)
		{
			return;
		}
		int num = FindBuffIndex(21);
		if (num != -1)
		{
			float num2 = PotionDelayModifier.ApplyTo(oldPotionDelayModifier.Undo(buffTime[num]));
			if (num2 < 1f)
			{
				num2 = 1f;
			}
			buffTime[num] = (int)num2;
		}
	}

	private Collision.HurtTile GetHurtTile()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		Collision.HurtTile result = Collision.HurtTiles(position, width, (!mount.Active || !mount.Cart) ? height : (height - 16), this);
		if (result.type >= 0)
		{
			return result;
		}
		foreach (Point touchedTile in TouchedTiles)
		{
			Tile tile = Main.tile[touchedTile.X, touchedTile.Y];
			if (tile != null && tile.active() && tile.nactive() && !TileID.Sets.Suffocate[tile.type] && Collision.CanTileHurt(tile.type, touchedTile.X, touchedTile.Y, this))
			{
				return new Collision.HurtTile
				{
					type = tile.type,
					x = touchedTile.X,
					y = touchedTile.Y
				};
			}
		}
		return result;
	}

	private void ApplyTouchDamage(int tileId, int x, int y)
	{
		if (TileID.Sets.TouchDamageHot[tileId])
		{
			AddBuff(67, 20);
		}
		if (TileID.Sets.Suffocate[tileId])
		{
			if (suffocateDelay < 5)
			{
				suffocateDelay++;
			}
			else
			{
				AddBuff(68, 1);
			}
		}
		else
		{
			suffocateDelay = 0;
		}
		if (TileID.Sets.TouchDamageBleeding[tileId])
		{
			AddBuff(30, Main.rand.Next(240, 600));
		}
		int num = TileID.Sets.TouchDamageImmediate[tileId];
		if (num > 0)
		{
			num = Main.DamageVar(num, 0f - luck);
			Hurt(PlayerDeathReason.ByOther(3), num, 0, pvp: false, quiet: false, Crit: false, 0);
		}
		if (TileID.Sets.TouchDamageDestroyTile[tileId])
		{
			WorldGen.KillTile(x, y);
			if (Main.netMode == 1 && !Main.tile[x, y].active())
			{
				NetMessage.SendData(17, -1, -1, null, 4, x, y);
			}
		}
	}

	private void CapAttackSpeeds()
	{
	}

	private float TurnAttackSpeedToUseTimeMultiplier(float speed)
	{
		if (speed > 3f)
		{
			speed = 3f;
		}
		if (speed != 0f)
		{
			speed = 1f / speed;
		}
		return speed;
	}

	public void UpdateLuck()
	{
		UpdateLuckFactors();
		RecalculateLuck();
		if (luckNeedsSync && whoAmI == Main.myPlayer)
		{
			luckNeedsSync = false;
			NetMessage.SendData(134, -1, -1, null, whoAmI);
		}
	}

	private void ResetControls()
	{
		controlUp = false;
		controlLeft = false;
		controlDown = false;
		controlRight = false;
		controlJump = false;
		controlUseItem = false;
		controlUseTile = false;
		controlThrow = false;
		controlInv = false;
		controlHook = false;
		controlTorch = false;
		controlSmart = false;
		controlMount = false;
		controlQuickHeal = false;
		controlQuickMana = false;
		controlCreativeMenu = false;
		mapStyle = false;
		mapAlphaDown = false;
		mapAlphaUp = false;
		mapFullScreen = false;
		mapZoomIn = false;
		mapZoomOut = false;
	}

	private void UpdateControlHolds()
	{
		if (whoAmI == Main.myPlayer)
		{
			if (controlUp && releaseUp)
			{
				FlexibleWandCycleOffset--;
			}
			if (controlDown && releaseDown)
			{
				FlexibleWandCycleOffset++;
			}
		}
		if (controlUp)
		{
			releaseUp = false;
		}
		else
		{
			releaseUp = true;
		}
	}

	public void TryOpeningFullscreenMap()
	{
		if (Main.mapEnabled)
		{
			Main.playerInventory = false;
			sign = -1;
			Main.editSign = false;
			SetTalkNPC(-1);
			Main.npcChatCornerItem = 0;
			SoundEngine.PlaySound(10);
			Main.mapFullscreenScale = 2.5f;
			Main.mapFullscreen = true;
			Main.resetMapFull = true;
			Main.buffString = string.Empty;
			releaseInventory = false;
		}
	}

	public void UpdateLuckFactors()
	{
		UpdateLadyBugLuckTime();
		UpdateCoinLuck();
		if (whoAmI == Main.myPlayer)
		{
			float num = torchLuck;
			TryRecalculatingTorchLuck();
			if (torchLuck != num)
			{
				luckNeedsSync = true;
			}
		}
	}

	public void RecalculateLuck()
	{
		if (PlayerLoader.PreModifyLuck(this, ref luck))
		{
			luck = GetLadyBugLuck() * 0.2f + torchLuck * 0.2f;
			luck += (float)(int)luckPotion * 0.1f;
			if (usedGalaxyPearl)
			{
				luck += 0.03f;
			}
			if (LanternNight.LanternsUp)
			{
				luck += 0.3f;
			}
			if (HasGardenGnomeNearby)
			{
				luck += 0.2f;
			}
			luck += equipmentBasedLuckBonus;
			luck += CalculateCoinLuck();
		}
		PlayerLoader.ModifyLuck(this, ref luck);
	}

	public static int GetMouseScrollDelta()
	{
		return PlayerInput.ScrollWheelDelta / 120;
	}

	private void UpdatePortableStoolUsage()
	{
		bool flag = portableStoolInfo.HasAStool && controlUp && !gravControl && !mount.Active && velocity.X == 0f && velocity.Y == 0f && !pulley && grappling[0] == -1;
		if (flag)
		{
			flag = CanFitSpace(portableStoolInfo.HeightBoost);
		}
		if (flag)
		{
			portableStoolInfo.IsInUse = true;
			ResizeHitbox();
		}
	}

	private void ResizeHitbox()
	{
		position.Y += height;
		height = 42 + HeightOffsetBoost;
		position.Y -= height;
	}

	private void UpdateReleaseUseTile()
	{
		bool flag = !tileInteractAttempted;
		if (_lockTileInteractionsTimer > 0 && !releaseUseTile)
		{
			flag = false;
		}
		releaseUseTile = flag;
		if (_lockTileInteractionsTimer > 0)
		{
			_lockTileInteractionsTimer--;
		}
	}

	private void GetMinecartDamage(float currentSpeed, out int damage, out float knockback)
	{
		switch (mount.Type)
		{
		default:
			damage = Main.DamageVar(25f + 55f * currentSpeed, luck);
			break;
		case 11:
		case 15:
		case 16:
		case 18:
		case 19:
		case 20:
		case 21:
		case 22:
		case 24:
		case 25:
		case 26:
		case 27:
		case 28:
		case 29:
		case 30:
		case 31:
		case 32:
		case 33:
		case 34:
		case 35:
		case 36:
		case 38:
		case 39:
		case 51:
		case 53:
			damage = Main.DamageVar(25f + 55f * currentSpeed, luck);
			break;
		case 13:
			damage = Main.DamageVar(15f + 30f * currentSpeed, luck);
			break;
		}
		if (UsingSuperCart)
		{
			damage = Main.DamageVar(50f + 100f * currentSpeed, luck);
		}
		knockback = 10f + 40f * currentSpeed;
		if (Main.hardMode)
		{
			damage = (int)((double)damage * 1.5);
		}
		if (Main.expertMode)
		{
			damage = (int)((double)damage * 1.5);
		}
	}

	public void UpdateMiscCounter()
	{
		miscCounter++;
		if (miscCounter >= 300)
		{
			miscCounter = 0;
		}
	}

	private void WingAirLogicTweaks()
	{
		if (wingsLogic < 1)
		{
			return;
		}
		WingStats wingStats = GetWingStats(wingsLogic);
		bool flag = TryingToHoverDown && controlJump && wingTime > 0f;
		if (wingStats.HasDownHoverStats && flag)
		{
			if (wingStats.DownHoverSpeedOverride != -1f)
			{
				accRunSpeed = wingStats.DownHoverSpeedOverride;
			}
			runAcceleration *= wingStats.DownHoverAccelerationMult;
		}
		else
		{
			if (wingStats.AccRunSpeedOverride != -1f && wingStats.AccRunSpeedOverride > accRunSpeed)
			{
				accRunSpeed = wingStats.AccRunSpeedOverride;
			}
			runAcceleration *= wingStats.AccRunAccelerationMult;
		}
		if (wingsLogic == 45 && (float)timeSinceLastDashStarted >= 60f)
		{
			runSlowdown *= 6f;
		}
		ItemLoader.HorizontalWingSpeeds(this);
	}

	private void RocketBootVisuals()
	{
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_030e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0314: Unknown result type (might be due to invalid IL or missing references)
		//IL_033a: Unknown result type (might be due to invalid IL or missing references)
		//IL_033f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0341: Unknown result type (might be due to invalid IL or missing references)
		//IL_0346: Unknown result type (might be due to invalid IL or missing references)
		//IL_034e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0355: Unknown result type (might be due to invalid IL or missing references)
		//IL_035a: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_023e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0248: Unknown result type (might be due to invalid IL or missing references)
		//IL_024d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0255: Unknown result type (might be due to invalid IL or missing references)
		//IL_025b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0265: Unknown result type (might be due to invalid IL or missing references)
		//IL_026a: Unknown result type (might be due to invalid IL or missing references)
		//IL_026f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0277: Unknown result type (might be due to invalid IL or missing references)
		//IL_027c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0283: Unknown result type (might be due to invalid IL or missing references)
		//IL_0288: Unknown result type (might be due to invalid IL or missing references)
		//IL_028d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0295: Unknown result type (might be due to invalid IL or missing references)
		//IL_029c: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_03aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_03af: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c8: Unknown result type (might be due to invalid IL or missing references)
		int num = height;
		if (gravDir == -1f)
		{
			num = 4;
		}
		Vector2 val2 = default(Vector2);
		for (int i = 0; i < 2; i++)
		{
			int num2 = ((i == 0) ? 2 : (-2));
			Rectangle val = ((i != 0) ? new Rectangle((int)position.X + width - 4, (int)position.Y + num - 10, 8, 8) : new Rectangle((int)position.X - 4, (int)position.Y + num - 10, 8, 8));
			if (direction == -1)
			{
				val.X -= 4;
			}
			int type = 6;
			float scale = 2.5f;
			int alpha = 100;
			float num3 = 1f;
			((Vector2)(ref val2))..ctor((float)(-num2) - velocity.X * 0.3f, 2f * gravDir - velocity.Y * 0.3f);
			Dust dust;
			switch (vanityRocketBoots)
			{
			case 5:
				type = 6;
				scale = 2.5f;
				break;
			case 1:
				if (socialShadowRocketBoots)
				{
					type = 27;
					scale = 1.5f;
				}
				break;
			case 3:
				type = 76;
				scale = 1f;
				alpha = 20;
				break;
			case 2:
				if (fairyBoots)
				{
					type = Main.rand.NextFromList(new short[6] { 61, 61, 61, 242, 64, 63 });
					scale = 2f;
					alpha = 120;
				}
				else
				{
					type = 16;
					scale = 1.5f;
					alpha = 20;
				}
				break;
			case 4:
			{
				int num4 = Main.rand.Next(6);
				val.Y += 2 * (int)gravDir;
				if (num4 == 0 || num4 == 1)
				{
					dust = Dust.NewDustDirect(val.TopLeft(), val.Width, val.Height, 278, 0f, 0f, 100, Color.Lerp(Color.LimeGreen, Color.White, Main.rand.NextFloat() * 0.3f));
					dust.shader = GameShaders.Armor.GetSecondaryShader(cShoe, this);
					dust.scale = 0.66f;
					dust.noGravity = true;
					Dust dust2 = dust;
					dust2.velocity *= 0.25f;
					Dust dust3 = dust;
					dust3.velocity -= velocity * 0.5f;
					Dust dust4 = dust;
					dust4.velocity += val2 * 0.5f;
					Dust dust5 = dust;
					dust5.position += dust.velocity * 4f;
					if (Main.rand.Next(5) == 0)
					{
						dust.fadeIn = 0.8f;
					}
					continue;
				}
				type = 107;
				alpha = 100;
				scale = 0.7f;
				num3 = 0.5f;
				break;
			}
			}
			dust = Dust.NewDustDirect(val.TopLeft(), val.Width, val.Height, type, 0f, 0f, alpha, default(Color), scale);
			dust.shader = GameShaders.Armor.GetSecondaryShader(cShoe, this);
			Dust dust6 = dust;
			dust6.velocity += val2;
			Dust dust7 = dust;
			dust7.velocity *= num3;
			switch (vanityRocketBoots)
			{
			case 5:
				dust.noGravity = true;
				break;
			case 1:
				dust.noGravity = true;
				break;
			case 2:
			{
				Dust dust9 = dust;
				dust9.velocity *= 0.1f;
				break;
			}
			case 3:
			{
				Dust dust8 = dust;
				dust8.velocity *= 0.05f;
				dust.velocity.Y += 0.15f;
				dust.noLight = true;
				if (Main.rand.Next(2) == 0)
				{
					dust.noGravity = true;
					dust.scale = 1.75f;
				}
				break;
			}
			}
			if (fairyBoots)
			{
				dust.noGravity = true;
				dust.noLightEmittence = true;
			}
		}
	}

	public void WingFrame(bool wingFlap, bool isCustomWings = false)
	{
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b67: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b72: Unknown result type (might be due to invalid IL or missing references)
		//IL_0166: Unknown result type (might be due to invalid IL or missing references)
		//IL_017d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0183: Unknown result type (might be due to invalid IL or missing references)
		//IL_07c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_07d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_07de: Unknown result type (might be due to invalid IL or missing references)
		//IL_07e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_07eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0803: Unknown result type (might be due to invalid IL or missing references)
		//IL_0828: Unknown result type (might be due to invalid IL or missing references)
		//IL_082d: Unknown result type (might be due to invalid IL or missing references)
		//IL_082f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0834: Unknown result type (might be due to invalid IL or missing references)
		//IL_083e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0843: Unknown result type (might be due to invalid IL or missing references)
		//IL_084d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0852: Unknown result type (might be due to invalid IL or missing references)
		//IL_1003: Unknown result type (might be due to invalid IL or missing references)
		//IL_1008: Unknown result type (might be due to invalid IL or missing references)
		//IL_1021: Unknown result type (might be due to invalid IL or missing references)
		//IL_1026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c01: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c06: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c0b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c15: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c1a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c1f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c2e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c33: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c38: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c3a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c3c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c41: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c48: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c5c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c66: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c82: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c88: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c8d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c92: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c99: Unknown result type (might be due to invalid IL or missing references)
		//IL_0ca3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0ca8: Unknown result type (might be due to invalid IL or missing references)
		//IL_08d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_08e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_08eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0903: Unknown result type (might be due to invalid IL or missing references)
		//IL_0908: Unknown result type (might be due to invalid IL or missing references)
		//IL_090d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0915: Unknown result type (might be due to invalid IL or missing references)
		//IL_092d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0952: Unknown result type (might be due to invalid IL or missing references)
		//IL_0957: Unknown result type (might be due to invalid IL or missing references)
		//IL_0959: Unknown result type (might be due to invalid IL or missing references)
		//IL_095e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0967: Unknown result type (might be due to invalid IL or missing references)
		//IL_096d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0972: Unknown result type (might be due to invalid IL or missing references)
		//IL_098a: Unknown result type (might be due to invalid IL or missing references)
		//IL_098f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0994: Unknown result type (might be due to invalid IL or missing references)
		//IL_099e: Unknown result type (might be due to invalid IL or missing references)
		//IL_09a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_09ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_09b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_09bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_09c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_09c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_13b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_13bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_13c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0ef5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0f04: Unknown result type (might be due to invalid IL or missing references)
		//IL_0f09: Unknown result type (might be due to invalid IL or missing references)
		//IL_0ed9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0ee8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0eed: Unknown result type (might be due to invalid IL or missing references)
		//IL_0f18: Unknown result type (might be due to invalid IL or missing references)
		//IL_0f1d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0f22: Unknown result type (might be due to invalid IL or missing references)
		//IL_13e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_13e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_13f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_13fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_1403: Unknown result type (might be due to invalid IL or missing references)
		//IL_105e: Unknown result type (might be due to invalid IL or missing references)
		//IL_108c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0f2c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0f2e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0f33: Unknown result type (might be due to invalid IL or missing references)
		//IL_0f3a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0f4e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0f6a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0f74: Unknown result type (might be due to invalid IL or missing references)
		//IL_0f79: Unknown result type (might be due to invalid IL or missing references)
		//IL_1423: Unknown result type (might be due to invalid IL or missing references)
		//IL_1428: Unknown result type (might be due to invalid IL or missing references)
		//IL_142a: Unknown result type (might be due to invalid IL or missing references)
		//IL_1439: Unknown result type (might be due to invalid IL or missing references)
		//IL_1450: Unknown result type (might be due to invalid IL or missing references)
		//IL_1456: Unknown result type (might be due to invalid IL or missing references)
		//IL_1458: Unknown result type (might be due to invalid IL or missing references)
		//IL_145d: Unknown result type (might be due to invalid IL or missing references)
		//IL_1462: Unknown result type (might be due to invalid IL or missing references)
		//IL_1465: Unknown result type (might be due to invalid IL or missing references)
		//IL_146a: Unknown result type (might be due to invalid IL or missing references)
		//IL_146c: Unknown result type (might be due to invalid IL or missing references)
		//IL_1471: Unknown result type (might be due to invalid IL or missing references)
		//IL_1473: Unknown result type (might be due to invalid IL or missing references)
		//IL_147a: Unknown result type (might be due to invalid IL or missing references)
		//IL_1483: Unknown result type (might be due to invalid IL or missing references)
		//IL_14d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_14d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_14d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_14e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_14ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_1505: Unknown result type (might be due to invalid IL or missing references)
		//IL_1507: Unknown result type (might be due to invalid IL or missing references)
		//IL_150c: Unknown result type (might be due to invalid IL or missing references)
		//IL_1511: Unknown result type (might be due to invalid IL or missing references)
		//IL_1514: Unknown result type (might be due to invalid IL or missing references)
		//IL_1519: Unknown result type (might be due to invalid IL or missing references)
		//IL_151b: Unknown result type (might be due to invalid IL or missing references)
		//IL_1520: Unknown result type (might be due to invalid IL or missing references)
		//IL_1522: Unknown result type (might be due to invalid IL or missing references)
		//IL_1529: Unknown result type (might be due to invalid IL or missing references)
		//IL_1532: Unknown result type (might be due to invalid IL or missing references)
		//IL_1581: Unknown result type (might be due to invalid IL or missing references)
		//IL_1586: Unknown result type (might be due to invalid IL or missing references)
		//IL_1588: Unknown result type (might be due to invalid IL or missing references)
		//IL_1597: Unknown result type (might be due to invalid IL or missing references)
		//IL_15ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_15b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_15b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_15bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_15c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_15c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_15c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_15ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_15cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_15d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_15d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_15e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_1408: Unknown result type (might be due to invalid IL or missing references)
		//IL_1412: Unknown result type (might be due to invalid IL or missing references)
		//IL_1417: Unknown result type (might be due to invalid IL or missing references)
		//IL_1114: Unknown result type (might be due to invalid IL or missing references)
		//IL_1119: Unknown result type (might be due to invalid IL or missing references)
		//IL_11be: Unknown result type (might be due to invalid IL or missing references)
		//IL_11c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_1760: Unknown result type (might be due to invalid IL or missing references)
		//IL_1778: Unknown result type (might be due to invalid IL or missing references)
		//IL_177e: Unknown result type (might be due to invalid IL or missing references)
		//IL_17b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_17bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_17c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_1288: Unknown result type (might be due to invalid IL or missing references)
		//IL_128d: Unknown result type (might be due to invalid IL or missing references)
		bool flag = wingsLogic != wings;
		if (wings == 4)
		{
			if (wingFlap || jump > 0)
			{
				rocketDelay2--;
				if (rocketDelay2 <= 0)
				{
					SoundEngine.PlaySound(in SoundID.Item13, position);
					rocketDelay2 = 60;
				}
				int num = 2;
				if (TryingToHoverUp)
				{
					num = 4;
				}
				for (int i = 0; i < num; i++)
				{
					int type = 6;
					if (head == 41)
					{
						_ = body;
					}
					float scale = 1.75f;
					int alpha = 100;
					float num2 = position.X + (float)(width / 2) + 16f;
					if (direction > 0)
					{
						num2 = position.X + (float)(width / 2) - 26f;
					}
					float num3 = position.Y + (float)height - 18f;
					if (i == 1 || i == 3)
					{
						num2 = position.X + (float)(width / 2) + 8f;
						if (direction > 0)
						{
							num2 = position.X + (float)(width / 2) - 20f;
						}
						num3 += 6f;
					}
					if (i > 1)
					{
						num3 += velocity.Y;
					}
					int num4 = Dust.NewDust(new Vector2(num2, num3), 8, 8, type, 0f, 0f, alpha, default(Color), scale);
					Main.dust[num4].velocity.X *= 0.1f;
					Main.dust[num4].velocity.Y = Main.dust[num4].velocity.Y * 1f + 2f * gravDir - velocity.Y * 0.3f;
					Main.dust[num4].noGravity = true;
					Main.dust[num4].noLightEmittence = flag;
					Main.dust[num4].shader = GameShaders.Armor.GetSecondaryShader(cWings, this);
					if (num == 4)
					{
						Main.dust[num4].velocity.Y += 6f;
					}
				}
				wingFrameCounter++;
				if (wingFrameCounter > 4)
				{
					wingFrame++;
					wingFrameCounter = 0;
					if (wingFrame >= 3)
					{
						wingFrame = 0;
					}
				}
			}
			else if (!controlJump || velocity.Y == 0f)
			{
				wingFrame = 3;
			}
			return;
		}
		if (wings == 28 && ShouldDrawWingsThatAreAlwaysAnimated())
		{
			if (!flag && velocity.Y != 0f)
			{
				Lighting.AddLight(base.Bottom, 0.3f, 0.1f, 0.4f);
			}
			return;
		}
		if (wings == 22)
		{
			if (!controlJump)
			{
				wingFrame = 0;
				wingFrameCounter = 0;
			}
			else if (wingTime > 0f)
			{
				if (TryingToHoverDown)
				{
					if (velocity.X != 0f)
					{
						wingFrameCounter++;
						int num5 = 2;
						if (wingFrameCounter < num5)
						{
							wingFrame = 1;
							return;
						}
						if (wingFrameCounter < num5 * 2)
						{
							wingFrame = 2;
							return;
						}
						if (wingFrameCounter < num5 * 3)
						{
							wingFrame = 3;
							return;
						}
						if (wingFrameCounter < num5 * 4 - 1)
						{
							wingFrame = 2;
							return;
						}
						wingFrame = 2;
						wingFrameCounter = 0;
					}
					else
					{
						wingFrameCounter++;
						int num6 = 6;
						if (wingFrameCounter < num6)
						{
							wingFrame = 4;
							return;
						}
						if (wingFrameCounter < num6 * 2)
						{
							wingFrame = 5;
							return;
						}
						if (wingFrameCounter < num6 * 3 - 1)
						{
							wingFrame = 4;
							return;
						}
						wingFrame = 4;
						wingFrameCounter = 0;
					}
				}
				else
				{
					wingFrameCounter++;
					int num7 = 2;
					if (wingFrameCounter < num7)
					{
						wingFrame = 4;
						return;
					}
					if (wingFrameCounter < num7 * 2)
					{
						wingFrame = 5;
						return;
					}
					if (wingFrameCounter < num7 * 3)
					{
						wingFrame = 6;
						return;
					}
					if (wingFrameCounter < num7 * 4 - 1)
					{
						wingFrame = 5;
						return;
					}
					wingFrame = 5;
					wingFrameCounter = 0;
				}
			}
			else
			{
				wingFrameCounter++;
				int num8 = 6;
				if (wingFrameCounter < num8)
				{
					wingFrame = 4;
					return;
				}
				if (wingFrameCounter < num8 * 2)
				{
					wingFrame = 5;
					return;
				}
				if (wingFrameCounter < num8 * 3 - 1)
				{
					wingFrame = 4;
					return;
				}
				wingFrame = 4;
				wingFrameCounter = 0;
			}
			return;
		}
		if (wings == 12)
		{
			if (wingFlap || jump > 0)
			{
				wingFrameCounter++;
				int num9 = 5;
				if (wingFrameCounter < num9)
				{
					wingFrame = 1;
					return;
				}
				if (wingFrameCounter < num9 * 2)
				{
					wingFrame = 2;
					return;
				}
				if (wingFrameCounter < num9 * 3)
				{
					wingFrame = 3;
					return;
				}
				if (wingFrameCounter < num9 * 4 - 1)
				{
					wingFrame = 2;
					return;
				}
				wingFrame = 2;
				wingFrameCounter = 0;
			}
			else if (velocity.Y != 0f)
			{
				wingFrame = 2;
			}
			else
			{
				wingFrame = 0;
			}
			return;
		}
		if (wings == 24)
		{
			if (wingFlap || jump > 0)
			{
				wingFrameCounter++;
				int num10 = 1;
				if (wingFrameCounter < num10)
				{
					wingFrame = 1;
					return;
				}
				if (wingFrameCounter < num10 * 2)
				{
					wingFrame = 2;
					return;
				}
				if (wingFrameCounter < num10 * 3)
				{
					wingFrame = 3;
					return;
				}
				wingFrame = 2;
				if (wingFrameCounter >= num10 * 4 - 1)
				{
					wingFrameCounter = 0;
				}
			}
			else if (velocity.Y != 0f)
			{
				if (controlJump)
				{
					wingFrameCounter++;
					int num11 = 3;
					if (wingFrameCounter < num11)
					{
						wingFrame = 1;
						return;
					}
					if (wingFrameCounter < num11 * 2)
					{
						wingFrame = 2;
						return;
					}
					if (wingFrameCounter < num11 * 3)
					{
						wingFrame = 3;
						return;
					}
					wingFrame = 2;
					if (wingFrameCounter >= num11 * 4 - 1)
					{
						wingFrameCounter = 0;
					}
				}
				else if (wingTime == 0f)
				{
					wingFrame = 0;
				}
				else
				{
					wingFrame = 1;
				}
			}
			else
			{
				wingFrame = 0;
			}
			return;
		}
		if (wings == 30)
		{
			bool flag2 = false;
			if (wingFlap || jump > 0)
			{
				wingFrameCounter++;
				int num12 = 2;
				if (wingFrameCounter >= num12 * 3)
				{
					wingFrameCounter = 0;
				}
				wingFrame = 1 + wingFrameCounter / num12;
				flag2 = true;
			}
			else if (velocity.Y != 0f)
			{
				if (controlJump)
				{
					wingFrameCounter++;
					int num13 = 2;
					if (wingFrameCounter >= num13 * 3)
					{
						wingFrameCounter = 0;
					}
					wingFrame = 1 + wingFrameCounter / num13;
					flag2 = true;
				}
				else if (wingTime == 0f)
				{
					wingFrame = 0;
				}
				else
				{
					wingFrame = 0;
				}
			}
			else
			{
				wingFrame = 0;
			}
			if (!flag2)
			{
				return;
			}
			for (int j = 0; j < 4; j++)
			{
				if (Main.rand.Next(4) == 0)
				{
					Vector2 val = (-0.74539816f + (float)Math.PI / 8f * (float)j + 0.03f * (float)j).ToRotationVector2() * new Vector2((float)(-direction * 20), 20f);
					Dust dust = Main.dust[Dust.NewDust(base.Center, 0, 0, 229, 0f, 0f, 100, Color.White, 0.8f)];
					dust.noGravity = true;
					dust.noLightEmittence = flag;
					dust.position = base.Center + val;
					dust.velocity = DirectionTo(dust.position) * 2f;
					if (Main.rand.Next(10) != 0)
					{
						dust.customData = this;
					}
					else
					{
						dust.fadeIn = 0.5f;
					}
					dust.shader = GameShaders.Armor.GetSecondaryShader(cWings, this);
				}
			}
			for (int k = 0; k < 4; k++)
			{
				if (Main.rand.Next(8) == 0)
				{
					Vector2 val2 = (-0.7053982f + (float)Math.PI / 8f * (float)k + 0.03f * (float)k).ToRotationVector2() * new Vector2((float)(direction * 20), 24f) + new Vector2((float)(-direction) * 16f, 0f);
					Dust dust2 = Main.dust[Dust.NewDust(base.Center, 0, 0, 229, 0f, 0f, 100, Color.White, 0.5f)];
					dust2.noGravity = true;
					dust2.noLightEmittence = flag;
					dust2.position = base.Center + val2;
					dust2.velocity = Vector2.Normalize(dust2.position - base.Center - new Vector2((float)(-direction) * 16f, 0f)) * 2f;
					dust2.position += dust2.velocity * 5f;
					if (Main.rand.Next(10) != 0)
					{
						dust2.customData = this;
					}
					else
					{
						dust2.fadeIn = 0.5f;
					}
					dust2.shader = GameShaders.Armor.GetSecondaryShader(cWings, this);
				}
			}
			return;
		}
		if (wings == 34 && ShouldDrawWingsThatAreAlwaysAnimated())
		{
			if (wingFlap || jump > 0)
			{
				wingFrameCounter++;
				int num14 = 4;
				if (wingFrameCounter >= num14 * 6)
				{
					wingFrameCounter = 0;
				}
				wingFrame = wingFrameCounter / num14;
			}
			else if (velocity.Y != 0f)
			{
				if (controlJump)
				{
					wingFrameCounter++;
					int num15 = 9;
					if (wingFrameCounter >= num15 * 6)
					{
						wingFrameCounter = 0;
					}
					wingFrame = wingFrameCounter / num15;
				}
				else
				{
					wingFrameCounter++;
					int num16 = 6;
					if (wingFrameCounter >= num16 * 6)
					{
						wingFrameCounter = 0;
					}
					wingFrame = wingFrameCounter / num16;
				}
			}
			else
			{
				wingFrameCounter++;
				int num17 = 4;
				if (wingFrameCounter >= num17 * 6)
				{
					wingFrameCounter = 0;
				}
				wingFrame = wingFrameCounter / num17;
			}
			return;
		}
		if (wings == 45 && ShouldDrawWingsThatAreAlwaysAnimated())
		{
			if (wingTime > 0f)
			{
				rocketDelay2--;
				if (rocketDelay2 <= 0)
				{
					SoundEngine.PlaySound(in SoundID.Item24, position);
					rocketDelay2 = 30;
				}
			}
			if (velocity.Y == 0f)
			{
				wingFrameCounter = 0;
				wingFrame = 0;
			}
			else
			{
				wingFrameCounter++;
				int num18 = 3;
				if (wingTime == 0f)
				{
					num18 = 5;
				}
				if (wingFrameCounter >= num18 * 6)
				{
					wingFrameCounter = 0;
				}
				wingFrame = wingFrameCounter / num18;
			}
			if (Main.netMode != 2 && Main.rand.Next(8) == 0)
			{
				Rectangle val3 = Utils.CenteredRectangle(Main.ReverseGravitySupport(base.Bottom - Main.screenPosition) + Main.screenPosition, new Vector2(40f, 24f));
				Dust dust3 = Dust.NewDustDirect(val3.TopLeft(), val3.Width, val3.Height, 43, 0f, 0f, 0, Color.White * 0.5f, 0.2f);
				dust3.fadeIn = 0.4f;
				dust3.velocity += velocity;
				dust3.velocity *= 0.35f;
				dust3.shader = GameShaders.Armor.GetSecondaryShader(cWings, this);
			}
			return;
		}
		if (wings == 44 && ShouldDrawWingsThatAreAlwaysAnimated())
		{
			int num19 = 5;
			if (wingFlap || jump > 0)
			{
				wingFrameCounter++;
				if (wingFrameCounter >= num19 * 6)
				{
					wingFrameCounter = 0;
				}
				wingFrame = 1 + wingFrameCounter / num19;
			}
			else if (velocity.Y != 0f)
			{
				if (controlJump)
				{
					wingFrame = 2;
				}
				else if (ShouldFloatInWater && wet)
				{
					wingFrame = 0;
				}
				else
				{
					wingFrame = 3;
				}
			}
			else
			{
				wingFrameCounter++;
				if (wingFrameCounter >= num19 * 6)
				{
					wingFrameCounter = 0;
				}
				wingFrame = 1 + wingFrameCounter / num19;
			}
			return;
		}
		if (wings == 39 && ShouldDrawWingsThatAreAlwaysAnimated())
		{
			if (wingFlap || jump > 0)
			{
				wingFrameCounter++;
				int num20 = 4;
				if (wingFrameCounter >= num20 * 6)
				{
					wingFrameCounter = 0;
				}
				wingFrame = wingFrameCounter / num20;
			}
			else if (velocity.Y != 0f)
			{
				if (controlJump)
				{
					wingFrameCounter++;
					int num21 = 9;
					if (wingFrameCounter >= num21 * 6)
					{
						wingFrameCounter = 0;
					}
					wingFrame = wingFrameCounter / num21;
				}
				else
				{
					wingFrameCounter++;
					int num22 = 6;
					if (wingFrameCounter >= num22 * 6)
					{
						wingFrameCounter = 0;
					}
					wingFrame = wingFrameCounter / num22;
				}
			}
			else
			{
				wingFrameCounter++;
				int num23 = 4;
				if (wingFrameCounter >= num23 * 6)
				{
					wingFrameCounter = 0;
				}
				wingFrame = wingFrameCounter / num23;
			}
			int num24 = 1;
			if (wingFrame == 3)
			{
				num24 = 5;
			}
			if (velocity.Y == 0f)
			{
				num24 = 0;
			}
			Rectangle val4 = Utils.CenteredRectangle((gravDir == 1f) ? (base.Bottom + new Vector2(0f, -10f)) : (base.Top + new Vector2(0f, 10f)), new Vector2(50f, 20f));
			for (int l = 0; l < num24; l++)
			{
				Dust dust4 = Dust.NewDustDirect(val4.TopLeft(), val4.Width, val4.Height, 31, 0f, 0f, 0, Color.Black);
				dust4.scale = 0.7f;
				dust4.velocity *= 0.4f;
				dust4.velocity.Y += gravDir * 0.5f;
				dust4.shader = GameShaders.Armor.GetSecondaryShader(cWings, this);
			}
			return;
		}
		if (wings == 33)
		{
			bool flag3 = false;
			if (wingFlap || jump > 0)
			{
				flag3 = true;
			}
			else if (velocity.Y != 0f && controlJump)
			{
				flag3 = true;
			}
			if (!flag3)
			{
				return;
			}
			Color newColor = Main.hslToRgb(Main.rgbToHsl(eyeColor).X, 1f, 0.5f);
			int num25 = ((direction != 1) ? (-4) : 0);
			int num26 = ((gravDir == 1f) ? height : 0);
			for (int m = 0; m < 2; m++)
			{
				Dust dust5 = Main.dust[Dust.NewDust(position, width, height, 182, velocity.X, velocity.Y, 127, newColor)];
				dust5.noGravity = true;
				dust5.fadeIn = 1f;
				dust5.scale = 1f;
				dust5.noLight = true;
				dust5.noLightEmittence = flag;
				dust5.shader = GameShaders.Armor.GetSecondaryShader(cWings, this);
				switch (m)
				{
				case 0:
					dust5.position = new Vector2(position.X + (float)num25, position.Y + (float)num26);
					dust5.velocity.X = dust5.velocity.X * 1f - 2f - velocity.X * 0.3f;
					dust5.velocity.Y = dust5.velocity.Y * 1f + 2f * gravDir - velocity.Y * 0.3f;
					break;
				case 1:
					dust5.position = new Vector2(position.X + (float)width + (float)num25, position.Y + (float)num26);
					dust5.velocity.X = dust5.velocity.X * 1f + 2f - velocity.X * 0.3f;
					dust5.velocity.Y = dust5.velocity.Y * 1f + 2f * gravDir - velocity.Y * 0.3f;
					break;
				}
				if (dust5.dustIndex != 6000)
				{
					Dust dust6 = Dust.CloneDust(dust5);
					dust6.scale *= 0.65f;
					dust6.fadeIn *= 0.65f;
					dust6.color = new Color(255, 255, 255, 255);
					dust5.noLight = true;
					dust5.noLightEmittence = flag;
					dust5.shader = GameShaders.Armor.GetSecondaryShader(cWings, this);
				}
			}
			return;
		}
		if (wings == 38)
		{
			bool flag4 = false;
			if (wingFlap || jump > 0)
			{
				wingFrameCounter++;
				if (wingFrameCounter >= 32)
				{
					wingFrameCounter = 0;
				}
				wingFrame = 1 + wingFrameCounter / 8;
				if (wingFrame == 4)
				{
					wingFrame = 2;
				}
				flag4 = true;
			}
			else if (velocity.Y != 0f)
			{
				if (controlJump)
				{
					wingFrameCounter++;
					if (wingFrameCounter >= 32)
					{
						wingFrameCounter = 0;
					}
					wingFrame = 1 + wingFrameCounter / 8;
					if (wingFrame == 4)
					{
						wingFrame = 2;
					}
					flag4 = true;
				}
				else
				{
					wingFrame = 0;
				}
			}
			else
			{
				wingFrame = 0;
			}
			if (!flag4)
			{
				return;
			}
			Vector2 val5 = default(Vector2);
			((Vector2)(ref val5))..ctor((float)direction, gravDir);
			Vector2 value = velocity * 0.5f;
			int type2 = 267;
			int num27 = miscCounter * direction;
			for (int n = 0; n < 3; n++)
			{
				Vector2 val6 = Vector2.Zero;
				switch (n)
				{
				case 1:
					val6 = velocity * -0.33f;
					break;
				case 2:
					val6 = velocity * -0.66f;
					break;
				}
				Vector2 val7 = new Vector2(-39f, 6f) * val5 + Utils.RotatedBy(new Vector2(2f, 0f), (double)((float)num27 / -15f * ((float)Math.PI * 2f)), default(Vector2));
				Dust dust7 = Dust.NewDustPerfect(base.Center + val7 + val6, type2, value, 0, underShirtColor);
				dust7.noGravity = true;
				dust7.noLight = true;
				dust7.noLightEmittence = flag;
				dust7.scale = 0.47f;
				dust7.shader = GameShaders.Armor.GetSecondaryShader(cWings, this);
				val7 = new Vector2(-23f, 2f) * val5 + Utils.RotatedBy(new Vector2(2f, 0f), (double)((float)num27 / -15f * ((float)Math.PI * 2f)), default(Vector2));
				Dust dust8 = Dust.NewDustPerfect(base.Center + val7 + val6, type2, value, 0, underShirtColor);
				dust8.noGravity = true;
				dust8.noLight = true;
				dust8.noLightEmittence = flag;
				dust8.scale = 0.35f;
				dust8.shader = GameShaders.Armor.GetSecondaryShader(cWings, this);
				val7 = new Vector2(-31f, -6f) * val5 + Utils.RotatedBy(new Vector2(2f, 0f), (double)((float)num27 / -20f * ((float)Math.PI * 2f)), default(Vector2));
				Dust dust9 = Dust.NewDustPerfect(base.Center + val7 + val6, type2, value, 0, underShirtColor);
				dust9.noGravity = true;
				dust9.noLight = true;
				dust9.noLightEmittence = flag;
				dust9.scale = 0.49f;
				dust9.shader = GameShaders.Armor.GetSecondaryShader(cWings, this);
			}
			return;
		}
		int num28 = 4;
		int num29 = 4;
		int num30 = 0;
		if (wings == 43)
		{
			num29 = 7;
			num30 = 1;
			num28 = 3;
		}
		if (isCustomWings)
		{
			return;
		}
		if (wings == 32)
		{
			num28 = 3;
		}
		if (wingFlap || jump > 0)
		{
			wingFrameCounter++;
			if (wingFrameCounter > num28)
			{
				wingFrame++;
				wingFrameCounter = 0;
				if (wingFrame >= num29)
				{
					wingFrame = num30;
				}
			}
		}
		else if (velocity.Y != 0f)
		{
			wingFrame = 1;
			if (wings == 32)
			{
				wingFrame = 3;
			}
			if (wings == 43)
			{
				wingFrame = 2;
				if (ShouldFloatInWater && wet)
				{
					wingFrame = 0;
				}
			}
			if (wings == 29 && Main.rand.Next(5) == 0)
			{
				int num31 = 4;
				if (direction == 1)
				{
					num31 = -40;
				}
				int num32 = Dust.NewDust(new Vector2(position.X + (float)(width / 2) + (float)num31, position.Y + (float)(height / 2) - 15f), 30, 30, 6, 0f, 0f, 100, default(Color), 2.4f);
				Main.dust[num32].noGravity = true;
				Main.dust[num32].noLightEmittence = flag;
				Dust obj = Main.dust[num32];
				obj.velocity *= 0.3f;
				if (Main.rand.Next(10) == 0)
				{
					Main.dust[num32].fadeIn = 2f;
				}
				Main.dust[num32].shader = GameShaders.Armor.GetSecondaryShader(cWings, this);
			}
		}
		else
		{
			wingFrame = 0;
		}
	}

	public bool ShouldDrawWingsThatAreAlwaysAnimated()
	{
		if ((velocity.Y != 0f || grappling[0] != -1) && (!wet || !ShouldFloatInWater))
		{
			return !mount.Active;
		}
		return false;
	}

	private void WingAirVisuals()
	{
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_017c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0182: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01de: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0275: Unknown result type (might be due to invalid IL or missing references)
		//IL_0290: Unknown result type (might be due to invalid IL or missing references)
		//IL_0296: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_035a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0376: Unknown result type (might be due to invalid IL or missing references)
		//IL_037c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0392: Unknown result type (might be due to invalid IL or missing references)
		//IL_039c: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_04df: Unknown result type (might be due to invalid IL or missing references)
		//IL_04ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0505: Unknown result type (might be due to invalid IL or missing references)
		//IL_0537: Unknown result type (might be due to invalid IL or missing references)
		//IL_0541: Unknown result type (might be due to invalid IL or missing references)
		//IL_0546: Unknown result type (might be due to invalid IL or missing references)
		//IL_0554: Unknown result type (might be due to invalid IL or missing references)
		//IL_055a: Unknown result type (might be due to invalid IL or missing references)
		//IL_055f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0564: Unknown result type (might be due to invalid IL or missing references)
		//IL_0422: Unknown result type (might be due to invalid IL or missing references)
		//IL_0442: Unknown result type (might be due to invalid IL or missing references)
		//IL_0448: Unknown result type (might be due to invalid IL or missing references)
		//IL_046c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0476: Unknown result type (might be due to invalid IL or missing references)
		//IL_047b: Unknown result type (might be due to invalid IL or missing references)
		//IL_06d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_070c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0712: Unknown result type (might be due to invalid IL or missing references)
		//IL_0732: Unknown result type (might be due to invalid IL or missing references)
		//IL_073c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0741: Unknown result type (might be due to invalid IL or missing references)
		//IL_0749: Unknown result type (might be due to invalid IL or missing references)
		//IL_074f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0759: Unknown result type (might be due to invalid IL or missing references)
		//IL_075e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0763: Unknown result type (might be due to invalid IL or missing references)
		//IL_0796: Unknown result type (might be due to invalid IL or missing references)
		//IL_07a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_07a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_07ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_07b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_095d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0975: Unknown result type (might be due to invalid IL or missing references)
		//IL_097b: Unknown result type (might be due to invalid IL or missing references)
		//IL_099f: Unknown result type (might be due to invalid IL or missing references)
		//IL_09a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_09ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_05eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_060d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0613: Unknown result type (might be due to invalid IL or missing references)
		//IL_0645: Unknown result type (might be due to invalid IL or missing references)
		//IL_064f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0654: Unknown result type (might be due to invalid IL or missing references)
		//IL_0662: Unknown result type (might be due to invalid IL or missing references)
		//IL_0668: Unknown result type (might be due to invalid IL or missing references)
		//IL_066d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0672: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a63: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a7b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a81: Unknown result type (might be due to invalid IL or missing references)
		//IL_0aac: Unknown result type (might be due to invalid IL or missing references)
		//IL_0ab6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0abb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b36: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b51: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b57: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b77: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b81: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b86: Unknown result type (might be due to invalid IL or missing references)
		//IL_081a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0852: Unknown result type (might be due to invalid IL or missing references)
		//IL_0858: Unknown result type (might be due to invalid IL or missing references)
		//IL_0878: Unknown result type (might be due to invalid IL or missing references)
		//IL_0882: Unknown result type (might be due to invalid IL or missing references)
		//IL_0887: Unknown result type (might be due to invalid IL or missing references)
		//IL_088f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0895: Unknown result type (might be due to invalid IL or missing references)
		//IL_089f: Unknown result type (might be due to invalid IL or missing references)
		//IL_08a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_08a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_08dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_08e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_08eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_08f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_08f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c23: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c41: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c47: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c72: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c7c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c81: Unknown result type (might be due to invalid IL or missing references)
		//IL_0d0c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0d2d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0d33: Unknown result type (might be due to invalid IL or missing references)
		//IL_0d53: Unknown result type (might be due to invalid IL or missing references)
		//IL_0d5d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0d62: Unknown result type (might be due to invalid IL or missing references)
		bool noLightEmittence = wingsLogic != wings;
		if (wings == 10 && Main.rand.Next(2) == 0)
		{
			int num = 4;
			if (direction == 1)
			{
				num = -40;
			}
			int num2 = Dust.NewDust(new Vector2(position.X + (float)(width / 2) + (float)num, position.Y + (float)(height / 2) - 15f), 30, 30, 76, 0f, 0f, 50, default(Color), 0.6f);
			Main.dust[num2].fadeIn = 1.1f;
			Main.dust[num2].noGravity = true;
			Main.dust[num2].noLight = true;
			Dust obj = Main.dust[num2];
			obj.velocity *= 0.3f;
			Main.dust[num2].shader = GameShaders.Armor.GetSecondaryShader(cWings, this);
		}
		if (wings == 34 && Main.rand.Next(2) == 0)
		{
			int num3 = 4;
			if (direction == 1)
			{
				num3 = -40;
			}
			int num4 = Dust.NewDust(new Vector2(position.X + (float)(width / 2) + (float)num3, position.Y + (float)(height / 2) - 15f), 30, 30, 261, 0f, 0f, 50, default(Color), 0.6f);
			Main.dust[num4].fadeIn = 1.1f;
			Main.dust[num4].noGravity = true;
			Main.dust[num4].noLight = true;
			Main.dust[num4].noLightEmittence = noLightEmittence;
			Dust obj2 = Main.dust[num4];
			obj2.velocity *= 0.3f;
			Main.dust[num4].shader = GameShaders.Armor.GetSecondaryShader(cWings, this);
		}
		_ = wings;
		_ = wings;
		if (wings == 9 && Main.rand.Next(2) == 0)
		{
			int num5 = 4;
			if (direction == 1)
			{
				num5 = -40;
			}
			int num6 = Dust.NewDust(new Vector2(position.X + (float)(width / 2) + (float)num5, position.Y + (float)(height / 2) - 15f), 30, 30, 6, 0f, 0f, 200, default(Color), 2f);
			Main.dust[num6].noGravity = true;
			Main.dust[num6].noLightEmittence = noLightEmittence;
			Dust obj3 = Main.dust[num6];
			obj3.velocity *= 0.3f;
			Main.dust[num6].shader = GameShaders.Armor.GetSecondaryShader(cWings, this);
		}
		if (wings == 6 && Main.rand.Next(4) == 0)
		{
			int num7 = 4;
			if (direction == 1)
			{
				num7 = -40;
			}
			int num8 = Dust.NewDust(new Vector2(position.X + (float)(width / 2) + (float)num7, position.Y + (float)(height / 2) - 15f), 30, 30, 55, 0f, 0f, 200);
			Dust obj4 = Main.dust[num8];
			obj4.velocity *= 0.3f;
			Main.dust[num8].noLightEmittence = noLightEmittence;
			Main.dust[num8].shader = GameShaders.Armor.GetSecondaryShader(cWings, this);
		}
		if (wings == 5 && Main.rand.Next(3) == 0)
		{
			int num9 = 6;
			if (direction == 1)
			{
				num9 = -30;
			}
			int num10 = Dust.NewDust(new Vector2(position.X + (float)(width / 2) + (float)num9, position.Y), 18, height, 58, 0f, 0f, 255, default(Color), 1.2f);
			Main.dust[num10].noLightEmittence = noLightEmittence;
			Dust obj5 = Main.dust[num10];
			obj5.velocity *= 0.3f;
			Main.dust[num10].shader = GameShaders.Armor.GetSecondaryShader(cWings, this);
		}
		if (wings == 26)
		{
			int num11 = 6;
			if (direction == 1)
			{
				num11 = -30;
			}
			int num12 = Dust.NewDust(new Vector2(position.X + (float)(width / 2) + (float)num11, position.Y), 18, height, 217, 0f, 0f, 100, default(Color), 1.4f);
			Main.dust[num12].noGravity = true;
			Main.dust[num12].noLight = true;
			Dust obj6 = Main.dust[num12];
			obj6.velocity /= 4f;
			Dust obj7 = Main.dust[num12];
			obj7.velocity -= velocity;
			Main.dust[num12].shader = GameShaders.Armor.GetSecondaryShader(cWings, this);
			if (Main.rand.Next(2) == 0)
			{
				num11 = -24;
				if (direction == 1)
				{
					num11 = 12;
				}
				float num13 = position.Y;
				if (gravDir == -1f)
				{
					num13 += (float)(height / 2);
				}
				num12 = Dust.NewDust(new Vector2(position.X + (float)(width / 2) + (float)num11, num13), 12, height / 2, 217, 0f, 0f, 100, default(Color), 1.4f);
				Main.dust[num12].noGravity = true;
				Main.dust[num12].noLight = true;
				Dust obj8 = Main.dust[num12];
				obj8.velocity /= 4f;
				Dust obj9 = Main.dust[num12];
				obj9.velocity -= velocity;
				Main.dust[num12].shader = GameShaders.Armor.GetSecondaryShader(cWings, this);
			}
		}
		if (wings == 37)
		{
			int num14 = 6;
			if (direction == 1)
			{
				num14 = -30;
			}
			Dust dust = Dust.NewDustDirect(new Vector2(position.X + (float)(width / 2) + (float)num14, position.Y), 24, height, Utils.SelectRandom<int>(Main.rand, 31, 31, 31), 0f, 0f, 100);
			dust.noGravity = true;
			dust.noLight = true;
			Dust dust2 = dust;
			dust2.velocity /= 4f;
			Dust dust3 = dust;
			dust3.velocity -= velocity / 2f;
			dust.shader = GameShaders.Armor.GetSecondaryShader(cWings, this);
			if (dust.type == 55)
			{
				dust.noGravity = true;
				Dust dust4 = dust;
				dust4.velocity *= 2f;
				dust.color = Color.Red;
			}
			if (Main.rand.Next(3) == 0)
			{
				num14 = -24;
				if (direction == 1)
				{
					num14 = 12;
				}
				float num15 = position.Y;
				if (gravDir == -1f)
				{
					num15 += (float)(height / 2);
				}
				dust = Dust.NewDustDirect(new Vector2(position.X + (float)(width / 2) + (float)num14, num15), 16, height / 2, Utils.SelectRandom<int>(Main.rand, 31, 31, 31), 0f, 0f, 100);
				dust.noGravity = true;
				dust.noLight = true;
				Dust dust5 = dust;
				dust5.velocity /= 4f;
				Dust dust6 = dust;
				dust6.velocity -= velocity / 2f;
				dust.shader = GameShaders.Armor.GetSecondaryShader(cWings, this);
				if (dust.type == 55)
				{
					dust.noGravity = true;
					Dust dust7 = dust;
					dust7.velocity *= 2f;
					dust.color = Color.Red;
				}
			}
		}
		if (wings == 29 && Main.rand.Next(3) == 0)
		{
			int num16 = 4;
			if (direction == 1)
			{
				num16 = -40;
			}
			int num17 = Dust.NewDust(new Vector2(position.X + (float)(width / 2) + (float)num16, position.Y + (float)(height / 2) - 15f), 30, 30, 6, 0f, 0f, 100, default(Color), 2.4f);
			Main.dust[num17].noGravity = true;
			Dust obj10 = Main.dust[num17];
			obj10.velocity *= 0.3f;
			Main.dust[num17].noLightEmittence = noLightEmittence;
			if (Main.rand.Next(10) == 0)
			{
				Main.dust[num17].fadeIn = 2f;
			}
			Main.dust[num17].shader = GameShaders.Armor.GetSecondaryShader(cWings, this);
		}
		if (wings != 31)
		{
			return;
		}
		if (Main.rand.Next(6) == 0)
		{
			int num18 = 4;
			if (direction == 1)
			{
				num18 = -40;
			}
			Dust obj11 = Main.dust[Dust.NewDust(new Vector2(position.X + (float)(width / 2) + (float)num18, position.Y + (float)(height / 2) - 15f), 30, 30, 86)];
			obj11.noGravity = true;
			obj11.scale = 1f;
			obj11.fadeIn = 1.2f;
			obj11.velocity *= 0.2f;
			obj11.noLight = true;
			obj11.shader = GameShaders.Armor.GetSecondaryShader(cWings, this);
		}
		if (Main.rand.Next(3) == 0)
		{
			int num19 = 4;
			if (direction == 1)
			{
				num19 = -40;
			}
			Dust obj12 = Main.dust[Dust.NewDust(new Vector2(position.X + (float)(width / 2) + (float)num19, position.Y + (float)(height / 2) - 15f), 30, 30, 240)];
			obj12.noGravity = true;
			obj12.scale = 1.2f;
			obj12.velocity *= 0.2f;
			obj12.alpha = 200;
			obj12.shader = GameShaders.Armor.GetSecondaryShader(cWings, this);
		}
		if (Main.rand.Next(2) != 0)
		{
			return;
		}
		if (Main.rand.Next(6) == 0)
		{
			int num20 = -24;
			if (direction == 1)
			{
				num20 = 12;
			}
			float num21 = position.Y;
			if (gravDir == -1f)
			{
				num21 += (float)(height / 2);
			}
			Dust obj13 = Main.dust[Dust.NewDust(new Vector2(position.X + (float)(width / 2) + (float)num20, num21), 12, height / 2, 86)];
			obj13.noGravity = true;
			obj13.scale = 1f;
			obj13.fadeIn = 1.2f;
			obj13.velocity *= 0.2f;
			obj13.noLight = true;
			obj13.shader = GameShaders.Armor.GetSecondaryShader(cWings, this);
		}
		if (Main.rand.Next(3) == 0)
		{
			int num22 = -24;
			if (direction == 1)
			{
				num22 = 12;
			}
			float num23 = position.Y;
			if (gravDir == -1f)
			{
				num23 += (float)(height / 2);
			}
			Dust obj14 = Main.dust[Dust.NewDust(new Vector2(position.X + (float)(width / 2) + (float)num22, num23), 12, height / 2, 240)];
			obj14.noGravity = true;
			obj14.scale = 1.2f;
			obj14.velocity *= 0.2f;
			obj14.alpha = 200;
			obj14.shader = GameShaders.Armor.GetSecondaryShader(cWings, this);
		}
	}

	private void HandleBeingInChestRange()
	{
		//IL_01e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		//IL_025a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0260: Unknown result type (might be due to invalid IL or missing references)
		//IL_0265: Unknown result type (might be due to invalid IL or missing references)
		//IL_026a: Unknown result type (might be due to invalid IL or missing references)
		//IL_026d: Unknown result type (might be due to invalid IL or missing references)
		//IL_027e: Unknown result type (might be due to invalid IL or missing references)
		//IL_02eb: Unknown result type (might be due to invalid IL or missing references)
		if (chest != -1)
		{
			if (chest != -2)
			{
				piggyBankProjTracker.Clear();
			}
			if (chest != -5)
			{
				voidLensChest.Clear();
			}
			bool flag = false;
			int projectileLocalIndex = piggyBankProjTracker.ProjectileLocalIndex;
			if (projectileLocalIndex >= 0)
			{
				flag = true;
				if (!Main.projectile[projectileLocalIndex].active || (Main.projectile[projectileLocalIndex].type != 525 && Main.projectile[projectileLocalIndex].type != 960))
				{
					Main.PlayInteractiveProjectileOpenCloseSound(Main.projectile[projectileLocalIndex].type, open: false);
					chest = -1;
					Recipe.FindRecipes();
				}
				else
				{
					int num = (int)(((double)position.X + (double)width * 0.5) / 16.0);
					int num2 = (int)(((double)position.Y + (double)height * 0.5) / 16.0);
					Vector2 val = Main.projectile[projectileLocalIndex].Hitbox.ClosestPointInRect(base.Center);
					chestX = (int)val.X / 16;
					chestY = (int)val.Y / 16;
					if (num < chestX - tileRangeX || num > chestX + tileRangeX + 1 || num2 < chestY - tileRangeY || num2 > chestY + tileRangeY + 1)
					{
						if (chest != -1)
						{
							Main.PlayInteractiveProjectileOpenCloseSound(Main.projectile[projectileLocalIndex].type, open: false);
						}
						chest = -1;
						Recipe.FindRecipes();
					}
				}
			}
			int projectileLocalIndex2 = voidLensChest.ProjectileLocalIndex;
			if (projectileLocalIndex2 >= 0)
			{
				flag = true;
				if (!Main.projectile[projectileLocalIndex2].active || Main.projectile[projectileLocalIndex2].type != 734)
				{
					SoundEngine.PlaySound(in SoundID.Item130);
					chest = -1;
					Recipe.FindRecipes();
				}
				else
				{
					int num3 = (int)(((double)position.X + (double)width * 0.5) / 16.0);
					int num4 = (int)(((double)position.Y + (double)height * 0.5) / 16.0);
					Vector2 val2 = Main.projectile[projectileLocalIndex2].Hitbox.ClosestPointInRect(base.Center);
					chestX = (int)val2.X / 16;
					chestY = (int)val2.Y / 16;
					if (num3 < chestX - tileRangeX || num3 > chestX + tileRangeX + 1 || num4 < chestY - tileRangeY || num4 > chestY + tileRangeY + 1)
					{
						if (chest != -1)
						{
							SoundEngine.PlaySound(in SoundID.Item130);
						}
						chest = -1;
						Recipe.FindRecipes();
					}
				}
			}
			if (flag)
			{
				return;
			}
			if (!IsInInteractionRangeToMultiTileHitbox(chestX, chestY))
			{
				if (chest != -1)
				{
					SoundEngine.PlaySound(11);
				}
				chest = -1;
				Recipe.FindRecipes();
			}
			else if (!Main.tile[chestX, chestY].active())
			{
				SoundEngine.PlaySound(11);
				chest = -1;
				Recipe.FindRecipes();
			}
		}
		else
		{
			piggyBankProjTracker.Clear();
			voidLensChest.Clear();
		}
	}

	public bool IsInInteractionRangeToMultiTileHitbox(int chestPointX, int chestPointY)
	{
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		int num = (int)(((double)position.X + (double)width * 0.5) / 16.0);
		int num2 = (int)(((double)position.Y + (double)height * 0.5) / 16.0);
		Rectangle empty = Rectangle.Empty;
		Tile tile = Main.tile[chestPointX, chestPointY];
		if (tile.type == 463 || tile.type == 491)
		{
			((Rectangle)(ref empty))..ctor(chestPointX * 16 - 16, chestPointY * 16 - 32, 48, 64);
		}
		if (TileID.Sets.BasicChest[tile.type] || tile.type == 97)
		{
			((Rectangle)(ref empty))..ctor(chestPointX * 16, chestPointY * 16, 32, 32);
		}
		if (TileID.Sets.BasicDresser[tile.type])
		{
			((Rectangle)(ref empty))..ctor(chestPointX * 16, chestPointY * 16, 48, 32);
		}
		if (tile.type == 29)
		{
			((Rectangle)(ref empty))..ctor(chestPointX * 16, chestPointY * 16, 32, 16);
		}
		((Rectangle)(ref empty)).Inflate(-1, -1);
		Point val = empty.ClosestPointInRect(base.Center).ToTileCoordinates();
		chestPointX = val.X;
		chestPointY = val.Y;
		if (num >= chestPointX - tileRangeX && num <= chestPointX + tileRangeX + 1 && num2 >= chestPointY - tileRangeY)
		{
			return num2 <= chestPointY + tileRangeY + 1;
		}
		return false;
	}

	public void ResetVisibleAccessories()
	{
		handon = -1;
		handoff = -1;
		back = -1;
		front = -1;
		shoe = -1;
		waist = -1;
		shield = -1;
		neck = -1;
		face = -1;
		balloon = -1;
		backpack = -1;
		tail = -1;
		faceHead = -1;
		faceFlower = -1;
		balloonFront = -1;
		beard = -1;
	}

	public void UpdateArmorLights()
	{
		//IL_030a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0321: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_02fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_03cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_04c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_04e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_04a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_04b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_04b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_04bc: Unknown result type (might be due to invalid IL or missing references)
		if (vortexStealthActive)
		{
			return;
		}
		float num = 0f;
		float num2 = 0f;
		float num3 = 0f;
		switch (head)
		{
		case 11:
			num = 0.92f;
			num2 = 0.8f;
			num3 = 0.65f;
			break;
		case 216:
			num = 0.7f;
			num2 = 0.95f;
			num3 = 0.82f;
			break;
		case 169:
			num = 0f;
			num2 = 0.36f;
			num3 = 0.4f;
			break;
		case 170:
			num = 0.4f;
			num2 = 0.16f;
			num3 = 0.36f;
			break;
		case 171:
			num = 0.5f;
			num2 = 0.25f;
			num3 = 0.05f;
			break;
		case 189:
			num = 0.9f;
			num2 = 0.9f;
			num3 = 0.7f;
			break;
		case 178:
			num = 0.1f;
			num2 = 0.2f;
			num3 = 0.3f;
			break;
		case 211:
			num = 0.2f;
			num2 = 0.4f;
			num3 = 0.8f;
			break;
		}
		float num4 = 0f;
		float num5 = 0f;
		float num6 = 0f;
		switch (body)
		{
		case 175:
			num4 = 0f;
			num5 = 0.36f;
			num6 = 0.4f;
			break;
		case 176:
			num4 = 0.4f;
			num5 = 0.16f;
			num6 = 0.36f;
			break;
		case 177:
			num4 = 0.5f;
			num5 = 0.25f;
			num6 = 0.05f;
			break;
		case 190:
			num = 0.9f;
			num2 = 0.9f;
			num3 = 0.7f;
			break;
		case 205:
			num4 = 0.2f;
			num5 = 0.4f;
			num6 = 0.8f;
			break;
		}
		float num7 = 0f;
		float num8 = 0f;
		float num9 = 0f;
		switch (legs)
		{
		case 110:
			num7 = 0f;
			num8 = 0.36f;
			num9 = 0.4f;
			break;
		case 111:
			num7 = 0.4f;
			num8 = 0.16f;
			num9 = 0.36f;
			break;
		case 112:
			num7 = 0.5f;
			num8 = 0.25f;
			num9 = 0.05f;
			break;
		case 130:
			num = 0.9f;
			num2 = 0.9f;
			num3 = 0.7f;
			break;
		}
		if (num != 0f || num2 != 0f || num3 != 0f)
		{
			float num10 = 1f;
			if (num == num4 && num2 == num5 && num3 == num6)
			{
				num10 += 0.5f;
			}
			if (num == num7 && num2 == num8 && num3 == num9)
			{
				num10 += 0.5f;
			}
			Vector2 val = default(Vector2);
			((Vector2)(ref val))..ctor((float)(width / 2 + 8 * direction), 2f);
			if (fullRotation != 0f)
			{
				val = val.RotatedBy(fullRotation, fullRotationOrigin);
			}
			int i = (int)(position.X + val.X) / 16;
			int j = (int)(position.Y + val.Y) / 16;
			Lighting.AddLight(i, j, num * num10, num2 * num10, num3 * num10);
		}
		if (num4 != 0f || num5 != 0f || num6 != 0f)
		{
			float num11 = 1f;
			if (num4 == num && num5 == num2 && num6 == num3)
			{
				num11 += 0.5f;
			}
			if (num4 == num7 && num5 == num8 && num6 == num9)
			{
				num11 += 0.5f;
			}
			Vector2 val2 = default(Vector2);
			((Vector2)(ref val2))..ctor((float)(width / 2 + 8), (float)(height / 2));
			if (fullRotation != 0f)
			{
				val2 = val2.RotatedBy(fullRotation, fullRotationOrigin);
			}
			int i2 = (int)(position.X + val2.X) / 16;
			int j2 = (int)(position.Y + val2.Y) / 16;
			Lighting.AddLight(i2, j2, num4 * num11, num5 * num11, num6 * num11);
		}
		if (num7 != 0f || num8 != 0f || num9 != 0f)
		{
			float num12 = 1f;
			if (num7 == num4 && num8 == num5 && num9 == num6)
			{
				num12 += 0.5f;
			}
			if (num7 == num && num8 == num2 && num9 == num3)
			{
				num12 += 0.5f;
			}
			Vector2 val3 = default(Vector2);
			((Vector2)(ref val3))..ctor((float)(width / 2 + 8 * direction), (float)height * 0.75f);
			if (fullRotation != 0f)
			{
				val3 = val3.RotatedBy(fullRotation, fullRotationOrigin);
			}
			int i3 = (int)(position.X + val3.X) / 16;
			int j3 = (int)(position.Y + val3.Y) / 16;
			Lighting.AddLight(i3, j3, num7 * num12, num8 * num12, num9 * num12);
		}
	}

	public void Update_NPCCollision()
	{
		//IL_013d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_014e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0153: Unknown result type (might be due to invalid IL or missing references)
		//IL_019b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_03df: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01df: Unknown result type (might be due to invalid IL or missing references)
		if (creativeGodMode)
		{
			return;
		}
		Rectangle val = default(Rectangle);
		((Rectangle)(ref val))..ctor((int)position.X, (int)position.Y, width, height);
		Rectangle npcRect = default(Rectangle);
		for (int i = 0; i < 200; i++)
		{
			if (!Main.npc[i].active || Main.npc[i].friendly || Main.npc[i].damage <= 0)
			{
				continue;
			}
			int specialHitSetter = -1;
			switch (Main.npc[i].type)
			{
			case 396:
			case 397:
			case 398:
			case 400:
			case 401:
				specialHitSetter = 1;
				break;
			case 636:
				specialHitSetter = 1;
				if (Main.npc[i].ai[0] == 0f || Main.npc[i].ai[0] == 10f)
				{
					continue;
				}
				break;
			}
			if (!CombinedHooks.CanNPCHitPlayer(Main.npc[i], this, ref specialHitSetter) || (specialHitSetter == -1 && immune) || (dash == 2 && i == eocHit && eocDash > 0) || npcTypeNoAggro[Main.npc[i].type])
			{
				continue;
			}
			float damageMultiplier = 1f;
			NPC obj = Main.npc[i];
			obj.position += Main.npc[i].netOffset;
			((Rectangle)(ref npcRect))..ctor((int)Main.npc[i].position.X, (int)Main.npc[i].position.Y, Main.npc[i].width, Main.npc[i].height);
			NPC.GetMeleeCollisionData(val, i, ref specialHitSetter, ref damageMultiplier, ref npcRect);
			if (((Rectangle)(ref val)).Intersects(npcRect))
			{
				if (npcTypeNoAggro[Main.npc[i].type])
				{
					continue;
				}
				bool flag = true;
				bool flag2 = false;
				bool num = CanParryAgainst(val, npcRect, Main.npc[i].velocity);
				float num2 = thorns;
				float knockback = 10f;
				if (turtleThorns)
				{
					num2 = 2f;
				}
				if (num)
				{
					num2 = 2f;
					knockback = 5f;
					flag = false;
					flag2 = true;
				}
				int num3 = -1;
				if (Main.npc[i].position.X + (float)(Main.npc[i].width / 2) < position.X + (float)(width / 2))
				{
					num3 = 1;
				}
				int num4 = Main.DamageVar((float)Main.npc[i].damage * damageMultiplier, 0f - luck);
				bool flag3 = !immune;
				if (specialHitSetter >= 0)
				{
					flag3 = hurtCooldowns[specialHitSetter] == 0;
				}
				if (whoAmI == Main.myPlayer && num2 > 0f && flag3 && !Main.npc[i].dontTakeDamage)
				{
					int num5 = (int)((float)num4 * num2);
					if (num5 > 1000)
					{
						num5 = 1000;
					}
					ApplyDamageToNPC(Main.npc[i], num5, knockback, -num3);
				}
				if (whoAmI == Main.myPlayer && cactusThorns && flag3 && !Main.npc[i].dontTakeDamage)
				{
					int damage = 15;
					if (Main.masterMode)
					{
						damage = 45;
					}
					else if (Main.expertMode)
					{
						damage = 30;
					}
					ApplyDamageToNPC(Main.npc[i], damage, knockback, -num3);
				}
				if (flag && Hurt(dodgeable: Main.npc[i].IsDamageDodgeable(), damageSource: PlayerDeathReason.ByNPC(i), Damage: num4, hitDirection: num3, pvp: false, quiet: false, Crit: false, cooldownCounter: specialHitSetter) > 0.0 && !dead && !flag2)
				{
					StatusFromNPC(Main.npc[i]);
				}
				if (num)
				{
					GiveImmuneTimeForCollisionAttack(longInvince ? 60 : 30);
					AddBuff(198, 300, quiet: false);
				}
			}
			NPC obj2 = Main.npc[i];
			obj2.position -= Main.npc[i].netOffset;
		}
	}

	public bool CanParryAgainst(Rectangle blockingPlayerRect, Rectangle enemyRect, Vector2 enemyVelocity)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		if (shieldParryTimeLeft > 0 && Math.Sign(((Rectangle)(ref enemyRect)).Center.X - ((Rectangle)(ref blockingPlayerRect)).Center.X) == direction && enemyVelocity != Vector2.Zero)
		{
			return !immune;
		}
		return false;
	}

	private void PurgeDD2EnergyCrystals()
	{
		if (trashItem.type == 3822)
		{
			trashItem.TurnToAir();
		}
		if (Main.myPlayer == whoAmI && Main.mouseItem.type == 3822)
		{
			Main.mouseItem.TurnToAir();
		}
		for (int i = 0; i < 59; i++)
		{
			Item item = inventory[i];
			if (item.stack > 0 && item.type == 3822)
			{
				item.TurnToAir();
			}
		}
		if (this.chest == -2)
		{
			Chest chest = bank;
			for (int j = 0; j < 40; j++)
			{
				if (chest.item[j].stack > 0 && chest.item[j].type == 3822)
				{
					chest.item[j].TurnToAir();
				}
			}
		}
		if (this.chest == -4)
		{
			Chest chest2 = bank3;
			for (int k = 0; k < 40; k++)
			{
				if (chest2.item[k].stack > 0 && chest2.item[k].type == 3822)
				{
					chest2.item[k].TurnToAir();
				}
			}
		}
		if (this.chest == -5)
		{
			Chest chest3 = bank4;
			for (int l = 0; l < 40; l++)
			{
				if (chest3.item[l].stack > 0 && chest3.item[l].type == 3822)
				{
					chest3.item[l].TurnToAir();
				}
			}
		}
		if (this.chest == -3)
		{
			Chest chest4 = bank2;
			for (int m = 0; m < 40; m++)
			{
				if (chest4.item[m].stack > 0 && chest4.item[m].type == 3822)
				{
					chest4.item[m].TurnToAir();
				}
			}
		}
		if (this.chest <= -1)
		{
			return;
		}
		Chest chest5 = Main.chest[this.chest];
		for (int n = 0; n < 40; n++)
		{
			if (chest5.item[n].stack > 0 && chest5.item[n].type == 3822)
			{
				chest5.item[n].TurnToAir();
				if (Main.netMode == 1)
				{
					NetMessage.SendData(32, -1, -1, null, this.chest, n);
				}
			}
		}
	}

	public void ItemCheck_ManageRightClickFeatures()
	{
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		bool flag = selectedItem != 58 && controlUseTile && Main.myPlayer == whoAmI && !tileInteractionHappened && releaseUseItem && !controlUseItem && !mouseInterface && !CaptureManager.Instance.Active && !Main.HoveringOverAnNPC && !Main.SmartInteractShowingGenuine;
		bool flag2 = flag;
		if (!ItemID.Sets.ItemsThatAllowRepeatedRightClick[inventory[selectedItem].type] && !Main.mouseRightRelease)
		{
			flag2 = false;
		}
		if (flag2 && altFunctionUse == 0)
		{
			for (int i = 0; i < _projectilesToInteractWith.Count; i++)
			{
				Projectile projectile = Main.projectile[_projectilesToInteractWith[i]];
				Rectangle hitbox = projectile.Hitbox;
				if (((Rectangle)(ref hitbox)).Contains(Main.MouseWorld.ToPoint()) || Main.SmartInteractProj == projectile.whoAmI)
				{
					flag = false;
					flag2 = false;
					break;
				}
			}
		}
		if (flag2 && altFunctionUse == 0 && itemTime == 0 && itemAnimation == 0)
		{
			int num = -1;
			int type = 7;
			switch (inventory[selectedItem].type)
			{
			case 5324:
				num = 5329;
				type = 22;
				break;
			case 5329:
				num = 5330;
				type = 22;
				break;
			case 5330:
				num = 5324;
				type = 22;
				break;
			case 4346:
				num = 5391;
				type = 22;
				break;
			case 5391:
				num = 4346;
				type = 22;
				break;
			case 5325:
				num = 4131;
				break;
			case 4131:
				num = 5325;
				break;
			case 5323:
				num = 5455;
				break;
			case 5455:
				num = 5323;
				break;
			case 4767:
				num = 5453;
				break;
			case 5453:
				num = 4767;
				break;
			case 5309:
				num = 5454;
				break;
			case 5454:
				num = 5309;
				break;
			case 5358:
				num = 5360;
				type = 22;
				break;
			case 5360:
				num = 5361;
				type = 22;
				break;
			case 5361:
				num = 5359;
				type = 22;
				break;
			case 5359:
				num = 5358;
				type = 22;
				break;
			case 5437:
				num = 5358;
				type = 22;
				break;
			}
			if (num != -1)
			{
				releaseUseTile = false;
				Main.mouseRightRelease = false;
				SoundEngine.PlaySound(type);
				inventory[selectedItem].ChangeItemType(num);
				Recipe.FindRecipes();
			}
		}
		if (flag2 && altFunctionUse == 0 && inventory[selectedItem].type == 3384)
		{
			altFunctionUse = 1;
			controlUseItem = true;
		}
		if (flag2 && altFunctionUse == 0 && inventory[selectedItem].type == 3858)
		{
			altFunctionUse = 1;
			controlUseItem = true;
		}
		if (flag2 && altFunctionUse == 0 && inventory[selectedItem].type == 4673)
		{
			altFunctionUse = 1;
			controlUseItem = true;
		}
		if (flag2 && altFunctionUse == 0 && inventory[selectedItem].type == 3852 && itemAnimation == 0)
		{
			altFunctionUse = 1;
			controlUseItem = true;
		}
		if (flag2 && altFunctionUse == 0 && inventory[selectedItem].shoot > 0 && ProjectileID.Sets.TurretFeature[inventory[selectedItem].shoot])
		{
			altFunctionUse = 1;
			controlUseItem = true;
		}
		if (flag2 && altFunctionUse == 0 && inventory[selectedItem].shoot > 0 && ProjectileID.Sets.MinionTargettingFeature[inventory[selectedItem].shoot])
		{
			altFunctionUse = 1;
			controlUseItem = true;
		}
		if (flag2 && altFunctionUse == 0 && ItemLoader.AltFunctionUse(inventory[selectedItem], this))
		{
			altFunctionUse = 1;
			controlUseItem = true;
		}
		if (!controlUseItem && altFunctionUse == 1)
		{
			altFunctionUse = 0;
		}
		ItemCheck_ManageRightClickFeatures_ShieldRaise(flag);
	}

	public void ItemCheck_ManageRightClickFeatures_ShieldRaise(bool theGeneralCheck)
	{
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_0159: Unknown result type (might be due to invalid IL or missing references)
		//IL_0163: Unknown result type (might be due to invalid IL or missing references)
		//IL_0168: Unknown result type (might be due to invalid IL or missing references)
		bool mouseRight = PlayerInput.Triggers.JustPressed.MouseRight;
		if (whoAmI != Main.myPlayer)
		{
			mouseRight = shieldRaised;
			theGeneralCheck = shieldRaised;
		}
		bool shouldGuard = false;
		bool flag = inventory[selectedItem].type == 3823 || inventory[selectedItem].type == 4760;
		if (theGeneralCheck && flag && hasRaisableShield && !mount.Active && (itemAnimation == 0 || mouseRight))
		{
			shouldGuard = true;
		}
		if (shield_parry_cooldown > 0)
		{
			shield_parry_cooldown--;
			if (shield_parry_cooldown == 0)
			{
				SoundEngine.PlaySound(25, base.Center);
				for (int i = 0; i < 10; i++)
				{
					int num = Dust.NewDust(base.Center + new Vector2((float)(direction * 6 + ((direction == -1) ? (-10) : 0)), -14f), 10, 16, 45, 0f, 0f, 255, new Color(255, 100, 0, 127), (float)Main.rand.Next(10, 16) * 0.1f);
					Main.dust[num].noLight = true;
					Main.dust[num].noGravity = true;
					Dust obj = Main.dust[num];
					obj.velocity *= 0.5f;
				}
			}
		}
		if (shieldParryTimeLeft > 0 && ++shieldParryTimeLeft > 20)
		{
			shieldParryTimeLeft = 0;
		}
		TryTogglingShield(shouldGuard);
	}

	public void TryTogglingShield(bool shouldGuard)
	{
		if (shouldGuard == shieldRaised)
		{
			return;
		}
		shieldRaised = shouldGuard;
		if (shieldRaised)
		{
			if (shield_parry_cooldown == 0)
			{
				shieldParryTimeLeft = 1;
			}
			itemAnimation = 0;
			itemTime = 0;
			reuseDelay = 0;
		}
		else
		{
			shield_parry_cooldown = 15;
			shieldParryTimeLeft = 0;
			ApplyAttackCooldown(20);
		}
	}

	private void HandleHotbar()
	{
		int num = PlayerInput.Triggers.Current.HotbarPlus.ToInt() - PlayerInput.Triggers.Current.HotbarMinus.ToInt();
		if (PlayerInput.CurrentProfile.HotbarAllowsRadial && num != 0 && PlayerInput.Triggers.Current.HotbarHoldTime > PlayerInput.CurrentProfile.HotbarRadialHoldTimeRequired && PlayerInput.CurrentProfile.HotbarRadialHoldTimeRequired != -1)
		{
			PlayerInput.MiscSettingsTEMP.HotbarRadialShouldBeUsed = true;
			PlayerInput.Triggers.Current.HotbarScrollCD = 2;
		}
		if (PlayerInput.CurrentProfile.HotbarRadialHoldTimeRequired != -1)
		{
			num = PlayerInput.Triggers.JustReleased.HotbarPlus.ToInt() - PlayerInput.Triggers.JustReleased.HotbarMinus.ToInt();
			if (PlayerInput.Triggers.Current.HotbarScrollCD == 1 && num != 0)
			{
				num = 0;
			}
		}
		if (PlayerInput.Triggers.Current.HotbarScrollCD == 0 && num != 0)
		{
			HotbarOffset += num;
			PlayerInput.Triggers.Current.HotbarScrollCD = 8;
		}
		if (!Main.inFancyUI && !Main.ingameOptionsWindow)
		{
			HotbarOffset += PlayerInput.ScrollWheelDelta / -120;
		}
		ScrollHotbar(HotbarOffset);
		HotbarOffset = 0;
	}

	private void ItemCheckWrapped(int i)
	{
		int num;
		if (!controlLeft && !controlRight && !controlUp && !controlDown && PlayerInput.UsingGamepad && Main.SmartCursorIsUsed)
		{
			num = ((((Vector2)(ref PlayerInput.GamepadThumbstickRight)).Length() < 0.05f) ? 1 : 0);
			if (num != 0)
			{
				ForceForwardCursor(state: true);
			}
		}
		else
		{
			num = 0;
		}
		int num2;
		if (PlayerInput.smartSelectPointer.ShouldBeUsed())
		{
			num2 = ((!Main.SmartCursorIsUsed) ? 1 : 0);
			if (num2 != 0)
			{
				ForceSmartSelectCursor(state: true);
			}
		}
		else
		{
			num2 = 0;
		}
		LockOnHelper.SetUP();
		int stack = inventory[selectedItem].stack;
		if (Main.ignoreErrors)
		{
			ItemCheck();
		}
		else
		{
			ItemCheck();
		}
		if (stack != inventory[selectedItem].stack)
		{
			Recipe.FindRecipes();
		}
		LockOnHelper.SetDOWN();
		if (num2 != 0)
		{
			ForceSmartSelectCursor(state: false);
		}
		if (num != 0)
		{
			ForceForwardCursor(state: false);
		}
		if (itemAnimation == 0)
		{
			lastVisualizedSelectedItem = HeldItem.Clone();
		}
	}

	private void ForceForwardCursor(bool state)
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		if (state != _forceForwardCursor)
		{
			_forceForwardCursor = state;
			if (state)
			{
				_inputMouseCoordsForward = new Point(PlayerInput.MouseX, PlayerInput.MouseY);
				_mainMouseCoordsForward = new Point(Main.mouseX, Main.mouseY);
				Point val = (base.Center - Main.screenPosition + new Vector2((float)(direction * 200), 0f)).ToPoint();
				Main.mouseX = (PlayerInput.MouseX = val.X);
				Main.mouseY = (PlayerInput.MouseY = val.Y);
			}
			else
			{
				PlayerInput.MouseX = _inputMouseCoordsForward.X;
				PlayerInput.MouseY = _inputMouseCoordsForward.Y;
				Main.mouseX = _mainMouseCoordsForward.X;
				Main.mouseY = _mainMouseCoordsForward.Y;
			}
		}
	}

	private void ForceSmartSelectCursor(bool state)
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		if (state != _forceSmartSelectCursor)
		{
			_forceSmartSelectCursor = state;
			if (state)
			{
				_inputMouseCoordsSmartSelect = new Point(PlayerInput.MouseX, PlayerInput.MouseY);
				_mainMouseCoordsSmartSelect = new Point(Main.mouseX, Main.mouseY);
				_tileTargetSmartSelect = new Point(tileTargetX, tileTargetY);
				Point val = PlayerInput.smartSelectPointer.GetPointerPosition().ToPoint();
				Main.mouseX = (PlayerInput.MouseX = val.X);
				Main.mouseY = (PlayerInput.MouseY = val.Y);
				Point val2 = (val.ToVector2() + Main.screenPosition).ToTileCoordinates();
				tileTargetX = val2.X;
				tileTargetY = val2.Y;
			}
			else
			{
				PlayerInput.MouseX = _inputMouseCoordsSmartSelect.X;
				PlayerInput.MouseY = _inputMouseCoordsSmartSelect.Y;
				Main.mouseX = _mainMouseCoordsSmartSelect.X;
				Main.mouseY = _mainMouseCoordsSmartSelect.Y;
				tileTargetX = _tileTargetSmartSelect.X;
				tileTargetY = _tileTargetSmartSelect.Y;
			}
		}
	}

	public void ScrollHotbar(int Offset)
	{
		if (selectedItem >= 10)
		{
			return;
		}
		Offset = ClampHotbarOffset(Offset);
		selectedItem += Offset;
		if (Offset != 0)
		{
			SoundEngine.PlaySound(12);
			int num = selectedItem - Offset;
			DpadRadial.ChangeSelection(-1);
			CircularRadial.ChangeSelection(-1);
			selectedItem = num + Offset;
			nonTorch = -1;
		}
		if (changeItem >= 0)
		{
			if (selectedItem != changeItem)
			{
				SoundEngine.PlaySound(12);
			}
			selectedItem = changeItem;
			changeItem = -1;
		}
		if (itemAnimation == 0 && selectedItem != 58)
		{
			while (selectedItem > 9)
			{
				selectedItem -= 10;
			}
			while (selectedItem < 0)
			{
				selectedItem += 10;
			}
		}
	}

	private static int ClampHotbarOffset(int Offset)
	{
		while (Offset > 9)
		{
			Offset -= 10;
		}
		while (Offset < 0)
		{
			Offset += 10;
		}
		return Offset;
	}

	public List<int> GetListOfProjectilesToInteractWithHack()
	{
		return _projectilesToInteractWith;
	}

	public void LockGamepadTileInteractions()
	{
		releaseUseTile = false;
		_lockTileInteractionsTimer = 3;
		PlayerInput.LockGamepadTileUseButton = true;
	}

	public void LookForTileInteractions()
	{
		if (Main.netMode == 2 || Main.myPlayer != whoAmI || Main.mapFullscreen || Main.InGameUI.CurrentState == Main.BestiaryUI)
		{
			return;
		}
		int smartInteractX = tileTargetX;
		int smartInteractY = tileTargetY;
		if (Main.SmartInteractShowingGenuine && Main.SmartInteractNPC == -1 && Main.SmartInteractProj == -1)
		{
			smartInteractX = Main.SmartInteractX;
			smartInteractY = Main.SmartInteractY;
		}
		bool flag = controlUseTile;
		if (PlayerInput.UsingGamepad && Main.HoveringOverAnNPC)
		{
			flag = false;
		}
		if (Main.gamePaused)
		{
			flag = false;
		}
		if (releaseUseTile)
		{
			tileInteractionHappened = false;
		}
		tileInteractAttempted = flag;
		if (tileInteractAttempted && releaseUseTile)
		{
			if (Main.instance.currentNPCShowingChatBubble > -1 && (talkNPC == -1 || !Main.npcChatRelease))
			{
				tileInteractAttempted = true;
				releaseUseTile = false;
			}
			if (Main.HasInteractibleObjectThatIsNotATile)
			{
				tileInteractAttempted = true;
				releaseUseTile = false;
			}
		}
		if (IsInTileInteractionRange(smartInteractX, smartInteractY, TileReachCheckSettings.Simple))
		{
			TileInteractionsCheckLongDistance(tileTargetX, tileTargetY);
			TileInteractionsCheck(smartInteractX, smartInteractY);
		}
		else
		{
			TileInteractionsCheckLongDistance(smartInteractX, smartInteractY);
		}
		TryInteractingWithMinecartTrackInNearbyArea(smartInteractX, smartInteractY);
	}

	private void TryInteractingWithMinecartTrackInNearbyArea(int selectedTargetX, int selectedTargetY)
	{
		if ((mount.Active && MountID.Sets.Cart[mount.Type]) || !botherWithUnaimedMinecartTracks || tileInteractionHappened || Main.SmartInteractShowingGenuine || Main.SmartInteractNPC != -1 || Main.SmartInteractProj != -1 || !WorldGen.InWorld(selectedTargetX, selectedTargetY, 10) || gravDir != 1f)
		{
			return;
		}
		int num = 2;
		for (int i = selectedTargetX - num; i <= selectedTargetX + num; i++)
		{
			for (int j = selectedTargetY - num; j <= selectedTargetY + num; j++)
			{
				if (!IsInTileInteractionRange(i, j, TileReachCheckSettings.Simple))
				{
					continue;
				}
				Tile tile = Main.tile[i, j];
				if (tile == null)
				{
					continue;
				}
				if (tile.active() && tile.type == 314)
				{
					if (!cursorItemIconEnabled)
					{
						noThrow = 2;
						cursorItemIconEnabled = true;
						cursorItemIconID = 2343;
					}
					if (tileInteractAttempted)
					{
						TileInteractionsCheck(i, j);
					}
				}
				if (tileInteractionHappened)
				{
					return;
				}
			}
		}
	}

	public bool InInteractionRange(int interactX, int interactY, TileReachCheckSettings settings)
	{
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		int num = (int)(((double)position.X + (double)width * 0.5) / 16.0);
		int num2 = (int)(((double)position.Y + (double)height * 0.5) / 16.0);
		Tile tile = Main.tile[interactX, interactY];
		settings.GetRanges(this, out var x, out var y);
		if (tile.type == 597)
		{
			if (interactX < num)
			{
				interactX += 2;
			}
			if (interactY < num2)
			{
				interactY += 3;
			}
			Point val = position.ToTileCoordinates();
			Point val2 = base.BottomRight.ToTileCoordinates();
			if (val2.X >= interactX - x + 1 && val.X <= interactX + x - 1 && val2.Y >= interactY - y + 2)
			{
				return val.Y <= interactY + y - 1;
			}
			return false;
		}
		if (tile.type == 475)
		{
			if (num >= interactX - x - 1 && num <= interactX + x + 2 && num2 >= interactY - y - 1)
			{
				return num2 <= interactY + y + 2;
			}
			return false;
		}
		if (tile.type == 470)
		{
			if (num >= interactX - x - 1 && num <= interactX + x + 1 && num2 >= interactY - y - 1)
			{
				return num2 <= interactY + y + 2;
			}
			return false;
		}
		if (num >= interactX - x && num <= interactX + x + 1 && num2 >= interactY - y)
		{
			return num2 <= interactY + y + 1;
		}
		return false;
	}

	public bool IsInTileInteractionRange(int targetX, int targetY, TileReachCheckSettings settings)
	{
		settings.GetRanges(this, out var x, out var y);
		if (position.X / 16f - (float)x <= (float)targetX && (position.X + (float)width) / 16f + (float)x - 1f >= (float)targetX && position.Y / 16f - (float)y <= (float)targetY)
		{
			return (position.Y + (float)height) / 16f + (float)y - 2f >= (float)targetY;
		}
		return false;
	}

	public void TileInteractionsCheck(int myX, int myY)
	{
		if (Main.tile[myX, myY] == null)
		{
			Main.tile[myX, myY] = default(Tile);
		}
		if (Main.tile[myX, myY].active())
		{
			TileInteractionsMouseOver(myX, myY);
			TileInteractionsUse(myX, myY);
		}
	}

	private void TileInteractionsCheckLongDistance(int myX, int myY)
	{
		if (!WorldGen.InWorld(myX, myY, 10) || Main.tile[myX, myY] == null || !Main.tile[myX, myY].active())
		{
			return;
		}
		if (TileID.Sets.BasicChest[Main.tile[myX, myY].type])
		{
			TileInteractionsMouseOver_Containers(myX, myY);
			if (cursorItemIconText == "")
			{
				cursorItemIconEnabled = false;
				cursorItemIconID = 0;
			}
		}
		if (Main.tile[myX, myY].type == 88)
		{
			Tile tile = Main.tile[myX, myY];
			int num = myY;
			int x = myX - tile.frameX % 54 / 18;
			if (tile.frameY % 36 != 0)
			{
				num--;
			}
			int num2 = Chest.FindChest(x, num);
			cursorItemIconID = -1;
			if (num2 < 0)
			{
				cursorItemIconText = Lang.dresserType[0].Value;
			}
			else
			{
				if (Main.chest[num2].name != "")
				{
					cursorItemIconText = Main.chest[num2].name;
				}
				else
				{
					cursorItemIconText = Lang.dresserType[tile.frameX / 54].Value;
				}
				if (cursorItemIconText == Lang.dresserType[tile.frameX / 54].Value)
				{
					cursorItemIconID = Chest.dresserTypeToIcon[tile.frameX / 54];
					cursorItemIconText = "";
				}
			}
			noThrow = 2;
			cursorItemIconEnabled = true;
			if (cursorItemIconText == "")
			{
				cursorItemIconEnabled = false;
				cursorItemIconID = 0;
			}
		}
		if (Main.tileSign[Main.tile[myX, myY].type])
		{
			noThrow = 2;
			int num3 = Main.tile[myX, myY].frameX / 18;
			int num4 = Main.tile[myX, myY].frameY / 18;
			num3 %= 2;
			int num5 = myX - num3;
			int num6 = myY - num4;
			Main.signBubble = true;
			Main.signX = num5 * 16 + 16;
			Main.signY = num6 * 16;
			int num7 = Sign.ReadSign(num5, num6, CreateIfMissing: false);
			if (num7 != -1 && tileTargetX >= num5 && tileTargetY >= num6 && tileTargetX <= num5 + 1 && tileTargetY <= num6 + 1)
			{
				Main.signHover = num7;
				cursorItemIconEnabled = false;
				cursorItemIconID = -1;
			}
		}
		TileLoader.MouseOverFar(myX, myY);
	}

	private void TileInteractionsUse(int myX, int myY)
	{
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_06d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_06f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0738: Unknown result type (might be due to invalid IL or missing references)
		//IL_11bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_11c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_1207: Unknown result type (might be due to invalid IL or missing references)
		//IL_1212: Unknown result type (might be due to invalid IL or missing references)
		//IL_1253: Unknown result type (might be due to invalid IL or missing references)
		//IL_125e: Unknown result type (might be due to invalid IL or missing references)
		//IL_129f: Unknown result type (might be due to invalid IL or missing references)
		//IL_12aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_12eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_12f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_1334: Unknown result type (might be due to invalid IL or missing references)
		//IL_133f: Unknown result type (might be due to invalid IL or missing references)
		//IL_138f: Unknown result type (might be due to invalid IL or missing references)
		//IL_139a: Unknown result type (might be due to invalid IL or missing references)
		//IL_13ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_13f5: Unknown result type (might be due to invalid IL or missing references)
		if (WiresUI.Open || ownedProjectileCounts[651] > 0)
		{
			return;
		}
		bool flag = releaseUseTile;
		if (!tileInteractAttempted)
		{
			return;
		}
		bool flag2 = false;
		Tile tile = Main.tile[myX, myY];
		if (tile.type == 212 && snowBallLauncherInteractionCooldown <= 0)
		{
			flag2 = true;
			snowBallLauncherInteractionCooldown = 7;
			SoundEngine.PlaySound(in SoundID.Item11, position);
			tile = Main.tile[myX, myY];
			int num = tile.frameX / 18;
			int num2 = 0;
			while (num >= 3)
			{
				num2++;
				num -= 3;
			}
			num = myX - num;
			tile = Main.tile[myX, myY];
			int num3;
			for (num3 = tile.frameY / 18; num3 >= 3; num3 -= 3)
			{
			}
			num3 = myY - num3;
			float num4 = 12f + (float)Main.rand.Next(450) * 0.01f;
			float num5 = Main.rand.Next(85, 105);
			float num6 = Main.rand.Next(-35, 11);
			int type = 166;
			int damage = 35;
			float knockBack = 3.5f;
			Vector2 val = default(Vector2);
			((Vector2)(ref val))..ctor((float)((num + 2) * 16 - 8), (float)((num3 + 2) * 16 - 8 - 4));
			if (num2 == 0)
			{
				num5 *= -1f;
				val.X -= 14f;
				val.X -= 2f;
			}
			else
			{
				val.X += 14f;
			}
			float num7 = num5;
			float num8 = num6;
			float num9 = (float)Math.Sqrt(num7 * num7 + num8 * num8);
			num9 = num4 / num9;
			num7 *= num9;
			num8 *= num9;
			int num10 = Projectile.NewProjectile(GetProjectileSource_TileInteraction(num, num3), val.X, val.Y, num7, num8, type, damage, knockBack, Main.myPlayer, -Main.rand.Next(0, 16));
			Main.projectile[num10].originatedFromActivableTile = true;
		}
		if (flag)
		{
			tile = Main.tile[myX, myY];
			if (tile.type != 132)
			{
				tile = Main.tile[myX, myY];
				if (tile.type != 136)
				{
					tile = Main.tile[myX, myY];
					if (tile.type != 144)
					{
						tile = Main.tile[myX, myY];
						if (tile.type == 597)
						{
							flag2 = true;
							TryOpeningFullscreenMap();
						}
						else
						{
							tile = Main.tile[myX, myY];
							if (tile.type != 441)
							{
								tile = Main.tile[myX, myY];
								if (tile.type != 468)
								{
									tile = Main.tile[myX, myY];
									if (tile.type == 139 || TileLoader.IsModMusicBox(Main.tile[myX, myY]))
									{
										flag2 = true;
										SoundEngine.PlaySound(28, myX * 16, myY * 16, 0);
										WorldGen.SwitchMB(myX, myY);
									}
									else
									{
										tile = Main.tile[myX, myY];
										if (tile.type == 215)
										{
											flag2 = true;
											SoundEngine.PlaySound(28, myX * 16, myY * 16, 0);
											tile = Main.tile[myX, myY];
											int num11 = tile.frameX % 54 / 18;
											tile = Main.tile[myX, myY];
											int num12 = tile.frameY % 36 / 18;
											int num13 = myX - num11;
											int num14 = myY - num12;
											int num15 = 36;
											tile = Main.tile[num13, num14];
											if (tile.frameY >= 36)
											{
												num15 = -36;
											}
											for (int i = num13; i < num13 + 3; i++)
											{
												for (int j = num14; j < num14 + 2; j++)
												{
													tile = Main.tile[i, j];
													ref short frameY = ref tile.frameY;
													tile = Main.tile[i, j];
													frameY = (short)(tile.frameY + num15);
												}
											}
											NetMessage.SendTileSquare(-1, num13, num14, 3, 2);
										}
										else
										{
											tile = Main.tile[myX, myY];
											if (tile.type == 207)
											{
												flag2 = true;
												SoundEngine.PlaySound(28, myX * 16, myY * 16, 0);
												WorldGen.SwitchFountain(myX, myY);
											}
											else
											{
												tile = Main.tile[myX, myY];
												if (tile.type != 410)
												{
													tile = Main.tile[myX, myY];
													if (tile.type != 480)
													{
														tile = Main.tile[myX, myY];
														if (tile.type != 509)
														{
															tile = Main.tile[myX, myY];
															if (tile.type != 657)
															{
																tile = Main.tile[myX, myY];
																if (tile.type != 658)
																{
																	tile = Main.tile[myX, myY];
																	if (tile.type == 455)
																	{
																		flag2 = true;
																		SoundEngine.PlaySound(28, myX * 16, myY * 16, 0);
																		GamepadEnableGrappleCooldown();
																		BirthdayParty.ToggleManualParty();
																	}
																	else
																	{
																		tile = Main.tile[myX, myY];
																		if (tile.type == 216)
																		{
																			flag2 = true;
																			WorldGen.LaunchRocket(myX, myY, fromWiring: false);
																		}
																		else
																		{
																			tile = Main.tile[myX, myY];
																			if (tile.type != 386)
																			{
																				tile = Main.tile[myX, myY];
																				if (tile.type != 387)
																				{
																					tile = Main.tile[myX, myY];
																					if (tile.type != 388)
																					{
																						tile = Main.tile[myX, myY];
																						if (tile.type != 389)
																						{
																							tile = Main.tile[myX, myY];
																							if (tile.type != 15)
																							{
																								tile = Main.tile[myX, myY];
																								if (tile.type != 497)
																								{
																									tile = Main.tile[myX, myY];
																									if (tile.type != 89)
																									{
																										tile = Main.tile[myX, myY];
																										if (tile.type != 102)
																										{
																											tile = Main.tile[myX, myY];
																											if (tile.type != 487)
																											{
																												tile = Main.tile[myX, myY];
																												if (tile.type == 335)
																												{
																													flag2 = true;
																													WorldGen.LaunchRocketSmall(myX, myY, fromWiring: false);
																												}
																												else
																												{
																													tile = Main.tile[myX, myY];
																													if (tile.type == 411)
																													{
																														tile = Main.tile[myX, myY];
																														if (tile.frameX < 36)
																														{
																															flag2 = true;
																															Wiring.HitSwitch(myX, myY);
																															NetMessage.SendData(59, -1, -1, null, myX, myY);
																															goto IL_295e;
																														}
																													}
																													tile = Main.tile[myX, myY];
																													if (tile.type == 494)
																													{
																														flag2 = true;
																														for (int k = 0; k < 1000; k++)
																														{
																															if (ProjectileID.Sets.IsAGolfBall[Main.projectile[k].type] && Main.projectile[k].owner == whoAmI)
																															{
																																Main.projectile[k].Kill();
																															}
																														}
																														GetPreferredGolfBallToUse(out var projType);
																														Projectile.NewProjectile(GetProjectileSource_TileInteraction(myX, myY), (float)(myX * 16) + 8.5f, myY * 16 + 6, 0f, 0f, projType, 0, 0f, whoAmI, 0f, -1f);
																													}
																													else
																													{
																														tile = Main.tile[myX, myY];
																														if (tile.type == 338)
																														{
																															flag2 = true;
																															int num16 = myY;
																															tile = Main.tile[myX, num16];
																															if (tile.frameY == 18)
																															{
																																num16--;
																															}
																															bool flag3 = false;
																															for (int l = 0; l < 1000; l++)
																															{
																																if (Main.projectile[l].active && Main.projectile[l].aiStyle == 73 && Main.projectile[l].ai[0] == (float)myX && Main.projectile[l].ai[1] == (float)num16)
																																{
																																	flag3 = true;
																																	break;
																																}
																															}
																															if (!flag3)
																															{
																																int num17 = Projectile.NewProjectile(GetProjectileSource_TileInteraction(myX, num16), myX * 16 + 8, num16 * 16 + 2, 0f, 0f, 419 + Main.rand.Next(4), 0, 0f, whoAmI, myX, num16);
																																Main.projectile[num17].originatedFromActivableTile = true;
																															}
																														}
																														else
																														{
																															tile = Main.tile[myX, myY];
																															if (tile.type != 33)
																															{
																																tile = Main.tile[myX, myY];
																																if (tile.type != 49)
																																{
																																	tile = Main.tile[myX, myY];
																																	if (tile.type != 372)
																																	{
																																		tile = Main.tile[myX, myY];
																																		if (tile.type != 174)
																																		{
																																			tile = Main.tile[myX, myY];
																																			if (tile.type != 646)
																																			{
																																				bool[] torch = TileID.Sets.Torch;
																																				tile = Main.tile[myX, myY];
																																				if (!torch[tile.type])
																																				{
																																					tile = Main.tile[myX, myY];
																																					if (tile.type != 13)
																																					{
																																						tile = Main.tile[myX, myY];
																																						if (tile.type == 50)
																																						{
																																							tile = Main.tile[myX, myY];
																																							if (tile.frameX == 90)
																																							{
																																								goto IL_0c62;
																																							}
																																						}
																																						bool[] canDropFromRightClick = TileID.Sets.CanDropFromRightClick;
																																						tile = Main.tile[myX, myY];
																																						if (!canDropFromRightClick[tile.type])
																																						{
																																							tile = Main.tile[myX, myY];
																																							if (tile.type == 466)
																																							{
																																								flag2 = true;
																																								GamepadEnableGrappleCooldown();
																																								int num18 = myY;
																																								Tile tileSafely = Framing.GetTileSafely(myX, myY);
																																								if (tileSafely.frameY == 0)
																																								{
																																									num18 += 3;
																																								}
																																								if (tileSafely.frameY == 18)
																																								{
																																									num18 += 2;
																																								}
																																								if (tileSafely.frameY == 36)
																																								{
																																									num18++;
																																								}
																																								if (DD2Event.Ongoing)
																																								{
																																									DD2Event.RequestToSkipWaitTime(myX, myY);
																																								}
																																								else
																																								{
																																									bool flag4 = !DD2Event.Ongoing && !NPC.AnyNPCs(548) && !Main.pumpkinMoon && !Main.snowMoon;
																																									if (flag4)
																																									{
																																										flag4 = HasItem(3828);
																																									}
																																									if (flag4)
																																									{
																																										flag4 = !DD2Event.WouldFailSpawningHere(myX, num18);
																																										if (!flag4)
																																										{
																																											DD2Event.FailureMessage(-1);
																																										}
																																									}
																																									if (flag4)
																																									{
																																										flag4 = ConsumeItem(3828, reverseOrder: true);
																																									}
																																									if (flag4)
																																									{
																																										DD2Event.SummonCrystal(myX, num18, whoAmI);
																																									}
																																								}
																																							}
																																							else
																																							{
																																								tile = Main.tile[myX, myY];
																																								if (tile.type == 334)
																																								{
																																									flag2 = true;
																																									if (ItemFitsWeaponRack(inventory[selectedItem]))
																																									{
																																										GamepadEnableGrappleCooldown();
																																										PlaceWeapon(myX, myY);
																																									}
																																									else
																																									{
																																										int num19 = myX;
																																										int num20 = myY;
																																										tile = Main.tile[myX, myY];
																																										if (tile.frameY == 0)
																																										{
																																											num20++;
																																										}
																																										tile = Main.tile[myX, myY];
																																										if (tile.frameY == 36)
																																										{
																																											num20--;
																																										}
																																										tile = Main.tile[myX, num20];
																																										int frameX = tile.frameX;
																																										tile = Main.tile[myX, num20];
																																										int num21 = tile.frameX;
																																										int num22 = 0;
																																										while (num21 >= 5000)
																																										{
																																											num21 -= 5000;
																																											num22++;
																																										}
																																										if (num22 != 0)
																																										{
																																											num21 = (num22 - 1) * 18;
																																										}
																																										num21 %= 54;
																																										if (num21 == 18)
																																										{
																																											tile = Main.tile[myX - 1, num20];
																																											frameX = tile.frameX;
																																											num19--;
																																										}
																																										if (num21 == 36)
																																										{
																																											tile = Main.tile[myX - 2, num20];
																																											frameX = tile.frameX;
																																											num19 -= 2;
																																										}
																																										if (frameX >= 5000)
																																										{
																																											GamepadEnableGrappleCooldown();
																																											WorldGen.KillTile(myX, num20, fail: true);
																																											if (Main.netMode == 1)
																																											{
																																												NetMessage.SendData(17, -1, -1, null, 0, myX, num20, 1f);
																																											}
																																										}
																																									}
																																								}
																																								else
																																								{
																																									tile = Main.tile[myX, myY];
																																									if (tile.type == 440)
																																									{
																																										flag2 = true;
																																										tile = Main.tile[myX, myY];
																																										int num23 = tile.frameX / 54;
																																										tile = Main.tile[myX, myY];
																																										int num24 = tile.frameY / 54;
																																										tile = Main.tile[myX, myY];
																																										_ = tile.frameX % 54 / 18;
																																										tile = Main.tile[myX, myY];
																																										_ = tile.frameY % 54 / 18;
																																										int num25 = -1;
																																										switch (num23)
																																										{
																																										case 0:
																																											num25 = 1526;
																																											break;
																																										case 1:
																																											num25 = 1524;
																																											break;
																																										case 2:
																																											num25 = 1525;
																																											break;
																																										case 3:
																																											num25 = 1523;
																																											break;
																																										case 4:
																																											num25 = 1522;
																																											break;
																																										case 5:
																																											num25 = 1527;
																																											break;
																																										case 6:
																																											num25 = 3643;
																																											break;
																																										}
																																										if (num25 != -1)
																																										{
																																											if (num24 == 0 && HasItem(num25) && selectedItem != 58)
																																											{
																																												GamepadEnableGrappleCooldown();
																																												if (Main.netMode != 1)
																																												{
																																													ConsumeItem(num25);
																																													WorldGen.ToggleGemLock(myX, myY, on: true);
																																												}
																																												else
																																												{
																																													ConsumeItem(num25);
																																													NetMessage.SendData(105, -1, -1, null, myX, myY, 1f);
																																												}
																																											}
																																											else if (num24 == 1)
																																											{
																																												GamepadEnableGrappleCooldown();
																																												if (Main.netMode != 1)
																																												{
																																													WorldGen.ToggleGemLock(myX, myY, on: false);
																																												}
																																												else
																																												{
																																													NetMessage.SendData(105, -1, -1, null, myX, myY);
																																												}
																																											}
																																										}
																																									}
																																									else
																																									{
																																										tile = Main.tile[myX, myY];
																																										if (tile.type == 395)
																																										{
																																											flag2 = true;
																																											TEItemFrame.OnPlayerInteraction(this, myX, myY);
																																										}
																																										else
																																										{
																																											tile = Main.tile[myX, myY];
																																											if (tile.type == 520)
																																											{
																																												flag2 = true;
																																												TEFoodPlatter.OnPlayerInteraction(this, myX, myY);
																																											}
																																											else
																																											{
																																												tile = Main.tile[myX, myY];
																																												if (tile.type == 471)
																																												{
																																													flag2 = true;
																																													TEWeaponsRack.OnPlayerInteraction(this, myX, myY);
																																												}
																																												else
																																												{
																																													tile = Main.tile[myX, myY];
																																													if (tile.type == 470)
																																													{
																																														flag2 = true;
																																														TEDisplayDoll.OnPlayerInteraction(this, myX, myY);
																																													}
																																													else
																																													{
																																														tile = Main.tile[myX, myY];
																																														if (tile.type == 475)
																																														{
																																															flag2 = true;
																																															TEHatRack.OnPlayerInteraction(this, myX, myY);
																																														}
																																														else
																																														{
																																															tile = Main.tile[myX, myY];
																																															if (tile.type == 125)
																																															{
																																																flag2 = true;
																																																AddBuff(29, 108000);
																																																SoundEngine.PlaySound(in SoundID.Item4, position);
																																															}
																																															else
																																															{
																																																tile = Main.tile[myX, myY];
																																																if (tile.type == 621)
																																																{
																																																	flag2 = true;
																																																	AddBuff(192, 7200);
																																																	SoundEngine.PlaySound(in SoundID.Item2, position);
																																																}
																																																else
																																																{
																																																	tile = Main.tile[myX, myY];
																																																	if (tile.type == 464)
																																																	{
																																																		flag2 = true;
																																																		AddBuff(348, 108000);
																																																		SoundEngine.PlaySound(in SoundID.Item4, position);
																																																	}
																																																	else
																																																	{
																																																		tile = Main.tile[myX, myY];
																																																		if (tile.type == 377)
																																																		{
																																																			flag2 = true;
																																																			AddBuff(159, 108000);
																																																			SoundEngine.PlaySound(in SoundID.Item37, position);
																																																		}
																																																		else
																																																		{
																																																			tile = Main.tile[myX, myY];
																																																			if (tile.type == 354)
																																																			{
																																																				flag2 = true;
																																																				AddBuff(150, 108000);
																																																				SoundEngine.PlaySound(in SoundID.Item4, position);
																																																			}
																																																			else
																																																			{
																																																				tile = Main.tile[myX, myY];
																																																				if (tile.type == 287)
																																																				{
																																																					flag2 = true;
																																																					AddBuff(93, 108000);
																																																					SoundEngine.PlaySound(in SoundID.Item149, position);
																																																				}
																																																				else
																																																				{
																																																					tile = Main.tile[myX, myY];
																																																					if (tile.type == 356)
																																																					{
																																																						flag2 = true;
																																																						if (!Main.fastForwardTimeToDawn && (Main.netMode == 1 || Main.sundialCooldown == 0))
																																																						{
																																																							Main.Sundialing();
																																																							SoundEngine.PlaySound(in SoundID.Item4, position);
																																																						}
																																																					}
																																																					else
																																																					{
																																																						tile = Main.tile[myX, myY];
																																																						if (tile.type == 663)
																																																						{
																																																							flag2 = true;
																																																							if (!Main.fastForwardTimeToDusk && (Main.netMode == 1 || Main.moondialCooldown == 0))
																																																							{
																																																								Main.Moondialing();
																																																								SoundEngine.PlaySound(in SoundID.Item4, position);
																																																							}
																																																						}
																																																						else
																																																						{
																																																							tile = Main.tile[myX, myY];
																																																							if (tile.type == 79)
																																																							{
																																																								flag2 = true;
																																																								int num26 = myX;
																																																								int num27 = myY;
																																																								int num28 = num26;
																																																								tile = Main.tile[myX, myY];
																																																								num26 = num28 + tile.frameX / 18 * -1;
																																																								tile = Main.tile[myX, myY];
																																																								if (tile.frameX >= 72)
																																																								{
																																																									num26 += 4;
																																																									num26++;
																																																								}
																																																								else
																																																								{
																																																									num26 += 2;
																																																								}
																																																								tile = Main.tile[myX, myY];
																																																								int num29 = tile.frameY / 18;
																																																								int num30 = 0;
																																																								while (num29 > 1)
																																																								{
																																																									num29 -= 2;
																																																									num30++;
																																																								}
																																																								num27 -= num29;
																																																								num27 += 2;
																																																								if (!IsHoveringOverABottomSideOfABed(myX, myY))
																																																								{
																																																									if (IsWithinSnappngRangeToTile(myX, myY, 96))
																																																									{
																																																										flag2 = true;
																																																										GamepadEnableGrappleCooldown();
																																																										sleeping.StartSleeping(this, myX, myY);
																																																									}
																																																								}
																																																								else
																																																								{
																																																									FindSpawn();
																																																									if (SpawnX == num26 && SpawnY == num27)
																																																									{
																																																										RemoveSpawn();
																																																										Main.NewText(Language.GetTextValue("Game.SpawnPointRemoved"), byte.MaxValue, 240, 20);
																																																									}
																																																									else if (CheckSpawn(num26, num27))
																																																									{
																																																										ChangeSpawn(num26, num27);
																																																										Main.NewText(Language.GetTextValue("Game.SpawnPointSet"), byte.MaxValue, 240, 20);
																																																									}
																																																								}
																																																							}
																																																							else
																																																							{
																																																								bool[] tileSign = Main.tileSign;
																																																								tile = Main.tile[myX, myY];
																																																								if (tileSign[tile.type])
																																																								{
																																																									flag2 = true;
																																																									bool flag5 = true;
																																																									if (sign >= 0 && Sign.ReadSign(myX, myY, CreateIfMissing: false) == sign)
																																																									{
																																																										sign = -1;
																																																										Main.npcChatText = "";
																																																										Main.editSign = false;
																																																										SoundEngine.PlaySound(11);
																																																										flag5 = false;
																																																									}
																																																									if (flag5)
																																																									{
																																																										if (Main.netMode == 0)
																																																										{
																																																											SetTalkNPC(-1);
																																																											Main.npcChatCornerItem = 0;
																																																											Main.playerInventory = false;
																																																											Main.editSign = false;
																																																											int num31 = Sign.ReadSign(myX, myY);
																																																											if (num31 < 0)
																																																											{
																																																												return;
																																																											}
																																																											SoundEngine.PlaySound(10);
																																																											sign = num31;
																																																											Main.npcChatText = Main.sign[num31].text;
																																																										}
																																																										else
																																																										{
																																																											tile = Main.tile[myX, myY];
																																																											int num32 = tile.frameX / 18;
																																																											tile = Main.tile[myX, myY];
																																																											int num33 = tile.frameY / 18;
																																																											while (num32 > 1)
																																																											{
																																																												num32 -= 2;
																																																											}
																																																											int num34 = myX - num32;
																																																											int num35 = myY - num33;
																																																											bool[] tileSign2 = Main.tileSign;
																																																											tile = Main.tile[num34, num35];
																																																											if (tileSign2[tile.type])
																																																											{
																																																												NetMessage.SendData(46, -1, -1, null, num34, num35);
																																																											}
																																																										}
																																																									}
																																																								}
																																																								else
																																																								{
																																																									tile = Main.tile[myX, myY];
																																																									if (tile.type == 104)
																																																									{
																																																										flag2 = true;
																																																										string textValue = Language.GetTextValue("GameUI.TimeAtMorning");
																																																										double num36 = Main.time;
																																																										if (!Main.dayTime)
																																																										{
																																																											num36 += 54000.0;
																																																										}
																																																										num36 = num36 / 86400.0 * 24.0;
																																																										double num37 = 7.5;
																																																										num36 = num36 - num37 - 12.0;
																																																										if (num36 < 0.0)
																																																										{
																																																											num36 += 24.0;
																																																										}
																																																										if (num36 >= 12.0)
																																																										{
																																																											textValue = Language.GetTextValue("GameUI.TimePastMorning");
																																																										}
																																																										int num38 = (int)num36;
																																																										double num39 = (int)((num36 - (double)num38) * 60.0);
																																																										string text = string.Concat(num39);
																																																										if (num39 < 10.0)
																																																										{
																																																											text = "0" + text;
																																																										}
																																																										if (num38 > 12)
																																																										{
																																																											num38 -= 12;
																																																										}
																																																										if (num38 == 0)
																																																										{
																																																											num38 = 12;
																																																										}
																																																										Main.NewText(Language.GetTextValue("Game.Time", num38 + ":" + text + " " + textValue), byte.MaxValue, 240, 20);
																																																									}
																																																									else
																																																									{
																																																										tile = Main.tile[myX, myY];
																																																										if (tile.type == 237)
																																																										{
																																																											flag2 = true;
																																																											bool flag6 = false;
																																																											if (!NPC.AnyNPCs(245) && Main.hardMode && NPC.downedPlantBoss)
																																																											{
																																																												for (int m = 0; m < 58; m++)
																																																												{
																																																													if (inventory[m].type == 1293)
																																																													{
																																																														if (ItemLoader.ConsumeItem(inventory[m], this))
																																																														{
																																																															inventory[m].stack--;
																																																														}
																																																														if (inventory[m].stack <= 0)
																																																														{
																																																															inventory[m].SetDefaults();
																																																														}
																																																														flag6 = true;
																																																														break;
																																																													}
																																																												}
																																																											}
																																																											if (flag6)
																																																											{
																																																												SoundEngine.PlaySound(15, (int)position.X, (int)position.Y, 0);
																																																												if (Main.netMode != 1)
																																																												{
																																																													NPC.SpawnOnPlayer(whoAmI, 245);
																																																												}
																																																												else
																																																												{
																																																													NetMessage.SendData(61, -1, -1, null, whoAmI, 245f);
																																																												}
																																																											}
																																																										}
																																																										else if (TileLoader.IsClosedDoor(Main.tile[myX, myY]))
																																																										{
																																																											flag2 = true;
																																																											if (WorldGen.IsLockedDoor(myX, myY))
																																																											{
																																																												int num40 = 1141;
																																																												bool flag7 = false;
																																																												for (int n = 0; n < 58; n++)
																																																												{
																																																													if (inventory[n].type == num40 && inventory[n].stack > 0)
																																																													{
																																																														flag7 = true;
																																																														if (ItemLoader.ConsumeItem(inventory[n], this))
																																																														{
																																																															inventory[n].stack--;
																																																														}
																																																														if (inventory[n].stack <= 0)
																																																														{
																																																															inventory[n] = new Item();
																																																														}
																																																														WorldGen.UnlockDoor(myX, myY);
																																																														if (Main.netMode == 1)
																																																														{
																																																															NetMessage.SendData(52, -1, -1, null, whoAmI, 2f, myX, myY);
																																																														}
																																																														break;
																																																													}
																																																												}
																																																												if (!flag7 && useVoidBag())
																																																												{
																																																													for (int num41 = 0; num41 < 40; num41++)
																																																													{
																																																														if (bank4.item[num41].type == num40 && bank4.item[num41].stack > 0)
																																																														{
																																																															bank4.item[num41].stack--;
																																																															if (bank4.item[num41].stack <= 0)
																																																															{
																																																																bank4.item[num41] = new Item();
																																																															}
																																																															WorldGen.UnlockDoor(myX, myY);
																																																															if (Main.netMode == 1)
																																																															{
																																																																NetMessage.SendData(52, -1, -1, null, whoAmI, 2f, myX, myY);
																																																															}
																																																														}
																																																													}
																																																												}
																																																											}
																																																											else
																																																											{
																																																												tile = Main.tile[myX, myY];
																																																												int type2 = tile.type;
																																																												WorldGen.OpenDoor(myX, myY, direction);
																																																												tile = Main.tile[myX, myY];
																																																												if (tile.type != type2)
																																																												{
																																																													NetMessage.SendData(19, -1, -1, null, 0, myX, myY, direction);
																																																												}
																																																												else
																																																												{
																																																													WorldGen.OpenDoor(myX, myY, -direction);
																																																													tile = Main.tile[myX, myY];
																																																													if (tile.type != type2)
																																																													{
																																																														NetMessage.SendData(19, -1, -1, null, 0, myX, myY, -direction);
																																																													}
																																																												}
																																																											}
																																																										}
																																																										else if (TileLoader.CloseDoorID(Main.tile[myX, myY]) >= 0)
																																																										{
																																																											flag2 = true;
																																																											if (WorldGen.CloseDoor(myX, myY))
																																																											{
																																																												NetMessage.SendData(19, -1, -1, null, 1, myX, myY, direction);
																																																											}
																																																										}
																																																										else
																																																										{
																																																											tile = Main.tile[myX, myY];
																																																											if (tile.type == 88)
																																																											{
																																																												flag2 = true;
																																																												tile = Main.tile[myX, myY];
																																																												int num42 = tile.frameX / 18;
																																																												num42 %= 3;
																																																												num42 = myX - num42;
																																																												tile = Main.tile[myX, myY];
																																																												int num43 = myY - tile.frameY / 18;
																																																												tile = Main.tile[myX, myY];
																																																												if (tile.frameY == 0)
																																																												{
																																																													Main.CancelClothesWindow(quiet: true);
																																																													Main.mouseRightRelease = false;
																																																													CloseSign();
																																																													SetTalkNPC(-1);
																																																													Main.npcChatCornerItem = 0;
																																																													Main.npcChatText = "";
																																																													if (Main.editChest)
																																																													{
																																																														SoundEngine.PlaySound(12);
																																																														Main.editChest = false;
																																																														Main.npcChatText = string.Empty;
																																																													}
																																																													if (editedChestName)
																																																													{
																																																														NetMessage.SendData(33, -1, -1, NetworkText.FromLiteral(Main.chest[chest].name), chest, 1f);
																																																														editedChestName = false;
																																																													}
																																																													if (Main.netMode == 1)
																																																													{
																																																														if (num42 == chestX && num43 == chestY && chest != -1)
																																																														{
																																																															chest = -1;
																																																															Recipe.FindRecipes();
																																																															SoundEngine.PlaySound(11);
																																																														}
																																																														else
																																																														{
																																																															NetMessage.SendData(31, -1, -1, null, num42, num43);
																																																															Main.stackSplit = 600;
																																																														}
																																																													}
																																																													else
																																																													{
																																																														piggyBankProjTracker.Clear();
																																																														voidLensChest.Clear();
																																																														int num44 = Chest.FindChest(num42, num43);
																																																														if (num44 != -1)
																																																														{
																																																															Main.stackSplit = 600;
																																																															if (num44 == chest)
																																																															{
																																																																chest = -1;
																																																																Recipe.FindRecipes();
																																																																SoundEngine.PlaySound(11);
																																																															}
																																																															else if (num44 != chest && chest == -1)
																																																															{
																																																																OpenChest(num42, num43, num44);
																																																																SoundEngine.PlaySound(10);
																																																															}
																																																															else
																																																															{
																																																																OpenChest(num42, num43, num44);
																																																																SoundEngine.PlaySound(12);
																																																															}
																																																															Recipe.FindRecipes();
																																																														}
																																																													}
																																																												}
																																																												else
																																																												{
																																																													Main.playerInventory = false;
																																																													chest = -1;
																																																													Recipe.FindRecipes();
																																																													SetTalkNPC(-1);
																																																													Main.npcChatCornerItem = 0;
																																																													Main.npcChatText = "";
																																																													Main.interactedDresserTopLeftX = num42;
																																																													Main.interactedDresserTopLeftY = num43;
																																																													Main.OpenClothesWindow();
																																																												}
																																																											}
																																																											else
																																																											{
																																																												tile = Main.tile[myX, myY];
																																																												if (tile.type == 209)
																																																												{
																																																													flag2 = true;
																																																													Tile tile2 = Main.tile[myX, myY];
																																																													int num45 = tile2.frameX % 72 / 18;
																																																													int num46 = tile2.frameY % 54 / 18;
																																																													int num47 = myX - num45;
																																																													int num48 = myY - num46;
																																																													int num49 = tile2.frameY / 54;
																																																													int num50 = tile2.frameX / 72;
																																																													int num51 = -1;
																																																													if (num45 == 1 || num45 == 2)
																																																													{
																																																														num51 = num46;
																																																													}
																																																													int num52 = 0;
																																																													if (num45 == 3 || (num45 == 2 && num50 != 3 && num50 != 4))
																																																													{
																																																														num52 = -54;
																																																													}
																																																													if (num45 == 0 || (num45 == 1 && num50 != 3 && num50 != 4))
																																																													{
																																																														num52 = 54;
																																																													}
																																																													if (num49 >= 8 && num52 > 0)
																																																													{
																																																														num52 = 0;
																																																													}
																																																													if (num49 == 0 && num52 < 0)
																																																													{
																																																														num52 = 0;
																																																													}
																																																													bool flag8 = false;
																																																													if (num52 != 0)
																																																													{
																																																														for (int num53 = num47; num53 < num47 + 4; num53++)
																																																														{
																																																															for (int num54 = num48; num54 < num48 + 3; num54++)
																																																															{
																																																																tile = Main.tile[num53, num54];
																																																																ref short frameY2 = ref tile.frameY;
																																																																tile = Main.tile[num53, num54];
																																																																frameY2 = (short)(tile.frameY + num52);
																																																															}
																																																														}
																																																														flag8 = true;
																																																													}
																																																													if ((num50 == 3 || num50 == 4) && (num51 == 1 || num51 == 0))
																																																													{
																																																														num52 = ((num50 == 3) ? 72 : (-72));
																																																														for (int num55 = num47; num55 < num47 + 4; num55++)
																																																														{
																																																															for (int num56 = num48; num56 < num48 + 3; num56++)
																																																															{
																																																																tile = Main.tile[num55, num56];
																																																																ref short frameX2 = ref tile.frameX;
																																																																tile = Main.tile[num55, num56];
																																																																frameX2 = (short)(tile.frameX + num52);
																																																															}
																																																														}
																																																														flag8 = true;
																																																													}
																																																													if (flag8)
																																																													{
																																																														NetMessage.SendTileSquare(-1, num47, num48, 4, 3);
																																																													}
																																																													if (num51 != -1)
																																																													{
																																																														bool flag9 = false;
																																																														if ((num50 == 3 || num50 == 4) && num51 == 2)
																																																														{
																																																															flag9 = true;
																																																														}
																																																														if (flag9)
																																																														{
																																																															WorldGen.ShootFromCannon(num47, num48, num49, num50 + 1, 0, 0f, whoAmI, fromWire: false);
																																																														}
																																																													}
																																																												}
																																																												else
																																																												{
																																																													tile = Main.tile[myX, myY];
																																																													if (tile.type != 510)
																																																													{
																																																														tile = Main.tile[myX, myY];
																																																														if (tile.type != 511)
																																																														{
																																																															bool[] basicChest = TileID.Sets.BasicChest;
																																																															tile = Main.tile[myX, myY];
																																																															if (basicChest[tile.type])
																																																															{
																																																																tile = Main.tile[myX, myY];
																																																																if (tile.type < TileID.Count)
																																																																{
																																																																	goto IL_224c;
																																																																}
																																																															}
																																																															tile = Main.tile[myX, myY];
																																																															if (tile.type != 29)
																																																															{
																																																																tile = Main.tile[myX, myY];
																																																																if (tile.type != 97)
																																																																{
																																																																	tile = Main.tile[myX, myY];
																																																																	if (tile.type != 463)
																																																																	{
																																																																		tile = Main.tile[myX, myY];
																																																																		if (tile.type != 491)
																																																																		{
																																																																			tile = Main.tile[myX, myY];
																																																																			if (tile.type == 314 && gravDir == 1f)
																																																																			{
																																																																				flag2 = true;
																																																																				bool flag10 = true;
																																																																				if (mount.Active)
																																																																				{
																																																																					if (mount.Cart)
																																																																					{
																																																																						flag10 = false;
																																																																					}
																																																																					else
																																																																					{
																																																																						mount.Dismount(this);
																																																																					}
																																																																				}
																																																																				if (flag10)
																																																																				{
																																																																					LaunchMinecartHook(myX, myY);
																																																																				}
																																																																			}
																																																																			goto IL_295e;
																																																																		}
																																																																	}
																																																																}
																																																															}
																																																															goto IL_224c;
																																																														}
																																																													}
																																																													flag2 = true;
																																																													Tile tile3 = Main.tile[myX, myY];
																																																													int num57 = tile3.frameX % 36 / 18;
																																																													int num58 = tile3.frameY % 36 / 18;
																																																													int num59 = myX - num57;
																																																													int num60 = myY - num58;
																																																													int num61 = tile3.frameY / 36;
																																																													_ = tile3.frameX / 36;
																																																													int num62 = 0;
																																																													if (num57 == 0)
																																																													{
																																																														num62 = -36;
																																																													}
																																																													if (num57 == 1)
																																																													{
																																																														num62 = 36;
																																																													}
																																																													if (num61 >= 7 && num62 > 0)
																																																													{
																																																														num62 = -252;
																																																													}
																																																													if (num61 == 0 && num62 < 0)
																																																													{
																																																														num62 = 252;
																																																													}
																																																													bool flag11 = false;
																																																													if (num62 != 0)
																																																													{
																																																														for (int num63 = num59; num63 < num59 + 2; num63++)
																																																														{
																																																															for (int num64 = num60; num64 < num60 + 2; num64++)
																																																															{
																																																																tile = Main.tile[num63, num64];
																																																																ref short frameY3 = ref tile.frameY;
																																																																tile = Main.tile[num63, num64];
																																																																frameY3 = (short)(tile.frameY + num62);
																																																															}
																																																														}
																																																														flag11 = true;
																																																													}
																																																													if (flag11)
																																																													{
																																																														NetMessage.SendTileSquare(-1, num59, num60, 2, 2);
																																																													}
																																																												}
																																																											}
																																																										}
																																																									}
																																																								}
																																																							}
																																																						}
																																																					}
																																																				}
																																																			}
																																																		}
																																																	}
																																																}
																																															}
																																														}
																																													}
																																												}
																																											}
																																										}
																																									}
																																								}
																																							}
																																							goto IL_295e;
																																						}
																																					}
																																				}
																																				goto IL_0c62;
																																			}
																																		}
																																	}
																																}
																															}
																															short num65 = 18;
																															Tile tile4 = Main.tile[myX, myY];
																															if (tile4.frameX > 0)
																															{
																																num65 = -18;
																															}
																															tile4.frameX += num65;
																															NetMessage.SendTileSquare(-1, myX, myY);
																															flag2 = true;
																															GamepadEnableGrappleCooldown();
																														}
																													}
																												}
																												goto IL_295e;
																											}
																										}
																									}
																									if (IsWithinSnappngRangeToTile(myX, myY, 40))
																									{
																										flag2 = true;
																										GamepadEnableGrappleCooldown();
																										sitting.SitDown(this, myX, myY);
																									}
																									goto IL_295e;
																								}
																							}
																							if (IsWithinSnappngRangeToTile(myX, myY, 40))
																							{
																								flag2 = true;
																								GamepadEnableGrappleCooldown();
																								sitting.SitDown(this, myX, myY);
																							}
																							goto IL_295e;
																						}
																					}
																					flag2 = true;
																					tile = Main.tile[myX, myY];
																					bool flag12 = tile.type == 389;
																					if (WorldGen.ShiftTallGate(myX, myY, flag12))
																					{
																						NetMessage.SendData(19, -1, -1, null, 4 + flag12.ToInt(), myX, myY);
																					}
																					goto IL_295e;
																				}
																			}
																			flag2 = true;
																			tile = Main.tile[myX, myY];
																			bool flag13 = tile.type == 387;
																			int num66 = WorldGen.ShiftTrapdoor(myX, myY, (float)(myY * 16) > base.Center.Y).ToInt();
																			if (num66 == 0)
																			{
																				num66 = -WorldGen.ShiftTrapdoor(myX, myY, (float)(myY * 16) <= base.Center.Y).ToInt();
																			}
																			if (num66 != 0)
																			{
																				NetMessage.SendData(19, -1, -1, null, 2 + (!flag13).ToInt(), myX, myY, num66 * Math.Sign((float)(myY * 16) - base.Center.Y));
																			}
																		}
																	}
																	goto IL_295e;
																}
															}
														}
													}
												}
												flag2 = true;
												SoundEngine.PlaySound(28, myX * 16, myY * 16, 0);
												GamepadEnableGrappleCooldown();
												WorldGen.SwitchMonolith(myX, myY);
											}
										}
									}
									goto IL_295e;
								}
							}
							flag2 = true;
							tile = Main.tile[myX, myY];
							int num67;
							for (num67 = tile.frameX / 18; num67 > 1; num67 -= 2)
							{
							}
							num67 = myX - num67;
							tile = Main.tile[myX, myY];
							int num68 = myY - tile.frameY / 18;
							tile = Main.tile[myX, myY];
							Animation.NewTemporaryAnimation(2, tile.type, num67, num68);
							tile = Main.tile[myX, myY];
							NetMessage.SendTemporaryAnimation(-1, 2, tile.type, num67, num68);
							Wiring.HitSwitch(myX, myY);
							NetMessage.SendData(59, -1, -1, null, myX, myY);
						}
						goto IL_295e;
					}
				}
			}
			flag2 = true;
			Wiring.HitSwitch(myX, myY);
			NetMessage.SendData(59, -1, -1, null, myX, myY);
			goto IL_295e;
		}
		goto IL_2969;
		IL_295e:
		if (TileLoader.RightClick(myX, myY))
		{
			flag2 = true;
		}
		goto IL_2969;
		IL_224c:
		flag2 = true;
		Main.mouseRightRelease = false;
		int num69 = 0;
		tile = Main.tile[myX, myY];
		int num70;
		for (num70 = tile.frameX / 18; num70 > 1; num70 -= 2)
		{
		}
		num70 = myX - num70;
		tile = Main.tile[myX, myY];
		int num71 = myY - tile.frameY / 18;
		tile = Main.tile[myX, myY];
		if (tile.type == 29)
		{
			num69 = 1;
		}
		else
		{
			tile = Main.tile[myX, myY];
			if (tile.type == 97)
			{
				num69 = 2;
			}
			else
			{
				tile = Main.tile[myX, myY];
				if (tile.type == 463)
				{
					num69 = 3;
					tile = Main.tile[myX, myY];
					num70 = ((tile.frameX != 36) ? (num70 + 1) : (num70 - 1));
					num71 += 2;
				}
				else
				{
					tile = Main.tile[myX, myY];
					if (tile.type == 491)
					{
						num69 = 4;
						tile = Main.tile[myX, myY];
						num70 = ((tile.frameX != 36) ? (num70 + 1) : (num70 - 1));
						num71 += 2;
					}
				}
			}
		}
		CloseSign();
		SetTalkNPC(-1);
		Main.npcChatCornerItem = 0;
		Main.npcChatText = "";
		if (Main.editChest)
		{
			SoundEngine.PlaySound(12);
			Main.editChest = false;
			Main.npcChatText = string.Empty;
		}
		if (editedChestName)
		{
			NetMessage.SendData(33, -1, -1, NetworkText.FromLiteral(Main.chest[chest].name), chest, 1f);
			editedChestName = false;
		}
		bool flag14 = Chest.IsLocked(num70, num71);
		if (Main.netMode == 1 && num69 == 0 && !flag14)
		{
			if (num70 == chestX && num71 == chestY && chest != -1)
			{
				chest = -1;
				Recipe.FindRecipes();
				SoundEngine.PlaySound(11);
			}
			else
			{
				if (WorldGen.IsChestRigged(num70, num71))
				{
					_framesLeftEligibleForDeadmansChestDeathAchievement = 600;
				}
				NetMessage.SendData(31, -1, -1, null, num70, num71);
				Main.stackSplit = 600;
			}
		}
		else
		{
			int num72 = -1;
			switch (num69)
			{
			case 1:
				num72 = -2;
				break;
			case 2:
				num72 = -3;
				break;
			case 3:
				num72 = -4;
				break;
			case 4:
				if (disableVoidBag < 0)
				{
					num72 = -5;
				}
				break;
			default:
			{
				bool flag15 = false;
				if (Chest.IsLocked(num70, num71))
				{
					tile = Main.tile[num70, num71];
					int type3 = tile.type;
					int num73 = 327;
					switch (type3)
					{
					case 21:
						tile = Main.tile[num70, num71];
						if (tile.frameX >= 144)
						{
							tile = Main.tile[num70, num71];
							if (tile.frameX <= 178)
							{
								num73 = 329;
							}
						}
						tile = Main.tile[num70, num71];
						if (tile.frameX < 828)
						{
							break;
						}
						tile = Main.tile[num70, num71];
						if (tile.frameX <= 1006)
						{
							tile = Main.tile[num70, num71];
							int num74 = tile.frameX / 18;
							int num75 = 0;
							while (num74 >= 2)
							{
								num74 -= 2;
								num75++;
							}
							num75 -= 23;
							num73 = 1533 + num75;
						}
						break;
					case 467:
						tile = Main.tile[num70, num71];
						if (tile.frameX / 36 == 13)
						{
							num73 = 4714;
						}
						break;
					}
					flag15 = true;
					bool flag16 = false;
					bool flag17 = num73 != 329;
					for (int num76 = 0; num76 < 58; num76++)
					{
						if (inventory[num76].type != num73 || inventory[num76].stack <= 0 || !Chest.Unlock(num70, num71))
						{
							continue;
						}
						flag16 = true;
						if (flag17)
						{
							if (ItemLoader.ConsumeItem(inventory[num76], this))
							{
								inventory[num76].stack--;
							}
							if (inventory[num76].stack <= 0)
							{
								inventory[num76] = new Item();
							}
						}
						if (Main.netMode == 1)
						{
							NetMessage.SendData(52, -1, -1, null, whoAmI, 1f, num70, num71);
						}
					}
					if (!flag16 && useVoidBag())
					{
						for (int num77 = 0; num77 < 40; num77++)
						{
							if (bank4.item[num77].type != num73 || bank4.item[num77].stack <= 0 || !Chest.Unlock(num70, num71))
							{
								continue;
							}
							if (num73 != 329)
							{
								bank4.item[num77].stack--;
								if (bank4.item[num77].stack <= 0)
								{
									bank4.item[num77] = new Item();
								}
							}
							if (Main.netMode == 1)
							{
								NetMessage.SendData(52, -1, -1, null, whoAmI, 1f, num70, num71);
							}
						}
					}
				}
				if (!flag15)
				{
					num72 = Chest.FindChest(num70, num71);
				}
				break;
			}
			}
			if (num72 != -1)
			{
				Main.stackSplit = 600;
				bool num78 = WorldGen.IsChestRigged(num70, num71);
				if (num72 == chest)
				{
					chest = -1;
					SoundEngine.PlaySound(11);
				}
				else if (num72 != chest && chest == -1)
				{
					OpenChest(num70, num71, num72);
					SoundEngine.PlaySound(10);
					tile = Main.tile[num70, num71];
					if (tile.frameX >= 36)
					{
						tile = Main.tile[num70, num71];
						if (tile.frameX < 72)
						{
							AchievementsHelper.HandleSpecialEvent(this, 16);
						}
					}
				}
				else
				{
					OpenChest(num70, num71, num72);
					SoundEngine.PlaySound(12);
				}
				if (num78)
				{
					Wiring.HitSwitch(myX, myY);
					NetMessage.SendData(59, -1, -1, null, myX, myY);
					_framesLeftEligibleForDeadmansChestDeathAchievement = 600;
				}
				Recipe.FindRecipes();
			}
		}
		goto IL_295e;
		IL_2969:
		if (flag2)
		{
			tileInteractionHappened = true;
		}
		return;
		IL_0c62:
		WorldGen.KillTile(myX, myY);
		if (Main.netMode == 1)
		{
			NetMessage.SendData(17, -1, -1, null, 0, myX, myY);
		}
		flag2 = true;
		GamepadEnableGrappleCooldown();
		goto IL_295e;
	}

	public static bool IsHoveringOverABottomSideOfABed(int myX, int myY)
	{
		short frameX = Main.tile[myX, myY].frameX;
		bool flag = frameX / 72 == 1;
		bool flag2 = frameX % 72 < 36;
		if (flag)
		{
			flag2 = !flag2;
		}
		return flag2;
	}

	public void PetAnimal(int animalNpcIndex)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		GetPettingInfo(animalNpcIndex, out var targetDirection, out var playerPositionWhenPetting, out var isPetSmall);
		playerPositionWhenPetting = playerPositionWhenPetting.Floor();
		Vector2 offset = playerPositionWhenPetting - base.Bottom;
		bool flag = CanSnapToPosition(offset);
		if (flag && !WorldGen.SolidTileAllowBottomSlope((int)playerPositionWhenPetting.X / 16, (int)playerPositionWhenPetting.Y / 16))
		{
			flag = false;
		}
		if (!flag)
		{
			return;
		}
		if (isPettingAnimal && base.Bottom == playerPositionWhenPetting)
		{
			StopPettingAnimal();
			return;
		}
		StopVanityActions();
		RemoveAllGrapplingHooks();
		if (mount.Active)
		{
			mount.Dismount(this);
		}
		base.Bottom = playerPositionWhenPetting;
		ChangeDir(targetDirection);
		isPettingAnimal = true;
		isTheAnimalBeingPetSmall = isPetSmall;
		velocity = Vector2.Zero;
		gravDir = 1f;
		if (whoAmI == Main.myPlayer)
		{
			AchievementsHelper.HandleSpecialEvent(this, 21);
		}
	}

	private void GetPettingInfo(int animalNpcIndex, out int targetDirection, out Vector2 playerPositionWhenPetting, out bool isPetSmall)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		NPC nPC = Main.npc[animalNpcIndex];
		targetDirection = ((nPC.Center.X > base.Center.X) ? 1 : (-1));
		int num = NPCID.Sets.PlayerDistanceWhilePetting[nPC.type];
		isPetSmall = NPCID.Sets.IsPetSmallForPetting[nPC.type];
		playerPositionWhenPetting = nPC.Bottom + new Vector2((float)(-targetDirection * num), 0f);
	}

	public bool CanSnapToPosition(Vector2 offset)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		if (Collision.SolidCollision(position + offset, width, height))
		{
			return false;
		}
		bool canSnapToPosition = Collision.CanHit(position, width, height, position + offset, width, height);
		if (!canSnapToPosition)
		{
			TryAllowingSnappingToPosition(ref canSnapToPosition, position, position + offset);
			if (!canSnapToPosition)
			{
				int num = Math.Sign(offset.X);
				if (num != 0)
				{
					Vector2 val = default(Vector2);
					((Vector2)(ref val))..ctor((float)(num * width), 0f);
					if (Collision.TileCollision(position, val, width, height, fallThrough: true, fall2: true, (int)gravDir) == val)
					{
						TryAllowingSnappingToPosition(ref canSnapToPosition, position + val, position + offset);
					}
				}
			}
		}
		return canSnapToPosition;
	}

	private void TryAllowingSnappingToPosition(ref bool canSnapToPosition, Vector2 pos1, Vector2 pos2)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		Vector2 val = default(Vector2);
		((Vector2)(ref val))..ctor((float)(width - 2), 0f);
		canSnapToPosition = Collision.CanHit(pos1 + val, 2, height, pos2, 2, height);
		if (!canSnapToPosition)
		{
			canSnapToPosition = Collision.CanHit(pos1 + val, 2, height, pos2 + val, 2, height);
		}
		if (!canSnapToPosition)
		{
			canSnapToPosition = Collision.CanHit(pos1, 2, height, pos2, 2, height);
		}
		if (!canSnapToPosition)
		{
			canSnapToPosition = Collision.CanHit(pos1, 2, height, pos2 + val, 2, height);
		}
	}

	public void StopVanityActions(bool multiplayerBroadcast = true)
	{
		StopPettingAnimal();
		sitting.SitUp(this, multiplayerBroadcast);
		sleeping.StopSleeping(this, multiplayerBroadcast);
	}

	private void StopPettingAnimal()
	{
		isPettingAnimal = false;
		isTheAnimalBeingPetSmall = false;
	}

	private void UpdatePettingAnimal()
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		if (!isPettingAnimal)
		{
			return;
		}
		if (talkNPC == -1)
		{
			StopPettingAnimal();
			return;
		}
		int num = Math.Sign(Main.npc[talkNPC].Center.X - base.Center.X);
		if (controlLeft || controlRight || controlUp || controlDown || controlJump || pulley || mount.Active || num != direction)
		{
			StopPettingAnimal();
			return;
		}
		GetPettingInfo(talkNPC, out var _, out var playerPositionWhenPetting, out var _);
		if (base.Bottom.Distance(playerPositionWhenPetting) > 2f)
		{
			StopPettingAnimal();
		}
	}

	/// <summary>
	/// Handles boilerplate for gamepad and UI when opening or closing a container.
	/// <br />Sets <see cref="F:Terraria.Player.chestX" />, and <see cref="F:Terraria.Player.chestY" />, and <see cref="F:Terraria.Player.chest" /> to the given coordinates.
	/// </summary>
	/// <param name="x">The top-left X coordinate of the container.</param>
	/// <param name="y">The top-left Y coordinate of the container.</param>
	/// <param name="newChest">The container index in <see cref="F:Terraria.Main.chest" /> if opening, or -1 if closing.</param>
	public void OpenChest(int x, int y, int newChest)
	{
		if (chest != -1 && Main.myPlayer == whoAmI)
		{
			for (int i = 0; i < 40; i++)
			{
				ItemSlot.SetGlow(i, -1f, chest: true);
			}
		}
		chest = newChest;
		Main.playerInventory = true;
		UILinkPointNavigator.ForceMovementCooldown(120);
		if (PlayerInput.GrappleAndInteractAreShared)
		{
			PlayerInput.Triggers.JustPressed.Grapple = false;
		}
		Main.recBigList = false;
		chestX = x;
		chestY = y;
	}

	public void CloseSign()
	{
		if (sign > -1)
		{
			SoundEngine.PlaySound(11);
			sign = -1;
			Main.editSign = false;
			Main.npcChatText = string.Empty;
		}
	}

	private void LaunchMinecartHook(int myX, int myY)
	{
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		Vector2 val = default(Vector2);
		((Vector2)(ref val))..ctor((float)Main.mouseX + Main.screenPosition.X, (float)Main.mouseY + Main.screenPosition.Y);
		((Vector2)(ref val))..ctor((float)(myX * 16 + 8), (float)(myY * 16 + 8));
		if (direction > 0)
		{
			minecartLeft = false;
		}
		else
		{
			minecartLeft = true;
		}
		RemoveAllGrapplingHooks();
		Projectile.NewProjectile(GetProjectileSource_TileInteraction(myX, myY), val.X, val.Y, 0f, 0f, 403, 0, 0f, whoAmI);
		releaseHook = false;
	}

	public void RemoveAllGrapplingHooks()
	{
		ClearGrapplingBlacklist();
		grappling[0] = -1;
		grapCount = 0;
		for (int i = 0; i < 1000; i++)
		{
			if (Main.projectile[i].active && Main.projectile[i].owner == whoAmI && Main.projectile[i].aiStyle == 7)
			{
				Main.projectile[i].Kill();
			}
		}
	}

	public void RemoveAllFishingBobbers()
	{
		for (int i = 0; i < 1000; i++)
		{
			if (Main.projectile[i].active && Main.projectile[i].owner == whoAmI && Main.projectile[i].bobber)
			{
				Main.projectile[i].Kill();
			}
		}
	}

	private void TileInteractionsMouseOver(int myX, int myY)
	{
		//IL_1432: Unknown result type (might be due to invalid IL or missing references)
		if (myX != tileTargetX || myY != tileTargetY)
		{
			return;
		}
		if (Main.tile[myX, myY].type == 79)
		{
			if (!IsHoveringOverABottomSideOfABed(myX, myY))
			{
				if (IsWithinSnappngRangeToTile(myX, myY, 96))
				{
					noThrow = 2;
					cursorItemIconEnabled = true;
					cursorItemIconID = 5013;
				}
			}
			else
			{
				noThrow = 2;
				cursorItemIconEnabled = true;
				int num = Main.tile[myX, myY].frameY / 36;
				switch (num)
				{
				case 0:
					cursorItemIconID = 224;
					break;
				case 1:
					cursorItemIconID = 644;
					break;
				case 2:
					cursorItemIconID = 645;
					break;
				case 3:
					cursorItemIconID = 646;
					break;
				case 4:
					cursorItemIconID = 920;
					break;
				case 5:
					cursorItemIconID = 1470;
					break;
				case 6:
					cursorItemIconID = 1471;
					break;
				case 7:
					cursorItemIconID = 1472;
					break;
				case 8:
					cursorItemIconID = 1473;
					break;
				case 9:
					cursorItemIconID = 1719;
					break;
				case 10:
					cursorItemIconID = 1720;
					break;
				case 11:
					cursorItemIconID = 1721;
					break;
				case 12:
					cursorItemIconID = 1722;
					break;
				case 13:
				case 14:
				case 15:
				case 16:
				case 17:
				case 18:
					cursorItemIconID = 2066 + num - 13;
					break;
				case 19:
				case 20:
					cursorItemIconID = 2139 + num - 19;
					break;
				default:
					switch (num)
					{
					case 21:
						cursorItemIconID = 2231;
						break;
					case 22:
						cursorItemIconID = 2520;
						break;
					case 23:
						cursorItemIconID = 2538;
						break;
					case 24:
						cursorItemIconID = 2553;
						break;
					case 25:
						cursorItemIconID = 2568;
						break;
					case 26:
						cursorItemIconID = 2669;
						break;
					case 27:
						cursorItemIconID = 2811;
						break;
					case 28:
						cursorItemIconID = 3162;
						break;
					case 29:
						cursorItemIconID = 3164;
						break;
					case 30:
						cursorItemIconID = 3163;
						break;
					case 31:
						cursorItemIconID = 3897;
						break;
					case 32:
						cursorItemIconID = 3932;
						break;
					case 33:
						cursorItemIconID = 3959;
						break;
					case 34:
						cursorItemIconID = 4146;
						break;
					case 35:
						cursorItemIconID = 4167;
						break;
					case 36:
						cursorItemIconID = 4188;
						break;
					case 37:
						cursorItemIconID = 4209;
						break;
					case 38:
						cursorItemIconID = 4299;
						break;
					case 39:
						cursorItemIconID = 4567;
						break;
					case 40:
						cursorItemIconID = 5149;
						break;
					case 41:
						cursorItemIconID = 5170;
						break;
					case 42:
						cursorItemIconID = 5191;
						break;
					default:
						cursorItemIconID = 646;
						break;
					}
					break;
				}
			}
		}
		if (Main.tile[myX, myY].type == 597)
		{
			int pylonStyleFromTile = TETeleportationPylon.GetPylonStyleFromTile(Main.tile[myX, myY]);
			int pylonItemTypeFromTileStyle = TETeleportationPylon.GetPylonItemTypeFromTileStyle(pylonStyleFromTile);
			noThrow = 2;
			cursorItemIconEnabled = true;
			cursorItemIconID = pylonItemTypeFromTileStyle;
			if (pylonStyleFromTile == 1)
			{
				cursorItemIconID = 4875;
			}
			if (pylonStyleFromTile == 2)
			{
				cursorItemIconID = 4916;
			}
			if (pylonStyleFromTile == 3)
			{
				cursorItemIconID = 4917;
			}
			if (pylonStyleFromTile == 4)
			{
				cursorItemIconID = 4918;
			}
			if (pylonStyleFromTile == 5)
			{
				cursorItemIconID = 4919;
			}
			if (pylonStyleFromTile == 6)
			{
				cursorItemIconID = 4920;
			}
			if (pylonStyleFromTile == 7)
			{
				cursorItemIconID = 4921;
			}
			if (pylonStyleFromTile == 8)
			{
				cursorItemIconID = 4951;
			}
		}
		if (Main.tile[myX, myY].type == 621)
		{
			noThrow = 2;
			cursorItemIconEnabled = true;
			cursorItemIconID = 3750;
		}
		if (Main.tile[myX, myY].type == 464)
		{
			noThrow = 2;
			cursorItemIconEnabled = true;
			cursorItemIconID = 3814;
		}
		if (Main.tile[myX, myY].type == 33)
		{
			noThrow = 2;
			cursorItemIconEnabled = true;
			cursorItemIconID = 105;
			int num2 = Main.tile[myX, myY].frameY / 22;
			if (num2 == 1)
			{
				cursorItemIconID = 1405;
			}
			if (num2 == 2)
			{
				cursorItemIconID = 1406;
			}
			if (num2 == 3)
			{
				cursorItemIconID = 1407;
			}
			if (num2 >= 4 && num2 <= 13)
			{
				cursorItemIconID = 2045 + num2 - 4;
			}
			if (num2 >= 14 && num2 <= 16)
			{
				cursorItemIconID = 2153 + num2 - 14;
			}
			if (num2 == 17)
			{
				cursorItemIconID = 2236;
			}
			if (num2 == 18)
			{
				cursorItemIconID = 2523;
			}
			if (num2 == 19)
			{
				cursorItemIconID = 2542;
			}
			if (num2 == 20)
			{
				cursorItemIconID = 2556;
			}
			if (num2 == 21)
			{
				cursorItemIconID = 2571;
			}
			if (num2 == 22)
			{
				cursorItemIconID = 2648;
			}
			if (num2 == 23)
			{
				cursorItemIconID = 2649;
			}
			if (num2 == 24)
			{
				cursorItemIconID = 2650;
			}
			switch (num2)
			{
			case 25:
				cursorItemIconID = 2651;
				break;
			case 26:
				cursorItemIconID = 2818;
				break;
			case 27:
				cursorItemIconID = 3171;
				break;
			case 28:
				cursorItemIconID = 3173;
				break;
			case 29:
				cursorItemIconID = 3172;
				break;
			case 30:
				cursorItemIconID = 3890;
				break;
			case 31:
				cursorItemIconID = 3936;
				break;
			case 32:
				cursorItemIconID = 3962;
				break;
			case 33:
				cursorItemIconID = 4150;
				break;
			case 34:
				cursorItemIconID = 4171;
				break;
			case 35:
				cursorItemIconID = 4192;
				break;
			case 36:
				cursorItemIconID = 4213;
				break;
			case 37:
				cursorItemIconID = 4303;
				break;
			case 38:
				cursorItemIconID = 4571;
				break;
			case 39:
				cursorItemIconID = 5153;
				break;
			case 40:
				cursorItemIconID = 5174;
				break;
			case 41:
				cursorItemIconID = 5195;
				break;
			}
		}
		if (Main.tile[myX, myY].type == 21)
		{
			TileInteractionsMouseOver_Containers(myX, myY);
		}
		if (Main.tile[myX, myY].type == 467)
		{
			TileInteractionsMouseOver_Containers(myX, myY);
		}
		if (Main.tile[myX, myY].type == 441)
		{
			Tile tile = Main.tile[myX, myY];
			int num3 = myX;
			int num4 = myY;
			if (tile.frameX % 36 != 0)
			{
				num3--;
			}
			if (tile.frameY % 36 != 0)
			{
				num4--;
			}
			cursorItemIconID = -1;
			cursorItemIconID = Chest.chestTypeToIcon[tile.frameX / 36];
			noThrow = 2;
			cursorItemIconEnabled = true;
		}
		if (Main.tile[myX, myY].type == 468)
		{
			Tile tile2 = Main.tile[myX, myY];
			int num5 = myX;
			int num6 = myY;
			if (tile2.frameX % 36 != 0)
			{
				num5--;
			}
			if (tile2.frameY % 36 != 0)
			{
				num6--;
			}
			cursorItemIconID = -1;
			cursorItemIconID = Chest.chestTypeToIcon2[tile2.frameX / 36];
			noThrow = 2;
			cursorItemIconEnabled = true;
		}
		if (Main.tile[myX, myY].type == 88)
		{
			Tile tile3 = Main.tile[myX, myY];
			int num7 = myY;
			int x = myX - tile3.frameX % 54 / 18;
			if (tile3.frameY % 36 != 0)
			{
				num7--;
			}
			int num8 = Chest.FindChest(x, num7);
			cursorItemIconID = -1;
			if (num8 < 0)
			{
				cursorItemIconText = Lang.dresserType[0].Value;
			}
			else
			{
				if (Main.chest[num8].name != "")
				{
					cursorItemIconText = Main.chest[num8].name;
				}
				else
				{
					cursorItemIconText = Lang.dresserType[tile3.frameX / 54].Value;
				}
				if (cursorItemIconText == Lang.dresserType[tile3.frameX / 54].Value)
				{
					cursorItemIconID = Chest.dresserTypeToIcon[tile3.frameX / 54];
					cursorItemIconText = "";
				}
			}
			noThrow = 2;
			cursorItemIconEnabled = true;
			if (Main.tile[myX, myY].frameY > 0)
			{
				cursorItemIconID = 269;
				cursorItemIconText = "";
			}
		}
		if (Main.tile[myX, myY].type == 10 || Main.tile[myX, myY].type == 11)
		{
			Tile tile4 = Main.tile[myX, myY];
			noThrow = 2;
			cursorItemIconEnabled = true;
			int num9 = tile4.frameY;
			int num10 = 0;
			while (num9 >= 54)
			{
				num9 -= 54;
				num10++;
			}
			if (tile4.type == 10)
			{
				num10 += 36 * (tile4.frameX / 54);
			}
			if (tile4.type == 11)
			{
				num10 += 36 * (tile4.frameX / 72);
			}
			switch (num10)
			{
			case 0:
				cursorItemIconID = 25;
				break;
			case 9:
				cursorItemIconID = 837;
				break;
			case 10:
				cursorItemIconID = 912;
				break;
			case 11:
				cursorItemIconID = 1141;
				break;
			case 12:
				cursorItemIconID = 1137;
				break;
			case 13:
				cursorItemIconID = 1138;
				break;
			case 14:
				cursorItemIconID = 1139;
				break;
			case 15:
				cursorItemIconID = 1140;
				break;
			case 16:
				cursorItemIconID = 1411;
				break;
			case 17:
				cursorItemIconID = 1412;
				break;
			case 18:
				cursorItemIconID = 1413;
				break;
			case 19:
				cursorItemIconID = 1458;
				break;
			case 20:
			case 21:
			case 22:
			case 23:
				cursorItemIconID = 1709 + num10 - 20;
				break;
			case 24:
				cursorItemIconID = 1793;
				break;
			case 25:
				cursorItemIconID = 1815;
				break;
			case 26:
				cursorItemIconID = 1924;
				break;
			case 27:
				cursorItemIconID = 2044;
				break;
			case 28:
				cursorItemIconID = 2265;
				break;
			case 29:
				cursorItemIconID = 2528;
				break;
			case 30:
				cursorItemIconID = 2561;
				break;
			case 31:
				cursorItemIconID = 2576;
				break;
			case 32:
				cursorItemIconID = 2815;
				break;
			case 33:
				cursorItemIconID = 3129;
				break;
			case 34:
				cursorItemIconID = 3131;
				break;
			case 35:
				cursorItemIconID = 3130;
				break;
			case 36:
				cursorItemIconID = 3888;
				break;
			case 37:
				cursorItemIconID = 3941;
				break;
			case 38:
				cursorItemIconID = 3967;
				break;
			case 39:
				cursorItemIconID = 4155;
				break;
			case 40:
				cursorItemIconID = 4176;
				break;
			case 41:
				cursorItemIconID = 4197;
				break;
			case 42:
				cursorItemIconID = 4218;
				break;
			case 43:
				cursorItemIconID = 4307;
				break;
			case 44:
				cursorItemIconID = 4415;
				break;
			case 45:
				cursorItemIconID = 4576;
				break;
			case 46:
				cursorItemIconID = 5158;
				break;
			case 47:
				cursorItemIconID = 5179;
				break;
			case 48:
				cursorItemIconID = 5200;
				break;
			case 4:
			case 5:
			case 6:
			case 7:
			case 8:
				cursorItemIconID = 812 + num10;
				break;
			default:
				cursorItemIconID = 649 + num10;
				break;
			}
		}
		if (Main.tile[myX, myY].type == 104)
		{
			noThrow = 2;
			cursorItemIconEnabled = true;
			switch (Main.tile[myX, myY].frameX / 36)
			{
			case 0:
				cursorItemIconID = 359;
				break;
			case 1:
				cursorItemIconID = 2237;
				break;
			case 2:
				cursorItemIconID = 2238;
				break;
			case 3:
				cursorItemIconID = 2239;
				break;
			case 4:
				cursorItemIconID = 2240;
				break;
			case 5:
				cursorItemIconID = 2241;
				break;
			case 6:
				cursorItemIconID = 2560;
				break;
			case 7:
				cursorItemIconID = 2575;
				break;
			case 8:
				cursorItemIconID = 2591;
				break;
			case 9:
				cursorItemIconID = 2592;
				break;
			case 10:
				cursorItemIconID = 2593;
				break;
			case 11:
				cursorItemIconID = 2594;
				break;
			case 12:
				cursorItemIconID = 2595;
				break;
			case 13:
				cursorItemIconID = 2596;
				break;
			case 14:
				cursorItemIconID = 2597;
				break;
			case 15:
				cursorItemIconID = 2598;
				break;
			case 16:
				cursorItemIconID = 2599;
				break;
			case 17:
				cursorItemIconID = 2600;
				break;
			case 18:
				cursorItemIconID = 2601;
				break;
			case 19:
				cursorItemIconID = 2602;
				break;
			case 20:
				cursorItemIconID = 2603;
				break;
			case 21:
				cursorItemIconID = 2604;
				break;
			case 22:
				cursorItemIconID = 2605;
				break;
			case 23:
				cursorItemIconID = 2606;
				break;
			case 24:
				cursorItemIconID = 2809;
				break;
			case 25:
				cursorItemIconID = 3126;
				break;
			case 26:
				cursorItemIconID = 3128;
				break;
			case 27:
				cursorItemIconID = 3127;
				break;
			case 28:
				cursorItemIconID = 3898;
				break;
			case 29:
				cursorItemIconID = 3899;
				break;
			case 30:
				cursorItemIconID = 3900;
				break;
			case 31:
				cursorItemIconID = 3901;
				break;
			case 32:
				cursorItemIconID = 3902;
				break;
			case 33:
				cursorItemIconID = 3940;
				break;
			case 34:
				cursorItemIconID = 3966;
				break;
			case 35:
				cursorItemIconID = 4154;
				break;
			case 36:
				cursorItemIconID = 4175;
				break;
			case 37:
				cursorItemIconID = 4196;
				break;
			case 38:
				cursorItemIconID = 4217;
				break;
			case 39:
				cursorItemIconID = 4306;
				break;
			case 40:
				cursorItemIconID = 4575;
				break;
			case 41:
				cursorItemIconID = 5157;
				break;
			case 42:
				cursorItemIconID = 5178;
				break;
			case 43:
				cursorItemIconID = 5199;
				break;
			}
		}
		if (Main.tile[myX, myY].type == 356)
		{
			noThrow = 2;
			cursorItemIconEnabled = true;
			cursorItemIconID = 3064;
		}
		if (Main.tile[myX, myY].type == 663)
		{
			noThrow = 2;
			cursorItemIconEnabled = true;
			cursorItemIconID = 5381;
		}
		if (Main.tile[myX, myY].type == 377)
		{
			noThrow = 2;
			cursorItemIconEnabled = true;
			cursorItemIconID = 3198;
		}
		if (Main.tile[myX, myY].type == 209)
		{
			noThrow = 2;
			cursorItemIconEnabled = true;
			if (Main.tile[myX, myY].frameX < 72)
			{
				cursorItemIconID = 928;
			}
			else if (Main.tile[myX, myY].frameX < 144)
			{
				cursorItemIconID = 1337;
			}
			else if (Main.tile[myX, myY].frameX < 216)
			{
				cursorItemIconID = 3369;
			}
			else if (Main.tile[myX, myY].frameX < 360)
			{
				cursorItemIconID = 3664;
			}
			int num11;
			for (num11 = Main.tile[myX, myY].frameX / 18; num11 >= 4; num11 -= 4)
			{
			}
			if (num11 < 2)
			{
				cursorItemIconReversed = true;
			}
			else
			{
				cursorItemIconReversed = false;
			}
		}
		if (Main.tile[myX, myY].type == 216)
		{
			noThrow = 2;
			cursorItemIconEnabled = true;
			int num12 = Main.tile[myX, myY].frameY;
			int num13 = 0;
			while (num12 >= 40)
			{
				num12 -= 40;
				num13++;
			}
			cursorItemIconID = 970 + num13;
		}
		if (Main.tile[myX, myY].type == 387 || Main.tile[myX, myY].type == 386)
		{
			noThrow = 2;
			cursorItemIconEnabled = true;
			int x2 = 0;
			int y = 0;
			WorldGen.GetTopLeftAndStyles(ref x2, ref y, 2, 1 + (Main.tile[myX, myY].type == 386).ToInt(), 18, 18);
			cursorItemIconID = 3239;
		}
		if (Main.tile[myX, myY].type == 389 || Main.tile[myX, myY].type == 388)
		{
			noThrow = 2;
			cursorItemIconEnabled = true;
			cursorItemIconID = 3240;
		}
		if (Main.tile[myX, myY].type == 335)
		{
			noThrow = 2;
			cursorItemIconEnabled = true;
			cursorItemIconID = 2700;
		}
		if (Main.tile[myX, myY].type == 15 && IsWithinSnappngRangeToTile(myX, myY, 40))
		{
			noThrow = 2;
			cursorItemIconEnabled = true;
			cursorItemIconID = WorldGen.GetItemDrop_Chair(Main.tile[myX, myY].frameY / 40);
			if (Main.tile[myX, myY].frameX / 18 < 1)
			{
				cursorItemIconReversed = true;
			}
		}
		if (Main.tile[myX, myY].type == 102 && IsWithinSnappngRangeToTile(myX, myY, 40))
		{
			noThrow = 2;
			cursorItemIconEnabled = true;
			cursorItemIconID = 355;
		}
		if (Main.tile[myX, myY].type == 89 && IsWithinSnappngRangeToTile(myX, myY, 40))
		{
			noThrow = 2;
			cursorItemIconEnabled = true;
			cursorItemIconID = WorldGen.GetItemDrop_Benches(Main.tile[myX, myY].frameX / 54);
		}
		if (Main.tile[myX, myY].type == 487 && IsWithinSnappngRangeToTile(myX, myY, 40))
		{
			noThrow = 2;
			cursorItemIconEnabled = true;
			cursorItemIconID = WorldGen.GetItemDrop_PicnicTables(Main.tile[myX, myY].frameX / 72);
		}
		if (Main.tile[myX, myY].type == 497 && IsWithinSnappngRangeToTile(myX, myY, 40))
		{
			noThrow = 2;
			cursorItemIconEnabled = true;
			cursorItemIconID = WorldGen.GetItemDrop_Toilet(Main.tile[myX, myY].frameY / 40);
			if (Main.tile[myX, myY].frameX / 18 < 1)
			{
				cursorItemIconReversed = true;
			}
		}
		if (Main.tile[myX, myY].type == 410)
		{
			noThrow = 2;
			cursorItemIconEnabled = true;
			cursorItemIconID = 3536 + Math.Min(Main.tile[myX, myY].frameX / 36, 3);
		}
		if (Main.tile[myX, myY].type == 480)
		{
			noThrow = 2;
			cursorItemIconEnabled = true;
			cursorItemIconID = 4054;
		}
		if (Main.tile[myX, myY].type == 509)
		{
			noThrow = 2;
			cursorItemIconEnabled = true;
			cursorItemIconID = 4318;
		}
		if (Main.tile[myX, myY].type == 657)
		{
			noThrow = 2;
			cursorItemIconEnabled = true;
			cursorItemIconID = 5345;
		}
		if (Main.tile[myX, myY].type == 658)
		{
			noThrow = 2;
			cursorItemIconEnabled = true;
			cursorItemIconID = 5347;
		}
		if (Main.tile[myX, myY].type == 463)
		{
			noThrow = 2;
			cursorItemIconEnabled = true;
			cursorItemIconID = 3813;
		}
		if (Main.tile[myX, myY].type == 491)
		{
			noThrow = 2;
			cursorItemIconEnabled = true;
			cursorItemIconID = 4076;
		}
		if (Main.tile[myX, myY].type == 494)
		{
			noThrow = 2;
			cursorItemIconEnabled = true;
			cursorItemIconID = 4089;
		}
		if (Main.tile[myX, myY].type == 411 && Main.tile[myX, myY].frameX < 36)
		{
			noThrow = 2;
			cursorItemIconEnabled = true;
			cursorItemIconID = 3545;
		}
		if (Main.tile[myX, myY].type == 338)
		{
			noThrow = 2;
			cursorItemIconEnabled = true;
			cursorItemIconID = 2738;
		}
		if (Main.tile[myX, myY].type == 455)
		{
			noThrow = 2;
			cursorItemIconEnabled = true;
			cursorItemIconID = 3747;
		}
		if ((Main.tile[myX, myY].type == 219 || Main.tile[myX, myY].type == 642) && ItemID.Sets.ExtractinatorMode[inventory[selectedItem].type] > -1)
		{
			noThrow = 2;
			cursorItemIconEnabled = true;
			cursorItemIconID = inventory[selectedItem].type;
		}
		if (Main.tile[myX, myY].type == 212)
		{
			noThrow = 2;
			cursorItemIconEnabled = true;
			cursorItemIconID = 949;
		}
		if (Main.tile[myX, myY].type == 314 && gravDir == 1f)
		{
			noThrow = 2;
			cursorItemIconEnabled = true;
			cursorItemIconID = 2343;
		}
		if (Main.tile[myX, myY].type == 215)
		{
			noThrow = 2;
			cursorItemIconEnabled = true;
			int num14 = Main.tile[myX, myY].frameX / 54;
			switch (num14)
			{
			case 0:
				cursorItemIconID = 966;
				break;
			case 14:
				cursorItemIconID = 5299;
				break;
			case 15:
				cursorItemIconID = 5357;
				break;
			case 8:
			case 9:
			case 10:
			case 11:
			case 12:
			case 13:
				cursorItemIconID = 4689 + num14 - 8;
				break;
			case 7:
				cursorItemIconID = 3724;
				break;
			case 6:
				cursorItemIconID = 3723;
				break;
			case 5:
				cursorItemIconID = 3050;
				break;
			default:
				cursorItemIconID = 3046 + num14 - 1;
				break;
			}
		}
		if (Main.tile[myX, myY].type == 4)
		{
			noThrow = 2;
			cursorItemIconEnabled = true;
			int num15 = Main.tile[myX, myY].frameY / 22;
			switch (num15)
			{
			case 0:
				cursorItemIconID = 8;
				break;
			case 8:
				cursorItemIconID = 523;
				break;
			case 9:
				cursorItemIconID = 974;
				break;
			case 10:
				cursorItemIconID = 1245;
				break;
			case 11:
				cursorItemIconID = 1333;
				break;
			case 12:
				cursorItemIconID = 2274;
				break;
			case 13:
				cursorItemIconID = 3004;
				break;
			case 14:
				cursorItemIconID = 3045;
				break;
			case 15:
				cursorItemIconID = 3114;
				break;
			case 16:
				cursorItemIconID = 4383;
				break;
			case 17:
				cursorItemIconID = 4384;
				break;
			case 18:
				cursorItemIconID = 4385;
				break;
			case 19:
				cursorItemIconID = 4386;
				break;
			case 20:
				cursorItemIconID = 4387;
				break;
			case 21:
				cursorItemIconID = 4388;
				break;
			case 22:
				cursorItemIconID = 5293;
				break;
			case 23:
				cursorItemIconID = 5353;
				break;
			default:
				cursorItemIconID = 426 + num15;
				break;
			}
		}
		if (Main.tile[myX, myY].type == 13)
		{
			noThrow = 2;
			cursorItemIconEnabled = true;
			switch (Main.tile[myX, myY].frameX / 18)
			{
			case 1:
				cursorItemIconID = 28;
				break;
			case 2:
				cursorItemIconID = 110;
				break;
			case 3:
				cursorItemIconID = 350;
				break;
			case 4:
				cursorItemIconID = 351;
				break;
			case 5:
				cursorItemIconID = 2234;
				break;
			case 6:
				cursorItemIconID = 2244;
				break;
			case 7:
				cursorItemIconID = 2257;
				break;
			case 8:
				cursorItemIconID = 2258;
				break;
			default:
				cursorItemIconID = 31;
				break;
			}
		}
		if (Main.tile[myX, myY].type == 29)
		{
			noThrow = 2;
			cursorItemIconEnabled = true;
			cursorItemIconID = 87;
		}
		if (Main.tile[myX, myY].type == 97)
		{
			noThrow = 2;
			cursorItemIconEnabled = true;
			cursorItemIconID = 346;
		}
		if (Main.tile[myX, myY].type == 510)
		{
			noThrow = 2;
			cursorItemIconEnabled = true;
			cursorItemIconID = 4319;
			int num16;
			for (num16 = Main.tile[myX, myY].frameX / 18; num16 >= 2; num16 -= 2)
			{
			}
			if (num16 == 0)
			{
				cursorItemIconReversed = true;
			}
			else
			{
				cursorItemIconReversed = false;
			}
		}
		if (Main.tile[myX, myY].type == 511)
		{
			noThrow = 2;
			cursorItemIconEnabled = true;
			cursorItemIconID = 4320;
			int num17;
			for (num17 = Main.tile[myX, myY].frameX / 18; num17 >= 2; num17 -= 2)
			{
			}
			if (num17 == 0)
			{
				cursorItemIconReversed = true;
			}
			else
			{
				cursorItemIconReversed = false;
			}
		}
		if (Main.tile[myX, myY].type == 49)
		{
			noThrow = 2;
			cursorItemIconEnabled = true;
			cursorItemIconID = 148;
		}
		if (Main.tile[myX, myY].type == 372)
		{
			noThrow = 2;
			cursorItemIconEnabled = true;
			cursorItemIconID = 3117;
		}
		if (Main.tile[myX, myY].type == 646)
		{
			noThrow = 2;
			cursorItemIconEnabled = true;
			cursorItemIconID = 5322;
		}
		if (Main.tile[myX, myY].type == 174)
		{
			noThrow = 2;
			cursorItemIconEnabled = true;
			cursorItemIconID = 713;
		}
		if (Main.tile[myX, myY].type == 50)
		{
			noThrow = 2;
			if (Main.tile[myX, myY].frameX == 90)
			{
				cursorItemIconEnabled = true;
				cursorItemIconID = 165;
			}
		}
		if (Main.tile[myX, myY].type == 139)
		{
			noThrow = 2;
			int num18 = 0;
			for (int num19 = Main.tile[myX, myY].frameY / 18; num19 >= 2; num19 -= 2)
			{
				num18++;
			}
			cursorItemIconEnabled = true;
			if (num18 == 28)
			{
				cursorItemIconID = 1963;
			}
			else if (num18 == 29)
			{
				cursorItemIconID = 1964;
			}
			else if (num18 == 30)
			{
				cursorItemIconID = 1965;
			}
			else if (num18 == 31)
			{
				cursorItemIconID = 2742;
			}
			else if (num18 == 32)
			{
				cursorItemIconID = 3044;
			}
			else if (num18 == 33)
			{
				cursorItemIconID = 3235;
			}
			else if (num18 == 34)
			{
				cursorItemIconID = 3236;
			}
			else if (num18 == 35)
			{
				cursorItemIconID = 3237;
			}
			else if (num18 == 36)
			{
				cursorItemIconID = 3370;
			}
			else if (num18 == 37)
			{
				cursorItemIconID = 3371;
			}
			else if (num18 == 38)
			{
				cursorItemIconID = 3796;
			}
			else if (num18 == 39)
			{
				cursorItemIconID = 3869;
			}
			else if (num18 == 40)
			{
				cursorItemIconID = 4082;
			}
			else if (num18 == 41)
			{
				cursorItemIconID = 4078;
			}
			else if (num18 == 42)
			{
				cursorItemIconID = 4079;
			}
			else if (num18 == 43)
			{
				cursorItemIconID = 4077;
			}
			else if (num18 == 44)
			{
				cursorItemIconID = 4080;
			}
			else if (num18 == 45)
			{
				cursorItemIconID = 4081;
			}
			else if (num18 == 46)
			{
				cursorItemIconID = 4237;
			}
			else if (num18 == 47)
			{
				cursorItemIconID = 4356;
			}
			else if (num18 == 48)
			{
				cursorItemIconID = 4357;
			}
			else if (num18 == 49)
			{
				cursorItemIconID = 4358;
			}
			else if (num18 == 50)
			{
				cursorItemIconID = 4421;
			}
			else if (num18 == 51)
			{
				cursorItemIconID = 4606;
			}
			else if (num18 == 52)
			{
				cursorItemIconID = 4979;
			}
			else if (num18 == 53)
			{
				cursorItemIconID = 4985;
			}
			else if (num18 == 54)
			{
				cursorItemIconID = 4990;
			}
			else if (num18 == 55)
			{
				cursorItemIconID = 4991;
			}
			else if (num18 == 56)
			{
				cursorItemIconID = 4992;
			}
			else if (num18 == 57)
			{
				cursorItemIconID = 5006;
			}
			else if (num18 == 58)
			{
				cursorItemIconID = 5014;
			}
			else if (num18 == 59)
			{
				cursorItemIconID = 5015;
			}
			else if (num18 == 60)
			{
				cursorItemIconID = 5016;
			}
			else if (num18 == 61)
			{
				cursorItemIconID = 5017;
			}
			else if (num18 == 62)
			{
				cursorItemIconID = 5018;
			}
			else if (num18 == 63)
			{
				cursorItemIconID = 5019;
			}
			else if (num18 == 64)
			{
				cursorItemIconID = 5020;
			}
			else if (num18 == 65)
			{
				cursorItemIconID = 5021;
			}
			else if (num18 == 66)
			{
				cursorItemIconID = 5022;
			}
			else if (num18 == 67)
			{
				cursorItemIconID = 5023;
			}
			else if (num18 == 68)
			{
				cursorItemIconID = 5024;
			}
			else if (num18 == 69)
			{
				cursorItemIconID = 5025;
			}
			else if (num18 == 70)
			{
				cursorItemIconID = 5026;
			}
			else if (num18 == 71)
			{
				cursorItemIconID = 5027;
			}
			else if (num18 == 72)
			{
				cursorItemIconID = 5028;
			}
			else if (num18 == 73)
			{
				cursorItemIconID = 5029;
			}
			else if (num18 == 74)
			{
				cursorItemIconID = 5030;
			}
			else if (num18 == 75)
			{
				cursorItemIconID = 5031;
			}
			else if (num18 == 76)
			{
				cursorItemIconID = 5032;
			}
			else if (num18 == 77)
			{
				cursorItemIconID = 5033;
			}
			else if (num18 == 78)
			{
				cursorItemIconID = 5034;
			}
			else if (num18 == 79)
			{
				cursorItemIconID = 5035;
			}
			else if (num18 == 80)
			{
				cursorItemIconID = 5036;
			}
			else if (num18 == 81)
			{
				cursorItemIconID = 5037;
			}
			else if (num18 == 82)
			{
				cursorItemIconID = 5038;
			}
			else if (num18 == 83)
			{
				cursorItemIconID = 5039;
			}
			else if (num18 == 84)
			{
				cursorItemIconID = 5040;
			}
			else if (num18 == 85)
			{
				cursorItemIconID = 5044;
			}
			else if (num18 == 86)
			{
				cursorItemIconID = 5112;
			}
			else if (num18 == 87)
			{
				cursorItemIconID = 5362;
			}
			else if (num18 >= 13)
			{
				cursorItemIconID = 1596 + num18 - 13;
			}
			else
			{
				cursorItemIconID = 562 + num18;
			}
		}
		if (Main.tile[myX, myY].type == 207)
		{
			noThrow = 2;
			int num20 = 0;
			for (int num21 = Main.tile[myX, myY].frameX / 18; num21 >= 2; num21 -= 2)
			{
				num20++;
			}
			cursorItemIconEnabled = true;
			switch (num20)
			{
			case 0:
				cursorItemIconID = 909;
				break;
			case 1:
				cursorItemIconID = 910;
				break;
			case 2:
				cursorItemIconID = 940;
				break;
			case 3:
				cursorItemIconID = 941;
				break;
			case 4:
				cursorItemIconID = 942;
				break;
			case 5:
				cursorItemIconID = 943;
				break;
			case 6:
				cursorItemIconID = 944;
				break;
			case 7:
				cursorItemIconID = 945;
				break;
			case 8:
				cursorItemIconID = 4922;
				break;
			case 9:
				cursorItemIconID = 4417;
				break;
			}
		}
		if (Main.tileSign[Main.tile[myX, myY].type])
		{
			noThrow = 2;
			int num22 = Main.tile[myX, myY].frameX / 18;
			int num23 = Main.tile[myX, myY].frameY / 18;
			num22 %= 2;
			int num24 = myX - num22;
			int num25 = myY - num23;
			Main.signBubble = true;
			Main.signX = num24 * 16 + 16;
			Main.signY = num25 * 16;
			int num26 = Sign.ReadSign(num24, num25, CreateIfMissing: false);
			if (num26 != -1)
			{
				Main.signHover = num26;
			}
			if (num26 != -1)
			{
				Main.signHover = num26;
				cursorItemIconEnabled = false;
				cursorItemIconID = -1;
			}
		}
		if (Main.tile[myX, myY].type == 237)
		{
			noThrow = 2;
			cursorItemIconEnabled = true;
			cursorItemIconID = 1293;
		}
		if (Main.tile[myX, myY].type == 466)
		{
			noThrow = 2;
			cursorItemIconEnabled = true;
			cursorItemIconID = 3828;
		}
		if (Main.tile[myX, myY].type == 125)
		{
			noThrow = 2;
			cursorItemIconEnabled = true;
			cursorItemIconID = 487;
		}
		if (Main.tile[myX, myY].type == 354)
		{
			noThrow = 2;
			cursorItemIconEnabled = true;
			cursorItemIconID = 2999;
		}
		if (Main.tile[myX, myY].type == 287)
		{
			noThrow = 2;
			cursorItemIconEnabled = true;
			cursorItemIconID = 2177;
		}
		if (Main.tile[myX, myY].type == 132)
		{
			noThrow = 2;
			cursorItemIconEnabled = true;
			cursorItemIconID = 513;
		}
		if (Main.tile[myX, myY].type == 136)
		{
			noThrow = 2;
			cursorItemIconEnabled = true;
			cursorItemIconID = 538;
		}
		if (Main.tile[myX, myY].type == 144)
		{
			noThrow = 2;
			cursorItemIconEnabled = true;
			int num27 = Main.tile[myX, myY].frameX / 18;
			if (num27 < 3)
			{
				cursorItemIconID = 583 + num27;
			}
			else
			{
				cursorItemIconID = 4484 + (num27 - 3);
			}
		}
		if (Main.tile[myX, myY].type == 440)
		{
			int num28 = Main.tile[myX, myY].frameX / 54;
			int num29 = Main.tile[myX, myY].frameY / 54;
			int num30 = -1;
			switch (num28)
			{
			case 0:
				num30 = 1526;
				break;
			case 1:
				num30 = 1524;
				break;
			case 2:
				num30 = 1525;
				break;
			case 3:
				num30 = 1523;
				break;
			case 4:
				num30 = 1522;
				break;
			case 5:
				num30 = 1527;
				break;
			case 6:
				num30 = 3643;
				break;
			}
			if (num30 != -1 && (num29 == 1 || HasItem(num30)))
			{
				noThrow = 2;
				cursorItemIconEnabled = true;
				cursorItemIconID = num30;
			}
		}
		else if (Main.tile[myX, myY].type == 470)
		{
			noThrow = 2;
			int num31 = Main.tile[myX, myY].frameX % 136 / 34;
			if (num31 < 2)
			{
				cursorItemIconEnabled = true;
				cursorItemIconID = 498;
			}
			else if (num31 < 4)
			{
				cursorItemIconEnabled = true;
				cursorItemIconID = 1989;
			}
		}
		else if (Main.tile[myX, myY].type == 475)
		{
			noThrow = 2;
			cursorItemIconEnabled = true;
			cursorItemIconID = 3977;
		}
		else if (Main.tile[myX, myY].type == 520)
		{
			noThrow = 2;
			int num32 = TEFoodPlatter.Find(myX, myY);
			if (num32 != -1)
			{
				cursorItemIconEnabled = true;
				TEFoodPlatter tEFoodPlatter = (TEFoodPlatter)TileEntity.ByID[num32];
				cursorItemIconID = tEFoodPlatter.item.type;
			}
		}
		else if (Main.tile[myX, myY].type == 395)
		{
			noThrow = 2;
			int num33 = myX;
			int num34 = myY;
			int num35 = Main.tile[myX, myY].frameX;
			int num36 = Main.tile[myX, myY].frameY;
			while (num36 > 0)
			{
				num36 -= 18;
				num34--;
			}
			while (num35 >= 36)
			{
				num35 -= 36;
			}
			while (num35 > 0)
			{
				num35 -= 18;
				num33--;
			}
			int num37 = TEItemFrame.Find(num33, num34);
			if (num37 != -1)
			{
				cursorItemIconEnabled = true;
				TEItemFrame tEItemFrame = (TEItemFrame)TileEntity.ByID[num37];
				cursorItemIconID = tEItemFrame.item.type;
			}
		}
		else if (Main.tile[myX, myY].type == 471)
		{
			noThrow = 2;
			int num38 = myX;
			int num39 = myY;
			int num40 = Main.tile[myX, myY].frameX;
			int num41 = Main.tile[myX, myY].frameY;
			while (num41 > 0)
			{
				num41 -= 18;
				num39--;
			}
			while (num40 >= 54)
			{
				num40 -= 54;
			}
			while (num40 > 0)
			{
				num40 -= 18;
				num38--;
			}
			int num42 = TEWeaponsRack.Find(num38, num39);
			if (num42 != -1)
			{
				cursorItemIconEnabled = true;
				TEWeaponsRack tEWeaponsRack = (TEWeaponsRack)TileEntity.ByID[num42];
				cursorItemIconID = tEWeaponsRack.item.type;
			}
		}
		else if (Main.tile[myX, myY].type == 334)
		{
			noThrow = 2;
		}
		TileLoader.MouseOver(myX, myY);
		if (PlayerInput.UsingGamepad && cursorItemIconText.Length == 0)
		{
			cursorItemIconEnabled = false;
			cursorItemIconID = 0;
		}
	}

	public Color ChatColor()
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		return (Color)(difficulty switch
		{
			1 => Main.mcColor, 
			2 => Main.hcColor, 
			_ => Color.White, 
		});
	}

	private void TileInteractionsMouseOver_Containers(int myX, int myY)
	{
		LocalizedText[] array = Lang.chestType;
		int[] array2 = Chest.chestTypeToIcon;
		Tile tile = Main.tile[myX, myY];
		if (tile.type == 467)
		{
			array = Lang.chestType2;
			array2 = Chest.chestTypeToIcon2;
		}
		int num = myX;
		int num2 = myY;
		if (tile.frameX % 36 != 0)
		{
			num--;
		}
		if (tile.frameY % 36 != 0)
		{
			num2--;
		}
		int num3 = Chest.FindChest(num, num2);
		cursorItemIconID = -1;
		if (num3 < 0)
		{
			cursorItemIconText = array[0].Value;
		}
		else
		{
			if (Main.chest[num3].name != "")
			{
				cursorItemIconText = Main.chest[num3].name;
			}
			else
			{
				cursorItemIconText = array[tile.frameX / 36].Value;
			}
			if (cursorItemIconText == array[tile.frameX / 36].Value)
			{
				cursorItemIconID = array2[tile.frameX / 36];
				cursorItemIconText = "";
			}
		}
		if (cursorItemIconID == 3988)
		{
			cursorItemIconID = 306;
		}
		noThrow = 2;
		cursorItemIconEnabled = true;
	}

	private void TryLandingOnDetonator()
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		if (whoAmI == Main.myPlayer && velocity.Y >= 3f)
		{
			Point val = (base.Bottom + new Vector2(0f, 0.01f)).ToTileCoordinates();
			Tile tileSafely = Framing.GetTileSafely(val.X, val.Y);
			if (tileSafely.active() && tileSafely.type == 411 && tileSafely.frameY == 0 && tileSafely.frameX < 36)
			{
				Wiring.HitSwitch(val.X, val.Y);
				NetMessage.SendData(59, -1, -1, null, val.X, val.Y);
			}
		}
	}

	private void TryBouncingBlocks(bool Falling)
	{
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0162: Unknown result type (might be due to invalid IL or missing references)
		//IL_0167: Unknown result type (might be due to invalid IL or missing references)
		//IL_0169: Unknown result type (might be due to invalid IL or missing references)
		//IL_0189: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0204: Unknown result type (might be due to invalid IL or missing references)
		//IL_0211: Unknown result type (might be due to invalid IL or missing references)
		//IL_0222: Unknown result type (might be due to invalid IL or missing references)
		//IL_0229: Unknown result type (might be due to invalid IL or missing references)
		//IL_022e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0233: Unknown result type (might be due to invalid IL or missing references)
		//IL_0236: Unknown result type (might be due to invalid IL or missing references)
		//IL_023b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0249: Unknown result type (might be due to invalid IL or missing references)
		//IL_024b: Unknown result type (might be due to invalid IL or missing references)
		bool num = !wet && !shimmering && (velocity.Y >= 5f || velocity.Y <= -5f);
		bool flag = false;
		bool flag2 = false;
		float num2 = 1f;
		if (!num)
		{
			return;
		}
		bool flag3 = false;
		int num3 = 0;
		foreach (Point touchedTile in TouchedTiles)
		{
			Tile tile = Main.tile[touchedTile.X, touchedTile.Y];
			if (tile != null && tile.active() && tile.nactive() && (flag || Main.tileBouncy[tile.type]))
			{
				flag3 = true;
				num3 = touchedTile.Y;
				break;
			}
		}
		if (!flag3)
		{
			return;
		}
		velocity.Y *= -0.8f;
		if (controlJump)
		{
			velocity.Y = MathHelper.Clamp(velocity.Y, -13f, 13f);
		}
		position.Y = num3 * 16 - ((velocity.Y < 0f) ? height : (-16));
		FloorVisuals(Falling);
		if (flag2)
		{
			Vector2 val = (fullRotation - (float)Math.PI / 2f).ToRotationVector2();
			if (val.Y > 0f)
			{
				val.Y *= -1f;
			}
			val.Y = val.Y * 0.5f + -0.5f;
			float num4 = 0f - val.Y;
			if (num4 < 0f)
			{
				num4 = 0f;
			}
			float num5 = num4 * 1.5f + 1f;
			float num6 = Math.Abs(velocity.Y) * num5 * num2;
			num6 = MathHelper.Clamp(num6, 2f, 16f);
			velocity = val * num6;
			float num7 = 20f;
			Vector2 val2 = base.Center + (fullRotation + (float)Math.PI / 2f).ToRotationVector2() * num7;
			val2 = base.Bottom;
			ParticleOrchestrator.RequestParticleSpawn(clientOnly: true, ParticleOrchestraType.Keybrand, new ParticleOrchestraSettings
			{
				PositionInWorld = val2
			}, whoAmI);
		}
		velocity.Y = MathHelper.Clamp(velocity.Y, -20f, 20f);
		if (velocity.Y * gravDir < 0f)
		{
			fallStart = (int)position.Y / 16;
		}
	}

	public bool CanAcceptItemIntoInventory(Item item)
	{
		if (preventAllItemPickups)
		{
			return ItemID.Sets.IgnoresEncumberingStone[item.type];
		}
		return true;
	}

	private void GrabItems(int i)
	{
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0151: Unknown result type (might be due to invalid IL or missing references)
		//IL_0156: Unknown result type (might be due to invalid IL or missing references)
		//IL_015a: Unknown result type (might be due to invalid IL or missing references)
		for (int j = 0; j < 400; j++)
		{
			Item item = Main.item[j];
			if (!item.active || item.shimmerTime != 0f || item.noGrabDelay != 0 || item.playerIndexTheItemIsReservedFor != i || !CanAcceptItemIntoInventory(item) || (item.shimmered && !((double)((Vector2)(ref item.velocity)).Length() < 0.2)) || !ItemLoader.CanPickup(item, this))
			{
				continue;
			}
			int itemGrabRange = GetItemGrabRange(item);
			Rectangle hitbox = item.Hitbox;
			Rectangle val = base.Hitbox;
			if (((Rectangle)(ref val)).Intersects(hitbox))
			{
				if (i != Main.myPlayer || (inventory[selectedItem].type == 0 && itemAnimation > 0))
				{
					continue;
				}
				if (!CombinedHooks.OnPickup(Main.item[j], this))
				{
					Main.item[j] = new Item();
					if (Main.netMode == 1)
					{
						NetMessage.SendData(21, -1, -1, null, j);
					}
				}
				else
				{
					item = PickupItem(i, j, item);
				}
				continue;
			}
			val = new Rectangle((int)position.X - itemGrabRange, (int)position.Y - itemGrabRange, width + itemGrabRange * 2, height + itemGrabRange * 2);
			if (!((Rectangle)(ref val)).Intersects(hitbox))
			{
				continue;
			}
			ItemSpaceStatus status = ItemSpace(item);
			if (!CanPullItem(item, status))
			{
				continue;
			}
			item.shimmered = false;
			item.beingGrabbed = true;
			bool flag = false;
			if (difficulty == 3 && CreativePowerManager.Instance.GetPower<CreativePowers.FarPlacementRangePower>().IsEnabledForPlayer(whoAmI))
			{
				flag = true;
			}
			if (!ItemLoader.GrabStyle(item, this))
			{
				if (flag)
				{
					PullItem_Pickup(item, 7f, 1);
				}
				else if (manaMagnet && (item.type == 184 || item.type == 1735 || item.type == 1868))
				{
					PullItem_Pickup(item, 12f, 5);
				}
				else if (lifeMagnet && (item.type == 58 || item.type == 1734 || item.type == 1867))
				{
					PullItem_Pickup(item, 15f, 5);
				}
				else if (ItemID.Sets.NebulaPickup[item.type])
				{
					PullItem_Pickup(item, 12f, 5);
				}
				else if (status.ItemIsGoingToVoidVault)
				{
					PullItem_ToVoidVault(item);
				}
				else if (goldRing && item.IsACoin)
				{
					PullItem_Pickup(item, 12f, 5);
				}
				else
				{
					PullItem_Common(item, 0.75f);
				}
			}
		}
	}

	private void PullItem_ToVoidVault(Item itemToPickUp)
	{
		PullItem_Pickup(itemToPickUp, 12f, 5);
	}

	private void PullItem_Common(Item itemToPickUp, float xPullSpeed)
	{
		if ((double)position.X + (double)width * 0.5 > (double)itemToPickUp.position.X + (double)itemToPickUp.width * 0.5)
		{
			if (itemToPickUp.velocity.X < itemGrabSpeedMax + velocity.X)
			{
				itemToPickUp.velocity.X += itemGrabSpeed;
			}
			if (itemToPickUp.velocity.X < 0f)
			{
				itemToPickUp.velocity.X += itemGrabSpeed * xPullSpeed;
			}
		}
		else
		{
			if (itemToPickUp.velocity.X > 0f - itemGrabSpeedMax + velocity.X)
			{
				itemToPickUp.velocity.X -= itemGrabSpeed;
			}
			if (itemToPickUp.velocity.X > 0f)
			{
				itemToPickUp.velocity.X -= itemGrabSpeed * xPullSpeed;
			}
		}
		if ((double)position.Y + (double)height * 0.5 > (double)itemToPickUp.position.Y + (double)itemToPickUp.height * 0.5)
		{
			if (itemToPickUp.velocity.Y < itemGrabSpeedMax)
			{
				itemToPickUp.velocity.Y += itemGrabSpeed;
			}
			if (itemToPickUp.velocity.Y < 0f)
			{
				itemToPickUp.velocity.Y += itemGrabSpeed * xPullSpeed;
			}
		}
		else
		{
			if (itemToPickUp.velocity.Y > 0f - itemGrabSpeedMax)
			{
				itemToPickUp.velocity.Y -= itemGrabSpeed;
			}
			if (itemToPickUp.velocity.Y > 0f)
			{
				itemToPickUp.velocity.Y -= itemGrabSpeed * xPullSpeed;
			}
		}
	}

	private void PullItem_Pickup(Item itemToPickUp, float speed, int acc)
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		Vector2 val = default(Vector2);
		((Vector2)(ref val))..ctor(itemToPickUp.position.X + (float)(itemToPickUp.width / 2), itemToPickUp.position.Y + (float)(itemToPickUp.height / 2));
		float num = base.Center.X - val.X;
		float num2 = base.Center.Y - val.Y;
		float num3 = (float)Math.Sqrt(num * num + num2 * num2);
		num3 = speed / num3;
		num *= num3;
		num2 *= num3;
		itemToPickUp.velocity.X = (itemToPickUp.velocity.X * (float)(acc - 1) + num) / (float)acc;
		itemToPickUp.velocity.Y = (itemToPickUp.velocity.Y * (float)(acc - 1) + num2) / (float)acc;
	}

	private Item PickupItem(int playerIndex, int worldItemArrayIndex, Item itemToPickUp)
	{
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		if (ItemID.Sets.NebulaPickup[itemToPickUp.type])
		{
			SoundEngine.PlaySound(7, (int)position.X, (int)position.Y);
			int num = itemToPickUp.buffType;
			itemToPickUp = new Item();
			if (Main.netMode == 1)
			{
				NetMessage.SendData(102, -1, -1, null, playerIndex, num, base.Center.X, base.Center.Y);
			}
			else
			{
				NebulaLevelup(num);
			}
		}
		if (itemToPickUp.type == 58 || itemToPickUp.type == 1734 || itemToPickUp.type == 1867)
		{
			SoundEngine.PlaySound(7, (int)position.X, (int)position.Y);
			Heal(20);
			itemToPickUp = new Item();
		}
		else if (itemToPickUp.type == 184 || itemToPickUp.type == 1735 || itemToPickUp.type == 1868)
		{
			SoundEngine.PlaySound(7, (int)position.X, (int)position.Y);
			statMana += 100;
			if (Main.myPlayer == whoAmI)
			{
				ManaEffect(100);
			}
			if (statMana > statManaMax2)
			{
				statMana = statManaMax2;
			}
			itemToPickUp = new Item();
		}
		else if (itemToPickUp.type == 4143)
		{
			SoundEngine.PlaySound(7, (int)position.X, (int)position.Y);
			statMana += 50;
			if (Main.myPlayer == whoAmI)
			{
				ManaEffect(50);
			}
			if (statMana > statManaMax2)
			{
				statMana = statManaMax2;
			}
			itemToPickUp = new Item();
		}
		else
		{
			itemToPickUp = GetItem(playerIndex, itemToPickUp, GetItemSettings.PickupItemFromWorld);
		}
		Main.item[worldItemArrayIndex] = itemToPickUp;
		if (Main.netMode == 1)
		{
			NetMessage.SendData(21, -1, -1, null, worldItemArrayIndex);
		}
		return itemToPickUp;
	}

	/// <summary>
	/// Heals the player for a certain amount.
	/// </summary>
	/// <param name="amount">The amount to heal the player by.</param>
	public void Heal(int amount)
	{
		statLife += amount;
		if (Main.myPlayer == whoAmI)
		{
			HealEffect(amount);
		}
		if (statLife > statLifeMax2)
		{
			statLife = statLifeMax2;
		}
	}

	/// <summary>
	/// Fetches the range at which the given item begins to gravitate towards the player.<br />
	/// This range, referred to as item grab range, is measured in pixels.
	/// </summary>
	/// <param name="item">The item whose grab range is being evaluated.</param>
	/// <returns>The item grab range of the player, in pixels.</returns>
	public int GetItemGrabRange(Item item)
	{
		int grabRange = defaultItemGrabRange;
		if (goldRing && item.IsACoin)
		{
			grabRange += Item.coinGrabRange;
		}
		if (manaMagnet && (item.type == 184 || item.type == 1735 || item.type == 1868))
		{
			grabRange += Item.manaGrabRange;
		}
		if (item.type == 4143)
		{
			grabRange += Item.manaGrabRange;
		}
		if (lifeMagnet && (item.type == 58 || item.type == 1734 || item.type == 1867))
		{
			grabRange += Item.lifeGrabRange;
		}
		if (treasureMagnet)
		{
			grabRange += Item.treasureGrabRange;
		}
		if (item.type == 3822)
		{
			grabRange += 50;
		}
		if (ItemID.Sets.NebulaPickup[item.type])
		{
			grabRange += 100;
		}
		if (difficulty == 3 && CreativePowerManager.Instance.GetPower<CreativePowers.FarPlacementRangePower>().IsEnabledForPlayer(whoAmI))
		{
			grabRange += 240;
		}
		ItemLoader.GrabRange(item, this, ref grabRange);
		return grabRange;
	}

	public bool SellItem(Item item, int stack = -1)
	{
		GetItemExpectedPrice(item, out var calcForSelling, out var calcForBuying);
		if (calcForSelling <= 0)
		{
			return false;
		}
		if (stack == -1)
		{
			stack = item.stack;
		}
		Item[] array = new Item[58];
		for (int i = 0; i < 58; i++)
		{
			array[i] = new Item();
			array[i] = inventory[i].Clone();
		}
		long num = calcForSelling / 5;
		if (num < 1)
		{
			num = 1L;
		}
		long num2 = num;
		num *= stack;
		int amount = Main.shopSellbackHelper.GetAmount(item);
		if (amount > 0)
		{
			num += (-num2 + calcForBuying) * Math.Min(amount, item.stack);
		}
		bool flag = false;
		while (num >= 1000000 && !flag)
		{
			int num3 = -1;
			for (int num4 = 53; num4 >= 0; num4--)
			{
				if (num3 == -1 && (inventory[num4].type == 0 || inventory[num4].stack == 0))
				{
					num3 = num4;
				}
				while (inventory[num4].type == 74 && inventory[num4].stack < inventory[num4].maxStack && num >= 1000000)
				{
					inventory[num4].stack++;
					num -= 1000000;
					DoCoins(num4);
					if (inventory[num4].stack == 0 && num3 == -1)
					{
						num3 = num4;
					}
				}
			}
			if (num >= 1000000)
			{
				if (num3 == -1)
				{
					flag = true;
					continue;
				}
				inventory[num3].SetDefaults(74);
				num -= 1000000;
			}
		}
		while (num >= 10000 && !flag)
		{
			int num5 = -1;
			for (int num6 = 53; num6 >= 0; num6--)
			{
				if (num5 == -1 && (inventory[num6].type == 0 || inventory[num6].stack == 0))
				{
					num5 = num6;
				}
				while (inventory[num6].type == 73 && inventory[num6].stack < inventory[num6].maxStack && num >= 10000)
				{
					inventory[num6].stack++;
					num -= 10000;
					DoCoins(num6);
					if (inventory[num6].stack == 0 && num5 == -1)
					{
						num5 = num6;
					}
				}
			}
			if (num >= 10000)
			{
				if (num5 == -1)
				{
					flag = true;
					continue;
				}
				inventory[num5].SetDefaults(73);
				num -= 10000;
			}
		}
		while (num >= 100 && !flag)
		{
			int num7 = -1;
			for (int num8 = 53; num8 >= 0; num8--)
			{
				if (num7 == -1 && (inventory[num8].type == 0 || inventory[num8].stack == 0))
				{
					num7 = num8;
				}
				while (inventory[num8].type == 72 && inventory[num8].stack < inventory[num8].maxStack && num >= 100)
				{
					inventory[num8].stack++;
					num -= 100;
					DoCoins(num8);
					if (inventory[num8].stack == 0 && num7 == -1)
					{
						num7 = num8;
					}
				}
			}
			if (num >= 100)
			{
				if (num7 == -1)
				{
					flag = true;
					continue;
				}
				inventory[num7].SetDefaults(72);
				num -= 100;
			}
		}
		while (num >= 1 && !flag)
		{
			int num9 = -1;
			for (int num10 = 53; num10 >= 0; num10--)
			{
				if (num9 == -1 && (inventory[num10].type == 0 || inventory[num10].stack == 0))
				{
					num9 = num10;
				}
				while (inventory[num10].type == 71 && inventory[num10].stack < inventory[num10].maxStack && num >= 1)
				{
					inventory[num10].stack++;
					num--;
					DoCoins(num10);
					if (inventory[num10].stack == 0 && num9 == -1)
					{
						num9 = num10;
					}
				}
			}
			if (num >= 1)
			{
				if (num9 == -1)
				{
					flag = true;
					continue;
				}
				inventory[num9].SetDefaults(71);
				num--;
			}
		}
		if (flag)
		{
			for (int j = 0; j < 58; j++)
			{
				inventory[j] = array[j].Clone();
			}
			return false;
		}
		return true;
	}

	/// <summary>
	/// Calls <see cref="M:Terraria.Item.Refresh(System.Boolean)" /> on all player-owned storage (inventory, banks, equipment). Also refreshes recipe and shop entries.
	/// <para /> This is called when entering a world and serves to ensure that items with <see cref="T:Terraria.GameContent.Items.ItemVariants" /> have the correct stats.
	/// </summary>
	public void RefreshItems(bool onlyIfVariantChanged = true)
	{
		if (onlyIfVariantChanged && whoAmI == Main.myPlayer)
		{
			Recipe.UpdateItemVariants();
		}
		RefreshItems(inventory, onlyIfVariantChanged);
		RefreshItems(armor, onlyIfVariantChanged);
		RefreshItems(dye, onlyIfVariantChanged);
		RefreshItems(miscEquips, onlyIfVariantChanged);
		RefreshItems(miscDyes, onlyIfVariantChanged);
		RefreshItems(bank.item, onlyIfVariantChanged);
		RefreshItems(bank2.item, onlyIfVariantChanged);
		RefreshItems(bank3.item, onlyIfVariantChanged);
		RefreshItems(bank4.item, onlyIfVariantChanged);
		RefreshItems(_temporaryItemSlots, onlyIfVariantChanged);
		foreach (Item item in from x in NPCShopDatabase.AllShops.SelectMany((AbstractNPCShop x) => x.ActiveEntries)
			select x.Item)
		{
			item.Refresh(onlyIfVariantChanged);
		}
	}

	private void RefreshItems(Item[] array, bool onlyIfVariantChanged)
	{
		for (int i = 0; i < array.Length; i++)
		{
			array[i]?.Refresh(onlyIfVariantChanged);
		}
	}

	public void GetItemExpectedPrice(Item item, out long calcForSelling, out long calcForBuying)
	{
		if (item.shopSpecialCurrency != -1)
		{
			CustomCurrencyManager.GetPrices(item, out calcForSelling, out calcForBuying);
			return;
		}
		int storeValue = item.GetStoreValue();
		calcForSelling = storeValue;
		calcForBuying = storeValue;
		if (discountAvailable)
		{
			if (!item.buyOnce)
			{
				calcForBuying = (int)((float)calcForBuying * 0.8f);
			}
			if (item.isAShopItem)
			{
				calcForSelling = calcForBuying;
			}
		}
		if (item.buyOnce)
		{
			calcForBuying = (int)Math.Round((double)calcForBuying / currentShoppingSettings.PriceAdjustment);
			calcForSelling = (int)Math.Round((double)calcForSelling / currentShoppingSettings.PriceAdjustment);
		}
		else
		{
			calcForBuying = (int)Math.Round((double)calcForBuying * currentShoppingSettings.PriceAdjustment);
			calcForSelling = (int)Math.Round((double)calcForSelling / currentShoppingSettings.PriceAdjustment);
		}
		if (item.buyOnce)
		{
			calcForBuying /= 5L;
			if (storeValue != 0 && calcForBuying < 1)
			{
				calcForBuying = 1L;
			}
		}
	}

	/// <summary>
	/// Attempts to "purchase" something that costs the given <paramref name="price" />.<br />
	/// Items will be taken from all of the player inventories and banks combined.<br />
	/// If <paramref name="customCurrency" /> is provided, the price will be in terms of the custom currency instead of coins.<br />
	/// If the player has enough currency, the currency will be taken from the inventories.<br />
	/// </summary>
	/// <param name="price"></param>
	/// <param name="customCurrency"></param>
	/// <returns>true if the player had enough currency to pay the price.</returns>
	public bool BuyItem(long price, int customCurrency = -1)
	{
		if (CanAfford(price, customCurrency))
		{
			return PayCurrency(price, customCurrency);
		}
		return false;
	}

	/// <summary>
	/// Checks if the player has the provided amount of money or custom currency (if <paramref name="customCurrency" /> is set) in their inventory and banks combined. Use <see cref="M:Terraria.Player.BuyItem(System.Int64,System.Int32)" /> if the player does have enough money to take that money from the player.
	/// </summary>
	public bool CanAfford(long price, int customCurrency = -1)
	{
		if (customCurrency != -1)
		{
			return CustomCurrencyManager.CanAfford(this, price, customCurrency);
		}
		bool overFlowing;
		long num = Utils.CoinsCount(out overFlowing, inventory, 58, 57, 56, 55, 54);
		long num2 = Utils.CoinsCount(out overFlowing, bank.item);
		long num3 = Utils.CoinsCount(out overFlowing, bank2.item);
		long num4 = Utils.CoinsCount(out overFlowing, bank3.item);
		long num5 = Utils.CoinsCount(out overFlowing, bank4.item);
		if (Utils.CoinsCombineStacks(out overFlowing, num, num2, num3, num4, num5) < price)
		{
			return false;
		}
		return true;
	}

	/// <summary>
	/// Attempts to "purchase" something that costs the given <paramref name="price" />.<br />
	/// Items will be taken from all of the player inventories and banks combined.<br />
	/// If <paramref name="customCurrency" /> is provided, the price will be in terms of the custom currency instead of coins.<br />
	/// The currency will be taken from the inventories.
	/// <para /> This method does not check if the player has enough currency (use <see cref="M:Terraria.Player.CanAfford(System.Int64,System.Int32)" /> to check that), the <b>game will crash if called on a player without enough currency</b>. Use <see cref="M:Terraria.Player.BuyItem(System.Int64,System.Int32)" /> instead for the more typical usage.
	/// </summary>
	public bool PayCurrency(long price, int customCurrency = -1)
	{
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_0194: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_025a: Unknown result type (might be due to invalid IL or missing references)
		//IL_02bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0320: Unknown result type (might be due to invalid IL or missing references)
		if (customCurrency != -1)
		{
			return CustomCurrencyManager.PayCurrency(this, price, customCurrency);
		}
		List<Item[]> list = new List<Item[]>();
		Dictionary<int, List<int>> dictionary = new Dictionary<int, List<int>>();
		List<Point> list2 = new List<Point>();
		List<Point> list3 = new List<Point>();
		List<Point> list4 = new List<Point>();
		List<Point> list5 = new List<Point>();
		List<Point> list6 = new List<Point>();
		List<Point> list7 = new List<Point>();
		list.Add(inventory);
		list.Add(bank.item);
		list.Add(bank2.item);
		list.Add(bank3.item);
		list.Add(bank4.item);
		for (int i = 0; i < list.Count; i++)
		{
			dictionary[i] = new List<int>();
		}
		dictionary[0] = new List<int> { 58, 57, 56, 55, 54 };
		for (int j = 0; j < list.Count; j++)
		{
			for (int k = 0; k < list[j].Length; k++)
			{
				if (!dictionary[j].Contains(k) && list[j][k].IsACoin)
				{
					list3.Add(new Point(j, k));
				}
			}
		}
		int num = 0;
		for (int num2 = list[num].Length - 1; num2 >= 0; num2--)
		{
			if (!dictionary[num].Contains(num2) && (list[num][num2].type == 0 || list[num][num2].stack == 0))
			{
				list2.Add(new Point(num, num2));
			}
		}
		num = 1;
		for (int num3 = list[num].Length - 1; num3 >= 0; num3--)
		{
			if (!dictionary[num].Contains(num3) && (list[num][num3].type == 0 || list[num][num3].stack == 0))
			{
				list4.Add(new Point(num, num3));
			}
		}
		num = 2;
		for (int num4 = list[num].Length - 1; num4 >= 0; num4--)
		{
			if (!dictionary[num].Contains(num4) && (list[num][num4].type == 0 || list[num][num4].stack == 0))
			{
				list5.Add(new Point(num, num4));
			}
		}
		num = 3;
		for (int num5 = list[num].Length - 1; num5 >= 0; num5--)
		{
			if (!dictionary[num].Contains(num5) && (list[num][num5].type == 0 || list[num][num5].stack == 0))
			{
				list6.Add(new Point(num, num5));
			}
		}
		num = 4;
		for (int num6 = list[num].Length - 1; num6 >= 0; num6--)
		{
			if (!dictionary[num].Contains(num6) && (list[num][num6].type == 0 || list[num][num6].stack == 0))
			{
				list7.Add(new Point(num, num6));
			}
		}
		if (TryPurchasing(price, list, list3, list2, list4, list5, list6, list7))
		{
			return false;
		}
		return true;
	}

	private static bool TryPurchasing(long price, List<Item[]> inv, List<Point> slotCoins, List<Point> slotsEmpty, List<Point> slotEmptyBank, List<Point> slotEmptyBank2, List<Point> slotEmptyBank3, List<Point> slotEmptyBank4)
	{
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_066c: Unknown result type (might be due to invalid IL or missing references)
		//IL_067d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0365: Unknown result type (might be due to invalid IL or missing references)
		//IL_036f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0395: Unknown result type (might be due to invalid IL or missing references)
		//IL_057a: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0584: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01be: Unknown result type (might be due to invalid IL or missing references)
		//IL_058f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_03be: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0404: Unknown result type (might be due to invalid IL or missing references)
		//IL_0260: Unknown result type (might be due to invalid IL or missing references)
		//IL_026c: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_02cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0311: Unknown result type (might be due to invalid IL or missing references)
		//IL_0323: Unknown result type (might be due to invalid IL or missing references)
		//IL_0338: Unknown result type (might be due to invalid IL or missing references)
		//IL_033d: Unknown result type (might be due to invalid IL or missing references)
		//IL_028b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0297: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0467: Unknown result type (might be due to invalid IL or missing references)
		//IL_0473: Unknown result type (might be due to invalid IL or missing references)
		//IL_04b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_04c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_04d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_04ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_04ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0518: Unknown result type (might be due to invalid IL or missing references)
		//IL_052a: Unknown result type (might be due to invalid IL or missing references)
		//IL_053f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0544: Unknown result type (might be due to invalid IL or missing references)
		//IL_0492: Unknown result type (might be due to invalid IL or missing references)
		//IL_049e: Unknown result type (might be due to invalid IL or missing references)
		//IL_04ae: Unknown result type (might be due to invalid IL or missing references)
		long num = price;
		Dictionary<Point, Item> dictionary = new Dictionary<Point, Item>();
		bool result = false;
		Point val = default(Point);
		while (num > 0)
		{
			long num2 = 1000000L;
			for (int i = 0; i < 4; i++)
			{
				if (num >= num2)
				{
					foreach (Point slotCoin in slotCoins)
					{
						if (inv[slotCoin.X][slotCoin.Y].type == 74 - i)
						{
							long num3 = num / num2;
							dictionary[slotCoin] = inv[slotCoin.X][slotCoin.Y].Clone();
							if (num3 < inv[slotCoin.X][slotCoin.Y].stack)
							{
								inv[slotCoin.X][slotCoin.Y].stack -= (int)num3;
							}
							else
							{
								inv[slotCoin.X][slotCoin.Y].SetDefaults();
								slotsEmpty.Add(slotCoin);
							}
							num -= num2 * (dictionary[slotCoin].stack - inv[slotCoin.X][slotCoin.Y].stack);
						}
					}
				}
				num2 /= 100;
			}
			if (num <= 0)
			{
				continue;
			}
			if (slotsEmpty.Count > 0)
			{
				slotsEmpty.Sort(DelegateMethods.CompareYReverse);
				((Point)(ref val))..ctor(-1, -1);
				for (int j = 0; j < inv.Count; j++)
				{
					num2 = 10000L;
					for (int k = 0; k < 3; k++)
					{
						if (num >= num2)
						{
							foreach (Point slotCoin2 in slotCoins)
							{
								if (slotCoin2.X == j && inv[slotCoin2.X][slotCoin2.Y].type == 74 - k && inv[slotCoin2.X][slotCoin2.Y].stack >= 1)
								{
									List<Point> list = slotsEmpty;
									if (j == 1 && slotEmptyBank.Count > 0)
									{
										list = slotEmptyBank;
									}
									if (j == 2 && slotEmptyBank2.Count > 0)
									{
										list = slotEmptyBank2;
									}
									if (j == 3 && slotEmptyBank3.Count > 0)
									{
										list = slotEmptyBank3;
									}
									if (j == 4 && slotEmptyBank4.Count > 0)
									{
										list = slotEmptyBank4;
									}
									if (--inv[slotCoin2.X][slotCoin2.Y].stack <= 0)
									{
										inv[slotCoin2.X][slotCoin2.Y].SetDefaults();
										list.Add(slotCoin2);
									}
									dictionary[list[0]] = inv[list[0].X][list[0].Y].Clone();
									inv[list[0].X][list[0].Y].SetDefaults(73 - k);
									inv[list[0].X][list[0].Y].stack = 100;
									val = list[0];
									list.RemoveAt(0);
									break;
								}
							}
						}
						if (val.X != -1 || val.Y != -1)
						{
							break;
						}
						num2 /= 100;
					}
					for (int l = 0; l < 2; l++)
					{
						if (val.X != -1 || val.Y != -1)
						{
							continue;
						}
						foreach (Point slotCoin3 in slotCoins)
						{
							if (slotCoin3.X == j && inv[slotCoin3.X][slotCoin3.Y].type == 73 + l && inv[slotCoin3.X][slotCoin3.Y].stack >= 1)
							{
								List<Point> list2 = slotsEmpty;
								if (j == 1 && slotEmptyBank.Count > 0)
								{
									list2 = slotEmptyBank;
								}
								if (j == 2 && slotEmptyBank2.Count > 0)
								{
									list2 = slotEmptyBank2;
								}
								if (j == 3 && slotEmptyBank3.Count > 0)
								{
									list2 = slotEmptyBank3;
								}
								if (j == 4 && slotEmptyBank4.Count > 0)
								{
									list2 = slotEmptyBank4;
								}
								if (--inv[slotCoin3.X][slotCoin3.Y].stack <= 0)
								{
									inv[slotCoin3.X][slotCoin3.Y].SetDefaults();
									list2.Add(slotCoin3);
								}
								dictionary[list2[0]] = inv[list2[0].X][list2[0].Y].Clone();
								inv[list2[0].X][list2[0].Y].SetDefaults(72 + l);
								inv[list2[0].X][list2[0].Y].stack = 100;
								val = list2[0];
								list2.RemoveAt(0);
								break;
							}
						}
					}
					if (val.X != -1 && val.Y != -1)
					{
						slotCoins.Add(val);
						break;
					}
				}
				slotsEmpty.Sort(DelegateMethods.CompareYReverse);
				slotEmptyBank.Sort(DelegateMethods.CompareYReverse);
				slotEmptyBank2.Sort(DelegateMethods.CompareYReverse);
				slotEmptyBank3.Sort(DelegateMethods.CompareYReverse);
				slotEmptyBank4.Sort(DelegateMethods.CompareYReverse);
				continue;
			}
			foreach (KeyValuePair<Point, Item> item in dictionary)
			{
				inv[item.Key.X][item.Key.Y] = item.Value.Clone();
			}
			result = true;
			break;
		}
		return result;
	}

	public void AdjTiles()
	{
		int num = 4;
		int num2 = 3;
		if (ateArtisanBread)
		{
			num += 4;
			num2 += 4;
		}
		for (int i = 0; i < adjTile.Length; i++)
		{
			oldAdjTile[i] = adjTile[i];
			adjTile[i] = false;
		}
		oldAdjWater = adjWater;
		adjWater = false;
		oldAdjHoney = adjHoney;
		adjHoney = false;
		oldAdjLava = adjLava;
		adjLava = false;
		oldAdjShimmer = adjShimmer;
		adjShimmer = false;
		alchemyTable = false;
		int num3 = (int)((position.X + (float)(width / 2)) / 16f);
		int num4 = (int)((position.Y + (float)height) / 16f);
		for (int j = num3 - num; j <= num3 + num; j++)
		{
			for (int k = num4 - num2; k < num4 + num2; k++)
			{
				if (Main.tile[j, k].active())
				{
					adjTile[Main.tile[j, k].type] = true;
					switch (Main.tile[j, k].type)
					{
					case 77:
					case 302:
						adjTile[17] = true;
						break;
					case 133:
						adjTile[17] = true;
						adjTile[77] = true;
						break;
					case 134:
						adjTile[16] = true;
						break;
					case 354:
					case 469:
					case 487:
						adjTile[14] = true;
						break;
					case 355:
						adjTile[13] = true;
						adjTile[14] = true;
						alchemyTable = true;
						break;
					}
					TileLoader.AdjTiles(this, Main.tile[j, k].type);
				}
				if ((Main.tile[j, k].liquid > 200 && Main.tile[j, k].liquidType() == 0) || TileID.Sets.CountsAsWaterSource[Main.tile[j, k].type])
				{
					adjWater = true;
				}
				if ((Main.tile[j, k].liquid > 200 && Main.tile[j, k].liquidType() == 2) || TileID.Sets.CountsAsHoneySource[Main.tile[j, k].type])
				{
					adjHoney = true;
				}
				if ((Main.tile[j, k].liquid > 200 && Main.tile[j, k].liquidType() == 1) || TileID.Sets.CountsAsLavaSource[Main.tile[j, k].type])
				{
					adjLava = true;
				}
				if ((Main.tile[j, k].liquid > 200 && Main.tile[j, k].liquidType() == 3) || TileID.Sets.CountsAsShimmerSource[Main.tile[j, k].type])
				{
					adjShimmer = true;
				}
			}
		}
		if (!Main.playerInventory)
		{
			return;
		}
		bool flag = false;
		for (int l = 0; l < adjTile.Length; l++)
		{
			if (oldAdjTile[l] != adjTile[l])
			{
				flag = true;
				break;
			}
		}
		if (adjWater != oldAdjWater)
		{
			flag = true;
		}
		if (adjHoney != oldAdjHoney)
		{
			flag = true;
		}
		if (adjLava != oldAdjLava)
		{
			flag = true;
		}
		if (adjShimmer != oldAdjShimmer)
		{
			flag = true;
		}
		if (flag)
		{
			Recipe.FindRecipes();
		}
	}

	public bool IsTileTypeInInteractionRange(int targetTileType, TileReachCheckSettings settings)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		Point val = position.ToTileCoordinates();
		Point val2 = base.BottomRight.ToTileCoordinates();
		settings.GetRanges(this, out var x, out var y);
		int num = Utils.Clamp(val.X - x + 1, 0, Main.maxTilesX - 1);
		int num2 = Utils.Clamp(val2.X + x - 1, 0, Main.maxTilesX - 1);
		int num3 = Utils.Clamp(val.Y - y + 1, 0, Main.maxTilesY - 1);
		int num4 = Utils.Clamp(val2.Y + y - 2, 0, Main.maxTilesY - 1);
		for (int i = num; i <= num2; i++)
		{
			for (int j = num3; j <= num4; j++)
			{
				Tile tile = Main.tile[i, j];
				if (tile != null && tile.active() && tile.type == targetTileType)
				{
					return true;
				}
			}
		}
		return false;
	}

	public void DisplayDollUpdate()
	{
		if (!Main.gamePaused)
		{
			UpdateMiscCounter();
		}
	}

	public bool IsColorfulDye(int dye)
	{
		if (dye > 0)
		{
			return ItemID.Sets.ColorfulDyeValues[dye];
		}
		return false;
	}

	public bool ShouldDrawFootball()
	{
		bool result = hasFootball && !pulley && !compositeBackArm.enabled;
		if (HeldItem.type == 4743 && itemAnimation > 0)
		{
			result = false;
		}
		return result;
	}

	public void PlayerFrame()
	{
		//IL_1635: Unknown result type (might be due to invalid IL or missing references)
		//IL_16ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_0714: Unknown result type (might be due to invalid IL or missing references)
		//IL_0719: Unknown result type (might be due to invalid IL or missing references)
		//IL_1d83: Unknown result type (might be due to invalid IL or missing references)
		//IL_0950: Unknown result type (might be due to invalid IL or missing references)
		//IL_095f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0893: Unknown result type (might be due to invalid IL or missing references)
		//IL_08bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_08f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0901: Unknown result type (might be due to invalid IL or missing references)
		//IL_0906: Unknown result type (might be due to invalid IL or missing references)
		//IL_074a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0759: Unknown result type (might be due to invalid IL or missing references)
		//IL_075e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0763: Unknown result type (might be due to invalid IL or missing references)
		//IL_076a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0781: Unknown result type (might be due to invalid IL or missing references)
		//IL_0787: Unknown result type (might be due to invalid IL or missing references)
		//IL_1a91: Unknown result type (might be due to invalid IL or missing references)
		//IL_1ebc: Unknown result type (might be due to invalid IL or missing references)
		//IL_1d58: Unknown result type (might be due to invalid IL or missing references)
		//IL_1a62: Unknown result type (might be due to invalid IL or missing references)
		//IL_1a3d: Unknown result type (might be due to invalid IL or missing references)
		//IL_09eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a0f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a15: Unknown result type (might be due to invalid IL or missing references)
		//IL_1c5c: Unknown result type (might be due to invalid IL or missing references)
		//IL_1a11: Unknown result type (might be due to invalid IL or missing references)
		//IL_0ad3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0af7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0afd: Unknown result type (might be due to invalid IL or missing references)
		//IL_18b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_18db: Unknown result type (might be due to invalid IL or missing references)
		//IL_190f: Unknown result type (might be due to invalid IL or missing references)
		//IL_1915: Unknown result type (might be due to invalid IL or missing references)
		//IL_192c: Unknown result type (might be due to invalid IL or missing references)
		//IL_1936: Unknown result type (might be due to invalid IL or missing references)
		//IL_193b: Unknown result type (might be due to invalid IL or missing references)
		//IL_1753: Unknown result type (might be due to invalid IL or missing references)
		//IL_177c: Unknown result type (might be due to invalid IL or missing references)
		//IL_17b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_17b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_17cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_17d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_17dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_195f: Unknown result type (might be due to invalid IL or missing references)
		//IL_1988: Unknown result type (might be due to invalid IL or missing references)
		//IL_19bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_19c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_19d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_19e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_19e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_1800: Unknown result type (might be due to invalid IL or missing references)
		//IL_1829: Unknown result type (might be due to invalid IL or missing references)
		//IL_185d: Unknown result type (might be due to invalid IL or missing references)
		//IL_1863: Unknown result type (might be due to invalid IL or missing references)
		//IL_187a: Unknown result type (might be due to invalid IL or missing references)
		//IL_1884: Unknown result type (might be due to invalid IL or missing references)
		//IL_1889: Unknown result type (might be due to invalid IL or missing references)
		//IL_0ba6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0bca: Unknown result type (might be due to invalid IL or missing references)
		//IL_0bd0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c07: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c11: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c16: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c24: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c2a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c34: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c39: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c3e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0e5c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0e7d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0e83: Unknown result type (might be due to invalid IL or missing references)
		//IL_10fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_111f: Unknown result type (might be due to invalid IL or missing references)
		//IL_1125: Unknown result type (might be due to invalid IL or missing references)
		//IL_114e: Unknown result type (might be due to invalid IL or missing references)
		//IL_1158: Unknown result type (might be due to invalid IL or missing references)
		//IL_115d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0d03: Unknown result type (might be due to invalid IL or missing references)
		//IL_0d23: Unknown result type (might be due to invalid IL or missing references)
		//IL_0d29: Unknown result type (might be due to invalid IL or missing references)
		//IL_267b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0fa8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0fc8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0fce: Unknown result type (might be due to invalid IL or missing references)
		//IL_1291: Unknown result type (might be due to invalid IL or missing references)
		//IL_12b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_12b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_12e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_12eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_12f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_27f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_27fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_2929: Unknown result type (might be due to invalid IL or missing references)
		//IL_2c25: Unknown result type (might be due to invalid IL or missing references)
		//IL_2968: Unknown result type (might be due to invalid IL or missing references)
		//IL_1390: Unknown result type (might be due to invalid IL or missing references)
		//IL_13ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_13b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_13e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_13f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_13f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_1518: Unknown result type (might be due to invalid IL or missing references)
		//IL_1535: Unknown result type (might be due to invalid IL or missing references)
		//IL_153b: Unknown result type (might be due to invalid IL or missing references)
		//IL_14b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_14d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_14db: Unknown result type (might be due to invalid IL or missing references)
		//IL_159d: Unknown result type (might be due to invalid IL or missing references)
		//IL_15a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_15ac: Unknown result type (might be due to invalid IL or missing references)
		if (swimTime > 0)
		{
			swimTime--;
			if (!wet)
			{
				swimTime = 0;
			}
		}
		head = armor[0].headSlot;
		body = armor[1].bodySlot;
		legs = armor[2].legSlot;
		if (armor[10].headSlot >= 0)
		{
			head = armor[10].headSlot;
		}
		if (armor[11].bodySlot >= 0)
		{
			body = armor[11].bodySlot;
		}
		if (armor[12].legSlot >= 0)
		{
			legs = armor[12].legSlot;
		}
		if (!dead)
		{
			UpdateVisibleAccessories();
		}
		wearsRobe = false;
		bool somethingSpecial = false;
		int num = SetMatch(new SetMatchRequest
		{
			Head = head,
			Body = body,
			Legs = legs,
			Male = Male,
			ArmorSlotRequested = 1
		}, ref wearsRobe);
		if (num != -1)
		{
			legs = num;
		}
		num = SetMatch(new SetMatchRequest
		{
			Head = head,
			Body = body,
			Legs = legs,
			Male = Male,
			ArmorSlotRequested = 2
		}, ref somethingSpecial);
		if (num != -1)
		{
			legs = num;
		}
		num = SetMatch(new SetMatchRequest
		{
			Head = head,
			Body = body,
			Legs = legs,
			Male = Male,
			ArmorSlotRequested = 0
		}, ref somethingSpecial);
		if (num != -1)
		{
			head = num;
		}
		if (body == 93)
		{
			shield = 0;
			handoff = 0;
		}
		if (body > 0 && ArmorIDs.Body.Sets.DisableHandOnAndOffAccDraw[body])
		{
			handon = 0;
			handoff = 0;
		}
		if (body > 0 && waist > 0 && ArmorIDs.Body.Sets.DisableBeltAccDraw[body] && ArmorIDs.Waist.Sets.IsABelt[waist])
		{
			waist = 0;
		}
		if (!dead && body >= 0)
		{
			int num2 = (Male ? ArmorIDs.Body.Sets.IncludedCapeBack : ArmorIDs.Body.Sets.IncludedCapeBackFemale)[body];
			if (num2 != -1)
			{
				if (ArmorIDs.Back.Sets.DrawInBackpackLayer[num2])
				{
					backpack = num2;
					cBackpack = cBody;
				}
				else if (ArmorIDs.Back.Sets.DrawInTailLayer[num2])
				{
					tail = num2;
					cTail = cBody;
				}
				else if (back == -1)
				{
					back = num2;
					cBack = cBody;
				}
			}
			int num3 = ArmorIDs.Body.Sets.IncludedCapeFront[body];
			if (num3 != -1 && front == -1)
			{
				front = num3;
				cFront = cBody;
			}
			ArmorIDs.Body.Sets.IncludeCapeFrontAndBackInfo includeCapeFrontAndBackInfo = ArmorIDs.Body.Sets.IncludeCapeFrontAndBack[body];
			if (!includeCapeFrontAndBackInfo.Invalid && back == -1 && front == -1)
			{
				front = includeCapeFrontAndBackInfo.frontCape;
				cFront = cBody;
				int backCape = includeCapeFrontAndBackInfo.backCape;
				if (ArmorIDs.Back.Sets.DrawInBackpackLayer[backCape])
				{
					backpack = backCape;
					cBackpack = cBody;
				}
				else if (ArmorIDs.Back.Sets.DrawInTailLayer[backCape])
				{
					tail = backCape;
					cTail = cBody;
				}
				else if (!sitting.isSitting)
				{
					back = backCape;
					cBack = cBody;
				}
			}
		}
		if (legs == 67)
		{
			shoe = 0;
		}
		if (legs == 140)
		{
			shoe = 0;
		}
		bool flag = false;
		if ((wereWolf || forceWerewolf) && !hideWolf)
		{
			legs = 20;
			body = 21;
			head = 38;
			flag = true;
		}
		bool flag2 = wet && !lavaWet && (!mount.Active || !mount.IsConsideredASlimeMount);
		if (merman || forceMerman)
		{
			if (!hideMerman)
			{
				head = 39;
				legs = 21;
				body = 22;
				flag = true;
			}
			if (flag2)
			{
				wings = 0;
			}
		}
		socialShadowRocketBoots = false;
		socialIgnoreLight = false;
		socialGhost = false;
		armorEffectDrawShadow = false;
		armorEffectDrawShadowSubtle = false;
		armorEffectDrawOutlines = false;
		armorEffectDrawShadowLokis = false;
		armorEffectDrawShadowBasilisk = false;
		armorEffectDrawOutlinesForbidden = false;
		armorEffectDrawShadowEOCShield = false;
		if (!isDisplayDollOrInanimate)
		{
			if (head == 101 && body == 66 && legs == 55)
			{
				socialGhost = true;
			}
			if (head == 156 && body == 66 && legs == 55)
			{
				socialGhost = true;
			}
			SetArmorEffectVisuals(this);
		}
		hermesStepSound.Style = SoundID.Run;
		hermesStepSound.IntendedCooldown = 9;
		if (head == 99 && body == 65 && legs == 54)
		{
			turtleArmor = true;
		}
		if (head == 162 && body == 170 && legs == 105)
		{
			spiderArmor = true;
		}
		ApplyArmorSoundAndDustChanges();
		if (legs == 140)
		{
			hermesStepSound.Style = SoundID.Item24;
			hermesStepSound.IntendedCooldown = 6;
		}
		if (flag)
		{
			face = -1;
			faceFlower = -1;
			faceHead = -1;
		}
		ItemLoader.PreUpdateVanitySet(this);
		if (head > 0 && face > 0)
		{
			if (ArmorIDs.Face.Sets.OverrideHelmet[face])
			{
				head = -1;
				faceHead = -1;
			}
			else if (!ArmorIDs.Face.Sets.DrawInFaceUnderHairLayer[face])
			{
				face = -1;
			}
		}
		if (head > 0 && faceHead > 0 && ArmorIDs.Head.Sets.UseAltFaceHeadDraw[head])
		{
			int num4 = ArmorIDs.Face.Sets.AltFaceHead[faceHead];
			if (num4 > 0)
			{
				faceHead = num4;
			}
		}
		if (webbed || frozen || stoned || (Main.gamePaused && !Main.gameMenu))
		{
			return;
		}
		if (head == 267 && body == 236 && (legs == 219 || legs == 220) && miscCounter % 15 == 0 && Main.rand.Next(3) == 0)
		{
			Vector2 center = base.Center;
			float num5 = 1f + Main.rand.NextFloat() * 0.5f;
			if (Main.rand.Next(2) == 0)
			{
				num5 *= -1f;
			}
			center += new Vector2(num5 * -25f, -8f);
			Dust obj = Main.dust[Dust.NewDust(center, 2, 2, 304, 0f, 0f, 100)];
			obj.rotation = Main.rand.NextFloat() * ((float)Math.PI * 2f);
			obj.alpha = 254;
			obj.velocity.X = num5 * 0.2f;
			obj.noGravity = true;
			obj.customData = this;
			obj.shader = GameShaders.Armor.GetSecondaryShader(cBody, this);
		}
		CombinedHooks.PlayerFrameEffects(this);
		if (!isDisplayDollOrInanimate)
		{
			if (((body == 68 && legs == 57 && head == 106) || (body == 74 && legs == 63 && head == 106)) && Main.rand.Next(10) == 0)
			{
				int num6 = Dust.NewDust(new Vector2(position.X - velocity.X * 2f, position.Y - 2f - velocity.Y * 2f), width, height, 43, 0f, 0f, 100, new Color(255, 0, 255), 0.3f);
				Main.dust[num6].fadeIn = 0.8f;
				Main.dust[num6].noGravity = true;
				Dust obj2 = Main.dust[num6];
				obj2.velocity *= 2f;
				Main.dust[num6].shader = GameShaders.Armor.GetSecondaryShader(ArmorSetDye(), this);
			}
			if (wings == 27 && wingsLogic == wings)
			{
				float num7 = 0.4f * stealth;
				Lighting.AddLight((int)base.Center.X / 16, (int)base.Center.Y / 16, num7, num7 * 0.9f, num7 * 0.2f);
			}
			if (head == 5 && body == 5 && legs == 5)
			{
				socialShadowRocketBoots = true;
			}
			if (head == 5 && body == 5 && legs == 5 && Main.rand.Next(10) == 0)
			{
				int num8 = Dust.NewDust(new Vector2(position.X, position.Y), width, height, 14, 0f, 0f, 200, default(Color), 1.2f);
				Main.dust[num8].shader = GameShaders.Armor.GetSecondaryShader(ArmorSetDye(), this);
			}
			if (head == 76 && body == 49 && legs == 45)
			{
				socialShadowRocketBoots = true;
			}
			if (head == 74 && body == 48 && legs == 44)
			{
				socialShadowRocketBoots = true;
			}
			if (head == 74 && body == 48 && legs == 44 && Main.rand.Next(10) == 0)
			{
				int num9 = Dust.NewDust(new Vector2(position.X, position.Y), width, height, 14, 0f, 0f, 200, default(Color), 1.2f);
				Main.dust[num9].shader = GameShaders.Armor.GetSecondaryShader(ArmorSetDye(), this);
			}
			if (head == 57 && body == 37 && legs == 35)
			{
				int maxValue = 10;
				if (Math.Abs(velocity.X) + Math.Abs(velocity.Y) > 1f)
				{
					maxValue = 2;
				}
				if (Main.rand.Next(maxValue) == 0)
				{
					int num10 = Dust.NewDust(new Vector2(position.X, position.Y), width, height, 115, 0f, 0f, 140, default(Color), 0.75f);
					Main.dust[num10].noGravity = true;
					Main.dust[num10].fadeIn = 1.5f;
					Dust obj3 = Main.dust[num10];
					obj3.velocity *= 0.3f;
					Dust obj4 = Main.dust[num10];
					obj4.velocity += velocity * 0.2f;
					Main.dust[num10].shader = GameShaders.Armor.GetSecondaryShader(ArmorSetDye(), this);
				}
			}
			if (head == 6 && body == 6 && legs == 6 && Math.Abs(velocity.X) + Math.Abs(velocity.Y) > 1f && !rocketFrame)
			{
				for (int i = 0; i < 2; i++)
				{
					int num11 = Dust.NewDust(new Vector2(position.X - velocity.X * 2f, position.Y - 2f - velocity.Y * 2f), width, height, 6, 0f, 0f, 100, default(Color), 2f);
					Main.dust[num11].noGravity = true;
					Main.dust[num11].noLight = true;
					Main.dust[num11].velocity.X -= velocity.X * 0.5f;
					Main.dust[num11].velocity.Y -= velocity.Y * 0.5f;
					Main.dust[num11].shader = GameShaders.Armor.GetSecondaryShader(ArmorSetDye(), this);
				}
			}
			if (head == 8 && body == 8 && legs == 8 && Math.Abs(velocity.X) + Math.Abs(velocity.Y) > 1f)
			{
				int num12 = Dust.NewDust(new Vector2(position.X - velocity.X * 2f, position.Y - 2f - velocity.Y * 2f), width, height, 40, 0f, 0f, 50, default(Color), 1.4f);
				Main.dust[num12].noGravity = true;
				Main.dust[num12].velocity.X = velocity.X * 0.25f;
				Main.dust[num12].velocity.Y = velocity.Y * 0.25f;
				Main.dust[num12].shader = GameShaders.Armor.GetSecondaryShader(ArmorSetDye(), this);
			}
			if (head == 9 && body == 9 && legs == 9 && Math.Abs(velocity.X) + Math.Abs(velocity.Y) > 1f && !rocketFrame)
			{
				for (int j = 0; j < 2; j++)
				{
					int num13 = Dust.NewDust(new Vector2(position.X - velocity.X * 2f, position.Y - 2f - velocity.Y * 2f), width, height, 6, 0f, 0f, 100, default(Color), 2f);
					Main.dust[num13].noGravity = true;
					Main.dust[num13].noLight = true;
					Main.dust[num13].velocity.X -= velocity.X * 0.5f;
					Main.dust[num13].velocity.Y -= velocity.Y * 0.5f;
					Main.dust[num13].shader = GameShaders.Armor.GetSecondaryShader(ArmorSetDye(), this);
				}
			}
			if (body == 18 && legs == 17 && (head == 32 || head == 33 || head == 34) && Main.rand.Next(10) == 0)
			{
				int num14 = Dust.NewDust(new Vector2(position.X - velocity.X * 2f, position.Y - 2f - velocity.Y * 2f), width, height, 43, 0f, 0f, 100, default(Color), 0.3f);
				Main.dust[num14].fadeIn = 0.8f;
				Dust obj5 = Main.dust[num14];
				obj5.velocity *= 0f;
				Main.dust[num14].shader = GameShaders.Armor.GetSecondaryShader(ArmorSetDye(), this);
			}
			if ((body == 24 || body == 229) && (legs == 23 || legs == 212) && (head == 43 || head == 41 || head == 42 || head == 254 || head == 255 || head == 256 || head == 257 || head == 258) && velocity.X != 0f && velocity.Y != 0f && Main.rand.Next(10) == 0)
			{
				int num15 = Dust.NewDust(new Vector2(position.X - velocity.X * 2f, position.Y - 2f - velocity.Y * 2f), width, height, 43, 0f, 0f, 100, default(Color), 0.3f);
				Main.dust[num15].fadeIn = 0.8f;
				Dust obj6 = Main.dust[num15];
				obj6.velocity *= 0f;
				Main.dust[num15].shader = GameShaders.Armor.GetSecondaryShader(ArmorSetDye(), this);
			}
			if (body == 36 && head == 56 && velocity.X != 0f && velocity.Y == 0f)
			{
				for (int k = 0; k < 2; k++)
				{
					int num16 = Dust.NewDust(new Vector2(position.X, position.Y + (float)((gravDir == 1f) ? (height - 2) : (-4))), width, 6, 106, 0f, 0f, 100, default(Color), 0.1f);
					Main.dust[num16].fadeIn = 1f;
					Main.dust[num16].noGravity = true;
					Dust obj7 = Main.dust[num16];
					obj7.velocity *= 0.2f;
					Main.dust[num16].shader = GameShaders.Armor.GetSecondaryShader(ArmorSetDye(), this);
				}
			}
			if (body == 27 && head == 46 && legs == 26 && velocity.X != 0f && velocity.Y == 0f && miscCounter % 2 == 0)
			{
				for (int l = 0; l < 2; l++)
				{
					int num17 = ((l != 0) ? Dust.NewDust(new Vector2(position.X + (float)(width / 2), position.Y + (float)height + gfxOffY), width / 2, 6, 76, 0f, 0f, 0, default(Color), 1.35f) : Dust.NewDust(new Vector2(position.X, position.Y + (float)height + gfxOffY), width / 2, 6, 76, 0f, 0f, 0, default(Color), 1.35f));
					Main.dust[num17].scale *= 1f + (float)Main.rand.Next(20, 40) * 0.01f;
					Main.dust[num17].noGravity = true;
					Main.dust[num17].noLight = true;
					Dust obj8 = Main.dust[num17];
					obj8.velocity *= 0.001f;
					Main.dust[num17].velocity.Y -= 0.003f;
					Main.dust[num17].shader = GameShaders.Armor.GetSecondaryShader(ArmorSetDye(), this);
				}
			}
		}
		drawingFootball = false;
		if (ShouldDrawFootball())
		{
			SetCompositeArmBack(enabled: true, CompositeArmStretchAmount.Full, (float)Math.PI / 10f * (float)direction * -1f);
			drawingFootball = true;
		}
		Item.GetDrawHitbox(HeldItem.type, this);
		bool flag3 = CanVisuallyHoldItem(HeldItem);
		bool flag4 = HeldItem.useStyle != 14;
		ItemLoader.UpdateVanitySet(this);
		if (mount.Active)
		{
			legFrameCounter = 0.0;
			legFrame.Y = legFrame.Height * 6;
			if (mount.Type == 23 || mount.Type == 45 || mount.Type == 48)
			{
				ref Rectangle reference = ref legFrame;
				_ = legFrame;
				reference.Y = 0;
			}
			if (velocity.Y != 0f)
			{
				if (mount.FlyTime > 0 && jump == 0 && controlJump && !mount.CanHover())
				{
					if (mount.Type == 0)
					{
						if (direction > 0)
						{
							if (Main.rand.Next(4) == 0)
							{
								int num18 = Dust.NewDust(new Vector2(base.Center.X - 22f, position.Y + (float)height - 6f), 20, 10, 64, velocity.X * 0.25f, velocity.Y * 0.25f, 255);
								Dust obj9 = Main.dust[num18];
								obj9.velocity *= 0.1f;
								Main.dust[num18].noLight = true;
							}
							if (Main.rand.Next(4) == 0)
							{
								int num19 = Dust.NewDust(new Vector2(base.Center.X + 12f, position.Y + (float)height - 6f), 20, 10, 64, velocity.X * 0.25f, velocity.Y * 0.25f, 255);
								Dust obj10 = Main.dust[num19];
								obj10.velocity *= 0.1f;
								Main.dust[num19].noLight = true;
							}
						}
						else
						{
							if (Main.rand.Next(4) == 0)
							{
								int num20 = Dust.NewDust(new Vector2(base.Center.X - 32f, position.Y + (float)height - 6f), 20, 10, 64, velocity.X * 0.25f, velocity.Y * 0.25f, 255);
								Dust obj11 = Main.dust[num20];
								obj11.velocity *= 0.1f;
								Main.dust[num20].noLight = true;
							}
							if (Main.rand.Next(4) == 0)
							{
								int num21 = Dust.NewDust(new Vector2(base.Center.X + 2f, position.Y + (float)height - 6f), 20, 10, 64, velocity.X * 0.25f, velocity.Y * 0.25f, 255);
								Dust obj12 = Main.dust[num21];
								obj12.velocity *= 0.1f;
								Main.dust[num21].noLight = true;
							}
						}
					}
					mount.TryBeginningFlight(this, 3);
					mount.UpdateFrame(this, 3, velocity);
					mount.TryLanding(this);
				}
				else if (wet)
				{
					mount.UpdateFrame(this, 4, velocity);
				}
				else
				{
					mount.TryBeginningFlight(this, 2);
					mount.UpdateFrame(this, 2, velocity);
					mount.TryLanding(this);
				}
			}
			else
			{
				mount.UpdateFrame(this, mount.GetIntendedGroundedFrame(this), velocity);
			}
		}
		else if (legs != 140)
		{
			if (swimTime > 0)
			{
				legFrameCounter += 2.0;
				while (legFrameCounter > 8.0)
				{
					legFrameCounter -= 8.0;
					legFrame.Y += legFrame.Height;
				}
				if (legFrame.Y < legFrame.Height * 7)
				{
					legFrame.Y = legFrame.Height * 19;
				}
				else if (legFrame.Y > legFrame.Height * 19)
				{
					legFrame.Y = legFrame.Height * 7;
				}
			}
			else if (velocity.Y != 0f || grappling[0] > -1)
			{
				legFrameCounter = 0.0;
				legFrame.Y = legFrame.Height * 5;
				if ((wings == 22 || wings == 28 || wings == 45) && ShouldDrawWingsThatAreAlwaysAnimated())
				{
					legFrame.Y = 0;
				}
			}
			else if (velocity.X != 0f)
			{
				if ((slippy || slippy2 || windPushed) && !controlLeft && !controlRight)
				{
					legFrameCounter = 0.0;
					ref Rectangle reference2 = ref legFrame;
					_ = legFrame;
					reference2.Y = 0;
				}
				else
				{
					legFrameCounter += (double)Math.Abs(velocity.X) * 1.3;
					while (legFrameCounter > 8.0)
					{
						legFrameCounter -= 8.0;
						legFrame.Y += legFrame.Height;
					}
					if (legFrame.Y < legFrame.Height * 7)
					{
						legFrame.Y = legFrame.Height * 19;
					}
					else if (legFrame.Y > legFrame.Height * 19)
					{
						legFrame.Y = legFrame.Height * 7;
					}
				}
			}
			else
			{
				legFrameCounter = 0.0;
				ref Rectangle reference3 = ref legFrame;
				_ = legFrame;
				reference3.Y = 0;
			}
		}
		if (carpetFrame >= 0)
		{
			legFrameCounter = 0.0;
			ref Rectangle reference4 = ref legFrame;
			_ = legFrame;
			reference4.Y = 0;
		}
		if (sandStorm)
		{
			if (grappling[0] >= 0)
			{
				sandStorm = false;
			}
			if (miscCounter % 4 == 0 && itemAnimation == 0)
			{
				ChangeDir(direction * -1);
				if (inventory[selectedItem].holdStyle == 2)
				{
					if (inventory[selectedItem].type == 946 || inventory[selectedItem].type == 4707)
					{
						itemLocation.X = position.X + (float)width * 0.5f - (float)(16 * direction);
					}
					if (inventory[selectedItem].type == 186)
					{
						itemLocation.X = position.X + (float)width * 0.5f + (float)(6 * direction);
						itemRotation = 0.79f * (float)(-direction);
					}
				}
			}
			legFrameCounter = 0.0;
			ref Rectangle reference5 = ref legFrame;
			_ = legFrame;
			reference5.Y = 0;
		}
		else if (itemAnimation > 0 && inventory[selectedItem].useStyle != 10 && flag4)
		{
			if (inventory[selectedItem].useStyle == 1 || inventory[selectedItem].type == 0)
			{
				if ((double)itemAnimation < (double)itemAnimationMax * 0.333)
				{
					bodyFrame.Y = bodyFrame.Height * 3;
				}
				else if ((double)itemAnimation < (double)itemAnimationMax * 0.666)
				{
					bodyFrame.Y = bodyFrame.Height * 2;
				}
				else
				{
					bodyFrame.Y = bodyFrame.Height;
				}
			}
			else if (inventory[selectedItem].useStyle == 7)
			{
				if ((double)itemAnimation > (double)itemAnimationMax * 0.5)
				{
					bodyFrame.Y = bodyFrame.Height * 3;
				}
				else
				{
					bodyFrame.Y = bodyFrame.Height * 2;
				}
			}
			else if (inventory[selectedItem].useStyle == 2)
			{
				bodyFrame.Y = bodyFrame.Height * 3;
			}
			else if (inventory[selectedItem].useStyle == 11)
			{
				if ((double)itemAnimation > (double)itemAnimationMax * 0.5)
				{
					bodyFrame.Y = bodyFrame.Height * 4;
				}
				else if ((double)itemAnimation > (double)itemAnimationMax * 0.15)
				{
					bodyFrame.Y = bodyFrame.Height * 3;
				}
				else
				{
					bodyFrame.Y = bodyFrame.Height * 2;
				}
			}
			else if (inventory[selectedItem].useStyle == 9)
			{
				bodyFrame.Y = 0;
			}
			else if (inventory[selectedItem].useStyle == 6)
			{
				float num22 = 1f - (float)itemAnimation / (float)itemAnimationMax;
				num22 *= 6f;
				if (num22 > 1f)
				{
					num22 = 1f;
				}
				if (num22 >= 0.5f)
				{
					bodyFrame.Y = bodyFrame.Height * 3;
				}
				else
				{
					bodyFrame.Y = bodyFrame.Height * 2;
				}
			}
			else if (inventory[selectedItem].useStyle == 3)
			{
				if ((double)itemAnimation > (double)itemAnimationMax * 0.666)
				{
					bodyFrame.Y = bodyFrame.Height * 3;
				}
				else
				{
					bodyFrame.Y = bodyFrame.Height * 3;
				}
			}
			else if (inventory[selectedItem].useStyle == 4)
			{
				bodyFrame.Y = bodyFrame.Height * 2;
			}
			else if (inventory[selectedItem].useStyle == 8)
			{
				bodyFrame.Y = 0;
			}
			else if (inventory[selectedItem].useStyle == 12)
			{
				bodyFrame.Y = bodyFrame.Height * 3;
			}
			else if (inventory[selectedItem].useStyle == 13)
			{
				if ((double)itemAnimation < (double)itemAnimationMax * 0.333)
				{
					bodyFrame.Y = bodyFrame.Height * 3;
				}
				else if ((double)itemAnimation < (double)itemAnimationMax * 0.666)
				{
					bodyFrame.Y = bodyFrame.Height * 2;
				}
				else
				{
					bodyFrame.Y = bodyFrame.Height;
				}
			}
			else if (inventory[selectedItem].useStyle == 5)
			{
				if (inventory[selectedItem].type == 281 || inventory[selectedItem].type == 986)
				{
					bodyFrame.Y = bodyFrame.Height * 2;
				}
				else
				{
					float num23 = itemRotation * (float)direction;
					bodyFrame.Y = bodyFrame.Height * 3;
					if ((double)num23 < -0.75)
					{
						bodyFrame.Y = bodyFrame.Height * 2;
						if (gravDir == -1f)
						{
							bodyFrame.Y = bodyFrame.Height * 4;
						}
					}
					if ((double)num23 > 0.6)
					{
						bodyFrame.Y = bodyFrame.Height * 4;
						if (gravDir == -1f)
						{
							bodyFrame.Y = bodyFrame.Height * 2;
						}
					}
				}
			}
			ItemLoader.UseItemFrame(inventory[selectedItem], this);
		}
		else if (pulley)
		{
			if (pulleyDir == 2)
			{
				bodyFrame.Y = bodyFrame.Height;
			}
			else
			{
				bodyFrame.Y = bodyFrame.Height * 2;
			}
		}
		else if (flag3 && inventory[selectedItem].holdStyle == 1 && (!wet || !inventory[selectedItem].noWet || ItemID.Sets.WaterTorches[BiomeTorchHoldStyle(inventory[selectedItem].type)]) && (!happyFunTorchTime || inventory[selectedItem].createTile != 4))
		{
			bodyFrame.Y = bodyFrame.Height * 3;
		}
		else if (flag3 && inventory[selectedItem].holdStyle == 2 && (!wet || !inventory[selectedItem].noWet))
		{
			bodyFrame.Y = bodyFrame.Height * 2;
		}
		else if (flag3 && inventory[selectedItem].holdStyle == 3)
		{
			bodyFrame.Y = bodyFrame.Height * 3;
		}
		else if (flag3 && inventory[selectedItem].holdStyle == 5)
		{
			bodyFrame.Y = bodyFrame.Height * 3;
		}
		else if (flag3 && inventory[selectedItem].holdStyle == 7)
		{
			bodyFrame.Y = bodyFrame.Height * 11;
		}
		else if (flag3 && inventory[selectedItem].holdStyle == 4 && velocity.Y == 0f && gravDir == 1f)
		{
			ref Rectangle reference6 = ref bodyFrame;
			_ = bodyFrame;
			reference6.Y = 0;
		}
		else if (shieldRaised)
		{
			bodyFrame.Y = bodyFrame.Height * 10;
		}
		else if (mount.Active)
		{
			bodyFrameCounter = 0.0;
			bodyFrame.Y = bodyFrame.Height * mount.BodyFrame;
		}
		else if (grappling[0] >= 0)
		{
			sandStorm = false;
			CancelAllJumpVisualEffects();
			Vector2 val = default(Vector2);
			((Vector2)(ref val))..ctor(position.X + (float)width * 0.5f, position.Y + (float)height * 0.5f);
			float num24 = 0f;
			float num25 = 0f;
			for (int m = 0; m < grapCount; m++)
			{
				num24 += Main.projectile[grappling[m]].position.X + (float)(Main.projectile[grappling[m]].width / 2);
				num25 += Main.projectile[grappling[m]].position.Y + (float)(Main.projectile[grappling[m]].height / 2);
			}
			num24 /= (float)grapCount;
			num25 /= (float)grapCount;
			num24 -= val.X;
			num25 -= val.Y;
			if (num25 < 0f && Math.Abs(num25) > Math.Abs(num24))
			{
				bodyFrame.Y = bodyFrame.Height * 2;
				if (gravDir == -1f)
				{
					bodyFrame.Y = bodyFrame.Height * 4;
				}
			}
			else if (num25 > 0f && Math.Abs(num25) > Math.Abs(num24))
			{
				bodyFrame.Y = bodyFrame.Height * 4;
				if (gravDir == -1f)
				{
					bodyFrame.Y = bodyFrame.Height * 2;
				}
			}
			else
			{
				bodyFrame.Y = bodyFrame.Height * 3;
			}
		}
		else if (wet && ShouldFloatInWater)
		{
			bodyFrame.Y = bodyFrame.Height * 10;
		}
		else if (swimTime > 0)
		{
			if (swimTime > 20)
			{
				ref Rectangle reference7 = ref bodyFrame;
				_ = bodyFrame;
				reference7.Y = 0;
			}
			else if (swimTime > 10)
			{
				bodyFrame.Y = bodyFrame.Height * 5;
			}
			else
			{
				ref Rectangle reference8 = ref bodyFrame;
				_ = bodyFrame;
				reference8.Y = 0;
			}
		}
		else if (velocity.Y != 0f)
		{
			if (sliding)
			{
				bodyFrame.Y = bodyFrame.Height * 3;
			}
			else if (sandStorm || carpetFrame >= 0)
			{
				bodyFrame.Y = bodyFrame.Height * 6;
			}
			else if (eocDash > 0)
			{
				bodyFrame.Y = bodyFrame.Height * 6;
			}
			else if (wings > 0)
			{
				if (wings == 22 || wings == 28 || wings == 45)
				{
					bodyFrame.Y = 0;
				}
				else if (velocity.Y > 0f)
				{
					if (controlJump)
					{
						bodyFrame.Y = bodyFrame.Height * 6;
					}
					else
					{
						bodyFrame.Y = bodyFrame.Height * 5;
					}
				}
				else
				{
					bodyFrame.Y = bodyFrame.Height * 6;
				}
			}
			else
			{
				bodyFrame.Y = bodyFrame.Height * 5;
			}
			bodyFrameCounter = 0.0;
		}
		else if (velocity.X != 0f)
		{
			if (legs == 140)
			{
				bodyFrameCounter += Math.Abs(velocity.X) * 0.5f;
				while (bodyFrameCounter > 8.0)
				{
					bodyFrameCounter -= 8.0;
					bodyFrame.Y += bodyFrame.Height;
				}
				if (bodyFrame.Y < bodyFrame.Height * 7)
				{
					bodyFrame.Y = bodyFrame.Height * 19;
				}
				else if (bodyFrame.Y > bodyFrame.Height * 19)
				{
					bodyFrame.Y = bodyFrame.Height * 7;
				}
			}
			else
			{
				bodyFrameCounter += (double)Math.Abs(velocity.X) * 1.5;
				bodyFrame.Y = legFrame.Y;
			}
		}
		else
		{
			bodyFrameCounter = 0.0;
			ref Rectangle reference9 = ref bodyFrame;
			_ = bodyFrame;
			reference9.Y = 0;
		}
		if (flag3 && itemAnimation <= 0)
		{
			ItemLoader.HoldItemFrame(inventory[selectedItem], this);
		}
		if (legs == 140)
		{
			legFrameCounter = 0.0;
			legFrame.Y = legFrame.Height * (velocity.Y != 0f).ToInt();
			int num26 = bodyFrame.Y / bodyFrame.Height;
			if (Main.OffsetsPlayerHeadgear[num26].Y == 0f)
			{
				legFrame.Y = legFrame.Height * 7;
			}
			if (wings == 22 || wings == 28)
			{
				legFrame.Y = 0;
			}
		}
		if (legs == 217 && (sitting.isSitting || sleeping.isSleeping))
		{
			legFrameCounter = 0.0;
			legFrame.Y = legFrame.Height * 5;
		}
		if (head == 259 && !skipAnimatingValuesInPlayerFrame)
		{
			rabbitOrderFrame.Update();
		}
	}

	private void CancelAllJumpVisualEffects()
	{
		ExtraJumpLoader.StopActiveJump(this, out var _);
	}

	public void CancelAllBootRunVisualEffects()
	{
		sailDash = false;
		coldDash = false;
		desertDash = false;
		fairyBoots = false;
		hellfireTreads = false;
	}

	private void UpdateFishingBobber(Item item)
	{
		switch (item.type)
		{
		case 5139:
			overrideFishingBobber = 986;
			break;
		case 5140:
			overrideFishingBobber = 987;
			break;
		case 5141:
			overrideFishingBobber = 988;
			break;
		case 5142:
			overrideFishingBobber = 989;
			break;
		case 5143:
			overrideFishingBobber = 990;
			break;
		case 5144:
			overrideFishingBobber = 991;
			break;
		case 5145:
			overrideFishingBobber = 992;
			break;
		case 5146:
			overrideFishingBobber = 993;
			break;
		}
	}

	private void UpdateBootVisualEffects(Item item)
	{
		switch (item.type)
		{
		case 128:
			vanityRocketBoots = 1;
			break;
		case 54:
			CancelAllBootRunVisualEffects();
			break;
		case 405:
		case 898:
			CancelAllBootRunVisualEffects();
			vanityRocketBoots = 2;
			break;
		case 4874:
			CancelAllBootRunVisualEffects();
			vanityRocketBoots = 5;
			hellfireTreads = true;
			break;
		case 1862:
			CancelAllBootRunVisualEffects();
			vanityRocketBoots = 3;
			break;
		case 5000:
			CancelAllBootRunVisualEffects();
			vanityRocketBoots = 4;
			break;
		case 3200:
		case 3990:
			CancelAllBootRunVisualEffects();
			sailDash = true;
			break;
		case 1579:
			CancelAllBootRunVisualEffects();
			coldDash = true;
			break;
		case 4055:
			CancelAllBootRunVisualEffects();
			desertDash = true;
			break;
		case 3993:
			CancelAllBootRunVisualEffects();
			fairyBoots = true;
			vanityRocketBoots = 2;
			break;
		}
	}

	private void UpdateVisibleAccessories()
	{
		for (int i = 3; i < 10; i++)
		{
			if (IsItemSlotUnlockedAndUsable(i))
			{
				UpdateVisibleAccessories(armor[i], hideVisibleAccessory[i], i);
			}
		}
		PlayerLoader.UpdateVisibleAccessories(this);
		for (int j = 13; j < 20; j++)
		{
			if (IsItemSlotUnlockedAndUsable(j))
			{
				Item item = armor[j];
				if (!ItemIsVisuallyIncompatible(item))
				{
					UpdateVisibleAccessory(j, item);
				}
			}
		}
		PlayerLoader.UpdateVisibleVanityAccessories(this);
		if (HeldItem.type == 4760 && ownedProjectileCounts[866] < 1)
		{
			shield = 9;
			cShield = 0;
		}
	}

	public bool ItemIsVisuallyIncompatible(Item item)
	{
		if (compositeBackArm.enabled && item.shieldSlot > 0)
		{
			return true;
		}
		if (item.shieldSlot > 0 && ItemID.Sets.IsFood[HeldItem.type])
		{
			return true;
		}
		if (body == 96 && item.backSlot > 0 && item.backSlot < ArmorIDs.Back.Count && ArmorIDs.Back.Sets.DrawInTailLayer[item.backSlot])
		{
			return true;
		}
		if (legs > 0 && ArmorIDs.Legs.Sets.IncompatibleWithFrogLeg[legs] && item.shoeSlot == 15)
		{
			return true;
		}
		if (item.balloonSlot == 18 && (body == 93 || body == 83))
		{
			return true;
		}
		return false;
	}

	private bool IsVisibleCapeBad(int accFrontSlot)
	{
		if ((uint)(accFrontSlot - 1) <= 4u || accFrontSlot == 8)
		{
			return true;
		}
		return false;
	}

	public void UpdateVisibleAccessory(int itemSlot, Item item, bool modded = false)
	{
		if (item.stringColor > 0)
		{
			stringColor = item.stringColor;
		}
		if (item.handOnSlot > 0)
		{
			handon = item.handOnSlot;
		}
		if (item.handOffSlot > 0)
		{
			handoff = item.handOffSlot;
		}
		if (item.backSlot > 0)
		{
			if (ArmorIDs.Back.Sets.DrawInBackpackLayer[item.backSlot])
			{
				backpack = item.backSlot;
			}
			else if (ArmorIDs.Back.Sets.DrawInTailLayer[item.backSlot])
			{
				tail = item.backSlot;
			}
			else
			{
				back = item.backSlot;
				front = -1;
			}
		}
		if (item.frontSlot > 0)
		{
			front = item.frontSlot;
		}
		if (sitting.isSitting)
		{
			back = -1;
		}
		if (item.shoeSlot > 0)
		{
			shoe = item.shoeSlot;
			if (!Male && ArmorIDs.Shoe.Sets.MaleToFemaleID[shoe] > 0)
			{
				shoe = ArmorIDs.Shoe.Sets.MaleToFemaleID[shoe];
			}
		}
		if (item.waistSlot > 0)
		{
			waist = item.waistSlot;
		}
		if (item.shieldSlot > 0)
		{
			shield = item.shieldSlot;
		}
		if (item.neckSlot > 0)
		{
			neck = item.neckSlot;
		}
		if (item.faceSlot > 0)
		{
			if (ArmorIDs.Face.Sets.DrawInFaceHeadLayer[item.faceSlot])
			{
				faceHead = item.faceSlot;
			}
			else if (ArmorIDs.Face.Sets.DrawInFaceFlowerLayer[item.faceSlot])
			{
				faceFlower = item.faceSlot;
			}
			else
			{
				face = item.faceSlot;
			}
		}
		if (item.balloonSlot > 0)
		{
			if (ArmorIDs.Balloon.Sets.DrawInFrontOfBackArmLayer[item.balloonSlot])
			{
				balloonFront = item.balloonSlot;
			}
			else
			{
				balloon = item.balloonSlot;
			}
		}
		if (item.beardSlot > 0)
		{
			beard = item.beardSlot;
		}
		if (item.wingSlot > 0)
		{
			wings = item.wingSlot;
		}
		if (item.type == 3580)
		{
			yoraiz0rEye = itemSlot - 2;
			if (modded)
			{
				yoraiz0rEye += 5;
			}
		}
		if (item.type == 3581)
		{
			yoraiz0rDarkness = true;
		}
		if (item.type == 3929)
		{
			leinforsHair = true;
		}
		if (item.type == 4404)
		{
			hasFloatingTube = true;
		}
		if (item.type == 4563)
		{
			hasUnicornHorn = true;
		}
		if (item.type == 1987)
		{
			hasAngelHalo = true;
		}
		if (item.type == 5075)
		{
			hasRainbowCursor = true;
		}
		ItemLoader.UpdateVisibleAccessory(item, this, hideVisual: false);
	}

	public void SetArmorEffectVisuals(Player drawPlayer)
	{
		if (drawPlayer.head == 111 && drawPlayer.body == 73 && drawPlayer.legs == 62)
		{
			armorEffectDrawShadowSubtle = true;
			armorEffectDrawOutlines = true;
		}
		if (drawPlayer.head == 134 && drawPlayer.body == 95 && drawPlayer.legs == 79)
		{
			armorEffectDrawShadowSubtle = true;
			armorEffectDrawOutlines = true;
		}
		if (drawPlayer.head == 107 && drawPlayer.body == 69 && drawPlayer.legs == 58)
		{
			armorEffectDrawShadowSubtle = true;
			armorEffectDrawShadow = true;
		}
		if (drawPlayer.head == 108 && drawPlayer.body == 70 && drawPlayer.legs == 59)
		{
			armorEffectDrawShadowSubtle = true;
			armorEffectDrawShadow = true;
		}
		if (drawPlayer.head == 109 && drawPlayer.body == 71 && drawPlayer.legs == 60)
		{
			armorEffectDrawShadowSubtle = true;
			armorEffectDrawShadow = true;
		}
		if (drawPlayer.head == 110 && drawPlayer.body == 72 && drawPlayer.legs == 61)
		{
			armorEffectDrawShadowSubtle = true;
			armorEffectDrawShadow = true;
		}
		if (drawPlayer.head == 193 && drawPlayer.body == 194 && drawPlayer.legs == 134)
		{
			armorEffectDrawShadowSubtle = true;
			armorEffectDrawShadowLokis = true;
			armorEffectDrawOutlines = true;
		}
		if (drawPlayer.mount.Active && drawPlayer.mount.Type == 3 && drawPlayer.velocity.Y != 0f && !drawPlayer.SlimeDontHyperJump)
		{
			armorEffectDrawShadow = true;
		}
		if (drawPlayer.mount.Active && drawPlayer.mount.Type == 10 && Math.Abs(drawPlayer.velocity.X) > drawPlayer.mount.DashSpeed - drawPlayer.mount.RunSpeed / 2f)
		{
			armorEffectDrawShadow = true;
		}
		if (drawPlayer.mount.Active && drawPlayer.mount.Type == 44 && Math.Abs(drawPlayer.velocity.X) > drawPlayer.mount.DashSpeed - drawPlayer.mount.RunSpeed / 4f)
		{
			armorEffectDrawShadow = true;
		}
		if (drawPlayer.mount.Active && drawPlayer.mount.Type == 45 && Math.Abs(drawPlayer.velocity.X) > drawPlayer.mount.DashSpeed * 0.9f)
		{
			armorEffectDrawShadow = true;
		}
		if (drawPlayer.mount.Active && drawPlayer.mount.Type == 14 && Math.Abs(drawPlayer.velocity.X) > drawPlayer.mount.RunSpeed / 2f)
		{
			armorEffectDrawShadowBasilisk = true;
		}
		if (drawPlayer.mount.Active && drawPlayer.mount.Type == 48)
		{
			armorEffectDrawOutlines = true;
			armorEffectDrawShadow = true;
		}
		if (drawPlayer.body == 67 && drawPlayer.legs == 56 && drawPlayer.head >= 103 && drawPlayer.head <= 105)
		{
			armorEffectDrawShadow = true;
		}
		if ((drawPlayer.head == 78 || drawPlayer.head == 79 || drawPlayer.head == 80) && drawPlayer.body == 51 && drawPlayer.legs == 47)
		{
			armorEffectDrawShadowSubtle = true;
		}
		if (drawPlayer.head == 200 && drawPlayer.body == 198 && drawPlayer.legs == 142)
		{
			armorEffectDrawShadowLokis = true;
			armorEffectDrawOutlinesForbidden = true;
		}
		if (drawPlayer.head == 171 && drawPlayer.body == 177 && drawPlayer.legs == 112)
		{
			armorEffectDrawShadow = true;
			armorEffectDrawOutlines = true;
		}
		if (drawPlayer.head == 169 && drawPlayer.body == 175 && drawPlayer.legs == 110)
		{
			armorEffectDrawShadow = true;
		}
		if (drawPlayer.head == 170 && drawPlayer.body == 176 && drawPlayer.legs == 111)
		{
			armorEffectDrawShadowLokis = true;
			armorEffectDrawOutlines = true;
		}
		if (drawPlayer.body == 209 && drawPlayer.legs == 159)
		{
			armorEffectDrawShadow = true;
		}
		if (drawPlayer.eocDash > 0)
		{
			armorEffectDrawShadowEOCShield = true;
		}
		else if (drawPlayer.dashDelay < 0)
		{
			armorEffectDrawShadow = true;
		}
		if (drawPlayer.head == 5 && drawPlayer.body == 5 && drawPlayer.legs == 5)
		{
			armorEffectDrawShadow = true;
		}
		if (drawPlayer.head == 74 && drawPlayer.body == 48 && drawPlayer.legs == 44)
		{
			armorEffectDrawShadow = true;
		}
		if (drawPlayer.head == 76 && drawPlayer.body == 49 && drawPlayer.legs == 45)
		{
			armorEffectDrawShadow = true;
		}
		if (drawPlayer.head == 7 && drawPlayer.body == 7 && drawPlayer.legs == 7)
		{
			armorEffectDrawShadow = true;
		}
		if (drawPlayer.head == 22 && drawPlayer.body == 14 && drawPlayer.legs == 14)
		{
			armorEffectDrawShadow = true;
		}
		if (drawPlayer.dye[0].dye == 30 && drawPlayer.dye[1].dye == 30 && drawPlayer.dye[2].dye == 30 && drawPlayer.head == 4 && drawPlayer.body == 27 && drawPlayer.legs == 26)
		{
			armorEffectDrawShadow = true;
			armorEffectDrawOutlines = true;
		}
		if (drawPlayer.head == 189 && drawPlayer.body == 190 && drawPlayer.legs == 130)
		{
			armorEffectDrawOutlines = true;
		}
		if (drawPlayer.body == 17 && drawPlayer.legs == 16 && (drawPlayer.head == 29 || drawPlayer.head == 30 || drawPlayer.head == 31))
		{
			armorEffectDrawShadow = true;
		}
		if (drawPlayer.body == 19 && drawPlayer.legs == 18 && (drawPlayer.head == 35 || drawPlayer.head == 36 || drawPlayer.head == 37))
		{
			armorEffectDrawOutlines = true;
		}
		if ((drawPlayer.body == 24 || drawPlayer.body == 229) && (drawPlayer.legs == 23 || drawPlayer.legs == 212) && (drawPlayer.head == 43 || drawPlayer.head == 41 || drawPlayer.head == 42 || drawPlayer.head == 254 || drawPlayer.head == 255 || drawPlayer.head == 256 || drawPlayer.head == 257 || drawPlayer.head == 258))
		{
			armorEffectDrawOutlines = true;
			armorEffectDrawShadow = true;
		}
		if (drawPlayer.head == 157 && drawPlayer.legs == 98 && drawPlayer.body != 105)
		{
			_ = drawPlayer.body;
		}
		if (drawPlayer.body == 36 && drawPlayer.head == 56)
		{
			armorEffectDrawOutlines = true;
		}
		if (drawPlayer.head == 267)
		{
			yoraiz0rDarkness = true;
		}
		ItemLoader.ArmorSetShadows(drawPlayer);
		if (drawPlayer.stoned || drawPlayer.stealth != 1f)
		{
			armorEffectDrawOutlines = false;
			armorEffectDrawShadow = false;
			armorEffectDrawShadowSubtle = false;
		}
	}

	public static int SetMatch(SetMatchRequest request, ref bool somethingSpecial)
	{
		int armorSlotRequested = request.ArmorSlotRequested;
		int num = -1;
		bool male = request.Male;
		num = armorSlotRequested switch
		{
			1 => request.Body, 
			2 => request.Legs, 
			_ => request.Head, 
		};
		int equipSlot = -1;
		if (armorSlotRequested == 0 && num == 201)
		{
			equipSlot = (male ? 201 : 202);
		}
		if (armorSlotRequested == 1)
		{
			bool flag = true;
			switch (num)
			{
			case 15:
				equipSlot = 88;
				break;
			case 36:
				equipSlot = 89;
				break;
			case 41:
				equipSlot = 97;
				break;
			case 42:
				equipSlot = 90;
				break;
			case 58:
				equipSlot = 91;
				break;
			case 59:
				equipSlot = 92;
				break;
			case 60:
				equipSlot = 93;
				break;
			case 61:
				equipSlot = 94;
				break;
			case 62:
				equipSlot = 95;
				break;
			case 63:
				equipSlot = 96;
				break;
			case 77:
				equipSlot = 121;
				break;
			case 165:
				equipSlot = ((!male) ? 99 : 118);
				break;
			case 166:
				flag = false;
				equipSlot = ((!male) ? 100 : 119);
				break;
			case 167:
				equipSlot = (male ? 101 : 102);
				break;
			case 180:
				equipSlot = 115;
				break;
			case 181:
				equipSlot = 116;
				break;
			case 183:
				equipSlot = (male ? 136 : 123);
				break;
			case 191:
				equipSlot = 131;
				break;
			case 93:
				equipSlot = 165;
				break;
			case 90:
				equipSlot = 166;
				break;
			case 88:
				equipSlot = 168;
				break;
			case 81:
				if (request.Legs == 0)
				{
					equipSlot = 169;
				}
				break;
			case 213:
				equipSlot = 187;
				break;
			case 215:
				equipSlot = 189;
				break;
			case 219:
				equipSlot = 196;
				break;
			case 221:
				equipSlot = 199;
				break;
			case 223:
				equipSlot = 204;
				break;
			case 231:
				equipSlot = 214;
				break;
			case 232:
				equipSlot = 215;
				break;
			case 233:
				equipSlot = 216;
				break;
			case 241:
				equipSlot = 229;
				break;
			}
			if (equipSlot != -1)
			{
				somethingSpecial = flag;
			}
		}
		if (armorSlotRequested == 2)
		{
			switch (num)
			{
			case 83:
				if (male)
				{
					equipSlot = 117;
				}
				break;
			case 84:
				if (male)
				{
					equipSlot = 120;
				}
				break;
			case 132:
				if (male)
				{
					equipSlot = 135;
				}
				break;
			case 57:
				if (male)
				{
					equipSlot = 137;
				}
				break;
			case 180:
				if (!male)
				{
					equipSlot = 179;
				}
				break;
			case 184:
				if (!male)
				{
					equipSlot = 183;
				}
				break;
			case 146:
				equipSlot = (male ? 146 : 147);
				break;
			case 154:
				equipSlot = (male ? 155 : 154);
				break;
			case 158:
				if (male)
				{
					equipSlot = 157;
				}
				break;
			case 191:
				if (!male)
				{
					equipSlot = 192;
				}
				break;
			case 193:
				if (!male)
				{
					equipSlot = 194;
				}
				break;
			case 197:
				if (!male)
				{
					equipSlot = 198;
				}
				break;
			case 203:
				if (!male)
				{
					equipSlot = 202;
				}
				break;
			case 208:
				if (!male)
				{
					equipSlot = 207;
				}
				break;
			case 219:
				if (!male)
				{
					equipSlot = 220;
				}
				break;
			case 232:
				if (!male)
				{
					equipSlot = 233;
				}
				break;
			}
		}
		ItemLoader.SetMatch(armorSlotRequested, num, male, ref equipSlot, ref somethingSpecial);
		return equipSlot;
	}

	/// <summary>
	/// Teleports the player to the provided world coordinates. In multiplayer, clients should send <see cref="F:Terraria.ID.MessageID.TeleportEntity" /> rather than call this method directly.
	/// <br /> <b>newPos: </b> The teleportation destination in world coordinates. (Sets position, not Center) 
	/// <br /> <b>Style: </b> Controls the visuals and sounds of the teleport. Equivalent to <see cref="T:Terraria.ID.TeleportationStyleID" /> values.
	/// </summary>
	public void Teleport(Vector2 newPos, int Style = 0, int extraInfo = 0)
	{
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_0170: Unknown result type (might be due to invalid IL or missing references)
		//IL_0175: Unknown result type (might be due to invalid IL or missing references)
		//IL_0248: Unknown result type (might be due to invalid IL or missing references)
		//IL_024e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0253: Unknown result type (might be due to invalid IL or missing references)
		//IL_0258: Unknown result type (might be due to invalid IL or missing references)
		//IL_025e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0267: Unknown result type (might be due to invalid IL or missing references)
		try
		{
			_funkytownAchievementCheckCooldown = 100;
			environmentBuffImmunityTimer = 4;
			if (Style != 10)
			{
				RemoveAllGrapplingHooks();
			}
			StopVanityActions();
			if (shimmering || shimmerWet)
			{
				shimmering = false;
				shimmerWet = false;
				wet = false;
				ClearBuff(353);
			}
			int extraInfo2 = 0;
			if (Style == 4)
			{
				extraInfo2 = lastPortalColorIndex;
			}
			if (Style == 9)
			{
				lastTeleportPylonStyleUsed = extraInfo;
				extraInfo2 = lastTeleportPylonStyleUsed;
			}
			float num = MathHelper.Clamp(1f - teleportTime * 0.99f, 0.01f, 1f);
			Vector2 val = position;
			Main.TeleportEffect(getRect(), Style, extraInfo2, num, TeleportationSide.Entry, newPos);
			float num2 = Vector2.Distance(position, newPos);
			PressurePlateHelper.UpdatePlayerPosition(this);
			position = newPos;
			if (Style == 8)
			{
				SoundEngine.PlaySound(in SoundID.Item6, val);
				SoundEngine.PlaySound(in SoundID.Item6, newPos);
			}
			fallStart = (int)(position.Y / 16f);
			if (whoAmI == Main.myPlayer)
			{
				bool flag = false;
				Vector2 val2 = new Vector2((float)Main.screenWidth, (float)Main.screenHeight);
				if (num2 < ((Vector2)(ref val2)).Length() / 2f + 100f)
				{
					int time = 0;
					if (Style == 1)
					{
						time = 10;
					}
					Main.SetCameraLerp(0.1f, time);
					flag = true;
				}
				else
				{
					NPC.ResetNetOffsets();
					Main.BlackFadeIn = 255;
					Lighting.Clear();
					Main.screenLastPosition = Main.screenPosition;
					Main.screenPosition.X = position.X + (float)(width / 2) - (float)(Main.screenWidth / 2);
					Main.screenPosition.Y = position.Y + (float)(height / 2) - (float)(Main.screenHeight / 2);
					Main.instantBGTransitionCounter = 10;
					ForceUpdateBiomes();
				}
				if (num > 0.1f || !flag || Style != 0)
				{
					if (Main.mapTime < 5)
					{
						Main.mapTime = 5;
					}
					Main.maxQ = true;
					Main.renderNow = true;
				}
			}
			if (Style == 4)
			{
				lastPortalColorIndex = extraInfo;
				extraInfo2 = lastPortalColorIndex;
				portalPhysicsFlag = true;
				gravity = 0f;
			}
			PressurePlateHelper.UpdatePlayerPosition(this);
			ResetAdvancedShadows();
			for (int i = 0; i < 3; i++)
			{
				UpdateSocialShadow();
			}
			oldPosition = position + BlehOldPositionFixer;
			Main.TeleportEffect(getRect(), Style, extraInfo2, num, TeleportationSide.Exit, val);
			teleportTime = 1f;
			teleportStyle = Style;
		}
		catch
		{
		}
	}

	public void DoPotionOfReturnTeleportationAndSetTheComebackPoint()
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		RemoveAllGrapplingHooks();
		PotionOfReturnOriginalUsePosition = base.Bottom;
		bool flag = immune;
		int num = immuneTime;
		StopVanityActions(multiplayerBroadcast: false);
		Spawn(PlayerSpawnContext.RecallFromItem);
		PotionOfReturnHomePosition = base.Bottom;
		NetMessage.SendData(13, -1, whoAmI, null, whoAmI);
		immune = flag;
		immuneTime = num;
	}

	public void DoPotionOfReturnReturnToOriginalUsePosition()
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		if (PotionOfReturnOriginalUsePosition.HasValue)
		{
			Vector2 val = PotionOfReturnOriginalUsePosition.Value + base.Size * new Vector2(-0.5f, -1f);
			int num = 8;
			Teleport(val, num);
			NetMessage.SendData(65, -1, -1, null, 0, whoAmI, val.X, val.Y, num);
			PotionOfReturnOriginalUsePosition = null;
			PotionOfReturnHomePosition = null;
		}
	}

	public void AutoFinchStaff()
	{
		int num = FindItem(4281);
		if (num != -1)
		{
			Item item = inventory[num];
			AddBuff(item.buffType, 3600, quiet: false);
		}
	}

	public void Spawn(PlayerSpawnContext context)
	{
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		//IL_0128: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_033e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0340: Unknown result type (might be due to invalid IL or missing references)
		//IL_0356: Unknown result type (might be due to invalid IL or missing references)
		//IL_035b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0397: Unknown result type (might be due to invalid IL or missing references)
		//IL_039c: Unknown result type (might be due to invalid IL or missing references)
		Main.LocalPlayer.creativeInterface = false;
		_funkytownAchievementCheckCooldown = 100;
		bool flag = false;
		if (context == PlayerSpawnContext.SpawningIntoWorld)
		{
			if (Main.netMode == 0 && unlockedBiomeTorches)
			{
				NPC nPC = new NPC();
				nPC.SetDefaults(664);
				Main.BestiaryTracker.Kills.RegisterKill(nPC);
			}
			if (dead)
			{
				AdjustRespawnTimerForWorldJoining(this);
				if (dead)
				{
					flag = true;
				}
			}
		}
		StopVanityActions();
		if (whoAmI == Main.myPlayer)
		{
			Main.NotifyOfEvent(GameNotificationType.SpawnOrDeath);
		}
		if (whoAmI == Main.myPlayer)
		{
			if (Main.mapTime < 5)
			{
				Main.mapTime = 5;
			}
			Main.instantBGTransitionCounter = 10;
			FindSpawn();
			if (!CheckSpawn(SpawnX, SpawnY))
			{
				SpawnX = -1;
				SpawnY = -1;
			}
			Main.maxQ = true;
			NPC.ResetNetOffsets();
		}
		if (Main.netMode == 1 && whoAmI == Main.myPlayer)
		{
			NetMessage.SendData(12, -1, -1, null, Main.myPlayer, (int)(byte)context);
		}
		headPosition = Vector2.Zero;
		bodyPosition = Vector2.Zero;
		legPosition = Vector2.Zero;
		headRotation = 0f;
		bodyRotation = 0f;
		legRotation = 0f;
		rabbitOrderFrame.Reset();
		lavaTime = lavaMax;
		if (!flag)
		{
			if (statLife <= 0)
			{
				int num = statLifeMax2 / 2;
				statLife = 100;
				if (num > statLife)
				{
					statLife = num;
				}
				breath = breathMax;
				if (spawnMax)
				{
					statLife = statLifeMax2;
					statMana = statManaMax2;
				}
			}
			immune = true;
			if (dead)
			{
				PlayerLoader.OnRespawn(this);
			}
			dead = false;
			immuneTime = 0;
		}
		active = true;
		Vector2 val = position;
		if (SpawnX >= 0 && SpawnY >= 0)
		{
			_ = SpawnX;
			_ = SpawnY;
			Spawn_SetPosition(SpawnX, SpawnY);
		}
		else
		{
			Spawn_SetPositionAtWorldSpawn();
		}
		wet = false;
		wetCount = 0;
		lavaWet = false;
		fallStart = (int)(position.Y / 16f);
		fallStart2 = fallStart;
		velocity.X = 0f;
		velocity.Y = 0f;
		ResetAdvancedShadows();
		for (int i = 0; i < 3; i++)
		{
			UpdateSocialShadow();
		}
		oldPosition = position + BlehOldPositionFixer;
		SetTalkNPC(-1);
		if (whoAmI == Main.myPlayer)
		{
			Main.npcChatCornerItem = 0;
		}
		if (!flag)
		{
			if (pvpDeath)
			{
				pvpDeath = false;
				immuneTime = 300;
				statLife = statLifeMax;
			}
			else if (context == PlayerSpawnContext.ReviveFromDeath)
			{
				immuneTime = 180;
			}
			else
			{
				immuneTime = 60;
			}
			if (immuneTime > 0 && !hostile)
			{
				immuneNoBlink = true;
			}
		}
		if (whoAmI == Main.myPlayer)
		{
			float num2 = Vector2.Distance(val, position);
			Vector2 val2 = new Vector2((float)Main.screenWidth, (float)Main.screenHeight);
			bool flag2 = num2 < ((Vector2)(ref val2)).Length() / 2f + 100f;
			if (flag2)
			{
				Main.SetCameraLerp(0.1f, 0);
				flag2 = true;
			}
			else
			{
				Main.BlackFadeIn = 255;
				Lighting.Clear();
				Main.screenLastPosition = Main.screenPosition;
				Main.instantBGTransitionCounter = 10;
			}
			if (!flag2)
			{
				Main.renderNow = true;
			}
			if (Main.netMode == 1)
			{
				Netplay.AddCurrentServerToRecentList();
			}
			if (!flag2)
			{
				Main.screenPosition.X = position.X + (float)(width / 2) - (float)(Main.screenWidth / 2);
				Main.screenPosition.Y = position.Y + (float)(height / 2) - (float)(Main.screenHeight / 2);
				ForceUpdateBiomes();
			}
		}
		if (flag)
		{
			immuneAlpha = 255;
		}
		UpdateGraveyard(now: true);
		if (whoAmI == Main.myPlayer && context == PlayerSpawnContext.ReviveFromDeath && difficulty == 3)
		{
			AutoFinchStaff();
		}
		if (whoAmI == Main.myPlayer && context == PlayerSpawnContext.SpawningIntoWorld)
		{
			Main.ReleaseHostAndPlayProcess();
			RefreshItems();
			SetPlayerDataToOutOfClassFields();
			Main.LocalGolfState.SetScoreTime();
			Main.ActivePlayerFileData.StartPlayTimer();
			Hooks.EnterWorld(whoAmI);
		}
	}

	public bool Spawn_GetPositionAtWorldSpawn(ref int floorX, ref int floorY)
	{
		int spawnTileX = Main.spawnTileX;
		int num = Main.spawnTileY;
		if (!Spawn_IsAreaAValidWorldSpawn(spawnTileX, num))
		{
			bool flag = false;
			if (!flag)
			{
				for (int i = 0; i < 30; i++)
				{
					if (Spawn_IsAreaAValidWorldSpawn(spawnTileX, num - i))
					{
						num -= i;
						flag = true;
						break;
					}
				}
			}
			if (!flag)
			{
				for (int j = 0; j < 30; j++)
				{
					if (Spawn_IsAreaAValidWorldSpawn(spawnTileX, num - j))
					{
						num -= j;
						flag = true;
						break;
					}
				}
			}
			if (flag)
			{
				floorX = spawnTileX;
				floorY = num;
				return true;
			}
			return false;
		}
		num = Spawn_DescendFromDefaultSpace(spawnTileX, num);
		floorX = spawnTileX;
		floorY = num;
		return false;
	}

	private void Spawn_SetPositionAtWorldSpawn()
	{
		int floorX = Main.spawnTileX;
		int floorY = Main.spawnTileY;
		bool num = Spawn_GetPositionAtWorldSpawn(ref floorX, ref floorY);
		Spawn_SetPosition(floorX, floorY);
		if (num && !Spawn_IsAreaAValidWorldSpawn(floorX, floorY))
		{
			Spawn_ForceClearArea(floorX, floorY);
		}
	}

	private static int Spawn_DescendFromDefaultSpace(int x, int y)
	{
		for (int i = 0; i < 50; i++)
		{
			bool flag = false;
			for (int j = -1; j <= 1; j++)
			{
				Tile tile = Main.tile[x + j, y + i];
				if (tile.nactive() && (Main.tileSolid[tile.type] || !Main.tileSolidTop[tile.type]))
				{
					flag = true;
					break;
				}
			}
			if (flag)
			{
				y += i;
				break;
			}
		}
		return y;
	}

	private static void Spawn_ForceClearArea(int floorX, int floorY)
	{
		for (int i = floorX - 1; i < floorX + 2; i++)
		{
			for (int j = floorY - 3; j < floorY; j++)
			{
				if (Main.tile[i, j] != null)
				{
					if (Main.tile[i, j].nactive() && Main.tileSolid[Main.tile[i, j].type] && !Main.tileSolidTop[Main.tile[i, j].type])
					{
						WorldGen.KillTile(i, j);
					}
					if (Main.tile[i, j].liquid > 0)
					{
						Main.tile[i, j].lava(lava: false);
						Main.tile[i, j].liquid = 0;
						WorldGen.SquareTileFrame(i, j);
					}
				}
			}
		}
	}

	private bool Spawn_IsAreaAValidWorldSpawn(int floorX, int floorY)
	{
		for (int i = floorX - 1; i < floorX + 2; i++)
		{
			for (int j = floorY - 3; j < floorY; j++)
			{
				if (Main.tile[i, j] != null)
				{
					if (Main.tile[i, j].nactive() && Main.tileSolid[Main.tile[i, j].type] && !Main.tileSolidTop[Main.tile[i, j].type])
					{
						return false;
					}
					if (Main.tile[i, j].liquid > 0)
					{
						return false;
					}
				}
			}
		}
		return true;
	}

	private void Spawn_SetPosition(int floorX, int floorY)
	{
		position.X = floorX * 16 + 8 - width / 2;
		position.Y = floorY * 16 - height;
	}

	public void SetImmuneTimeForAllTypes(int time)
	{
		immune = true;
		immuneTime = time;
		for (int i = 0; i < hurtCooldowns.Length; i++)
		{
			hurtCooldowns[i] = time;
		}
	}

	public void ShadowDodge()
	{
		SetImmuneTimeForAllTypes(longInvince ? 120 : 80);
		if (whoAmI != Main.myPlayer)
		{
			return;
		}
		for (int i = 0; i < maxBuffs; i++)
		{
			if (buffTime[i] > 0 && buffType[i] == 59)
			{
				DelBuff(i);
			}
		}
		PutHallowedArmorSetBonusOnCooldown();
		NetMessage.SendData(62, -1, -1, null, whoAmI, 2f);
	}

	private void PutHallowedArmorSetBonusOnCooldown()
	{
		shadowDodgeTimer = 1800;
	}

	public void BrainOfConfusionDodge()
	{
		SetImmuneTimeForAllTypes(longInvince ? 120 : 80);
		brainOfConfusionDodgeAnimationCounter = 300;
		if (whoAmI == Main.myPlayer)
		{
			AddBuff(321, 240, quiet: false);
			NetMessage.SendData(62, -1, -1, null, whoAmI, 4f);
		}
	}

	public void NinjaDodge()
	{
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0199: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0226: Unknown result type (might be due to invalid IL or missing references)
		//IL_0230: Unknown result type (might be due to invalid IL or missing references)
		//IL_0235: Unknown result type (might be due to invalid IL or missing references)
		//IL_0270: Unknown result type (might be due to invalid IL or missing references)
		//IL_0277: Unknown result type (might be due to invalid IL or missing references)
		//IL_027d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0309: Unknown result type (might be due to invalid IL or missing references)
		//IL_0313: Unknown result type (might be due to invalid IL or missing references)
		//IL_0318: Unknown result type (might be due to invalid IL or missing references)
		//IL_0353: Unknown result type (might be due to invalid IL or missing references)
		//IL_035a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0360: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_03fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0436: Unknown result type (might be due to invalid IL or missing references)
		//IL_043d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0443: Unknown result type (might be due to invalid IL or missing references)
		//IL_04cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_04d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_04de: Unknown result type (might be due to invalid IL or missing references)
		//IL_0519: Unknown result type (might be due to invalid IL or missing references)
		//IL_0520: Unknown result type (might be due to invalid IL or missing references)
		//IL_0526: Unknown result type (might be due to invalid IL or missing references)
		//IL_05b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_05bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_05c1: Unknown result type (might be due to invalid IL or missing references)
		SetImmuneTimeForAllTypes(longInvince ? 120 : 80);
		for (int i = 0; i < 100; i++)
		{
			int num = Dust.NewDust(new Vector2(position.X, position.Y), width, height, 31, 0f, 0f, 100, default(Color), 2f);
			Main.dust[num].position.X += Main.rand.Next(-20, 21);
			Main.dust[num].position.Y += Main.rand.Next(-20, 21);
			Dust obj = Main.dust[num];
			obj.velocity *= 0.4f;
			Main.dust[num].scale *= 1f + (float)Main.rand.Next(40) * 0.01f;
			Main.dust[num].shader = GameShaders.Armor.GetSecondaryShader(cWaist, this);
			if (Main.rand.Next(2) == 0)
			{
				Main.dust[num].scale *= 1f + (float)Main.rand.Next(40) * 0.01f;
				Main.dust[num].noGravity = true;
			}
		}
		int num2 = Gore.NewGore(new Vector2(position.X + (float)(width / 2) - 24f, position.Y + (float)(height / 2) - 24f), default(Vector2), Main.rand.Next(61, 64));
		Main.gore[num2].scale = 1.5f;
		Main.gore[num2].velocity.X = (float)Main.rand.Next(-50, 51) * 0.01f;
		Main.gore[num2].velocity.Y = (float)Main.rand.Next(-50, 51) * 0.01f;
		Gore obj2 = Main.gore[num2];
		obj2.velocity *= 0.4f;
		num2 = Gore.NewGore(new Vector2(position.X + (float)(width / 2) - 24f, position.Y + (float)(height / 2) - 24f), default(Vector2), Main.rand.Next(61, 64));
		Main.gore[num2].scale = 1.5f;
		Main.gore[num2].velocity.X = 1.5f + (float)Main.rand.Next(-50, 51) * 0.01f;
		Main.gore[num2].velocity.Y = 1.5f + (float)Main.rand.Next(-50, 51) * 0.01f;
		Gore obj3 = Main.gore[num2];
		obj3.velocity *= 0.4f;
		num2 = Gore.NewGore(new Vector2(position.X + (float)(width / 2) - 24f, position.Y + (float)(height / 2) - 24f), default(Vector2), Main.rand.Next(61, 64));
		Main.gore[num2].scale = 1.5f;
		Main.gore[num2].velocity.X = -1.5f - (float)Main.rand.Next(-50, 51) * 0.01f;
		Main.gore[num2].velocity.Y = 1.5f + (float)Main.rand.Next(-50, 51) * 0.01f;
		Gore obj4 = Main.gore[num2];
		obj4.velocity *= 0.4f;
		num2 = Gore.NewGore(new Vector2(position.X + (float)(width / 2) - 24f, position.Y + (float)(height / 2) - 24f), default(Vector2), Main.rand.Next(61, 64));
		Main.gore[num2].scale = 1.5f;
		Main.gore[num2].velocity.X = 1.5f + (float)Main.rand.Next(-50, 51) * 0.01f;
		Main.gore[num2].velocity.Y = -1.5f - (float)Main.rand.Next(-50, 51) * 0.01f;
		Gore obj5 = Main.gore[num2];
		obj5.velocity *= 0.4f;
		num2 = Gore.NewGore(new Vector2(position.X + (float)(width / 2) - 24f, position.Y + (float)(height / 2) - 24f), default(Vector2), Main.rand.Next(61, 64));
		Main.gore[num2].scale = 1.5f;
		Main.gore[num2].velocity.X = -1.5f - (float)Main.rand.Next(-50, 51) * 0.01f;
		Main.gore[num2].velocity.Y = -1.5f - (float)Main.rand.Next(-50, 51) * 0.01f;
		Gore obj6 = Main.gore[num2];
		obj6.velocity *= 0.4f;
		if (whoAmI == Main.myPlayer)
		{
			NetMessage.SendData(62, -1, -1, null, whoAmI, 1f);
		}
	}

	public void ApplyArmorSoundAndDustChanges()
	{
		int num = armor[0].headSlot;
		int num2 = armor[1].bodySlot;
		int num3 = armor[2].legSlot;
		if (armor[10].headSlot >= 0)
		{
			num = armor[10].headSlot;
		}
		if (armor[11].bodySlot >= 0)
		{
			num2 = armor[11].bodySlot;
		}
		if (armor[12].legSlot >= 0)
		{
			num3 = armor[12].legSlot;
		}
		if ((wereWolf || forceWerewolf) && !hideWolf)
		{
			num3 = 20;
			num2 = 21;
			num = 38;
		}
		if ((num == 75 || num == 7) && num2 == 7 && num3 == 7)
		{
			boneArmor = true;
		}
		if (num2 == 27 && num == 46 && num3 == 26)
		{
			frostArmor = true;
		}
	}

	private static float VanillaBaseDefenseEffectiveness()
	{
		if (Main.masterMode)
		{
			return 1f;
		}
		if (Main.expertMode)
		{
			return 0.75f;
		}
		return 0.5f;
	}

	internal double Hurt(PlayerDeathReason damageSource, int Damage, int hitDirection, bool pvp, bool quiet, bool Crit, int cooldownCounter, bool dodgeable = true, float armorPenetration = 0f)
	{
		return Hurt(damageSource, Damage, hitDirection, pvp, quiet, cooldownCounter, dodgeable, armorPenetration);
	}

	public double Hurt(PlayerDeathReason damageSource, int Damage, int hitDirection, bool pvp = false, bool quiet = false, int cooldownCounter = -1, bool dodgeable = true, float armorPenetration = 0f, float scalingArmorPenetration = 0f, float knockback = 4.5f)
	{
		HurtInfo info;
		return Hurt(damageSource, Damage, hitDirection, out info, pvp, quiet, cooldownCounter, dodgeable, armorPenetration, scalingArmorPenetration, knockback);
	}

	public double Hurt(PlayerDeathReason damageSource, int Damage, int hitDirection, out HurtInfo info, bool pvp = false, bool quiet = false, int cooldownCounter = -1, bool dodgeable = true, float armorPenetration = 0f, float scalingArmorPenetration = 0f, float knockback = 4.5f)
	{
		info = default(HurtInfo);
		if (shimmering && AllowShimmerDodge(damageSource, cooldownCounter, dodgeable))
		{
			return 0.0;
		}
		if (creativeGodMode)
		{
			return 0.0;
		}
		if (PlayerLoader.ImmuneTo(this, damageSource, cooldownCounter, dodgeable))
		{
			return 0.0;
		}
		bool flag = !immune;
		bool flag2 = false;
		switch (cooldownCounter)
		{
		case 0:
		case 1:
		case 3:
		case 4:
			flag = hurtCooldowns[cooldownCounter] <= 0;
			break;
		case 2:
			flag2 = true;
			cooldownCounter = -1;
			break;
		}
		if (flag)
		{
			HurtModifiers hurtModifiers = new HurtModifiers();
			hurtModifiers.DamageSource = damageSource;
			hurtModifiers.PvP = pvp;
			hurtModifiers.CooldownCounter = cooldownCounter;
			hurtModifiers.Dodgeable = dodgeable;
			hurtModifiers.HitDirection = hitDirection;
			HurtModifiers modifiers = hurtModifiers;
			PlayerLoader.ModifyHurt(this, ref modifiers);
			modifiers.ArmorPenetration += armorPenetration;
			modifiers.ScalingArmorPenetration += scalingArmorPenetration;
			if (flag2)
			{
				modifiers.Knockback.Base += 6f;
				modifiers.KnockbackImmunityEffectiveness *= 0.8f;
			}
			ApplyVanillaHurtEffectModifiers(ref modifiers);
			info = modifiers.ToHurtInfo(Damage, statDefense, pvp ? 0.5f : DefenseEffectiveness.Value, knockback, noKnockback);
			if (info.Cancelled)
			{
				return 0.0;
			}
			if (info.Dodgeable)
			{
				if (whoAmI == Main.myPlayer && PlayerLoader.FreeDodge(this, in info))
				{
					return 0.0;
				}
				if (whoAmI == Main.myPlayer && blackBelt && Main.rand.Next(10) == 0)
				{
					NinjaDodge();
					return 0.0;
				}
				if (whoAmI == Main.myPlayer && brainOfConfusionItem != null && !brainOfConfusionItem.IsAir && Main.rand.Next(6) == 0 && FindBuffIndex(321) == -1)
				{
					BrainOfConfusionDodge();
					return 0.0;
				}
				if (whoAmI == Main.myPlayer && shadowDodge)
				{
					ShadowDodge();
					return 0.0;
				}
				if (whoAmI == Main.myPlayer && PlayerLoader.ConsumableDodge(this, in info))
				{
					return 0.0;
				}
			}
			Hurt(info, quiet);
			return info.Damage;
		}
		return 0.0;
	}

	private void OnHurt_Part1(HurtInfo info)
	{
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		int hitDirection = info.HitDirection;
		if (whoAmI == Main.myPlayer && panic)
		{
			AddBuff(63, 480);
		}
		if (whoAmI == Main.myPlayer && setSquireT2)
		{
			AddBuff(205, 300);
		}
		stealth = 1f;
		if (Main.netMode == 1)
		{
			NetMessage.SendData(84, -1, -1, null, whoAmI);
		}
		if (whoAmI == Main.myPlayer)
		{
			Main.NotifyOfEvent(GameNotificationType.Damage);
			if (hasFootball)
			{
				for (int i = 0; i < 59; i++)
				{
					if (inventory[i].stack > 0 && inventory[i].type == 4743)
					{
						Projectile.NewProjectile(GetProjectileSource_Misc(12), base.Center, new Vector2((float)(-hitDirection * 4), -6f), 861, 0, 0f, whoAmI, 0f, 1f);
						inventory[i].SetDefaults();
						if (i == 58)
						{
							Main.mouseItem = new Item();
						}
					}
				}
			}
		}
		if (inventory[selectedItem].type == 4790 || inventory[selectedItem].type == 4788 || inventory[selectedItem].type == 4789)
		{
			for (int j = 0; j < 1000; j++)
			{
				if (Main.projectile[j].active && Main.projectile[j].owner == whoAmI && (Main.projectile[j].type == 879 || Main.projectile[j].type == 877 || Main.projectile[j].type == 878))
				{
					Main.projectile[j].active = false;
				}
			}
		}
		if (channel && inventory[selectedItem].InterruptChannelOnHurt)
		{
			channel = false;
		}
		if (itemAnimation > 0 && inventory[selectedItem].StopAnimationOnHurt)
		{
			channel = false;
			itemAnimation = 0;
			itemAnimationMax = 0;
		}
		if (!invis)
		{
			return;
		}
		for (int k = 0; k < maxBuffs; k++)
		{
			if (buffType[k] == 10)
			{
				DelBuff(k);
			}
		}
	}

	private void ApplyVanillaHurtEffectModifiers(ref HurtModifiers modifiers)
	{
		modifiers.FinalDamage *= Math.Max(1f - endurance, 0f);
		if (setSolar && solarShields > 0)
		{
			modifiers.FinalDamage *= 0.8f;
		}
		if (beetleDefense && beetleOrbs > 0)
		{
			modifiers.FinalDamage *= 1f - 0.15f * (float)beetleOrbs;
		}
		if (defendedByPaladin && whoAmI == Main.myPlayer && TeammateHasPalidinShieldAndCanTakeDamage())
		{
			modifiers.FinalDamage *= 0.75f;
		}
	}

	private void OnHurt_Part2(HurtInfo info)
	{
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0289: Unknown result type (might be due to invalid IL or missing references)
		PlayerDeathReason damageSource = info.DamageSource;
		if (ConsumeSolarFlare() && whoAmI == Main.myPlayer)
		{
			IEntitySource spawnSource = GetProjectileSource_SetBonus(1);
			Entity entity = null;
			if (damageSource.TryGetCausingEntity(out entity))
			{
				spawnSource = GetProjectileSource_OnHurt(entity, 1);
			}
			int num = Projectile.NewProjectile(spawnSource, base.Center.X, base.Center.Y, 0f, 0f, 608, (int)GetTotalDamage(DamageClass.Melee).ApplyTo(150f), 15f, Main.myPlayer);
			Main.projectile[num].netUpdate = true;
			Main.projectile[num].Kill();
		}
		if (beetleDefense && beetleOrbs > 0)
		{
			beetleOrbs--;
			for (int i = 0; i < maxBuffs; i++)
			{
				if (buffType[i] >= 95 && buffType[i] <= 97)
				{
					DelBuff(i);
				}
			}
			if (beetleOrbs > 0)
			{
				AddBuff(95 + beetleOrbs - 1, 5, quiet: false);
			}
			beetleCounter = 0f;
		}
		if (magicCuffs)
		{
			int sourceDamage = info.SourceDamage;
			statMana += sourceDamage;
			if (statMana > statManaMax2)
			{
				statMana = statManaMax2;
			}
			ManaEffect(sourceDamage);
		}
		if (!defendedByPaladin || whoAmI == Main.myPlayer || !Main.player[Main.myPlayer].hasPaladinShield)
		{
			return;
		}
		Player player = Main.player[Main.myPlayer];
		if (player.team != team || team == 0)
		{
			return;
		}
		float num2 = player.Distance(base.Center);
		bool flag = num2 < 800f;
		if (flag)
		{
			for (int j = 0; j < 255; j++)
			{
				if (j != Main.myPlayer && Main.player[j].active && !Main.player[j].dead && !Main.player[j].immune && Main.player[j].hasPaladinShield && Main.player[j].team == team && (float)Main.player[j].statLife > (float)Main.player[j].statLifeMax2 * 0.25f)
				{
					float num3 = Main.player[j].Distance(base.Center);
					if (num2 > num3 || (num2 == num3 && j < Main.myPlayer))
					{
						flag = false;
						break;
					}
				}
			}
		}
		if (flag)
		{
			int damage = info.Damage / 3;
			player.Hurt(PlayerDeathReason.LegacyEmpty(), damage, 0);
		}
	}

	private bool TeammateHasPalidinShieldAndCanTakeDamage()
	{
		bool result = false;
		for (int i = 0; i < 255; i++)
		{
			if (i != Main.myPlayer && Main.player[i].active && !Main.player[i].dead && !Main.player[i].immune && Main.player[i].hasPaladinShield && Main.player[i].team == team && (float)Main.player[i].statLife > (float)Main.player[i].statLifeMax2 * 0.25f)
			{
				result = true;
				break;
			}
		}
		return result;
	}

	private void OnHurt_Part3(HurtInfo info)
	{
		//IL_0169: Unknown result type (might be due to invalid IL or missing references)
		//IL_0184: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		double num = info.Damage;
		if (brainOfConfusionItem == null || brainOfConfusionItem.IsAir || Main.myPlayer != whoAmI)
		{
			return;
		}
		for (int i = 0; i < 200; i++)
		{
			if (!Main.npc[i].active || Main.npc[i].friendly)
			{
				continue;
			}
			int num2 = 300;
			num2 += (int)num * 2;
			if (Main.rand.Next(500) < num2)
			{
				Vector2 val = Main.npc[i].Center - base.Center;
				float num3 = ((Vector2)(ref val)).Length();
				float num4 = Main.rand.Next(200 + (int)num / 2, 301 + (int)num * 2);
				if (num4 > 500f)
				{
					num4 = 500f + (num4 - 500f) * 0.75f;
				}
				if (num4 > 700f)
				{
					num4 = 700f + (num4 - 700f) * 0.5f;
				}
				if (num4 > 900f)
				{
					num4 = 900f + (num4 - 900f) * 0.25f;
				}
				if (num3 < num4)
				{
					float num5 = Main.rand.Next(90 + (int)num / 3, 300 + (int)num / 2);
					Main.npc[i].AddBuff(31, (int)num5);
				}
			}
		}
		Projectile.NewProjectile(GetSource_Accessory_OnHurt(brainOfConfusionItem, info.DamageSource), base.Center.X + (float)Main.rand.Next(-40, 40), base.Center.Y - (float)Main.rand.Next(20, 60), velocity.X * 0.3f, velocity.Y * 0.3f, 565, 0, 0f, whoAmI);
	}

	public void Hurt(HurtInfo info, bool quiet = false)
	{
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0312: Unknown result type (might be due to invalid IL or missing references)
		//IL_0331: Unknown result type (might be due to invalid IL or missing references)
		//IL_06ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_06f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_07f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0825: Unknown result type (might be due to invalid IL or missing references)
		//IL_082b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0846: Unknown result type (might be due to invalid IL or missing references)
		//IL_0877: Unknown result type (might be due to invalid IL or missing references)
		//IL_087d: Unknown result type (might be due to invalid IL or missing references)
		//IL_091a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0947: Unknown result type (might be due to invalid IL or missing references)
		//IL_094d: Unknown result type (might be due to invalid IL or missing references)
		//IL_08b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_08e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_08eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_077e: Unknown result type (might be due to invalid IL or missing references)
		//IL_075d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0768: Unknown result type (might be due to invalid IL or missing references)
		PlayerDeathReason damageSource = info.DamageSource;
		int hitDirection = info.HitDirection;
		int cooldownCounter = info.CooldownCounter;
		bool pvP = info.PvP;
		double num = info.Damage;
		bool flag = false;
		bool flag2 = cooldownCounter == 2;
		if (Main.netMode == 1 && whoAmI == Main.myPlayer && !quiet)
		{
			if (info.Knockback != 0f && hitDirection != 0 && (!mount.Active || !mount.Cart))
			{
				NetMessage.SendData(13, -1, -1, null, whoAmI);
			}
			NetMessage.SendData(16, -1, -1, null, whoAmI);
			NetMessage.SendPlayerHurt(whoAmI, info);
		}
		PlayerLoader.OnHurt(this, info);
		OnHurt_Part1(info);
		OnHurt_Part2(info);
		OnHurt_Part3(info);
		Color color = (flag ? CombatText.DamagedFriendlyCrit : CombatText.DamagedFriendly);
		CombatText.NewText(new Rectangle((int)position.X, (int)position.Y, width, height), color, (int)num, flag);
		statLife -= (int)num;
		switch (cooldownCounter)
		{
		case -1:
		{
			immune = true;
			int num2 = 0;
			num2 = (pvP ? 8 : ((num == 1.0) ? (longInvince ? 40 : 20) : (longInvince ? 80 : 40)));
			immuneTime = num2;
			break;
		}
		case 0:
			if (num == 1.0)
			{
				hurtCooldowns[cooldownCounter] = (longInvince ? 40 : 20);
			}
			else
			{
				hurtCooldowns[cooldownCounter] = (longInvince ? 80 : 40);
			}
			break;
		case 1:
		case 3:
		case 4:
			if (num == 1.0)
			{
				hurtCooldowns[cooldownCounter] = (longInvince ? 40 : 20);
			}
			else
			{
				hurtCooldowns[cooldownCounter] = (longInvince ? 80 : 40);
			}
			break;
		}
		lifeRegenTime = 0f;
		int? num3 = damageSource.SourceProjectileType;
		if (num3.HasValue && ProjectileID.Sets.DismountsPlayersOnHit.IndexInRange(num3.Value) && ProjectileID.Sets.DismountsPlayersOnHit[num3.Value])
		{
			mount.Dismount(this);
		}
		if (whoAmI == Main.myPlayer)
		{
			if (starCloakItem != null && !starCloakItem.IsAir && (cooldownCounter == -1 || cooldownCounter == 1))
			{
				Vector2 val = default(Vector2);
				for (int i = 0; i < 3; i++)
				{
					float num4 = position.X + (float)Main.rand.Next(-400, 400);
					float num5 = position.Y - (float)Main.rand.Next(500, 800);
					((Vector2)(ref val))..ctor(num4, num5);
					float num6 = position.X + (float)(width / 2) - val.X;
					float num7 = position.Y + (float)(height / 2) - val.Y;
					num6 += (float)Main.rand.Next(-100, 101);
					float num8 = (float)Math.Sqrt(num6 * num6 + num7 * num7);
					num8 = 23f / num8;
					num6 *= num8;
					num7 *= num8;
					int type = 726;
					Item item = starCloakItem;
					if (starCloakItem_starVeilOverrideItem != null)
					{
						item = starCloakItem_starVeilOverrideItem;
						type = 725;
					}
					if (starCloakItem_beeCloakOverrideItem != null)
					{
						item = starCloakItem_beeCloakOverrideItem;
						type = 724;
					}
					if (starCloakItem_manaCloakOverrideItem != null)
					{
						item = starCloakItem_manaCloakOverrideItem;
						type = 723;
					}
					int num9 = 75;
					if (Main.masterMode)
					{
						num9 *= 3;
					}
					else if (Main.expertMode)
					{
						num9 *= 2;
					}
					Projectile.NewProjectile(GetSource_Accessory_OnHurt(item, info.DamageSource), num4, num5, num6, num7, type, num9, 5f, whoAmI, 0f, position.Y);
				}
			}
			if (honeyCombItem != null && !honeyCombItem.IsAir)
			{
				int num10 = 1;
				if (Main.rand.Next(3) == 0)
				{
					num10++;
				}
				if (Main.rand.Next(3) == 0)
				{
					num10++;
				}
				if (strongBees && Main.rand.Next(3) == 0)
				{
					num10++;
				}
				float num11 = 13f;
				if (strongBees)
				{
					num11 = 18f;
				}
				if (Main.masterMode)
				{
					num11 *= 2f;
				}
				else if (Main.expertMode)
				{
					num11 *= 1.5f;
				}
				IEntitySource source_Accessory_OnHurt = GetSource_Accessory_OnHurt(honeyCombItem, info.DamageSource);
				for (int j = 0; j < num10; j++)
				{
					float speedX = (float)Main.rand.Next(-35, 36) * 0.02f;
					float speedY = (float)Main.rand.Next(-35, 36) * 0.02f;
					Projectile.NewProjectile(source_Accessory_OnHurt, position.X, position.Y, speedX, speedY, beeType(), beeDamage((int)num11), beeKB(0f), Main.myPlayer);
				}
				AddBuff(48, 300);
			}
		}
		StopVanityActions();
		if (info.Knockback != 0f && hitDirection != 0 && (!mount.Active || !mount.Cart))
		{
			velocity.X = info.Knockback * (float)hitDirection;
			velocity.Y = info.Knockback * -7f / 9f;
			fallStart = (int)(position.Y / 16f);
		}
		if (!info.SoundDisabled)
		{
			if (stoned)
			{
				SoundEngine.PlaySound(0, (int)position.X, (int)position.Y);
			}
			else if (mount.Active && mount.Type == 52)
			{
				SoundEngine.PlaySound(3, (int)position.X, (int)position.Y, 6);
			}
			else if ((wereWolf || forceWerewolf) && !hideWolf)
			{
				SoundEngine.PlaySound(3, (int)position.X, (int)position.Y, 6);
			}
			else if (frostArmor)
			{
				SoundEngine.PlaySound(in SoundID.Item27, position);
			}
			else if (boneArmor)
			{
				SoundEngine.PlaySound(3, (int)position.X, (int)position.Y, 2);
			}
			else if (Main.dontStarveWorld && !Main.remixWorld)
			{
				SoundEngine.PlaySound(Male ? SoundID.DSTMaleHurt : SoundID.DSTFemaleHurt, position);
			}
			else
			{
				SoundEngine.PlaySound(Male ? 1 : 20, position);
			}
		}
		eyeHelper.BlinkBecausePlayerGotHurt();
		if (statLife > 0)
		{
			if (!info.DustDisabled)
			{
				double num12 = num / (double)statLifeMax2 * 100.0;
				float num13 = 2 * hitDirection;
				float num14 = 0f;
				if (flag2)
				{
					num12 *= 12.0;
					num14 = 6f;
				}
				for (int k = 0; (double)k < num12; k++)
				{
					if (stoned)
					{
						Dust.NewDust(position, width, height, 1, num13 + (float)hitDirection * num14 * Main.rand.NextFloat(), -2f);
					}
					else if (frostArmor)
					{
						int num15 = Dust.NewDust(position, width, height, 135, num13 + (float)hitDirection * num14 * Main.rand.NextFloat(), -2f);
						Main.dust[num15].shader = GameShaders.Armor.GetSecondaryShader(ArmorSetDye(), this);
					}
					else if (boneArmor)
					{
						int num16 = Dust.NewDust(position, width, height, 26, num13 + (float)hitDirection * num14 * Main.rand.NextFloat(), -2f);
						Main.dust[num16].shader = GameShaders.Armor.GetSecondaryShader(ArmorSetDye(), this);
					}
					else
					{
						Dust.NewDust(position, width, height, 5, num13 + (float)hitDirection * num14 * Main.rand.NextFloat(), -2f);
					}
				}
			}
			PlayerLoader.PostHurt(this, info);
		}
		else
		{
			statLife = 0;
			if (whoAmI == Main.myPlayer)
			{
				KillMe(damageSource, num, hitDirection, pvP);
			}
		}
	}

	private static bool AllowShimmerDodge(PlayerDeathReason damageSource, int cooldownCounter, bool dodgeable)
	{
		if (!dodgeable)
		{
			return false;
		}
		if (cooldownCounter == 1)
		{
			return false;
		}
		Entity entity = null;
		if (!damageSource.TryGetCausingEntity(out entity))
		{
			return true;
		}
		if (entity is NPC { active: not false } nPC && (nPC.boss || NPC.GetNPCInvasionGroup(nPC.type) != 0 || NPCID.Sets.CanHitPastShimmer[nPC.type]))
		{
			return false;
		}
		if (entity is Projectile { active: not false } projectile && ProjectileID.Sets.CanHitPastShimmer[projectile.type])
		{
			return false;
		}
		return true;
	}

	public void KillMeForGood()
	{
		PlayerFileData activePlayerFileData = Main.ActivePlayerFileData;
		if (!activePlayerFileData.ServerSideCharacter)
		{
			bool isCloudSave = activePlayerFileData.IsCloudSave;
			if (FileUtilities.Exists(Main.playerPathName, isCloudSave))
			{
				FileUtilities.Delete(Main.playerPathName, isCloudSave);
			}
			if (FileUtilities.Exists(Main.playerPathName + ".bak", isCloudSave))
			{
				FileUtilities.Delete(Main.playerPathName + ".bak", isCloudSave);
			}
			string text = Path.ChangeExtension(Main.playerPathName, ".tplr");
			if (FileUtilities.Exists(text, isCloudSave))
			{
				FileUtilities.Delete(text, isCloudSave);
			}
			if (FileUtilities.Exists(text + ".bak", isCloudSave))
			{
				FileUtilities.Delete(text + ".bak", isCloudSave);
			}
			Main.ActivePlayerFileData = new PlayerFileData();
		}
	}

	public void KillMe(PlayerDeathReason damageSource, double dmg, int hitDirection, bool pvp = false)
	{
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_07b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_07b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_07bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_07c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_07c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_07cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_034e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0359: Unknown result type (might be due to invalid IL or missing references)
		//IL_0568: Unknown result type (might be due to invalid IL or missing references)
		//IL_0577: Unknown result type (might be due to invalid IL or missing references)
		//IL_0998: Unknown result type (might be due to invalid IL or missing references)
		//IL_07e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0806: Unknown result type (might be due to invalid IL or missing references)
		//IL_080c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0827: Unknown result type (might be due to invalid IL or missing references)
		//IL_0849: Unknown result type (might be due to invalid IL or missing references)
		//IL_084f: Unknown result type (might be due to invalid IL or missing references)
		//IL_08dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_08fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0901: Unknown result type (might be due to invalid IL or missing references)
		//IL_0889: Unknown result type (might be due to invalid IL or missing references)
		//IL_08a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_08ae: Unknown result type (might be due to invalid IL or missing references)
		if (creativeGodMode || dead)
		{
			return;
		}
		StopVanityActions();
		bool playSound = true;
		bool genGore = true;
		if (!PlayerLoader.PreKill(this, dmg, hitDirection, pvp, ref playSound, ref genGore, ref damageSource))
		{
			return;
		}
		if (pvp)
		{
			pvpDeath = true;
		}
		if (trapDebuffSource)
		{
			AchievementsHelper.HandleSpecialEvent(this, 4);
		}
		if (Main.myPlayer == whoAmI && _framesLeftEligibleForDeadmansChestDeathAchievement > 0)
		{
			AchievementsHelper.HandleSpecialEvent(this, 23);
		}
		if (whoAmI == Main.myPlayer)
		{
			Main.NotifyOfEvent(GameNotificationType.SpawnOrDeath);
		}
		if (pvpDeath)
		{
			numberOfDeathsPVP++;
		}
		else
		{
			numberOfDeathsPVE++;
		}
		lastDeathPostion = base.Center;
		lastDeathTime = DateTime.Now;
		showLastDeath = true;
		bool overFlowing;
		long coinsOwned = Utils.CoinsCount(out overFlowing, inventory);
		if (Main.myPlayer == whoAmI)
		{
			lostCoins = coinsOwned;
			lostCoinString = Main.ValueToCoins(lostCoins);
		}
		if (Main.myPlayer == whoAmI)
		{
			EndOngoingTorchGodEvent();
		}
		if (Main.myPlayer == whoAmI)
		{
			Main.mapFullscreen = false;
		}
		if (Main.myPlayer == whoAmI)
		{
			trashItem.SetDefaults();
			if (difficulty == 0 || difficulty == 3)
			{
				for (int i = 0; i < 59; i++)
				{
					if (inventory[i].stack > 0 && ((inventory[i].type >= 1522 && inventory[i].type <= 1527) || inventory[i].type == 3643))
					{
						int num = Item.NewItem(GetItemSource_Death(), (int)position.X, (int)position.Y, width, height, inventory[i].type);
						Main.item[num].netDefaults(inventory[i].netID);
						Main.item[num].Prefix(inventory[i].prefix);
						Main.item[num].stack = inventory[i].stack;
						Main.item[num].velocity.Y = (float)Main.rand.Next(-20, 1) * 0.2f;
						Main.item[num].velocity.X = (float)Main.rand.Next(-20, 21) * 0.2f;
						Main.item[num].noGrabDelay = 100;
						Main.item[num].favorited = false;
						Main.item[num].newAndShiny = false;
						if (Main.netMode == 1)
						{
							NetMessage.SendData(21, -1, -1, null, num);
						}
						inventory[i].SetDefaults();
					}
				}
			}
			else if (difficulty == 1)
			{
				DropItems();
			}
			else if (difficulty == 2)
			{
				DropItems();
				KillMeForGood();
			}
		}
		if (playSound)
		{
			if (Main.dontStarveWorld || Main.tenthAnniversaryWorld)
			{
				SoundEngine.PlaySound(Male ? SoundID.DSTMaleHurt : SoundID.DSTFemaleHurt, position);
			}
			else
			{
				SoundEngine.PlaySound(5, (int)position.X, (int)position.Y);
			}
		}
		if (Main.tenthAnniversaryWorld)
		{
			for (int j = 0; j < 85; j++)
			{
				int type = Main.rand.Next(139, 143);
				int num2 = Dust.NewDust(new Vector2(position.X, position.Y), width, height, type, 0f, -10f, 0, default(Color), 1.2f);
				Main.dust[num2].velocity.X += (float)Main.rand.Next(-50, 51) * 0.01f;
				Main.dust[num2].velocity.Y += (float)Main.rand.Next(-50, 51) * 0.01f;
				Main.dust[num2].velocity.X *= 1f + (float)Main.rand.Next(-50, 51) * 0.01f;
				Main.dust[num2].velocity.Y *= 1f + (float)Main.rand.Next(-50, 51) * 0.01f;
				Main.dust[num2].velocity.X += (float)Main.rand.Next(-50, 51) * 0.05f;
				Main.dust[num2].velocity.Y += (float)Main.rand.Next(-50, 51) * 0.05f;
				Main.dust[num2].scale *= 1f + (float)Main.rand.Next(-30, 31) * 0.01f;
			}
			for (int k = 0; k < 40; k++)
			{
				int type2 = Main.rand.Next(276, 283);
				int num3 = Gore.NewGore(position, new Vector2(0f, -10f), type2);
				Main.gore[num3].velocity.X += (float)Main.rand.Next(-50, 51) * 0.01f;
				Main.gore[num3].velocity.Y += (float)Main.rand.Next(-50, 51) * 0.01f;
				Main.gore[num3].velocity.X *= 1f + (float)Main.rand.Next(-50, 51) * 0.01f;
				Main.gore[num3].velocity.Y *= 1f + (float)Main.rand.Next(-50, 51) * 0.01f;
				Main.gore[num3].scale *= 1f + (float)Main.rand.Next(-20, 21) * 0.01f;
				Main.gore[num3].velocity.X += (float)Main.rand.Next(-50, 51) * 0.05f;
				Main.gore[num3].velocity.Y += (float)Main.rand.Next(-50, 51) * 0.05f;
			}
		}
		headVelocity.Y = (float)Main.rand.Next(-40, -10) * 0.1f;
		bodyVelocity.Y = (float)Main.rand.Next(-40, -10) * 0.1f;
		legVelocity.Y = (float)Main.rand.Next(-40, -10) * 0.1f;
		headVelocity.X = (float)Main.rand.Next(-20, 21) * 0.1f + (float)(2 * hitDirection);
		bodyVelocity.X = (float)Main.rand.Next(-20, 21) * 0.1f + (float)(2 * hitDirection);
		legVelocity.X = (float)Main.rand.Next(-20, 21) * 0.1f + (float)(2 * hitDirection);
		if (stoned || !genGore)
		{
			headPosition = Vector2.Zero;
			bodyPosition = Vector2.Zero;
			legPosition = Vector2.Zero;
		}
		if (genGore)
		{
			for (int l = 0; l < 100; l++)
			{
				if (stoned)
				{
					Dust.NewDust(position, width, height, 1, 2 * hitDirection, -2f);
				}
				else if (frostArmor)
				{
					int num4 = Dust.NewDust(position, width, height, 135, 2 * hitDirection, -2f);
					Main.dust[num4].shader = GameShaders.Armor.GetSecondaryShader(ArmorSetDye(), this);
				}
				else if (boneArmor)
				{
					int num5 = Dust.NewDust(position, width, height, 26, 2 * hitDirection, -2f);
					Main.dust[num5].shader = GameShaders.Armor.GetSecondaryShader(ArmorSetDye(), this);
				}
				else
				{
					Dust.NewDust(position, width, height, 5, 2 * hitDirection, -2f);
				}
			}
		}
		mount.Dismount(this);
		dead = true;
		respawnTimer = GetRespawnTime(pvp);
		PlayerLoader.Kill(this, dmg, hitDirection, pvp, damageSource);
		immuneAlpha = 0;
		if (!ChildSafety.Disabled)
		{
			immuneAlpha = 255;
		}
		palladiumRegen = false;
		iceBarrier = false;
		crystalLeaf = false;
		NetworkText deathText = damageSource.GetDeathText(name);
		if (Main.netMode == 2)
		{
			ChatHelper.BroadcastChatMessage(deathText, new Color(225, 25, 25));
		}
		else if (Main.netMode == 0)
		{
			Main.NewText(deathText.ToString(), 225, 25, 25);
		}
		if (Main.netMode == 1 && whoAmI == Main.myPlayer)
		{
			NetMessage.SendPlayerDeath(whoAmI, damageSource, (int)dmg, hitDirection, pvp);
		}
		if (whoAmI == Main.myPlayer && (difficulty == 0 || difficulty == 3))
		{
			if (!pvp)
			{
				DropCoins();
			}
			else
			{
				lostCoins = 0L;
				lostCoinString = Main.ValueToCoins(lostCoins);
			}
		}
		DropTombstone(coinsOwned, deathText, hitDirection);
		if (whoAmI != Main.myPlayer)
		{
			return;
		}
		try
		{
			WorldGen.saveToonWhilePlaying();
		}
		catch
		{
		}
	}

	private int GetRespawnTime(bool pvp)
	{
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		int num = 600;
		bool flag = false;
		if (Main.netMode != 0 && !pvp)
		{
			for (int i = 0; i < 200; i++)
			{
				if (Main.npc[i].active && (Main.npc[i].boss || Main.npc[i].type == 13 || Main.npc[i].type == 14 || Main.npc[i].type == 15) && Math.Abs(base.Center.X - Main.npc[i].Center.X) + Math.Abs(base.Center.Y - Main.npc[i].Center.Y) < 4000f)
				{
					flag = true;
					break;
				}
			}
		}
		if (flag)
		{
			num += 600;
		}
		if (Main.expertMode)
		{
			num = (int)((double)num * 1.5);
		}
		if (flag && Main.getGoodWorld && Main.netMode != 0)
		{
			bool flag2 = false;
			for (int j = 0; j < 255; j++)
			{
				if (j != whoAmI && Main.player[j].active)
				{
					flag2 = true;
					break;
				}
			}
			if (flag2)
			{
				num *= 2;
			}
		}
		return num;
	}

	public void DropTombstone(long coinsOwned, NetworkText deathText, int hitDirection)
	{
		if (Main.netMode != 1)
		{
			float num;
			for (num = (float)Main.rand.Next(-35, 36) * 0.1f; num < 2f && num > -2f; num += (float)Main.rand.Next(-30, 31) * 0.1f)
			{
			}
			int num2 = Main.rand.Next(6);
			if (coinsOwned <= 100000)
			{
				num2 = ((num2 != 0) ? (200 + num2) : 43);
			}
			else
			{
				num2 = Main.rand.Next(5);
				num2 += 527;
			}
			IEntitySource projectileSource_Misc = GetProjectileSource_Misc(9);
			int damage = 0;
			int num3 = 0;
			if (Main.getGoodWorld)
			{
				damage = 70;
				num3 = 10;
			}
			int num4 = whoAmI;
			int num5 = ((!Main.getGoodWorld) ? Projectile.NewProjectile(projectileSource_Misc, position.X + (float)(width / 2), position.Y + (float)(height / 2), (float)Main.rand.Next(10, 30) * 0.1f * (float)hitDirection + num, (float)Main.rand.Next(-40, -20) * 0.1f, num2, damage, num3, Main.myPlayer, num4) : Projectile.NewProjectile(projectileSource_Misc, position.X + (float)(width / 2), position.Y + (float)(height / 2), ((float)Main.rand.Next(10, 30) * 0.1f * (float)hitDirection + num) * 1.5f, (float)Main.rand.Next(-40, -20) * 0.1f * 1.5f, num2, damage, num3, Main.myPlayer, num4));
			DateTime now = DateTime.Now;
			string text = now.ToString("D");
			if (GameCulture.FromCultureName(GameCulture.CultureName.English).IsActive)
			{
				text = now.ToString("MMMM d, yyy");
			}
			string miscText = deathText.ToString() + "\n" + text;
			Main.projectile[num5].miscText = miscText;
		}
	}

	public bool CanPullItem(Item item, ItemSpaceStatus status)
	{
		if (status.CanTakeItem)
		{
			return CanAcceptItemIntoInventory(item);
		}
		return false;
	}

	public ItemSpaceStatus ItemSpace(Item newItem)
	{
		if (ItemID.Sets.IsAPickup[newItem.type])
		{
			return new ItemSpaceStatus(CanTakeItem: true);
		}
		if (newItem.uniqueStack && HasItem(newItem.type))
		{
			return new ItemSpaceStatus(CanTakeItem: false);
		}
		if (ItemLoader.ItemSpace(newItem, this))
		{
			return new ItemSpaceStatus(CanTakeItem: true);
		}
		int num = 50;
		if (newItem.IsACoin)
		{
			num = 54;
		}
		for (int i = 0; i < num; i++)
		{
			if (CanItemSlotAccept(inventory[i], newItem))
			{
				return new ItemSpaceStatus(CanTakeItem: true);
			}
		}
		if (newItem.ammo > 0 && !newItem.notAmmo)
		{
			for (int j = 54; j < 58; j++)
			{
				if (CanGoIntoAmmoOnPickup(inventory[j], newItem))
				{
					return new ItemSpaceStatus(CanTakeItem: true);
				}
			}
		}
		for (int k = 54; k < 58; k++)
		{
			if (inventory[k].type > 0 && inventory[k].stack < inventory[k].maxStack && newItem.IsTheSameAs(inventory[k]) && ItemLoader.CanStack(inventory[k], newItem))
			{
				return new ItemSpaceStatus(CanTakeItem: true);
			}
		}
		if (ItemSpaceForCofveve(newItem))
		{
			return new ItemSpaceStatus(CanTakeItem: true, ItemIsGoingToVoidVault: true);
		}
		return new ItemSpaceStatus(CanTakeItem: false);
	}

	public bool ItemSpaceForCofveve(Item newItem)
	{
		if (!IsVoidVaultEnabled)
		{
			return false;
		}
		if (!CanVoidVaultAccept(newItem))
		{
			return false;
		}
		Item[] item = bank4.item;
		for (int i = 0; i < item.Length; i++)
		{
			if (CanItemSlotAccept(item[i], newItem))
			{
				return true;
			}
		}
		return false;
	}

	public bool CanItemSlotAccept(Item theSlot, Item theItemToAccept)
	{
		if (theSlot.type == 0)
		{
			return true;
		}
		bool flag = false;
		if (theSlot.stack < theSlot.maxStack && theItemToAccept.IsTheSameAs(theSlot))
		{
			flag = true;
		}
		if (flag && ItemLoader.CanStack(theSlot, theItemToAccept))
		{
			return true;
		}
		return false;
	}

	public bool CanGoIntoAmmoOnPickup(Item theSlot, Item theItemToAccept)
	{
		if (!theItemToAccept.CanFillEmptyAmmoSlot() && theSlot.type == 0)
		{
			return false;
		}
		return CanItemSlotAccept(theSlot, theItemToAccept);
	}

	public void DoCoins(int i)
	{
		if (inventory[i].stack != 100 || (inventory[i].type != 71 && inventory[i].type != 72 && inventory[i].type != 73))
		{
			return;
		}
		inventory[i].SetDefaults(inventory[i].type + 1);
		for (int j = 0; j < 54; j++)
		{
			if (inventory[j].IsTheSameAs(inventory[i]) && j != i && inventory[j].type == inventory[i].type && inventory[j].stack < inventory[j].maxStack)
			{
				inventory[j].stack++;
				inventory[i].SetDefaults();
				inventory[i].active = false;
				inventory[i].TurnToAir();
				DoCoins(j);
			}
		}
	}

	public Item FillAmmo(int plr, Item newItem, GetItemSettings settings)
	{
		for (int i = 54; i < 58; i++)
		{
			if (inventory[i].type > 0 && inventory[i].stack < inventory[i].maxStack && newItem.IsTheSameAs(inventory[i]) && ItemLoader.TryStackItems(inventory[i], newItem, out var numTransferred))
			{
				SoundEngine.PlaySound(7, (int)position.X, (int)position.Y);
				if (!settings.NoText)
				{
					PopupText.NewText(PopupTextContext.RegularItemPickup, newItem, numTransferred);
				}
				DoCoins(i);
				if (plr == Main.myPlayer)
				{
					Recipe.FindRecipes();
				}
				settings.HandlePostAction(inventory[i]);
				if (newItem.stack <= 0)
				{
					return new Item();
				}
			}
		}
		if (newItem.CanFillEmptyAmmoSlot())
		{
			for (int j = 54; j < 58; j++)
			{
				if (inventory[j].type == 0)
				{
					newItem.shimmered = false;
					inventory[j] = newItem;
					if (!settings.NoText)
					{
						PopupText.NewText(PopupTextContext.RegularItemPickup, newItem, newItem.stack);
					}
					DoCoins(j);
					SoundEngine.PlaySound(7, (int)position.X, (int)position.Y);
					if (plr == Main.myPlayer)
					{
						Recipe.FindRecipes();
					}
					settings.HandlePostAction(inventory[j]);
					return new Item();
				}
			}
		}
		return newItem;
	}

	/// <summary>
	/// Places the <paramref name="newItem" /> directly into this player's inventory. The <paramref name="settings" /> dictate how or if the pickup text is displayed as well as if the item can be placed into the Void Vault inventory. It is typical to use one of the existing options contained in the static fields of <see cref="T:Terraria.GetItemSettings" /> for this parameter to match vanilla behavior. The <paramref name="plr" /> parameter should always be set to the whoAmI of this player.
	/// <para /> Modders commonly use <see cref="M:Terraria.Player.QuickSpawnItem(Terraria.DataStructures.IEntitySource,Terraria.Item,System.Int32)" /> to give a player an item as it is simpler to implement, but GetItem allows for more control and should be used when possible.
	/// <para /> The return value is an Item instance containing the overflow. If the full stack of <paramref name="newItem" /> is placed into the inventory successfully, the return value will be an empty item instance. If the inventory is full or if only a partial stack of <paramref name="newItem" /> fit in the inventory, the return value will be the Item that didn't fit. If the returned <see cref="T:Terraria.Item" /> isn't <see cref="P:Terraria.Item.IsAir" />, that will have to be handled by the calling code, typically by spawning the item in the world as a drop or leaving it where <paramref name="newItem" /> came from.
	/// <para /> Make sure to test code using this method with a full inventory. Consulting vanilla code to match similar usages is recommended to implement specific item movement and popup text behavior the user would expect.
	/// </summary>
	/// <param name="plr"></param>
	/// <param name="newItem"></param>
	/// <param name="settings"></param>
	/// <returns></returns>
	public Item GetItem(int plr, Item newItem, GetItemSettings settings)
	{
		bool isACoin = newItem.IsACoin;
		Item item = newItem;
		int num = 50;
		if (newItem.noGrabDelay > 0)
		{
			return item;
		}
		int num2 = 0;
		if (newItem.uniqueStack && HasItem(newItem.type))
		{
			return item;
		}
		if (isACoin)
		{
			num2 = -4;
			num = 54;
		}
		if (item.FitsAmmoSlot())
		{
			item = FillAmmo(plr, item, settings);
			if (item.type == 0 || item.stack == 0)
			{
				return new Item();
			}
		}
		for (int i = num2; i < 50; i++)
		{
			int num3 = i;
			if (num3 < 0)
			{
				num3 = 54 + i;
			}
			if (GetItem_FillIntoOccupiedSlot(plr, newItem, settings, item, num3))
			{
				return new Item();
			}
		}
		if (!isACoin && newItem.useStyle != 0)
		{
			for (int j = 0; j < 10; j++)
			{
				if (GetItem_FillEmptyInventorySlot(plr, newItem, settings, item, j))
				{
					return new Item();
				}
			}
		}
		if (newItem.favorited)
		{
			for (int k = 0; k < num; k++)
			{
				if (GetItem_FillEmptyInventorySlot(plr, newItem, settings, item, k))
				{
					return new Item();
				}
			}
		}
		else
		{
			for (int num4 = num - 1; num4 >= 0; num4--)
			{
				if (GetItem_FillEmptyInventorySlot(plr, newItem, settings, item, num4))
				{
					return new Item();
				}
			}
		}
		if (settings.CanGoIntoVoidVault && IsVoidVaultEnabled && CanVoidVaultAccept(newItem) && GetItem_VoidVault(plr, bank4.item, newItem, settings, item))
		{
			return new Item();
		}
		return item;
	}

	private bool GetItem_VoidVault(int plr, Item[] inventory, Item newItem, GetItemSettings settings, Item returnItem)
	{
		if (!CanVoidVaultAccept(newItem))
		{
			return false;
		}
		for (int i = 0; i < inventory.Length; i++)
		{
			if (GetItem_FillIntoOccupiedSlot_VoidBag(plr, inventory, newItem, settings, returnItem, i))
			{
				return true;
			}
		}
		for (int j = 0; j < inventory.Length; j++)
		{
			if (GetItem_FillEmptyInventorySlot_VoidBag(plr, inventory, newItem, settings, returnItem, j))
			{
				return true;
			}
		}
		return false;
	}

	private bool CanVoidVaultAccept(Item item)
	{
		if (item.questItem)
		{
			return false;
		}
		if (item.type == 3822)
		{
			return false;
		}
		return true;
	}

	private bool GetItem_FillIntoOccupiedSlot_VoidBag(int plr, Item[] inv, Item newItem, GetItemSettings settings, Item returnItem, int i)
	{
		if (inv[i].type > 0 && inv[i].stack < inv[i].maxStack && returnItem.IsTheSameAs(inv[i]))
		{
			if (!ItemLoader.TryStackItems(inv[i], returnItem, out var numTransferred))
			{
				return false;
			}
			if (newItem.IsACoin)
			{
				SoundEngine.PlaySound(38, (int)position.X, (int)position.Y);
			}
			else
			{
				SoundEngine.PlaySound(7, (int)position.X, (int)position.Y);
			}
			if (!settings.NoText)
			{
				PopupText.NewText(PopupTextContext.ItemPickupToVoidContainer, newItem, numTransferred, noStack: false, settings.LongText);
			}
			AchievementsHelper.NotifyItemPickup(this, returnItem);
			settings.HandlePostAction(inv[i]);
			if (returnItem.stack <= 0)
			{
				return true;
			}
		}
		return false;
	}

	private bool GetItem_FillIntoOccupiedSlot(int plr, Item newItem, GetItemSettings settings, Item returnItem, int i)
	{
		if (inventory[i].type > 0 && inventory[i].stack < inventory[i].maxStack && returnItem.IsTheSameAs(inventory[i]))
		{
			if (!ItemLoader.TryStackItems(inventory[i], returnItem, out var numTransferred))
			{
				return false;
			}
			if (newItem.IsACoin)
			{
				SoundEngine.PlaySound(38, (int)position.X, (int)position.Y);
			}
			else
			{
				SoundEngine.PlaySound(7, (int)position.X, (int)position.Y);
			}
			if (!settings.NoText)
			{
				PopupText.NewText(PopupTextContext.RegularItemPickup, newItem, numTransferred, noStack: false, settings.LongText);
			}
			DoCoins(i);
			if (plr == Main.myPlayer)
			{
				Recipe.FindRecipes();
			}
			AchievementsHelper.NotifyItemPickup(this, returnItem);
			settings.HandlePostAction(inventory[i]);
			if (returnItem.stack <= 0)
			{
				return true;
			}
		}
		return false;
	}

	private bool GetItem_FillEmptyInventorySlot_VoidBag(int plr, Item[] inv, Item newItem, GetItemSettings settings, Item returnItem, int i)
	{
		if (inv[i].type != 0)
		{
			return false;
		}
		if (newItem.IsACoin)
		{
			SoundEngine.PlaySound(38, (int)position.X, (int)position.Y);
		}
		else
		{
			SoundEngine.PlaySound(7, (int)position.X, (int)position.Y);
		}
		returnItem.shimmered = false;
		inv[i] = returnItem;
		if (!settings.NoText)
		{
			PopupText.NewText(PopupTextContext.ItemPickupToVoidContainer, newItem, newItem.stack, noStack: false, settings.LongText);
		}
		DoCoins(i);
		if (plr == Main.myPlayer)
		{
			Recipe.FindRecipes();
		}
		AchievementsHelper.NotifyItemPickup(this, returnItem);
		settings.HandlePostAction(inv[i]);
		return true;
	}

	private bool GetItem_FillEmptyInventorySlot(int plr, Item newItem, GetItemSettings settings, Item returnItem, int i)
	{
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		if (inventory[i].type != 0)
		{
			return false;
		}
		if (newItem.IsACoin)
		{
			SoundEngine.PlaySound(38, (int)position.X, (int)position.Y);
		}
		else
		{
			SoundEngine.PlaySound(7, (int)position.X, (int)position.Y);
		}
		returnItem.shimmered = false;
		inventory[i] = returnItem;
		if (!settings.NoText)
		{
			PopupText.NewText(PopupTextContext.RegularItemPickup, newItem, newItem.stack, noStack: false, settings.LongText);
		}
		DoCoins(i);
		if (plr == Main.myPlayer)
		{
			Recipe.FindRecipes();
		}
		AchievementsHelper.NotifyItemPickup(this, returnItem);
		if (plr == Main.myPlayer && newItem.type == 5095)
		{
			LucyAxeMessage.Create(LucyAxeMessage.MessageSource.PickedUp, base.Top, new Vector2(0f, -7f));
		}
		settings.HandlePostAction(inventory[i]);
		return true;
	}

	public void PlaceThing(ref ItemCheckContext context)
	{
		if (itemTime == 0)
		{
			dontConsumeWand = false;
		}
		PlaceThing_Paintbrush();
		PlaceThing_PaintRoller();
		PlaceThing_PaintScrapper();
		PlaceThing_CannonBall();
		PlaceThing_XMasTreeTops();
		PlaceThing_ItemInExtractinator(ref context);
		PlaceThing_LockChest();
		if (!noBuilding)
		{
			PlaceThing_Tiles();
			PlaceThing_Walls();
		}
	}

	private void PlaceThing_Walls()
	{
		if (inventory[selectedItem].createWall < 0 || !(position.X / 16f - (float)tileRangeX - (float)inventory[selectedItem].tileBoost - (float)blockRange <= (float)tileTargetX) || !((position.X + (float)width) / 16f + (float)tileRangeX + (float)inventory[selectedItem].tileBoost - 1f + (float)blockRange >= (float)tileTargetX) || !(position.Y / 16f - (float)tileRangeY - (float)inventory[selectedItem].tileBoost - (float)blockRange <= (float)tileTargetY) || !((position.Y + (float)height) / 16f + (float)tileRangeY + (float)inventory[selectedItem].tileBoost - 2f + (float)blockRange >= (float)tileTargetY))
		{
			return;
		}
		cursorItemIconEnabled = true;
		if (!ItemTimeIsZero || itemAnimation <= 0 || !controlUseItem || (!Main.tile[tileTargetX + 1, tileTargetY].active() && Main.tile[tileTargetX + 1, tileTargetY].wall <= 0 && !Main.tile[tileTargetX - 1, tileTargetY].active() && Main.tile[tileTargetX - 1, tileTargetY].wall <= 0 && !Main.tile[tileTargetX, tileTargetY + 1].active() && Main.tile[tileTargetX, tileTargetY + 1].wall <= 0 && !Main.tile[tileTargetX, tileTargetY - 1].active() && Main.tile[tileTargetX, tileTargetY - 1].wall <= 0) || Main.tile[tileTargetX, tileTargetY].wall == inventory[selectedItem].createWall)
		{
			return;
		}
		bool flag = true;
		flag &= WallLoader.CanPlace(tileTargetX, tileTargetY, inventory[selectedItem].createWall);
		if (TileReplacementEnabled)
		{
			flag = PlaceThing_TryReplacingWalls(flag);
		}
		if (!flag)
		{
			return;
		}
		WorldGen.PlaceWall(tileTargetX, tileTargetY, inventory[selectedItem].createWall);
		if (Main.tile[tileTargetX, tileTargetY].wall == inventory[selectedItem].createWall)
		{
			WallLoader.PlaceInWorld(tileTargetX, tileTargetY, inventory[selectedItem]);
			ApplyItemTime(inventory[selectedItem], wallSpeed);
			if (Main.netMode == 1)
			{
				NetMessage.SendData(17, -1, -1, null, 3, tileTargetX, tileTargetY, inventory[selectedItem].createWall);
			}
			PlaceThing_Walls_FillEmptySpace();
			if (autoPaint && builderAccStatus[3] == 0)
			{
				TryPainting(tileTargetX, tileTargetY, paintingAWall: true, applyItemAnimation: false);
			}
		}
	}

	private void PlaceThing_Walls_FillEmptySpace()
	{
		if (inventory[selectedItem].stack <= 1)
		{
			return;
		}
		int createWall = inventory[selectedItem].createWall;
		for (int i = 0; i < 4; i++)
		{
			int num = tileTargetX;
			int num2 = tileTargetY;
			if (i == 0)
			{
				num--;
			}
			if (i == 1)
			{
				num++;
			}
			if (i == 2)
			{
				num2--;
			}
			if (i == 3)
			{
				num2++;
			}
			if (Main.tile[num, num2].wall != 0)
			{
				continue;
			}
			int num3 = 0;
			for (int j = 0; j < 4; j++)
			{
				int num4 = num;
				int num5 = num2;
				if (j == 0)
				{
					num4--;
				}
				if (j == 1)
				{
					num4++;
				}
				if (j == 2)
				{
					num5--;
				}
				if (j == 3)
				{
					num5++;
				}
				if (Main.tile[num4, num5].wall == createWall)
				{
					num3++;
				}
			}
			if (num3 != 4)
			{
				continue;
			}
			WorldGen.PlaceWall(num, num2, createWall);
			if (Main.tile[num, num2].wall == createWall)
			{
				if (ItemLoader.ConsumeItem(inventory[selectedItem], this))
				{
					inventory[selectedItem].stack--;
				}
				if (inventory[selectedItem].stack == 0)
				{
					inventory[selectedItem].SetDefaults();
				}
				if (Main.netMode == 1)
				{
					NetMessage.SendData(17, -1, -1, null, 3, num, num2, createWall);
				}
				if (autoPaint && builderAccStatus[3] == 0)
				{
					TryPainting(num, num2, paintingAWall: true, applyItemAnimation: false);
				}
			}
		}
	}

	private void PlaceThing_Tiles()
	{
		Item item = inventory[selectedItem];
		int tileToCreate = item.createTile;
		if (tileToCreate < 0 || !(position.X / 16f - (float)tileRangeX - (float)item.tileBoost - (float)blockRange <= (float)tileTargetX) || !((position.X + (float)width) / 16f + (float)tileRangeX + (float)item.tileBoost - 1f + (float)blockRange >= (float)tileTargetX) || !(position.Y / 16f - (float)tileRangeY - (float)item.tileBoost - (float)blockRange <= (float)tileTargetY) || !((position.Y + (float)height) / 16f + (float)tileRangeY + (float)item.tileBoost - 2f + (float)blockRange >= (float)tileTargetY))
		{
			return;
		}
		cursorItemIconEnabled = true;
		bool flag = PlaceThing_Tiles_CheckLavaBlocking();
		bool canUse = true;
		canUse = PlaceThing_Tiles_CheckGamepadTorchUsability(canUse);
		canUse = PlaceThing_Tiles_CheckWandUsability(canUse);
		canUse = PlaceThing_Tiles_CheckRopeUsability(canUse);
		canUse = PlaceThing_Tiles_CheckFlexibleWand(canUse);
		if (TileReplacementEnabled)
		{
			canUse = PlaceThing_TryReplacingTiles(canUse);
		}
		Tile targetTile = Main.tile[tileTargetX, tileTargetY];
		if (targetTile.active())
		{
			if (tileToCreate == 23 && targetTile.type == 59)
			{
				tileToCreate = 661;
			}
			if (tileToCreate == 199 && targetTile.type == 59)
			{
				tileToCreate = 662;
			}
		}
		if (canUse && ((!targetTile.active() && !flag) || (Main.tileCut[targetTile.type] && targetTile.type != 484) || (targetTile.type >= 373 && targetTile.type <= 375) || targetTile.type == 461 || tileToCreate == 199 || tileToCreate == 23 || tileToCreate == 662 || tileToCreate == 661 || tileToCreate == 2 || tileToCreate == 109 || tileToCreate == 60 || tileToCreate == 70 || tileToCreate == 633 || Main.tileMoss[tileToCreate] || TileID.Sets.BreakableWhenPlacing[targetTile.type]) && ItemTimeIsZero && itemAnimation > 0 && controlUseItem)
		{
			bool canPlace = false;
			bool newObjectType = false;
			bool? overrideCanPlace = null;
			int? forcedRandom = null;
			TileObject objectData = default(TileObject);
			FigureOutWhatToPlace(targetTile, item, out tileToCreate, out var previewPlaceStyle, out overrideCanPlace, out forcedRandom);
			PlantLoader.CheckAndInjectModSapling(tileTargetX, tileTargetY, ref tileToCreate, ref previewPlaceStyle);
			if (overrideCanPlace.HasValue)
			{
				canPlace = overrideCanPlace.Value;
			}
			else if (!TileLoader.CanPlace(tileTargetX, tileTargetY, tileToCreate))
			{
				canPlace = false;
			}
			else if (TileObjectData.CustomPlace(tileToCreate, previewPlaceStyle) && tileToCreate != 82 && tileToCreate != 227)
			{
				newObjectType = true;
				canPlace = TileObject.CanPlace(tileTargetX, tileTargetY, (ushort)tileToCreate, previewPlaceStyle, direction, out objectData, onlyCheck: false, forcedRandom);
				PlaceThing_Tiles_BlockPlacementIfOverPlayers(ref canPlace, ref objectData);
				PlaceThing_Tiles_BlockPlacementForRepeatedPigronatas(ref canPlace, ref objectData);
				PlaceThing_Tiles_BlockPlacementForRepeatedPumpkins(ref canPlace, ref objectData);
				PlaceThing_Tiles_BlockPlacementForRepeatedCoralAndBeachPiles(ref canPlace, ref objectData);
			}
			else
			{
				canPlace = PlaceThing_Tiles_BlockPlacementForAssortedThings(canPlace);
			}
			if (canPlace)
			{
				PlaceThing_Tiles_PlaceIt(newObjectType, objectData, tileToCreate);
			}
		}
	}

	private bool ModifyFlexibleWandPlacementInfo(ref int tileType, ref int tileStyle, ref int? forcedRandom)
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		FlexibleTileWand flexibleTileWand = HeldItem.GetFlexibleTileWand();
		if (flexibleTileWand == null)
		{
			return true;
		}
		if (whoAmI == Main.myPlayer)
		{
			Point val = default(Point);
			((Point)(ref val))..ctor(tileTargetX, tileTargetY);
			if (FlexibleWandLastPosition != val)
			{
				FlexibleWandLastPosition = val;
				FlexibleWandRandomSeed = Main.rand.Next();
			}
		}
		if (flexibleTileWand.TryGetPlacementOption(this, FlexibleWandRandomSeed, FlexibleWandCycleOffset, out var option, out var _))
		{
			tileType = option.TileIdToPlace;
			tileStyle = option.TileStyleToPlace;
			forcedRandom = FlexibleWandCycleOffset;
			return true;
		}
		return false;
	}

	private bool PlaceThing_TryReplacingWalls(bool canUse)
	{
		if (canUse && itemAnimation > 0 && ItemTimeIsZero && controlUseItem && PlaceThing_ValidWallForReplacement() && WorldGen.NearFriendlyWall(tileTargetX, tileTargetY) && WorldGen.ReplaceWall(tileTargetX, tileTargetY, (ushort)HeldItem.createWall))
		{
			canUse = false;
			ApplyItemTime(HeldItem, wallSpeed);
			NetMessage.SendData(17, -1, -1, null, 22, tileTargetX, tileTargetY, HeldItem.createWall);
			if (autoPaint && builderAccStatus[3] == 0)
			{
				TryPainting(tileTargetX, tileTargetY, paintingAWall: true, applyItemAnimation: false);
			}
		}
		return canUse;
	}

	private bool PlaceThing_ValidWallForReplacement()
	{
		_ = Main.tile[tileTargetX, tileTargetY];
		return Main.tile[tileTargetX, tileTargetY].wall > 0;
	}

	private bool PlaceThing_TryReplacingTiles(bool canUse)
	{
		//IL_01e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0204: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c4: Unknown result type (might be due to invalid IL or missing references)
		bool flag = PlaceThing_ValidTileForReplacement();
		if (flag)
		{
			TileObject.objectPreview.Reset();
		}
		if (controlUseItem && canUse && Main.tile[tileTargetX, tileTargetY].active() && itemAnimation > 0 && ItemTimeIsZero && flag)
		{
			Item bestPickaxe = GetBestPickaxe();
			if (bestPickaxe == null)
			{
				return false;
			}
			Tile tile = Main.tile[tileTargetX, tileTargetY];
			_ = ref tile.type;
			int num = hitReplace.HitObject(tileTargetX, tileTargetY, 1);
			int pickaxeDamage = GetPickaxeDamage(tileTargetX, tileTargetY, bestPickaxe.pick, num, tile);
			if (pickaxeDamage == 0)
			{
				return false;
			}
			if (!WorldGen.IsTileReplacable(tileTargetX, tileTargetY))
			{
				return false;
			}
			if (!TileLoader.CanReplace(tileTargetX, tileTargetY, tile.type, HeldItem.createTile))
			{
				return false;
			}
			if (!TileLoader.CanPlace(tileTargetX, tileTargetY, HeldItem.createTile))
			{
				return false;
			}
			if (hitReplace.AddDamage(num, pickaxeDamage) < 100)
			{
				int num2 = WorldGen.KillTile_GetTileDustAmount(fail: true, tile, tileTargetX, tileTargetY);
				for (int i = 0; i < num2; i++)
				{
					WorldGen.KillTile_MakeTileDust(tileTargetX, tileTargetY, tile);
				}
				WorldGen.KillTile_PlaySounds(tileTargetX, tileTargetY, fail: true, tile);
				if (HeldItem.consumable)
				{
					HeldItem.stack++;
				}
				dontConsumeWand = true;
				ApplyItemTime(bestPickaxe, pickSpeed);
				SetItemAnimation((int)((float)bestPickaxe.useTime * pickSpeed));
				return false;
			}
			ClearMiningCacheAt(tileTargetX, tileTargetY, 1);
			Point topLeft = TileObjectData.TopLeft(tileTargetX, tileTargetY).ToPoint();
			int[,] typeCaches = PlaceThing_Tiles_GetAutoAccessoryCache(TileObjectData.GetTileData(HeldItem.createTile, HeldItem.placeStyle), topLeft);
			int type = HeldItem.createTile;
			int style = HeldItem.placeStyle;
			if (UsingBiomeTorches && type == 4)
			{
				BiomeTorchPlaceStyle(ref type, ref style);
			}
			if (UsingBiomeTorches && type == 215)
			{
				BiomeCampfirePlaceStyle(ref type, ref style);
			}
			if (WorldGen.ReplaceTile(tileTargetX, tileTargetY, (ushort)type, style))
			{
				canUse = false;
				NetMessage.SendData(17, -1, -1, null, 21, tileTargetX, tileTargetY, type, style);
				ApplyItemTime(HeldItem);
				SetItemAnimation(HeldItem.useAnimation);
				PlaceThing_Tiles_PlaceIt_AutoPaintAndActuate(typeCaches, type, topLeft);
			}
		}
		return canUse;
	}

	private bool PlaceThing_ValidTileForReplacement()
	{
		int type = HeldItem.createTile;
		int style = HeldItem.placeStyle;
		if (UsingBiomeTorches && type == 4)
		{
			BiomeTorchPlaceStyle(ref type, ref style);
		}
		if (UsingBiomeTorches && type == 215)
		{
			BiomeCampfirePlaceStyle(ref type, ref style);
		}
		Tile tileCache = Main.tile[tileTargetX, tileTargetY];
		if (WorldGen.WouldTileReplacementBeBlockedByLiquid(tileTargetX, tileTargetY, 1))
		{
			return false;
		}
		if (ItemID.Sets.SortingPriorityRopes[HeldItem.type] != -1)
		{
			return false;
		}
		if (Main.tileMoss[type])
		{
			return false;
		}
		if (TileID.Sets.DoesntPlaceWithTileReplacement[type])
		{
			return false;
		}
		if (TileID.Sets.DoesntGetReplacedWithTileReplacement[tileCache.type])
		{
			return false;
		}
		if (!PlaceThing_CheckSpecificValidtyCaseForBlockSwap(type, tileCache.type))
		{
			return false;
		}
		if (Main.tileCut[tileCache.type])
		{
			return false;
		}
		if (TileID.Sets.Platforms[tileCache.type] && tileCache.type == type)
		{
			return tileCache.frameY != style * 18;
		}
		if (TileID.Sets.Torch[tileCache.type] && TileID.Sets.Torch[type])
		{
			if (tileCache.type == type)
			{
				return tileCache.frameY != style * 22;
			}
			return true;
		}
		if (TileID.Sets.Campfire[tileCache.type] && TileID.Sets.Campfire[type])
		{
			if (tileCache.type == type)
			{
				return tileCache.frameX / 54 != style;
			}
			return true;
		}
		if (TileID.Sets.BasicChest[tileCache.type] && TileID.Sets.BasicChest[type])
		{
			if (tileCache.frameX / 36 == style)
			{
				return tileCache.type != type;
			}
			return true;
		}
		if (TileID.Sets.BasicDresser[tileCache.type] && TileID.Sets.BasicDresser[type])
		{
			if (tileCache.frameX / 54 == style)
			{
				return tileCache.type != type;
			}
			return true;
		}
		bool flag = false;
		if (Main.tileRope[tileCache.type])
		{
			if (type != 314 && !TileID.Sets.Platforms[type])
			{
				return false;
			}
			flag = true;
		}
		if (!flag && Main.tileFrameImportant[type] && !TileID.Sets.Platforms[type])
		{
			return false;
		}
		if (Main.tile[tileTargetX, tileTargetY].type == type)
		{
			return false;
		}
		if (Main.tile[tileTargetX, tileTargetY].type == 230 && Main.getGoodWorld)
		{
			return false;
		}
		if (!TileID.Sets.IgnoresTileReplacementDropCheckWhenBeingPlaced[type])
		{
			WorldGen.KillTile_GetItemDrops(tileTargetX, tileTargetY, tileCache, out var dropItem, out var _, out var _, out var _);
			if (dropItem == HeldItem.type)
			{
				return false;
			}
		}
		if (!WorldGen.WouldTileReplacementWork((ushort)type, tileTargetX, tileTargetY))
		{
			return false;
		}
		return true;
	}

	private bool PlaceThing_CheckSpecificValidtyCaseForBlockSwap(int tileTypeBeingPlaced, int tileTypeCurrentlyPlaced)
	{
		bool flag = TileID.Sets.Falling[tileTypeBeingPlaced];
		bool flag2 = TileID.Sets.Falling[tileTypeCurrentlyPlaced] && !flag;
		if (flag2)
		{
			Item bestPickaxe = GetBestPickaxe();
			if (bestPickaxe != null && bestPickaxe.pick >= 110)
			{
				flag2 = false;
			}
		}
		if (flag2 && tileTargetY > 0)
		{
			Tile tile = Main.tile[tileTargetX, tileTargetY - 1];
			bool flag3 = false;
			if (tile != null)
			{
				flag3 |= !tile.active();
				flag3 |= tile.active() && !TileID.Sets.Falling[tile.type];
			}
			if (flag3)
			{
				flag2 = false;
			}
		}
		if (flag2)
		{
			return false;
		}
		return true;
	}

	public Item GetBestPickaxe()
	{
		Item item = null;
		for (int i = 0; i < 50; i++)
		{
			if (inventory[i].stack > 0 && inventory[i].pick > 0 && (item == null || inventory[i].pick > item.pick))
			{
				item = inventory[i];
			}
		}
		return item;
	}

	private TileObject PlaceThing_Tiles_PlaceIt(bool newObjectType, TileObject data, int tileToCreate)
	{
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d9: Unknown result type (might be due to invalid IL or missing references)
		int style = inventory[selectedItem].placeStyle;
		if (!newObjectType)
		{
			style = PlaceThing_Tiles_PlaceIt_GetLegacyTileStyle(style);
		}
		Point topLeft = ((data.type == 0) ? new Point(tileTargetX, tileTargetY) : new Point(data.xCoord, data.yCoord));
		int[,] typeCaches = PlaceThing_Tiles_GetAutoAccessoryCache(TileObjectData.GetTileData(data.type, data.style, data.alternate), topLeft);
		bool forced = false;
		bool flag;
		if (newObjectType)
		{
			flag = TileObject.Place(data);
			WorldGen.SquareTileFrame(tileTargetX, tileTargetY);
			if (Main.netMode != 1 || !TileID.Sets.IsAContainer[tileToCreate])
			{
				SoundEngine.PlaySound(0, tileTargetX * 16, tileTargetY * 16);
			}
		}
		else
		{
			if (UsingBiomeTorches && tileToCreate == 4 && style == 0)
			{
				BiomeTorchPlaceStyle(ref tileToCreate, ref style);
			}
			flag = WorldGen.PlaceTile(tileTargetX, tileTargetY, tileToCreate, mute: false, forced, whoAmI, style);
		}
		if (flag)
		{
			ApplyItemTime(inventory[selectedItem], tileSpeed);
			if (newObjectType)
			{
				TileObjectData.CallPostPlacementPlayerHook(tileTargetX, tileTargetY, tileToCreate, style, direction, data.alternate, data);
				if (Main.netMode == 1 && !Main.tileContainer[tileToCreate] && tileToCreate != 423)
				{
					NetMessage.SendObjectPlacement(-1, tileTargetX, tileTargetY, data.type, data.style, data.alternate, data.random, direction);
				}
			}
			else
			{
				NetMessage.SendData(17, -1, -1, null, 1, tileTargetX, tileTargetY, tileToCreate, style);
				PlaceThing_Tiles_PlaceIt_SpinChairs();
				PlaceThing_Tiles_PlaceIt_SpinBedsAndBaths();
			}
			PlaceThing_Tiles_PlaceIt_AdjustPlants();
			PlaceThing_Tiles_PlaceIt_SpinTraps();
			PlaceThing_Tiles_PlaceIt_TriggerLogicLamp();
			PlaceThing_Tiles_PlaceIt_SpinSmartPlatform();
			PlaceThing_Tiles_PlaceIt_ConsumeFlexibleWandMaterial();
			PlaceThing_Tiles_PlaceIt_UnslopeForSolids();
			PlaceThing_Tiles_PlaceIt_KillGrassForSolids();
			PlaceThing_Tiles_PlaceIt_AutoPaintAndActuate(typeCaches, tileToCreate, topLeft);
			if (PlayerInput.UsingGamepad && ItemID.Sets.SingleUseInGamepad[inventory[selectedItem].type] && Main.myPlayer == whoAmI && !Main.SmartCursorIsUsed)
			{
				Main.blockMouse = true;
			}
			TileLoader.PlaceInWorld(tileTargetX, tileTargetY, inventory[selectedItem]);
		}
		return data;
	}

	public void PlaceThing_Tiles_PlaceIt_ConsumeFlexibleWandMaterial()
	{
		FlexibleTileWand flexibleTileWand = inventory[selectedItem].GetFlexibleTileWand();
		if (flexibleTileWand != null && flexibleTileWand.TryGetPlacementOption(this, FlexibleWandRandomSeed, FlexibleWandCycleOffset, out var _, out var itemToConsume))
		{
			itemToConsume.stack--;
			if (itemToConsume.stack <= 0)
			{
				itemToConsume.TurnToAir();
			}
		}
	}

	public int BiomeTorchPlaceStyle(ref int type, ref int style)
	{
		if (!UsingBiomeTorches || style != 0)
		{
			return style;
		}
		if (ZoneShimmer)
		{
			style = 23;
		}
		else if (ZoneLihzhardTemple)
		{
			style = 21;
		}
		else if (ZoneDungeon)
		{
			style = 13;
		}
		else if (position.Y > (float)(Main.UnderworldLayer * 16))
		{
			style = 7;
		}
		else if (ZoneHallow)
		{
			style = 20;
		}
		else if (ZoneCorrupt)
		{
			style = 18;
		}
		else if (ZoneCrimson)
		{
			style = 19;
		}
		else if (ZoneSnow)
		{
			style = 9;
		}
		else if (ZoneGlowshroom)
		{
			style = 22;
		}
		else if (ZoneJungle)
		{
			style = 21;
		}
		else if ((ZoneDesert && (double)position.Y < Main.worldSurface * 16.0) || ZoneUndergroundDesert)
		{
			style = 16;
		}
		else if (ZoneDesert && Main.remixWorld)
		{
			style = 16;
		}
		if (CurrentSceneEffect.biomeTorchItemType.value > -1)
		{
			Item item = ContentSamples.ItemsByType[CurrentSceneEffect.biomeTorchItemType.value];
			type = item.createTile;
			style = item.placeStyle;
		}
		return style;
	}

	public int BiomeTorchHoldStyle(int style)
	{
		if (!UsingBiomeTorches || style != 8)
		{
			return style;
		}
		if (ZoneShimmer)
		{
			style = 5353;
		}
		else if (ZoneLihzhardTemple)
		{
			style = 4388;
		}
		else if (ZoneDungeon)
		{
			style = 3004;
		}
		else if (position.Y > (float)(Main.UnderworldLayer * 16))
		{
			style = 433;
		}
		else if (ZoneHallow)
		{
			style = 4387;
		}
		else if (ZoneCorrupt)
		{
			style = 4385;
		}
		else if (ZoneCrimson)
		{
			style = 4386;
		}
		else if (ZoneSnow)
		{
			style = 974;
		}
		else if (ZoneGlowshroom)
		{
			style = 5293;
		}
		else if (ZoneJungle)
		{
			style = 4388;
		}
		else if ((ZoneDesert && (double)position.Y < Main.worldSurface * 16.0) || ZoneUndergroundDesert)
		{
			style = 4383;
		}
		else if (ZoneDesert && Main.remixWorld)
		{
			style = 4383;
		}
		if (CurrentSceneEffect.biomeTorchItemType.value > -1)
		{
			style = CurrentSceneEffect.biomeTorchItemType.value;
		}
		return style;
	}

	public int BiomeCampfirePlaceStyle(ref int type, ref int style)
	{
		if (!UsingBiomeTorches || style != 0)
		{
			return style;
		}
		if (ZoneShimmer)
		{
			style = 15;
		}
		else if (ZoneLihzhardTemple)
		{
			style = 13;
		}
		else if (ZoneDungeon)
		{
			style = 7;
		}
		else if (position.Y > (float)(Main.UnderworldLayer * 16))
		{
			style = 2;
		}
		else if (ZoneHallow)
		{
			style = 12;
		}
		else if (ZoneCorrupt)
		{
			style = 10;
		}
		else if (ZoneCrimson)
		{
			style = 11;
		}
		else if (ZoneSnow)
		{
			style = 3;
		}
		else if (ZoneGlowshroom)
		{
			style = 14;
		}
		else if (ZoneJungle)
		{
			style = 13;
		}
		else if ((ZoneDesert && (double)position.Y < Main.worldSurface * 16.0) || ZoneUndergroundDesert)
		{
			style = 8;
		}
		else if (ZoneDesert && Main.remixWorld)
		{
			style = 8;
		}
		if (CurrentSceneEffect.biomeCampfireItemType.value > -1)
		{
			Item item = ContentSamples.ItemsByType[CurrentSceneEffect.biomeCampfireItemType.value];
			type = item.createTile;
			style = item.placeStyle;
		}
		return style;
	}

	public int BiomeCampfireHoldStyle(int itemType)
	{
		if (!UsingBiomeTorches || itemType != 966)
		{
			return itemType;
		}
		if (ZoneShimmer)
		{
			itemType = 5357;
		}
		else if (ZoneLihzhardTemple)
		{
			itemType = 4694;
		}
		else if (ZoneDungeon)
		{
			itemType = 3724;
		}
		else if (position.Y > (float)(Main.UnderworldLayer * 16))
		{
			itemType = 3047;
		}
		else if (ZoneHallow)
		{
			itemType = 4693;
		}
		else if (ZoneCorrupt)
		{
			itemType = 4691;
		}
		else if (ZoneCrimson)
		{
			itemType = 4692;
		}
		else if (ZoneSnow)
		{
			itemType = 3048;
		}
		else if (ZoneJungle)
		{
			itemType = 4694;
		}
		else if (ZoneGlowshroom)
		{
			itemType = 5299;
		}
		else if ((ZoneDesert && (double)position.Y < Main.worldSurface * 16.0) || ZoneUndergroundDesert)
		{
			itemType = 4689;
		}
		else if (ZoneDesert && Main.remixWorld)
		{
			itemType = 4689;
		}
		if (CurrentSceneEffect.biomeCampfireItemType.value > -1)
		{
			itemType = CurrentSceneEffect.biomeCampfireItemType.value;
		}
		return itemType;
	}

	private int[,] PlaceThing_Tiles_GetAutoAccessoryCache(TileObjectData data, Point topLeft)
	{
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		int[,] array = null;
		if (autoPaint || autoActuator)
		{
			int num = data?.Width ?? 1;
			int num2 = data?.Height ?? 1;
			array = new int[num, num2];
			for (int i = 0; i < num; i++)
			{
				for (int j = 0; j < num2; j++)
				{
					int x = topLeft.X + i;
					int y = topLeft.Y + j;
					if (Main.tile[x, y].active())
					{
						array[i, j] = Main.tile[x, y].type;
					}
					else
					{
						array[i, j] = -1;
					}
				}
			}
		}
		return array;
	}

	private int PlaceThing_Tiles_PlaceIt_GetLegacyTileStyle(int style)
	{
		int createTile = inventory[selectedItem].createTile;
		if (createTile == 36)
		{
			style = Main.rand.Next(7);
		}
		if (createTile == 212 && direction > 0)
		{
			style = 1;
		}
		if (createTile == 141)
		{
			style = Main.rand.Next(2);
		}
		if (createTile == 128 || createTile == 269 || createTile == 334)
		{
			style = ((direction >= 0) ? 1 : (-1));
		}
		if (createTile == 241 && inventory[selectedItem].placeStyle == 0)
		{
			style = Main.rand.Next(0, 9);
		}
		if (createTile == 35 && inventory[selectedItem].placeStyle == 0)
		{
			style = Main.rand.Next(9);
		}
		if (createTile == 314 && style == 2 && direction == 1)
		{
			style++;
		}
		if (createTile == 129)
		{
			style = (short)Main.rand.Next(18);
		}
		return style;
	}

	private void PlaceThing_Tiles_PlaceIt_UnslopeForSolids()
	{
		if (!Main.tileSolid[inventory[selectedItem].createTile] || (inventory[selectedItem].createTile >= 0 && TileID.Sets.Platforms[inventory[selectedItem].createTile]))
		{
			return;
		}
		int num = tileTargetX;
		int num2 = tileTargetY + 1;
		if (Main.tile[num, num2] != null && !TileID.Sets.Platforms[Main.tile[num, num2].type] && (Main.tile[num, num2].topSlope() || Main.tile[num, num2].halfBrick()))
		{
			WorldGen.SlopeTile(num, num2);
			if (Main.netMode == 1)
			{
				NetMessage.SendData(17, -1, -1, null, 14, num, num2);
			}
		}
		num = tileTargetX;
		num2 = tileTargetY - 1;
		if (Main.tile[num, num2] != null && !TileID.Sets.Platforms[Main.tile[num, num2].type] && Main.tile[num, num2].bottomSlope())
		{
			WorldGen.SlopeTile(num, num2);
			if (Main.netMode == 1)
			{
				NetMessage.SendData(17, -1, -1, null, 14, num, num2);
			}
		}
	}

	private void PlaceThing_Tiles_PlaceIt_KillGrassForSolids()
	{
		if (!Main.tileSolid[inventory[selectedItem].createTile])
		{
			return;
		}
		for (int i = tileTargetX - 1; i <= tileTargetX + 1; i++)
		{
			for (int j = tileTargetY - 1; j <= tileTargetY + 1; j++)
			{
				Tile tile = Main.tile[i, j];
				if (!tile.active() || inventory[selectedItem].createTile == tile.type || (tile.type != 2 && tile.type != 23 && tile.type != 60 && tile.type != 70 && tile.type != 109 && tile.type != 199 && tile.type != 477 && tile.type != 492 && tile.type != 633))
				{
					continue;
				}
				bool flag = true;
				for (int k = i - 1; k <= i + 1; k++)
				{
					for (int l = j - 1; l <= j + 1; l++)
					{
						if (!WorldGen.SolidTile(k, l))
						{
							flag = false;
						}
					}
				}
				if (flag)
				{
					WorldGen.KillTile(i, j, fail: true);
					if (Main.netMode == 1)
					{
						NetMessage.SendData(17, -1, -1, null, 0, i, j, 1f);
					}
				}
			}
		}
	}

	private void PlaceThing_Tiles_PlaceIt_AutoPaintAndActuate(int[,] typeCaches, int tileToCreate, Point topLeft)
	{
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		if (!autoPaint && !autoActuator)
		{
			return;
		}
		int num = 0;
		int num2 = 11;
		int num3 = 11;
		bool flag = TileID.Sets.Platforms[Main.tile[tileTargetX, tileTargetY].type];
		bool flag2 = TileID.Sets.Platforms[Main.tile[tileTargetX, tileTargetY].type] && TileID.Sets.Platforms[tileToCreate];
		if (!Main.tileFrameImportant[Main.tile[tileTargetX, tileTargetY].type] || flag)
		{
			num = 5;
			num3 = 6;
		}
		num = 0;
		num2 = typeCaches.GetLength(0);
		num3 = typeCaches.GetLength(1);
		for (int i = 0; i < num2; i++)
		{
			for (int j = num; j < num3; j++)
			{
				int num4 = topLeft.X + i;
				int num5 = topLeft.Y + j;
				if ((!Main.tile[num4, num5].active() && typeCaches[i, j] == -1) || (Main.tile[num4, num5].active() && !flag2 && (typeCaches[i, j] == Main.tile[num4, num5].type || Main.tile[num4, num5].type != tileToCreate)))
				{
					continue;
				}
				if (autoPaint && builderAccStatus[3] == 0)
				{
					TryPainting(num4, num5, paintingAWall: false, applyItemAnimation: false);
				}
				if (!autoActuator || builderAccStatus[2] != 0)
				{
					continue;
				}
				bool flag3 = Main.tileSolid[Main.tile[num4, num5].type] && !TileID.Sets.NotReallySolid[Main.tile[num4, num5].type];
				ushort type = Main.tile[num4, num5].type;
				if (type == 314 || (uint)(type - 386) <= 3u)
				{
					flag3 = false;
				}
				if (!flag3)
				{
					continue;
				}
				int num6 = FindItem(849);
				if (num6 > -1 && WorldGen.PlaceActuator(num4, num5))
				{
					NetMessage.SendData(17, -1, -1, null, 8, num4, num5);
					if (ItemLoader.ConsumeItem(inventory[num6], this))
					{
						inventory[num6].stack--;
					}
					if (inventory[num6].stack <= 0)
					{
						inventory[num6].SetDefaults();
					}
				}
			}
		}
	}

	private void PlaceThing_Tiles_PlaceIt_SpinSmartPlatform()
	{
		if (inventory[selectedItem].createTile < 0 || !TileID.Sets.Platforms[inventory[selectedItem].createTile] || !Main.SmartCursorIsUsed)
		{
			return;
		}
		int num = tileTargetX;
		int num2 = tileTargetY;
		int num3 = -1;
		int num4 = 0;
		int num5 = 0;
		bool flag = true;
		for (int i = -1; i < 2; i++)
		{
			for (int j = -1; j < 2; j++)
			{
				if ((i != 0 || j != 0) && TileID.Sets.Platforms[Main.tile[num + i, num2 + j].type])
				{
					flag = false;
				}
			}
		}
		if (flag)
		{
			return;
		}
		Tile tile = Main.tile[num - 1, num2 - 1];
		if (tile.active() && TileID.Sets.Platforms[tile.type] && tile.slope() != 2)
		{
			num4++;
		}
		tile = Main.tile[num - 1, num2 + 1];
		if (tile.active() && TileID.Sets.Platforms[tile.type] && tile.slope() != 1)
		{
			num5++;
		}
		tile = Main.tile[num + 1, num2 - 1];
		if (tile.active() && TileID.Sets.Platforms[tile.type] && tile.slope() != 1)
		{
			num5++;
		}
		tile = Main.tile[num + 1, num2 + 1];
		if (tile.active() && TileID.Sets.Platforms[tile.type] && tile.slope() != 2)
		{
			num4++;
		}
		tile = Main.tile[num - 1, num2];
		if (WorldGen.SolidTile(tile))
		{
			num4++;
			if (TileID.Sets.Platforms[tile.type] && tile.slope() == 0)
			{
				num4++;
			}
		}
		tile = Main.tile[num + 1, num2];
		if (WorldGen.SolidTile(tile))
		{
			num5++;
			if (TileID.Sets.Platforms[tile.type] && tile.slope() == 0)
			{
				num5++;
			}
		}
		if (num4 > num5)
		{
			num3 = 1;
		}
		else if (num5 > num4)
		{
			num3 = 2;
		}
		tile = Main.tile[num - 1, num2];
		if (tile.active() && TileID.Sets.Platforms[tile.type])
		{
			num3 = 0;
		}
		tile = Main.tile[num + 1, num2];
		if (tile.active() && TileID.Sets.Platforms[tile.type])
		{
			num3 = 0;
		}
		int num6 = 0;
		int num7 = 0;
		if (num3 != -1)
		{
			WorldGen.SlopeTile(num, num2, num3, noEffects: true);
			int num8 = Main.tile[num, num2].slope();
			if (Main.netMode == 1)
			{
				NetMessage.SendData(17, -1, -1, null, 14, tileTargetX, tileTargetY, num8);
			}
			if (num3 == 1)
			{
				num6 = -1;
				num7 = -1;
			}
			else
			{
				num6 = 1;
				num7 = -1;
			}
			tile = Main.tile[num + num6, num2 + num7];
			if (tile.active() && TileID.Sets.Platforms[tile.type] && tile.slope() == 0 && (!Main.tile[num + num6 + num6, num2 + num7].active() || !TileID.Sets.Platforms[Main.tile[num + num6 + num6, num2 + num7].type] || !Main.tile[num + num6 + num6, num2 + num7].halfBrick()))
			{
				WorldGen.SlopeTile(num + num6, num2 + num7, num3);
				num8 = tile.slope();
				if (Main.netMode == 1)
				{
					NetMessage.SendData(17, -1, -1, null, 14, num + num6, num2 + num7, num8);
				}
			}
			if (num3 == 1)
			{
				num6 = 1;
				num7 = 1;
			}
			else
			{
				num6 = -1;
				num7 = 1;
			}
			tile = Main.tile[num + num6, num2 + num7];
			if (tile.active() && TileID.Sets.Platforms[tile.type] && tile.slope() == 0 && WorldGen.PlatformProperSides(num + num6, num2 + num7, acceptNonOpposing: true) <= 0)
			{
				WorldGen.SlopeTile(num + num6, num2 + num7, num3);
				num8 = tile.slope();
				if (Main.netMode == 1)
				{
					NetMessage.SendData(17, -1, -1, null, 14, num + num6, num2 + num7, num8);
				}
			}
			return;
		}
		num3 = 0;
		int num9 = 0;
		num6 = -1;
		tile = Main.tile[num + num6, num2];
		if (tile.active() && TileID.Sets.Platforms[tile.type] && tile.slope() != 0)
		{
			int num10 = (tile.slope() == 1).ToDirectionInt() * num6;
			num3 = ((num10 != -1) ? tile.slope() : 0);
			bool flag2 = true;
			if (Main.tile[num + num6 * 2, num2 + num10].active() && TileID.Sets.Platforms[Main.tile[num + num6 * 2, num2].type] && num3 == Main.tile[num + num6 * 2, num2 + num10].slope())
			{
				flag2 = false;
			}
			if (Main.tile[num, num2 - num10].active() && TileID.Sets.Platforms[Main.tile[num, num2 - num10].type] && tile.slope() == Main.tile[num, num2 - num10].slope())
			{
				flag2 = false;
			}
			if (flag2)
			{
				WorldGen.SlopeTile(num + num6, num2, num3);
				num9 = tile.slope();
				if (Main.netMode == 1)
				{
					NetMessage.SendData(17, -1, -1, null, 14, num + num6, num2, num9);
				}
			}
		}
		num6 = 1;
		num7 = 0;
		tile = Main.tile[num + num6, num2 + num7];
		if (tile.active() && TileID.Sets.Platforms[tile.type] && tile.slope() != 0)
		{
			int num11 = (tile.slope() == 1).ToDirectionInt() * num6;
			num3 = ((num11 != -1) ? tile.slope() : 0);
			bool flag3 = true;
			if (Main.tile[num + num6 * 2, num2 + num11].active() && TileID.Sets.Platforms[Main.tile[num + num6 * 2, num2].type] && num3 == Main.tile[num + num6 * 2, num2 + num11].slope())
			{
				flag3 = false;
			}
			if (Main.tile[num, num2 - num11].active() && TileID.Sets.Platforms[Main.tile[num, num2 - num11].type] && tile.slope() == Main.tile[num, num2 - num11].slope())
			{
				flag3 = false;
			}
			if (flag3)
			{
				WorldGen.SlopeTile(num + num6, num2, num3);
				num9 = tile.slope();
				if (Main.netMode == 1)
				{
					NetMessage.SendData(17, -1, -1, null, 14, num + num6, num2, num9);
				}
			}
		}
		if (num4 != num5 || WorldGen.PlatformProperSides(num, num2) != 0)
		{
			return;
		}
		tile = Main.tile[num, num2 + 1];
		if (tile.active() && !tile.halfBrick() && tile.slope() == 0 && Main.tileSolid[tile.type])
		{
			num3 = ((direction != 1) ? 1 : 2);
			WorldGen.SlopeTile(num, num2, num3);
			num9 = Main.tile[num, num2].slope();
			if (Main.netMode == 1)
			{
				NetMessage.SendData(17, -1, -1, null, 14, tileTargetX, tileTargetY, num9);
			}
		}
	}

	private void PlaceThing_Tiles_PlaceIt_TriggerLogicLamp()
	{
		if (inventory[selectedItem].createTile == 419)
		{
			if (Main.netMode == 1)
			{
				NetMessage.SendData(17, -1, -1, null, 18, tileTargetX, tileTargetY);
			}
			else
			{
				Wiring.PokeLogicGate(tileTargetX, tileTargetY);
			}
		}
	}

	private void PlaceThing_Tiles_PlaceIt_SpinBedsAndBaths()
	{
		if ((inventory[selectedItem].createTile == 79 || inventory[selectedItem].createTile == 90) && Main.netMode == 1)
		{
			NetMessage.SendTileSquare(-1, tileTargetX, tileTargetY, 5);
		}
	}

	private void PlaceThing_Tiles_PlaceIt_SpinChairs()
	{
		if (inventory[selectedItem].createTile == 15)
		{
			if (direction == 1)
			{
				Tile tile = Main.tile[tileTargetX, tileTargetY];
				tile.frameX += 18;
				tile = Main.tile[tileTargetX, tileTargetY - 1];
				tile.frameX += 18;
			}
			if (Main.netMode == 1)
			{
				NetMessage.SendTileSquare(-1, tileTargetX - 1, tileTargetY - 1, 3);
			}
		}
	}

	private void PlaceThing_Tiles_PlaceIt_SpinTraps()
	{
		if (inventory[selectedItem].createTile == 137)
		{
			if (direction == 1)
			{
				Main.tile[tileTargetX, tileTargetY].frameX += 18;
			}
			if (Main.netMode == 1)
			{
				NetMessage.SendTileSquare(-1, tileTargetX, tileTargetY);
			}
		}
	}

	private void PlaceThing_Tiles_PlaceIt_AdjustPlants()
	{
		if (inventory[selectedItem].createTile != 3)
		{
			return;
		}
		FlowerPacketInfo flowerPacketInfo = ItemID.Sets.flowerPacketInfo[inventory[selectedItem].type];
		if (flowerPacketInfo == null)
		{
			return;
		}
		List<int> stylesOnPurity = flowerPacketInfo.stylesOnPurity;
		if (stylesOnPurity.Count != 0)
		{
			int num = stylesOnPurity[Main.rand.Next(stylesOnPurity.Count)];
			Main.tile[tileTargetX, tileTargetY].frameX = (short)(num * 18);
			if (Main.netMode == 1)
			{
				NetMessage.SendTileSquare(-1, tileTargetX, tileTargetY);
			}
		}
	}

	private bool PlaceThing_Tiles_PlaceIt_StaffOfRegrowthCheck(bool placed)
	{
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0296: Unknown result type (might be due to invalid IL or missing references)
		//IL_029b: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02bd: Unknown result type (might be due to invalid IL or missing references)
		bool flag = inventory[selectedItem].type == 213 || inventory[selectedItem].type == 5295;
		if (flag && !placed && Main.tile[tileTargetX, tileTargetY].type == 1 && Main.tile[tileTargetX, tileTargetY].active())
		{
			int num = 0;
			int num2 = 0;
			Point val = base.Center.ToTileCoordinates();
			Dictionary<ushort, int> dictionary = new Dictionary<ushort, int>();
			WorldUtils.Gen(new Point(val.X - 25, val.Y - 25), new Shapes.Rectangle(50, 50), new Actions.TileScanner(182, 515, 180, 513, 179, 512, 183, 516, 181, 514, 381, 517, 534, 535, 536, 537, 539, 540, 625, 626, 627, 628).Output(dictionary));
			foreach (KeyValuePair<ushort, int> item in dictionary)
			{
				if (item.Value > num2)
				{
					num2 = item.Value;
					num = item.Key;
				}
			}
			switch (num)
			{
			case 515:
				num = 182;
				break;
			case 513:
				num = 180;
				break;
			case 512:
				num = 179;
				break;
			case 516:
				num = 183;
				break;
			case 514:
				num = 181;
				break;
			case 517:
				num = 381;
				break;
			case 535:
				num = 534;
				break;
			case 537:
				num = 536;
				break;
			case 540:
				num = 539;
				break;
			case 626:
				num = 625;
				break;
			case 628:
				num = 627;
				break;
			}
			if (num2 == 0)
			{
				num = Utils.SelectRandom<int>(Main.rand, 182, 180, 179, 183, 181);
			}
			if (num != 0)
			{
				Main.tile[tileTargetX, tileTargetY].type = (ushort)num;
				WorldGen.SquareTileFrame(tileTargetX, tileTargetY);
				NetMessage.SendTileSquare(-1, tileTargetX, tileTargetY);
				placed = true;
			}
		}
		if (flag && !placed && Main.tile[tileTargetX, tileTargetY].type == 38 && Main.tile[tileTargetX, tileTargetY].active())
		{
			int num3 = 0;
			int num4 = 0;
			Point val2 = base.Center.ToTileCoordinates();
			Dictionary<ushort, int> dictionary2 = new Dictionary<ushort, int>();
			WorldUtils.Gen(new Point(val2.X - 25, val2.Y - 25), new Shapes.Rectangle(50, 50), new Actions.TileScanner(182, 515, 180, 513, 179, 512, 183, 516, 181, 514, 381, 517, 534, 535, 536, 537, 539, 540, 625, 626, 627, 628).Output(dictionary2));
			foreach (KeyValuePair<ushort, int> item2 in dictionary2)
			{
				if (item2.Value > num4)
				{
					num4 = item2.Value;
					num3 = item2.Key;
				}
			}
			switch (num3)
			{
			case 182:
				num3 = 515;
				break;
			case 180:
				num3 = 513;
				break;
			case 179:
				num3 = 512;
				break;
			case 183:
				num3 = 516;
				break;
			case 181:
				num3 = 514;
				break;
			case 381:
				num3 = 517;
				break;
			case 534:
				num3 = 535;
				break;
			case 536:
				num3 = 537;
				break;
			case 539:
				num3 = 540;
				break;
			case 625:
				num3 = 626;
				break;
			case 627:
				num3 = 628;
				break;
			}
			if (num4 == 0)
			{
				num3 = Utils.SelectRandom<int>(Main.rand, 515, 513, 512, 516, 514);
			}
			if (num3 != 0)
			{
				Main.tile[tileTargetX, tileTargetY].type = (ushort)num3;
				WorldGen.SquareTileFrame(tileTargetX, tileTargetY);
				NetMessage.SendTileSquare(-1, tileTargetX, tileTargetY);
				placed = true;
			}
		}
		return placed;
	}

	private bool PlaceThing_Tiles_BlockPlacementForAssortedThings(bool canPlace)
	{
		bool flag = inventory[selectedItem].type == 213 || inventory[selectedItem].type == 5295;
		if (flag)
		{
			if (Main.tile[tileTargetX, tileTargetY].type == 0 || Main.tile[tileTargetX, tileTargetY].type == 1 || Main.tile[tileTargetX, tileTargetY].type == 38)
			{
				canPlace = true;
			}
		}
		else if (inventory[selectedItem].createTile == 2 || inventory[selectedItem].createTile == 109)
		{
			if (Main.tile[tileTargetX, tileTargetY].nactive() && Main.tile[tileTargetX, tileTargetY].type == 0)
			{
				canPlace = true;
			}
		}
		else if (inventory[selectedItem].createTile == 23 || inventory[selectedItem].createTile == 199)
		{
			if (Main.tile[tileTargetX, tileTargetY].nactive())
			{
				if (Main.tile[tileTargetX, tileTargetY].type == 0)
				{
					canPlace = true;
				}
				else if (Main.tile[tileTargetX, tileTargetY].type == 59)
				{
					canPlace = true;
				}
			}
		}
		else if (inventory[selectedItem].createTile == 227)
		{
			canPlace = true;
		}
		else if (inventory[selectedItem].createTile >= 373 && inventory[selectedItem].createTile <= 375)
		{
			int x = tileTargetX;
			int y = tileTargetY - 1;
			if (Main.tile[x, y].nactive() && Main.tileSolid[Main.tile[x, y].type] && !Main.tileSolidTop[Main.tile[x, y].type])
			{
				canPlace = true;
			}
		}
		else if (inventory[selectedItem].createTile == 461)
		{
			int x2 = tileTargetX;
			int y2 = tileTargetY - 1;
			if (Main.tile[x2, y2].nactive() && Main.tileSolid[Main.tile[x2, y2].type] && !Main.tileSolidTop[Main.tile[x2, y2].type])
			{
				canPlace = true;
			}
		}
		else if (inventory[selectedItem].createTile == 60 || inventory[selectedItem].createTile == 70 || inventory[selectedItem].createTile == 661 || inventory[selectedItem].createTile == 662)
		{
			if (Main.tile[tileTargetX, tileTargetY].nactive() && Main.tile[tileTargetX, tileTargetY].type == 59)
			{
				canPlace = true;
			}
		}
		else if (TileID.Sets.Torch[inventory[selectedItem].createTile] || inventory[selectedItem].createTile == 136)
		{
			if (Main.tile[tileTargetX, tileTargetY].wall > 0)
			{
				canPlace = true;
			}
			else
			{
				if (!WorldGen.SolidTileNoAttach(tileTargetX, tileTargetY + 1) && !WorldGen.SolidTileNoAttach(tileTargetX - 1, tileTargetY) && !WorldGen.SolidTileNoAttach(tileTargetX + 1, tileTargetY))
				{
					if (!WorldGen.SolidTileNoAttach(tileTargetX, tileTargetY + 1) && (Main.tile[tileTargetX, tileTargetY + 1].halfBrick() || Main.tile[tileTargetX, tileTargetY + 1].slope() != 0))
					{
						if (!TileID.Sets.Platforms[Main.tile[tileTargetX, tileTargetY + 1].type])
						{
							WorldGen.SlopeTile(tileTargetX, tileTargetY + 1);
							if (Main.netMode == 1)
							{
								NetMessage.SendData(17, -1, -1, null, 14, tileTargetX, tileTargetY + 1);
							}
						}
					}
					else if (!WorldGen.SolidTileNoAttach(tileTargetX, tileTargetY + 1) && !WorldGen.SolidTileNoAttach(tileTargetX - 1, tileTargetY) && (Main.tile[tileTargetX - 1, tileTargetY].halfBrick() || Main.tile[tileTargetX - 1, tileTargetY].slope() != 0))
					{
						if (!TileID.Sets.Platforms[Main.tile[tileTargetX - 1, tileTargetY].type])
						{
							WorldGen.SlopeTile(tileTargetX - 1, tileTargetY);
							if (Main.netMode == 1)
							{
								NetMessage.SendData(17, -1, -1, null, 14, tileTargetX - 1, tileTargetY);
							}
						}
					}
					else if (!WorldGen.SolidTileNoAttach(tileTargetX, tileTargetY + 1) && !WorldGen.SolidTileNoAttach(tileTargetX + 1, tileTargetY) && (Main.tile[tileTargetX + 1, tileTargetY].halfBrick() || Main.tile[tileTargetX + 1, tileTargetY].slope() != 0) && !TileID.Sets.Platforms[Main.tile[tileTargetX + 1, tileTargetY].type])
					{
						WorldGen.SlopeTile(tileTargetX + 1, tileTargetY);
						if (Main.netMode == 1)
						{
							NetMessage.SendData(17, -1, -1, null, 14, tileTargetX + 1, tileTargetY);
						}
					}
				}
				int num = Main.tile[tileTargetX, tileTargetY + 1].type;
				if (Main.tile[tileTargetX, tileTargetY].halfBrick())
				{
					num = -1;
				}
				int num2 = Main.tile[tileTargetX - 1, tileTargetY].type;
				int num3 = Main.tile[tileTargetX + 1, tileTargetY].type;
				int tree = Main.tile[tileTargetX - 1, tileTargetY - 1].type;
				int tree2 = Main.tile[tileTargetX + 1, tileTargetY - 1].type;
				int tree3 = Main.tile[tileTargetX - 1, tileTargetY - 1].type;
				int tree4 = Main.tile[tileTargetX + 1, tileTargetY + 1].type;
				if (!Main.tile[tileTargetX, tileTargetY + 1].nactive())
				{
					num = -1;
				}
				if (!Main.tile[tileTargetX - 1, tileTargetY].nactive())
				{
					num2 = -1;
				}
				if (!Main.tile[tileTargetX + 1, tileTargetY].nactive())
				{
					num3 = -1;
				}
				if (!Main.tile[tileTargetX - 1, tileTargetY - 1].nactive())
				{
					tree = -1;
				}
				if (!Main.tile[tileTargetX + 1, tileTargetY - 1].nactive())
				{
					tree2 = -1;
				}
				if (!Main.tile[tileTargetX - 1, tileTargetY + 1].nactive())
				{
					tree3 = -1;
				}
				if (!Main.tile[tileTargetX + 1, tileTargetY + 1].nactive())
				{
					tree4 = -1;
				}
				if (num >= 0 && Main.tileSolid[num] && (!Main.tileNoAttach[num] || (num >= 0 && TileID.Sets.Platforms[num])))
				{
					canPlace = true;
				}
				else if ((num2 >= 0 && Main.tileSolid[num2] && !Main.tileNoAttach[num2]) || (WorldGen.IsTreeType(num2) && WorldGen.IsTreeType(tree) && WorldGen.IsTreeType(tree3)) || (num2 >= 0 && TileID.Sets.IsBeam[num2]))
				{
					canPlace = true;
				}
				else if ((num3 >= 0 && Main.tileSolid[num3] && !Main.tileNoAttach[num3]) || (WorldGen.IsTreeType(num3) && WorldGen.IsTreeType(tree2) && WorldGen.IsTreeType(tree4)) || (num3 >= 0 && TileID.Sets.IsBeam[num3]))
				{
					canPlace = true;
				}
			}
		}
		else if (inventory[selectedItem].createTile == 78 || inventory[selectedItem].createTile == 98 || inventory[selectedItem].createTile == 100 || inventory[selectedItem].createTile == 173 || inventory[selectedItem].createTile == 174 || inventory[selectedItem].createTile == 324)
		{
			if (Main.tile[tileTargetX, tileTargetY + 1].nactive() && (Main.tileSolid[Main.tile[tileTargetX, tileTargetY + 1].type] || Main.tileTable[Main.tile[tileTargetX, tileTargetY + 1].type]))
			{
				canPlace = true;
			}
		}
		else if (inventory[selectedItem].createTile == 419)
		{
			if (Main.tile[tileTargetX, tileTargetY + 1].active() && (Main.tile[tileTargetX, tileTargetY + 1].type == 419 || (inventory[selectedItem].placeStyle != 2 && Main.tile[tileTargetX, tileTargetY + 1].type == 420)))
			{
				canPlace = true;
			}
		}
		else if (inventory[selectedItem].createTile == 13 || inventory[selectedItem].createTile == 29 || inventory[selectedItem].createTile == 33 || inventory[selectedItem].createTile == 49 || inventory[selectedItem].createTile == 50 || inventory[selectedItem].createTile == 103)
		{
			if (Main.tile[tileTargetX, tileTargetY + 1].nactive() && Main.tileTable[Main.tile[tileTargetX, tileTargetY + 1].type])
			{
				canPlace = true;
			}
		}
		else if (inventory[selectedItem].createTile == 275 || inventory[selectedItem].createTile == 276 || inventory[selectedItem].createTile == 277)
		{
			canPlace = true;
		}
		else if (TileID.Sets.CanPlaceNextToNonSolidTile[inventory[selectedItem].createTile])
		{
			if (Main.tile[tileTargetX + 1, tileTargetY].active() || Main.tile[tileTargetX + 1, tileTargetY].wall > 0 || Main.tile[tileTargetX - 1, tileTargetY].active() || Main.tile[tileTargetX - 1, tileTargetY].wall > 0 || Main.tile[tileTargetX, tileTargetY + 1].active() || Main.tile[tileTargetX, tileTargetY + 1].wall > 0 || Main.tile[tileTargetX, tileTargetY - 1].active() || Main.tile[tileTargetX, tileTargetY - 1].wall > 0)
			{
				canPlace = true;
			}
		}
		else if (inventory[selectedItem].createTile == 314)
		{
			for (int i = tileTargetX - 1; i <= tileTargetX + 1; i++)
			{
				for (int j = tileTargetY - 1; j <= tileTargetY + 1; j++)
				{
					Tile tile = Main.tile[i, j];
					if (tile.active() || tile.wall > 0)
					{
						canPlace = true;
						break;
					}
				}
			}
		}
		else
		{
			Tile tile2 = Main.tile[tileTargetX - 1, tileTargetY];
			Tile tile3 = Main.tile[tileTargetX + 1, tileTargetY];
			Tile tile4 = Main.tile[tileTargetX, tileTargetY - 1];
			Tile tile5 = Main.tile[tileTargetX, tileTargetY + 1];
			if ((tile3.active() && (Main.tileSolid[tile3.type] || TileID.Sets.IsBeam[tile3.type] || Main.tileRope[tile3.type] || tile3.type == 314)) || tile3.wall > 0 || (tile2.active() && (Main.tileSolid[tile2.type] || TileID.Sets.IsBeam[tile2.type] || Main.tileRope[tile2.type] || tile2.type == 314)) || tile2.wall > 0 || (tile5.active() && (Main.tileSolid[tile5.type] || TileID.Sets.IsBeam[tile5.type] || Main.tileRope[tile5.type] || tile5.type == 314)) || tile5.wall > 0 || (tile4.active() && (Main.tileSolid[tile4.type] || TileID.Sets.IsBeam[tile4.type] || Main.tileRope[tile4.type] || tile4.type == 314)) || tile4.wall > 0)
			{
				canPlace = true;
			}
			else if (Main.tile[tileTargetX, tileTargetY].wall > 0)
			{
				canPlace = true;
			}
		}
		if (flag && Main.tile[tileTargetX, tileTargetY].active())
		{
			int x3 = tileTargetX;
			int y3 = tileTargetY;
			if (Main.tile[x3, y3].type == 3 || Main.tile[x3, y3].type == 73 || Main.tile[x3, y3].type == 84)
			{
				WorldGen.KillTile(tileTargetX, tileTargetY);
				if (!Main.tile[tileTargetX, tileTargetY].active() && Main.netMode == 1)
				{
					NetMessage.SendData(17, -1, -1, null, 0, tileTargetX, tileTargetY);
				}
			}
			else if (Main.tile[x3, y3].type == 83)
			{
				bool flag2 = false;
				int num4 = Main.tile[x3, y3].frameX / 18;
				if (num4 == 0 && Main.dayTime)
				{
					flag2 = true;
				}
				if (num4 == 1 && !Main.dayTime)
				{
					flag2 = true;
				}
				if (num4 == 3 && !Main.dayTime && (Main.bloodMoon || Main.moonPhase == 0))
				{
					flag2 = true;
				}
				if (num4 == 4 && (Main.raining || Main.cloudAlpha > 0f))
				{
					flag2 = true;
				}
				if (num4 == 5 && !Main.raining && Main.dayTime && Main.time > 40500.0)
				{
					flag2 = true;
				}
				if (flag2)
				{
					WorldGen.KillTile(tileTargetX, tileTargetY);
					NetMessage.SendData(17, -1, -1, null, 0, tileTargetX, tileTargetY);
				}
			}
		}
		if (Main.tileAlch[inventory[selectedItem].createTile])
		{
			canPlace = true;
		}
		if (Main.tile[tileTargetX, tileTargetY].active() && (Main.tileCut[Main.tile[tileTargetX, tileTargetY].type] || TileID.Sets.BreakableWhenPlacing[Main.tile[tileTargetX, tileTargetY].type] || (Main.tile[tileTargetX, tileTargetY].type >= 373 && Main.tile[tileTargetX, tileTargetY].type <= 375) || Main.tile[tileTargetX, tileTargetY].type == 461))
		{
			if (Main.tile[tileTargetX, tileTargetY].type != inventory[selectedItem].createTile)
			{
				bool num5 = Main.tile[tileTargetX, tileTargetY + 1].type != 78 && Main.tile[tileTargetX, tileTargetY + 1].type != 380 && Main.tile[tileTargetX, tileTargetY + 1].type != 579;
				bool flag3 = Main.tile[tileTargetX, tileTargetY].type == 3 || Main.tile[tileTargetX, tileTargetY].type == 73;
				bool flag4 = Main.tileAlch[Main.tile[tileTargetX, tileTargetY].type] && WorldGen.IsHarvestableHerbWithSeed(Main.tile[tileTargetX, tileTargetY].type, Main.tile[tileTargetX, tileTargetY].frameX / 18);
				bool flag5 = Main.tileAlch[inventory[selectedItem].createTile];
				if (num5 || ((flag3 || flag4) && flag5))
				{
					WorldGen.KillTile(tileTargetX, tileTargetY);
					if (!Main.tile[tileTargetX, tileTargetY].active() && Main.netMode == 1)
					{
						NetMessage.SendData(17, -1, -1, null, 0, tileTargetX, tileTargetY);
					}
				}
				else
				{
					canPlace = false;
				}
			}
			else
			{
				canPlace = false;
			}
		}
		if (!canPlace && inventory[selectedItem].createTile >= 0 && TileID.Sets.Platforms[inventory[selectedItem].createTile])
		{
			for (int k = tileTargetX - 1; k <= tileTargetX + 1; k++)
			{
				for (int l = tileTargetY - 1; l <= tileTargetY + 1; l++)
				{
					if (Main.tile[k, l].active())
					{
						canPlace = true;
						break;
					}
				}
			}
		}
		if (inventory[selectedItem].createTile == 3)
		{
			canPlace = WorldGen.IsFitToPlaceFlowerIn(tileTargetX, tileTargetY, 3);
			if (canPlace)
			{
				WorldGen.KillTile(tileTargetX, tileTargetY);
				if (Main.netMode == 1 && !Main.tile[tileTargetX, tileTargetY].active())
				{
					NetMessage.SendData(17, -1, -1, null, 0, tileTargetX, tileTargetY);
				}
			}
		}
		return canPlace;
	}

	private static void PlaceThing_Tiles_BlockPlacementForRepeatedPumpkins(ref bool canPlace, ref TileObject data)
	{
		if (data.type != 254)
		{
			return;
		}
		for (int i = -1; i < 1; i++)
		{
			for (int j = 0; j < 2; j++)
			{
				if (!WorldGen.CanCutTile(tileTargetX + j, tileTargetY + i, TileCuttingContext.TilePlacement))
				{
					canPlace = false;
				}
			}
		}
	}

	private static void PlaceThing_Tiles_BlockPlacementForRepeatedCoralAndBeachPiles(ref bool canPlace, ref TileObject data)
	{
		if (data.type == 81 || data.type == 324)
		{
			Tile tile = Main.tile[tileTargetX, tileTargetY];
			if (tile.active() && (Main.tileCut[tile.type] || TileID.Sets.BreakableWhenPlacing[tile.type] || (tile.type >= 373 && tile.type <= 375) || tile.type == 461))
			{
				canPlace = false;
			}
		}
	}

	private static void PlaceThing_Tiles_BlockPlacementForRepeatedPigronatas(ref bool canPlace, ref TileObject data)
	{
		if (data.type != 454)
		{
			return;
		}
		for (int i = -2; i < 2; i++)
		{
			Tile tile = Main.tile[tileTargetX + i, tileTargetY];
			if (tile.active() && tile.type == 454)
			{
				canPlace = false;
			}
		}
	}

	private static void PlaceThing_Tiles_BlockPlacementIfOverPlayers(ref bool canPlace, ref TileObject data)
	{
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		int num = 0;
		int num2 = 0;
		int num3 = 0;
		int num4 = 0;
		switch (data.type)
		{
		case 138:
		case 664:
			num = 32;
			num2 = 32;
			num3 = data.xCoord * 16;
			num4 = data.yCoord * 16;
			break;
		case 484:
			num = 32;
			num2 = 32;
			num3 = data.xCoord * 16;
			num4 = data.yCoord * 16;
			break;
		case 235:
			num = 48;
			num2 = 16;
			num3 = data.xCoord * 16;
			num4 = data.yCoord * 16;
			break;
		case 476:
			num = 16;
			num2 = 16;
			num3 = data.xCoord * 16;
			num4 = data.yCoord * 16;
			break;
		case 387:
			num = 32;
			num2 = 16;
			num3 = data.xCoord * 16;
			num4 = data.yCoord * 16;
			break;
		}
		if (num == 0 || num2 == 0)
		{
			return;
		}
		Rectangle val = default(Rectangle);
		((Rectangle)(ref val))..ctor(num3, num4, num, num2);
		for (int i = 0; i < 255; i++)
		{
			Player player = Main.player[i];
			if (player.active && !player.dead && !player.ghost)
			{
				Rectangle hitbox = player.Hitbox;
				if (((Rectangle)(ref hitbox)).Intersects(val))
				{
					canPlace = false;
					break;
				}
			}
		}
	}

	private bool PlaceThing_Tiles_CheckLavaBlocking()
	{
		bool result = false;
		if (Main.tile[tileTargetX, tileTargetY].liquid > 0 && Main.tile[tileTargetX, tileTargetY].lava())
		{
			if (Main.tileSolid[inventory[selectedItem].createTile])
			{
				result = true;
			}
			else if (!TileObjectData.CheckLiquidPlacement(inventory[selectedItem].createTile, inventory[selectedItem].placeStyle, Main.tile[tileTargetX, tileTargetY]))
			{
				result = true;
			}
		}
		return result;
	}

	private bool PlaceThing_Tiles_CheckRopeUsability(bool canUse)
	{
		if (Main.tileRope[inventory[selectedItem].createTile] && canUse && Main.tile[tileTargetX, tileTargetY].active() && Main.tileRope[Main.tile[tileTargetX, tileTargetY].type])
		{
			int num = tileTargetY;
			int x = tileTargetX;
			bool flag = inventory[selectedItem].createTile == 214;
			while (Main.tile[x, num].active() && (Main.tileRope[Main.tile[x, num].type] || Main.tile[x, num].type == 314 || TileID.Sets.Platforms[Main.tile[x, num].type]) && num < Main.maxTilesY - 5 && Main.tile[x, num + 2] != null && (flag || !Main.tile[x, num + 1].lava()))
			{
				num++;
				if (Main.tile[x, num] == null)
				{
					canUse = false;
					num = tileTargetY;
					break;
				}
			}
			if (!Main.tile[x, num].active())
			{
				tileTargetY = num;
			}
		}
		return canUse;
	}

	private bool PlaceThing_Tiles_CheckFlexibleWand(bool canUse)
	{
		FlexibleTileWand.PlacementOption option;
		Item itemToConsume;
		return inventory[selectedItem].GetFlexibleTileWand()?.TryGetPlacementOption(this, FlexibleWandRandomSeed, FlexibleWandCycleOffset, out option, out itemToConsume) ?? canUse;
	}

	private bool PlaceThing_Tiles_CheckWandUsability(bool canUse)
	{
		if (inventory[selectedItem].tileWand > 0)
		{
			int tileWand = inventory[selectedItem].tileWand;
			canUse = false;
			for (int i = 0; i < 58; i++)
			{
				if (tileWand == inventory[i].type && inventory[i].stack > 0)
				{
					canUse = true;
					break;
				}
			}
		}
		return canUse;
	}

	private bool PlaceThing_Tiles_CheckGamepadTorchUsability(bool canUse)
	{
		if (PlayerInput.UsingGamepad && inventory[selectedItem].createTile == 4 && Main.SmartCursorIsUsed && !Main.SmartCursorShowing)
		{
			canUse = false;
		}
		return canUse;
	}

	private void PlaceThing_LockChest()
	{
		Tile tile = Main.tile[tileTargetX, tileTargetY];
		Item item = inventory[selectedItem];
		if (!tile.active() || item.type != 5328 || !TileID.Sets.IsAContainer[tile.type] || !(position.X / 16f - (float)tileRangeX - (float)item.tileBoost - (float)blockRange <= (float)tileTargetX) || !((position.X + (float)width) / 16f + (float)tileRangeX + (float)item.tileBoost - 1f + (float)blockRange >= (float)tileTargetX) || !(position.Y / 16f - (float)tileRangeY - (float)item.tileBoost - (float)blockRange <= (float)tileTargetY) || !((position.Y + (float)height) / 16f + (float)tileRangeY + (float)item.tileBoost - 2f + (float)blockRange >= (float)tileTargetY) || !ItemTimeIsZero || itemAnimation <= 0 || !controlUseItem)
		{
			return;
		}
		Tile tileSafely = Framing.GetTileSafely(tileTargetX, tileTargetY);
		int type = tileSafely.type;
		int num = tileSafely.frameX / 36;
		switch (type)
		{
		case 21:
			switch (num)
			{
			default:
				return;
			case 1:
			case 3:
			case 18:
			case 19:
			case 20:
			case 21:
			case 22:
			case 35:
			case 37:
			case 39:
				break;
			}
			break;
		case 467:
			if (num != 12)
			{
				return;
			}
			break;
		}
		if (inventory[selectedItem].stack <= 0)
		{
			return;
		}
		int num2;
		for (num2 = Main.tile[tileTargetX, tileTargetY].frameX / 18; num2 > 1; num2 -= 2)
		{
		}
		num2 = tileTargetX - num2;
		int num3 = tileTargetY - Main.tile[tileTargetX, tileTargetY].frameY / 18;
		if (Chest.Lock(num2, num3))
		{
			inventory[selectedItem].stack--;
			if (inventory[selectedItem].stack <= 0)
			{
				inventory[selectedItem] = new Item();
			}
			if (Main.netMode == 1)
			{
				NetMessage.SendData(52, -1, -1, null, whoAmI, 3f, num2, num3);
			}
		}
	}

	private void PlaceThing_ItemInExtractinator(ref ItemCheckContext context)
	{
		Tile targetBlock = Main.tile[tileTargetX, tileTargetY];
		Item item = inventory[selectedItem];
		if (!targetBlock.active() || !(position.X / 16f - (float)tileRangeX - (float)item.tileBoost - (float)blockRange <= (float)tileTargetX) || !((position.X + (float)width) / 16f + (float)tileRangeX + (float)item.tileBoost - 1f + (float)blockRange >= (float)tileTargetX) || !(position.Y / 16f - (float)tileRangeY - (float)item.tileBoost - (float)blockRange <= (float)tileTargetY) || !((position.Y + (float)height) / 16f + (float)tileRangeY + (float)item.tileBoost - 2f + (float)blockRange >= (float)tileTargetY) || !ItemTimeIsZero || itemAnimation <= 0 || !controlUseItem)
		{
			return;
		}
		float num = 1f;
		if (targetBlock.type == 642)
		{
			num *= 0.33f;
		}
		ItemTrader itemTrader = TryGettingItemTraderFromBlock(targetBlock);
		if (itemTrader != null && itemTrader.TryGetTradeOption(item, out var option))
		{
			SoundEngine.PlaySound(7);
			ApplyItemTime(item, num);
			context.SkipItemConsumption = true;
			item.stack -= option.TakingItemStack;
			if (item.stack <= 0)
			{
				item.TurnToAir();
			}
			DropItemFromExtractinator(option.GivingITemType, option.GivingItemStack);
		}
		else if (ItemID.Sets.ExtractinatorMode[item.type] >= 0 && (targetBlock.type == 219 || targetBlock.type == 642))
		{
			ApplyItemTime(item, num);
			SoundEngine.PlaySound(7);
			int extractType = ItemID.Sets.ExtractinatorMode[item.type];
			ExtractinatorUse(extractType, targetBlock.type);
		}
	}

	private static ItemTrader TryGettingItemTraderFromBlock(Tile targetBlock)
	{
		ItemTrader result = null;
		if (targetBlock.type == 642)
		{
			result = ItemTrader.ChlorophyteExtractinator;
		}
		return result;
	}

	private void PlaceThing_XMasTreeTops()
	{
		if (inventory[selectedItem].type < 1874 || inventory[selectedItem].type > 1905 || !Main.tile[tileTargetX, tileTargetY].active() || Main.tile[tileTargetX, tileTargetY].type != 171 || !(position.X / 16f - (float)tileRangeX - (float)inventory[selectedItem].tileBoost - (float)blockRange <= (float)tileTargetX) || !((position.X + (float)width) / 16f + (float)tileRangeX + (float)inventory[selectedItem].tileBoost - 1f + (float)blockRange >= (float)tileTargetX) || !(position.Y / 16f - (float)tileRangeY - (float)inventory[selectedItem].tileBoost - (float)blockRange <= (float)tileTargetY) || !((position.Y + (float)height) / 16f + (float)tileRangeY + (float)inventory[selectedItem].tileBoost - 2f + (float)blockRange >= (float)tileTargetY) || !ItemTimeIsZero || itemAnimation <= 0 || !controlUseItem)
		{
			return;
		}
		int type = inventory[selectedItem].type;
		if (type >= 1874 && type <= 1877)
		{
			type -= 1873;
			if (WorldGen.checkXmasTreeDrop(tileTargetX, tileTargetY, 0) != type)
			{
				ApplyItemTime(inventory[selectedItem]);
				WorldGen.dropXmasTree(tileTargetX, tileTargetY, 0);
				WorldGen.setXmasTree(tileTargetX, tileTargetY, 0, type);
				int num = tileTargetX;
				int num2 = tileTargetY;
				if (Main.tile[tileTargetX, tileTargetY].frameX < 10)
				{
					num -= Main.tile[tileTargetX, tileTargetY].frameX;
					num2 -= Main.tile[tileTargetX, tileTargetY].frameY;
				}
				NetMessage.SendTileSquare(-1, num, num2);
			}
		}
		else if (type >= 1878 && type <= 1883)
		{
			type -= 1877;
			if (WorldGen.checkXmasTreeDrop(tileTargetX, tileTargetY, 1) != type)
			{
				ApplyItemTime(inventory[selectedItem]);
				WorldGen.dropXmasTree(tileTargetX, tileTargetY, 1);
				WorldGen.setXmasTree(tileTargetX, tileTargetY, 1, type);
				int num3 = tileTargetX;
				int num4 = tileTargetY;
				if (Main.tile[tileTargetX, tileTargetY].frameX < 10)
				{
					num3 -= Main.tile[tileTargetX, tileTargetY].frameX;
					num4 -= Main.tile[tileTargetX, tileTargetY].frameY;
				}
				NetMessage.SendTileSquare(-1, num3, num4);
			}
		}
		else if (type >= 1884 && type <= 1894)
		{
			type -= 1883;
			if (WorldGen.checkXmasTreeDrop(tileTargetX, tileTargetY, 2) != type)
			{
				ApplyItemTime(inventory[selectedItem]);
				WorldGen.dropXmasTree(tileTargetX, tileTargetY, 2);
				WorldGen.setXmasTree(tileTargetX, tileTargetY, 2, type);
				int num5 = tileTargetX;
				int num6 = tileTargetY;
				if (Main.tile[tileTargetX, tileTargetY].frameX < 10)
				{
					num5 -= Main.tile[tileTargetX, tileTargetY].frameX;
					num6 -= Main.tile[tileTargetX, tileTargetY].frameY;
				}
				NetMessage.SendTileSquare(-1, num5, num6);
			}
		}
		else
		{
			if (type < 1895 || type > 1905)
			{
				return;
			}
			type -= 1894;
			if (WorldGen.checkXmasTreeDrop(tileTargetX, tileTargetY, 3) != type)
			{
				ApplyItemTime(inventory[selectedItem]);
				WorldGen.dropXmasTree(tileTargetX, tileTargetY, 3);
				WorldGen.setXmasTree(tileTargetX, tileTargetY, 3, type);
				int num7 = tileTargetX;
				int num8 = tileTargetY;
				if (Main.tile[tileTargetX, tileTargetY].frameX < 10)
				{
					num7 -= Main.tile[tileTargetX, tileTargetY].frameX;
					num8 -= Main.tile[tileTargetX, tileTargetY].frameY;
				}
				NetMessage.SendTileSquare(-1, num7, num8);
			}
		}
	}

	private void PlaceThing_CannonBall()
	{
		if ((inventory[selectedItem].type == 929 || inventory[selectedItem].type == 1338 || inventory[selectedItem].type == 1345) && position.X / 16f - (float)tileRangeX - (float)inventory[selectedItem].tileBoost - (float)blockRange <= (float)tileTargetX && (position.X + (float)width) / 16f + (float)tileRangeX + (float)inventory[selectedItem].tileBoost - 1f + (float)blockRange >= (float)tileTargetX && position.Y / 16f - (float)tileRangeY - (float)inventory[selectedItem].tileBoost - (float)blockRange <= (float)tileTargetY && (position.Y + (float)height) / 16f + (float)tileRangeY + (float)inventory[selectedItem].tileBoost - 2f + (float)blockRange >= (float)tileTargetY)
		{
			int x = tileTargetX;
			int y = tileTargetY;
			if (Main.tile[x, y].active() && Main.tile[x, y].type == 209)
			{
				ShootFromCannon(x, y);
			}
		}
	}

	private void PlaceThing_PaintScrapper()
	{
		if (ItemID.Sets.IsPaintScraper[inventory[selectedItem].type] && position.X / 16f - (float)tileRangeX - (float)inventory[selectedItem].tileBoost - (float)blockRange <= (float)tileTargetX && (position.X + (float)width) / 16f + (float)tileRangeX + (float)inventory[selectedItem].tileBoost - 1f + (float)blockRange >= (float)tileTargetX && position.Y / 16f - (float)tileRangeY - (float)inventory[selectedItem].tileBoost - (float)blockRange <= (float)tileTargetY && (position.Y + (float)height) / 16f + (float)tileRangeY + (float)inventory[selectedItem].tileBoost - 2f + (float)blockRange >= (float)tileTargetY)
		{
			int x = tileTargetX;
			int y = tileTargetY;
			if (Main.tile[x, y] != null)
			{
				PlaceThing_PaintScrapper_TryScrapping(x, y);
				PlaceThing_PaintScrapper_LongMoss(x, y);
			}
		}
	}

	private void PlaceThing_PaintScrapper_LongMoss(int x, int y)
	{
		Tile tile = Main.tile[x, y];
		if (tile.type != 184)
		{
			return;
		}
		cursorItemIconEnabled = true;
		if (!ItemTimeIsZero || itemAnimation <= 0 || !controlUseItem)
		{
			return;
		}
		tile = Main.tile[x, y];
		_ = ref tile.type;
		tile = Main.tile[x, y];
		int frameX = tile.frameX;
		WorldGen.KillTile(x, y);
		tile = Main.tile[x, y];
		if (tile.active())
		{
			return;
		}
		ApplyItemTime(inventory[selectedItem]);
		if (Main.netMode == 1)
		{
			NetMessage.SendData(17, -1, -1, null, 0, x, y);
		}
		if (Main.rand.Next(9) == 0)
		{
			int type = 4349 + frameX / 22;
			switch (frameX / 22)
			{
			case 6:
				type = 4377;
				break;
			case 7:
				type = 4378;
				break;
			case 8:
				type = 4389;
				break;
			case 9:
				type = 5127;
				break;
			case 10:
				type = 5128;
				break;
			}
			int number = Item.NewItem(new EntitySource_ItemUse(this, HeldItem), x * 16, y * 16, 16, 16, type);
			NetMessage.SendData(21, -1, -1, null, number, 1f);
		}
	}

	private void PlaceThing_PaintScrapper_TryScrapping(int x, int y)
	{
		Tile tile = Main.tile[x, y];
		if ((0 | ((tile.wall > 0 && (tile.wallColor() > 0 || tile.invisibleWall() || tile.fullbrightWall())) ? 1 : 0) | ((tile.active() && (tile.color() > 0 || tile.invisibleBlock() || tile.fullbrightBlock())) ? 1 : 0)) == 0)
		{
			return;
		}
		cursorItemIconEnabled = true;
		if (ItemTimeIsZero && itemAnimation > 0 && controlUseItem)
		{
			if (WorldGen.paintTile(x, y, 0, broadCast: true) || WorldGen.paintCoatTile(x, y, 0, broadcast: true))
			{
				ApplyItemTime(inventory[selectedItem], tileSpeed);
			}
			else if (WorldGen.paintWall(x, y, 0, broadCast: true) || WorldGen.paintCoatWall(x, y, 0, broadcast: true))
			{
				ApplyItemTime(inventory[selectedItem], wallSpeed);
			}
		}
	}

	private void PlaceThing_PaintRoller()
	{
		if ((inventory[selectedItem].type != 1072 && inventory[selectedItem].type != 1544) || !(position.X / 16f - (float)tileRangeX - (float)inventory[selectedItem].tileBoost - (float)blockRange <= (float)tileTargetX) || !((position.X + (float)width) / 16f + (float)tileRangeX + (float)inventory[selectedItem].tileBoost - 1f + (float)blockRange >= (float)tileTargetX) || !(position.Y / 16f - (float)tileRangeY - (float)inventory[selectedItem].tileBoost - (float)blockRange <= (float)tileTargetY) || !((position.Y + (float)height) / 16f + (float)tileRangeY + (float)inventory[selectedItem].tileBoost - 2f + (float)blockRange >= (float)tileTargetY))
		{
			return;
		}
		int x = tileTargetX;
		int y = tileTargetY;
		if (Main.tile[x, y] != null && Main.tile[x, y].wall > 0)
		{
			cursorItemIconEnabled = true;
			if (ItemTimeIsZero && itemAnimation > 0 && controlUseItem)
			{
				TryPainting(x, y, paintingAWall: true);
			}
		}
	}

	private void PlaceThing_Paintbrush()
	{
		if ((inventory[selectedItem].type != 1071 && inventory[selectedItem].type != 1543) || !(position.X / 16f - (float)tileRangeX - (float)inventory[selectedItem].tileBoost - (float)blockRange <= (float)tileTargetX) || !((position.X + (float)width) / 16f + (float)tileRangeX + (float)inventory[selectedItem].tileBoost - 1f + (float)blockRange >= (float)tileTargetX) || !(position.Y / 16f - (float)tileRangeY - (float)inventory[selectedItem].tileBoost - (float)blockRange <= (float)tileTargetY) || !((position.Y + (float)height) / 16f + (float)tileRangeY + (float)inventory[selectedItem].tileBoost - 2f + (float)blockRange >= (float)tileTargetY))
		{
			return;
		}
		int x = tileTargetX;
		int y = tileTargetY;
		if (Main.tile[x, y] != null && Main.tile[x, y].active())
		{
			cursorItemIconEnabled = true;
			if (ItemTimeIsZero && itemAnimation > 0 && controlUseItem)
			{
				TryPainting(x, y);
			}
		}
	}

	public Item FindPaintOrCoating()
	{
		for (int i = 54; i < 58; i++)
		{
			if (inventory[i].stack > 0 && inventory[i].PaintOrCoating)
			{
				return inventory[i];
			}
		}
		for (int j = 0; j < 58; j++)
		{
			if (inventory[j].stack > 0 && inventory[j].PaintOrCoating)
			{
				return inventory[j];
			}
		}
		return null;
	}

	private void TryPainting(int x, int y, bool paintingAWall = false, bool applyItemAnimation = true)
	{
		Item item = FindPaintOrCoating();
		if (item != null)
		{
			if (item.paintCoating != 0)
			{
				ApplyCoating(x, y, paintingAWall, applyItemAnimation, item);
			}
			if (item.paint != 0)
			{
				ApplyPaint(x, y, paintingAWall, applyItemAnimation, item);
			}
		}
	}

	private void ApplyCoating(int x, int y, bool paintingAWall, bool applyItemAnimation, Item targetItem)
	{
		byte paintCoating = targetItem.paintCoating;
		if (paintingAWall)
		{
			if (WorldGen.paintCoatWall(x, y, paintCoating, broadcast: true))
			{
				targetItem.stack--;
				if (targetItem.stack <= 0)
				{
					targetItem.SetDefaults();
				}
				if (applyItemAnimation)
				{
					ApplyItemTime(inventory[selectedItem], wallSpeed);
				}
			}
		}
		else if (WorldGen.paintCoatTile(x, y, paintCoating, broadcast: true))
		{
			targetItem.stack--;
			if (targetItem.stack <= 0)
			{
				targetItem.SetDefaults();
			}
			if (applyItemAnimation)
			{
				ApplyItemTime(inventory[selectedItem], tileSpeed);
			}
		}
	}

	private void ApplyPaint(int x, int y, bool paintingAWall, bool applyItemAnimation, Item targetItem)
	{
		byte paint = targetItem.paint;
		if (paintingAWall)
		{
			if (Main.tile[x, y].wallColor() != paint && WorldGen.paintWall(x, y, paint, broadCast: true))
			{
				if (ItemLoader.ConsumeItem(targetItem, this))
				{
					targetItem.stack--;
				}
				if (targetItem.stack <= 0)
				{
					targetItem.SetDefaults();
				}
				if (applyItemAnimation)
				{
					ApplyItemTime(inventory[selectedItem], wallSpeed);
				}
			}
		}
		else if (Main.tile[x, y].color() != paint && WorldGen.paintTile(x, y, paint, broadCast: true))
		{
			if (ItemLoader.ConsumeItem(targetItem, this))
			{
				targetItem.stack--;
			}
			if (targetItem.stack <= 0)
			{
				targetItem.SetDefaults();
			}
			if (applyItemAnimation)
			{
				ApplyItemTime(inventory[selectedItem], tileSpeed);
			}
		}
	}

	private void ShootFromCannon(int x, int y)
	{
		int num = 0;
		int num2 = Main.tile[x, y].frameX / 72;
		int type = inventory[selectedItem].type;
		if (num2 == 0 && type == 929)
		{
			num = 1;
		}
		else if (num2 == 1 && type == 1338)
		{
			num = 2;
		}
		else if (num2 == 2 && type == 1345)
		{
			num = 3;
		}
		if (num <= 0 || (num == 2 && !WorldGen.BunnyCannonCanFire()))
		{
			return;
		}
		cursorItemIconEnabled = true;
		if (ItemTimeIsZero && itemAnimation > 0 && controlUseItem)
		{
			int num3 = Main.tile[x, y].frameX / 18;
			int num4 = 0;
			int num5 = 0;
			while (num3 >= 4)
			{
				num4++;
				num3 -= 4;
			}
			num3 = x - num3;
			int num6;
			for (num6 = Main.tile[x, y].frameY / 18; num6 >= 3; num6 -= 3)
			{
				num5++;
			}
			num6 = y - num6;
			ApplyItemTime(inventory[selectedItem]);
			WorldGen.ShootFromCannon(num3, num6, num5, num, inventory[selectedItem].damage, 8f, Main.myPlayer, fromWire: false);
		}
	}

	private void ExtractinatorUse(int extractType, int extractinatorBlockType)
	{
		int num = 5000;
		int num2 = 25;
		int num3 = 50;
		int num4 = -1;
		int num5 = -1;
		int num6 = -1;
		int num7 = 1;
		switch (extractType)
		{
		case 3347:
			num /= 3;
			num2 *= 2;
			num3 = 20;
			num4 = 10;
			break;
		case 2337:
			num = -1;
			num2 = -1;
			num3 = -1;
			num4 = -1;
			num5 = 1;
			num7 = -1;
			break;
		case 4354:
			num = -1;
			num2 = -1;
			num3 = -1;
			num4 = -1;
			num5 = -1;
			num7 = -1;
			num6 = 1;
			break;
		}
		int num8 = -1;
		int resultStack = 1;
		if (num4 != -1 && Main.rand.Next(num4) == 0)
		{
			num8 = 3380;
			if (Main.rand.Next(5) == 0)
			{
				resultStack += Main.rand.Next(2);
			}
			if (Main.rand.Next(10) == 0)
			{
				resultStack += Main.rand.Next(3);
			}
			if (Main.rand.Next(15) == 0)
			{
				resultStack += Main.rand.Next(4);
			}
		}
		else if (num7 != -1 && Main.rand.Next(2) == 0)
		{
			if (Main.rand.Next(12000) == 0)
			{
				num8 = 74;
				if (Main.rand.Next(14) == 0)
				{
					resultStack += Main.rand.Next(0, 2);
				}
				if (Main.rand.Next(14) == 0)
				{
					resultStack += Main.rand.Next(0, 2);
				}
				if (Main.rand.Next(14) == 0)
				{
					resultStack += Main.rand.Next(0, 2);
				}
			}
			else if (Main.rand.Next(800) == 0)
			{
				num8 = 73;
				if (Main.rand.Next(6) == 0)
				{
					resultStack += Main.rand.Next(1, 21);
				}
				if (Main.rand.Next(6) == 0)
				{
					resultStack += Main.rand.Next(1, 21);
				}
				if (Main.rand.Next(6) == 0)
				{
					resultStack += Main.rand.Next(1, 21);
				}
				if (Main.rand.Next(6) == 0)
				{
					resultStack += Main.rand.Next(1, 21);
				}
				if (Main.rand.Next(6) == 0)
				{
					resultStack += Main.rand.Next(1, 20);
				}
			}
			else if (Main.rand.Next(60) == 0)
			{
				num8 = 72;
				if (Main.rand.Next(4) == 0)
				{
					resultStack += Main.rand.Next(5, 26);
				}
				if (Main.rand.Next(4) == 0)
				{
					resultStack += Main.rand.Next(5, 26);
				}
				if (Main.rand.Next(4) == 0)
				{
					resultStack += Main.rand.Next(5, 26);
				}
				if (Main.rand.Next(4) == 0)
				{
					resultStack += Main.rand.Next(5, 25);
				}
			}
			else
			{
				num8 = 71;
				if (Main.rand.Next(3) == 0)
				{
					resultStack += Main.rand.Next(10, 26);
				}
				if (Main.rand.Next(3) == 0)
				{
					resultStack += Main.rand.Next(10, 26);
				}
				if (Main.rand.Next(3) == 0)
				{
					resultStack += Main.rand.Next(10, 26);
				}
				if (Main.rand.Next(3) == 0)
				{
					resultStack += Main.rand.Next(10, 25);
				}
			}
		}
		else if (num != -1 && Main.rand.Next(num) == 0)
		{
			num8 = 1242;
		}
		else if (num5 != -1)
		{
			num8 = ((Main.rand.Next(4) != 1) ? 2674 : ((Main.rand.Next(3) != 1) ? 2006 : ((Main.rand.Next(3) == 1) ? 2675 : 2002)));
		}
		else if (num6 != -1 && extractinatorBlockType == 642)
		{
			num8 = ((Main.rand.Next(10) == 1) ? (Main.rand.Next(5) switch
			{
				0 => 4354, 
				1 => 4389, 
				2 => 4377, 
				3 => 5127, 
				_ => 4378, 
			}) : (Main.rand.Next(5) switch
			{
				0 => 4349, 
				1 => 4350, 
				2 => 4351, 
				3 => 4352, 
				_ => 4353, 
			}));
		}
		else if (num6 != -1)
		{
			num8 = Main.rand.Next(5) switch
			{
				0 => 4349, 
				1 => 4350, 
				2 => 4351, 
				3 => 4352, 
				_ => 4353, 
			};
		}
		else if (num2 != -1 && Main.rand.Next(num2) == 0)
		{
			num8 = Main.rand.Next(6) switch
			{
				0 => 181, 
				1 => 180, 
				2 => 177, 
				3 => 179, 
				4 => 178, 
				_ => 182, 
			};
			if (Main.rand.Next(20) == 0)
			{
				resultStack += Main.rand.Next(0, 2);
			}
			if (Main.rand.Next(30) == 0)
			{
				resultStack += Main.rand.Next(0, 3);
			}
			if (Main.rand.Next(40) == 0)
			{
				resultStack += Main.rand.Next(0, 4);
			}
			if (Main.rand.Next(50) == 0)
			{
				resultStack += Main.rand.Next(0, 5);
			}
			if (Main.rand.Next(60) == 0)
			{
				resultStack += Main.rand.Next(0, 6);
			}
		}
		else if (num3 != -1 && Main.rand.Next(num3) == 0)
		{
			num8 = 999;
			if (Main.rand.Next(20) == 0)
			{
				resultStack += Main.rand.Next(0, 2);
			}
			if (Main.rand.Next(30) == 0)
			{
				resultStack += Main.rand.Next(0, 3);
			}
			if (Main.rand.Next(40) == 0)
			{
				resultStack += Main.rand.Next(0, 4);
			}
			if (Main.rand.Next(50) == 0)
			{
				resultStack += Main.rand.Next(0, 5);
			}
			if (Main.rand.Next(60) == 0)
			{
				resultStack += Main.rand.Next(0, 6);
			}
		}
		else if (Main.rand.Next(3) == 0)
		{
			if (Main.rand.Next(5000) == 0)
			{
				num8 = 74;
				if (Main.rand.Next(10) == 0)
				{
					resultStack += Main.rand.Next(0, 3);
				}
				if (Main.rand.Next(10) == 0)
				{
					resultStack += Main.rand.Next(0, 3);
				}
				if (Main.rand.Next(10) == 0)
				{
					resultStack += Main.rand.Next(0, 3);
				}
				if (Main.rand.Next(10) == 0)
				{
					resultStack += Main.rand.Next(0, 3);
				}
				if (Main.rand.Next(10) == 0)
				{
					resultStack += Main.rand.Next(0, 3);
				}
			}
			else if (Main.rand.Next(400) == 0)
			{
				num8 = 73;
				if (Main.rand.Next(5) == 0)
				{
					resultStack += Main.rand.Next(1, 21);
				}
				if (Main.rand.Next(5) == 0)
				{
					resultStack += Main.rand.Next(1, 21);
				}
				if (Main.rand.Next(5) == 0)
				{
					resultStack += Main.rand.Next(1, 21);
				}
				if (Main.rand.Next(5) == 0)
				{
					resultStack += Main.rand.Next(1, 21);
				}
				if (Main.rand.Next(5) == 0)
				{
					resultStack += Main.rand.Next(1, 20);
				}
			}
			else if (Main.rand.Next(30) == 0)
			{
				num8 = 72;
				if (Main.rand.Next(3) == 0)
				{
					resultStack += Main.rand.Next(5, 26);
				}
				if (Main.rand.Next(3) == 0)
				{
					resultStack += Main.rand.Next(5, 26);
				}
				if (Main.rand.Next(3) == 0)
				{
					resultStack += Main.rand.Next(5, 26);
				}
				if (Main.rand.Next(3) == 0)
				{
					resultStack += Main.rand.Next(5, 25);
				}
			}
			else
			{
				num8 = 71;
				if (Main.rand.Next(2) == 0)
				{
					resultStack += Main.rand.Next(10, 26);
				}
				if (Main.rand.Next(2) == 0)
				{
					resultStack += Main.rand.Next(10, 26);
				}
				if (Main.rand.Next(2) == 0)
				{
					resultStack += Main.rand.Next(10, 26);
				}
				if (Main.rand.Next(2) == 0)
				{
					resultStack += Main.rand.Next(10, 25);
				}
			}
		}
		else if (extractinatorBlockType == 642)
		{
			num8 = Main.rand.Next(14) switch
			{
				0 => 12, 
				1 => 11, 
				2 => 14, 
				3 => 13, 
				4 => 699, 
				5 => 700, 
				6 => 701, 
				7 => 702, 
				8 => 364, 
				9 => 1104, 
				10 => 365, 
				11 => 1105, 
				12 => 366, 
				_ => 1106, 
			};
			if (Main.rand.Next(20) == 0)
			{
				resultStack += Main.rand.Next(0, 2);
			}
			if (Main.rand.Next(30) == 0)
			{
				resultStack += Main.rand.Next(0, 3);
			}
			if (Main.rand.Next(40) == 0)
			{
				resultStack += Main.rand.Next(0, 4);
			}
			if (Main.rand.Next(50) == 0)
			{
				resultStack += Main.rand.Next(0, 5);
			}
			if (Main.rand.Next(60) == 0)
			{
				resultStack += Main.rand.Next(0, 6);
			}
		}
		else
		{
			num8 = Main.rand.Next(8) switch
			{
				0 => 12, 
				1 => 11, 
				2 => 14, 
				3 => 13, 
				4 => 699, 
				5 => 700, 
				6 => 701, 
				_ => 702, 
			};
			if (Main.rand.Next(20) == 0)
			{
				resultStack += Main.rand.Next(0, 2);
			}
			if (Main.rand.Next(30) == 0)
			{
				resultStack += Main.rand.Next(0, 3);
			}
			if (Main.rand.Next(40) == 0)
			{
				resultStack += Main.rand.Next(0, 4);
			}
			if (Main.rand.Next(50) == 0)
			{
				resultStack += Main.rand.Next(0, 5);
			}
			if (Main.rand.Next(60) == 0)
			{
				resultStack += Main.rand.Next(0, 6);
			}
		}
		ItemLoader.ExtractinatorUse(ref num8, ref resultStack, extractType, extractinatorBlockType);
		if (num8 > 0)
		{
			DropItemFromExtractinator(num8, resultStack);
		}
	}

	private void DropItemFromExtractinator(int itemType, int stack)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		Vector2 val = Main.ReverseGravitySupport(Main.MouseScreen) + Main.screenPosition;
		if (Main.SmartCursorIsUsed || PlayerInput.UsingGamepad)
		{
			val = base.Center;
		}
		int number = Item.NewItem(GetItemSource_TileInteraction(tileTargetX, tileTargetY), (int)val.X, (int)val.Y, 1, 1, itemType, stack, noBroadcast: false, -1);
		if (Main.netMode == 1)
		{
			NetMessage.SendData(21, -1, -1, null, number, 1f);
		}
	}

	/// <summary>
	/// Changes the player's direction (<see cref="F:Terraria.Entity.direction" />) while adjusting arm and item rotations to be consistent. Will also account for <see cref="F:Terraria.Player.pulley" /> and <see cref="F:Terraria.Player.pulleyDir" />. The player direction change will be prevented if the player is on a rope but there isn't space for the player to face the new direction.
	/// </summary>
	/// <param name="dir"></param>
	public void ChangeDir(int dir)
	{
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		if (dir == direction)
		{
			return;
		}
		if (!pulley || pulleyDir != 2)
		{
			direction = dir;
		}
		else
		{
			if (pulleyDir == 2 && dir == direction)
			{
				return;
			}
			int num = (int)(position.X + (float)(width / 2)) / 16 * 16 + 8 - width / 2;
			if (Collision.SolidCollision(new Vector2((float)num, position.Y), width, height))
			{
				return;
			}
			if (whoAmI == Main.myPlayer)
			{
				Main.cameraX = Main.cameraX + position.X - (float)num;
			}
			pulleyDir = 1;
			position.X = num;
			direction = dir;
		}
		compositeBackArm.rotation *= -1f;
		compositeFrontArm.rotation *= -1f;
		itemRotation *= -1f;
		itemLocation.X = MountedCenter.X + (MountedCenter.X - itemLocation.X);
	}

	public Rectangle getRect()
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		return new Rectangle((int)position.X, (int)position.Y, width, height);
	}

	public void HorsemansBlade_SpawnPumpkin(int npcIndex, int dmg, float kb)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		Vector2 center = Main.npc[npcIndex].Center;
		int logicCheckScreenHeight = Main.LogicCheckScreenHeight;
		int logicCheckScreenWidth = Main.LogicCheckScreenWidth;
		int num = Main.rand.Next(100, 300);
		int num2 = Main.rand.Next(100, 300);
		num = ((Main.rand.Next(2) != 0) ? (num + (logicCheckScreenWidth / 2 - num)) : (num - (logicCheckScreenWidth / 2 + num)));
		num2 = ((Main.rand.Next(2) != 0) ? (num2 + (logicCheckScreenHeight / 2 - num2)) : (num2 - (logicCheckScreenHeight / 2 + num2)));
		num += (int)position.X;
		num2 += (int)position.Y;
		Vector2 val = default(Vector2);
		((Vector2)(ref val))..ctor((float)num, (float)num2);
		float num3 = center.X - val.X;
		float num4 = center.Y - val.Y;
		float num5 = (float)Math.Sqrt(num3 * num3 + num4 * num4);
		num5 = 8f / num5;
		num3 *= num5;
		num4 *= num5;
		Projectile.NewProjectile(GetProjectileSource_Item(HeldItem), num, num2, num3, num4, 321, dmg, kb, whoAmI, npcIndex);
	}

	public void PutItemInInventoryFromItemUsage(int type, int theSelectedItem = -1)
	{
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < 58; i++)
		{
			Item item = inventory[i];
			if (item.stack > 0 && item.type == type && item.stack < item.maxStack)
			{
				item.stack++;
				return;
			}
		}
		if (theSelectedItem >= 0 && (inventory[theSelectedItem].type == 0 || inventory[theSelectedItem].stack <= 0))
		{
			inventory[theSelectedItem].SetDefaults(type);
			return;
		}
		Item item2 = new Item();
		item2.SetDefaults(type);
		if (GetItem(whoAmI, item2, GetItemSettings.ItemCreatedFromItemUsage).stack > 0)
		{
			Item item3 = item2;
			if (theSelectedItem != -1)
			{
				item3 = inventory[theSelectedItem];
			}
			int number = Item.NewItem(new EntitySource_ItemUse(this, item3), (int)position.X, (int)position.Y, width, height, type, 1, noBroadcast: false, 0, noGrabDelay: true);
			if (Main.netMode == 1)
			{
				NetMessage.SendData(21, -1, -1, null, number, 1f);
			}
		}
		else
		{
			item2.position.X = base.Center.X - (float)(item2.width / 2);
			item2.position.Y = base.Center.Y - (float)(item2.height / 2);
			item2.active = true;
			PopupText.NewText(PopupTextContext.RegularItemPickup, item2, 0);
		}
	}

	public bool SummonItemCheck(Item item)
	{
		int type = item.type;
		for (int i = 0; i < 200; i++)
		{
			NPC nPC = Main.npc[i];
			if (nPC.active && ((type == 43 && nPC.type == 4) || (type == 70 && nPC.type == 13) || ((type == 560) & (nPC.type == 50)) || (type == 544 && nPC.type == 125) || (type == 544 && nPC.type == 126) || (type == 556 && nPC.type == 134) || (type == 557 && nPC.type == 127) || (type == 1133 && nPC.type == 222) || (type == 1331 && nPC.type == 266) || (type == 4988 && nPC.type == 657) || (type == 5120 && nPC.type == 668)))
			{
				return false;
			}
		}
		return true;
	}

	public PlayerFishingConditions GetFishingConditions()
	{
		PlayerFishingConditions result = default(PlayerFishingConditions);
		Fishing_GetBestFishingPole(out result.Pole);
		Fishing_GetBait(out result.Bait);
		if (result.BaitItemType == 2673)
		{
			return result;
		}
		if (result.BaitPower == 0 || result.PolePower == 0)
		{
			return result;
		}
		int num = 0;
		if (FindBuffIndex(25) != -1)
		{
			num += 5;
		}
		if (canFloatInWater && wet)
		{
			num += 5;
		}
		if (sitting.TryGetSittingBlock(this, out var _) && sitting.details.IsAToilet)
		{
			num += 5;
		}
		int num2 = result.BaitPower + result.PolePower + fishingSkill + num;
		result.LevelMultipliers = Fishing_GetPowerMultiplier(result.Pole, result.Bait);
		result.FinalFishingLevel = (int)((float)num2 * result.LevelMultipliers);
		return result;
	}

	private float Fishing_GetPowerMultiplier(Item pole, Item bait)
	{
		float fishingLevel = 1f;
		if (Main.raining)
		{
			fishingLevel *= 1.2f;
		}
		if (Main.cloudBGAlpha > 0f)
		{
			fishingLevel *= 1.1f;
		}
		if (Main.dayTime && (Main.time < 5400.0 || Main.time > 48600.0))
		{
			fishingLevel *= 1.3f;
		}
		if (Main.dayTime && Main.time > 16200.0 && Main.time < 37800.0)
		{
			fishingLevel *= 0.8f;
		}
		if (!Main.dayTime && Main.time > 6480.0 && Main.time < 25920.0)
		{
			fishingLevel *= 0.8f;
		}
		if (Main.moonPhase == 0)
		{
			fishingLevel *= 1.1f;
		}
		if (Main.moonPhase == 1 || Main.moonPhase == 7)
		{
			fishingLevel *= 1.05f;
		}
		if (Main.moonPhase == 3 || Main.moonPhase == 5)
		{
			fishingLevel *= 0.95f;
		}
		if (Main.moonPhase == 4)
		{
			fishingLevel *= 0.9f;
		}
		if (Main.bloodMoon)
		{
			fishingLevel *= 1.1f;
		}
		PlayerLoader.GetFishingLevel(this, pole, bait, ref fishingLevel);
		return fishingLevel;
	}

	private void Fishing_GetBait(out Item bait)
	{
		bait = null;
		for (int i = 54; i < 58; i++)
		{
			if (inventory[i].stack > 0 && inventory[i].bait > 0)
			{
				bait = inventory[i];
				break;
			}
		}
		if (bait != null)
		{
			return;
		}
		for (int j = 0; j < 50; j++)
		{
			if (inventory[j].stack > 0 && inventory[j].bait > 0)
			{
				bait = inventory[j];
				break;
			}
		}
	}

	private void Fishing_GetBestFishingPole(out Item pole)
	{
		pole = inventory[selectedItem];
		if (pole.fishingPole != 0)
		{
			return;
		}
		for (int i = 0; i < 58; i++)
		{
			if (inventory[i].fishingPole > pole.fishingPole)
			{
				pole = inventory[i];
			}
		}
	}

	public bool HasUnityPotion()
	{
		for (int i = 0; i < 58; i++)
		{
			if (inventory[i].type == 2997 && inventory[i].stack > 0)
			{
				return true;
			}
		}
		if (useVoidBag())
		{
			for (int j = 0; j < 40; j++)
			{
				if (bank4.item[j].type == 2997 && bank4.item[j].stack > 0)
				{
					return true;
				}
			}
		}
		return false;
	}

	public void TakeUnityPotion()
	{
		for (int i = 0; i < 58; i++)
		{
			if (inventory[i].type == 2997 && inventory[i].stack > 0)
			{
				if (ItemLoader.ConsumeItem(inventory[i], this))
				{
					inventory[i].stack--;
				}
				if (inventory[i].stack <= 0)
				{
					inventory[i].SetDefaults();
				}
				return;
			}
		}
		if (!useVoidBag())
		{
			return;
		}
		for (int j = 0; j < 40; j++)
		{
			if (bank4.item[j].type == 2997 && bank4.item[j].stack > 0)
			{
				if (ItemLoader.ConsumeItem(bank4.item[j], this))
				{
					bank4.item[j].stack--;
				}
				if (bank4.item[j].stack <= 0)
				{
					bank4.item[j].SetDefaults();
				}
				break;
			}
		}
	}

	public void UnityTeleport(Vector2 telePos)
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		int num = 3;
		if (Main.netMode == 0)
		{
			Teleport(telePos, num);
		}
		else
		{
			NetMessage.SendData(65, -1, -1, null, 2, whoAmI, telePos.X, telePos.Y, num);
		}
	}

	private void PayDD2CrystalsBeforeUse(Item item)
	{
		int requiredDD2CrystalsToUse = GetRequiredDD2CrystalsToUse(item);
		for (int i = 0; i < requiredDD2CrystalsToUse; i++)
		{
			ConsumeItem(3822, reverseOrder: true);
		}
	}

	private bool CheckDD2CrystalPaymentLock(Item item)
	{
		if (!DD2Event.Ongoing)
		{
			return true;
		}
		int requiredDD2CrystalsToUse = GetRequiredDD2CrystalsToUse(item);
		return CountItem(3822, requiredDD2CrystalsToUse) >= requiredDD2CrystalsToUse;
	}

	private int GetRequiredDD2CrystalsToUse(Item item)
	{
		switch (item.type)
		{
		case 3818:
		case 3819:
		case 3820:
			return 10;
		case 3824:
		case 3825:
		case 3826:
			return 10;
		case 3832:
		case 3833:
		case 3834:
			return 10;
		case 3829:
		case 3830:
		case 3831:
			return 10;
		default:
			return 0;
		}
	}

	public void SporeSac(Item sourceItem)
	{
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_015e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0165: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_0171: Unknown result type (might be due to invalid IL or missing references)
		//IL_018c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0193: Unknown result type (might be due to invalid IL or missing references)
		//IL_0224: Unknown result type (might be due to invalid IL or missing references)
		//IL_0335: Unknown result type (might be due to invalid IL or missing references)
		//IL_033c: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f9: Unknown result type (might be due to invalid IL or missing references)
		int damage = 70;
		float knockBack = 1.5f;
		if (Main.rand.Next(15) != 0)
		{
			return;
		}
		int num = 0;
		for (int i = 0; i < 1000; i++)
		{
			if (Main.projectile[i].active && Main.projectile[i].owner == whoAmI && (Main.projectile[i].type == 567 || Main.projectile[i].type == 568))
			{
				num++;
			}
		}
		if (Main.rand.Next(15) < num || num >= 10)
		{
			return;
		}
		int num2 = 50;
		int num3 = 24;
		int num4 = 90;
		for (int j = 0; j < num2; j++)
		{
			int num5 = Main.rand.Next(200 - j * 2, 400 + j * 2);
			Vector2 center = base.Center;
			center.X += Main.rand.Next(-num5, num5 + 1);
			center.Y += Main.rand.Next(-num5, num5 + 1);
			if (Collision.SolidCollision(center, num3, num3) || Collision.WetCollision(center, num3, num3))
			{
				continue;
			}
			center.X += num3 / 2;
			center.Y += num3 / 2;
			if (!Collision.CanHit(new Vector2(base.Center.X, position.Y), 1, 1, center, 1, 1) && !Collision.CanHit(new Vector2(base.Center.X, position.Y - 50f), 1, 1, center, 1, 1))
			{
				continue;
			}
			int x = (int)center.X / 16;
			int y = (int)center.Y / 16;
			bool flag = false;
			if (Main.rand.Next(3) == 0 && Main.tile[x, y] != null && Main.tile[x, y].wall > 0)
			{
				flag = true;
			}
			else
			{
				center.X -= num4 / 2;
				center.Y -= num4 / 2;
				if (Collision.SolidCollision(center, num4, num4))
				{
					center.X += num4 / 2;
					center.Y += num4 / 2;
					flag = true;
				}
				else if (Main.tile[x, y] != null && Main.tile[x, y].active() && Main.tile[x, y].type == 19)
				{
					flag = true;
				}
			}
			if (!flag)
			{
				continue;
			}
			for (int k = 0; k < 1000; k++)
			{
				if (Main.projectile[k].active && Main.projectile[k].owner == whoAmI && Main.projectile[k].aiStyle == 105)
				{
					Vector2 val = center - Main.projectile[k].Center;
					if (((Vector2)(ref val)).Length() < 48f)
					{
						flag = false;
						break;
					}
				}
			}
			if (flag && Main.myPlayer == whoAmI)
			{
				Projectile.NewProjectile(GetProjectileSource_Accessory(sourceItem), center.X, center.Y, 0f, 0f, 567 + Main.rand.Next(2), damage, knockBack, whoAmI);
				break;
			}
		}
	}

	public void VolatileGelatin(Item sourceItem)
	{
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		if (Main.myPlayer != whoAmI)
		{
			return;
		}
		volatileGelatinCounter++;
		if (volatileGelatinCounter <= 40)
		{
			return;
		}
		volatileGelatinCounter = 0;
		int damage = 65;
		float knockBack = 7f;
		float num = 640f;
		NPC nPC = null;
		for (int i = 0; i < 200; i++)
		{
			NPC nPC2 = Main.npc[i];
			if (nPC2 != null && nPC2.active && nPC2.CanBeChasedBy(this) && Collision.CanHit(this, nPC2))
			{
				float num2 = Vector2.Distance(nPC2.Center, base.Center);
				if (num2 < num)
				{
					num = num2;
					nPC = nPC2;
				}
			}
		}
		if (nPC != null)
		{
			Vector2 v = nPC.Center - base.Center;
			v = v.SafeNormalize(Vector2.Zero) * 12f;
			v.Y -= 1.3f;
			Projectile.NewProjectile(GetProjectileSource_Accessory(sourceItem), base.Center.X, base.Center.Y, v.X, v.Y, 937, damage, knockBack, whoAmI);
		}
	}

	public bool CanHit(Entity ent)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		if (!Collision.CanHit(position, width, height, ent.position, ent.width, ent.height) && !Collision.CanHitLine(base.Center + new Vector2((float)(direction * width / 2), gravDir * (float)(-height) / 3f), 0, 0, ent.Center + new Vector2(0f, (float)(-ent.height / 3)), 0, 0) && !Collision.CanHitLine(base.Center + new Vector2((float)(direction * width / 2), gravDir * (float)(-height) / 3f), 0, 0, ent.Center, 0, 0))
		{
			return Collision.CanHitLine(base.Center + new Vector2((float)(direction * width / 2), 0f), 0, 0, ent.Center + new Vector2(0f, (float)(ent.height / 3)), 0, 0);
		}
		return true;
	}

	public Rectangle GetItemDrawFrame(int type)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		if (Main.dedServ)
		{
			return Rectangle.Empty;
		}
		Main.instance.LoadItem(type);
		if (ItemID.Sets.IsFood[type])
		{
			return TextureAssets.Item[type].Frame(1, 3, 0, 1);
		}
		if (Main.itemAnimations[type] != null)
		{
			return Main.itemAnimations[type].GetFrame(TextureAssets.Item[type].Value);
		}
		return TextureAssets.Item[type].Frame();
	}

	/// <summary>
	/// Used to determine what the overall scale of an item should be.<br></br>
	/// <see cref="M:Terraria.ModLoader.CombinedHooks.ModifyItemScale(Terraria.Player,Terraria.Item,System.Single@)" /> is called here.
	/// </summary>
	/// <param name="item">The item to fetch the adjusted scale of.</param>
	/// <returns>
	/// The final scale of the item, after the Titan Glove effect and all modded calculations.
	/// </returns>
	public float GetAdjustedItemScale(Item item)
	{
		float scale = item.scale;
		if (item.melee)
		{
			ApplyMeleeScale(ref scale);
		}
		CombinedHooks.ModifyItemScale(this, item, ref scale);
		return scale;
	}

	public void ApplyMeleeScale(ref float scale)
	{
		if (meleeScaleGlove)
		{
			scale *= 1.1f;
		}
	}

	public Vector2 ApplyRangeCompensation(float rangeCompensation, Vector2 startPos, Vector2 targetPos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		Vector2 v = targetPos - startPos;
		Vector2 val = v.SafeNormalize(Vector2.Zero);
		val.Y -= 1f;
		float num = ((Vector2)(ref v)).Length();
		num = (float)Math.Pow(num / 700f, 2.0) * 700f;
		targetPos.Y += val.Y * num * rangeCompensation * 1f;
		targetPos.X += (0f - val.X) * num * rangeCompensation * 1f;
		return targetPos;
	}

	public void ItemCheck()
	{
		if (PlayerLoader.PreItemCheck(this))
		{
			ItemCheck_Inner();
		}
		PlayerLoader.PostItemCheck(this);
	}

	private void ItemCheck_Inner()
	{
		//IL_0486: Unknown result type (might be due to invalid IL or missing references)
		//IL_048b: Unknown result type (might be due to invalid IL or missing references)
		//IL_05da: Unknown result type (might be due to invalid IL or missing references)
		//IL_05cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_04e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_04f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0614: Unknown result type (might be due to invalid IL or missing references)
		//IL_09b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_09d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_09de: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b01: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b1c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b22: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b24: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b33: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b38: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b3d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c93: Unknown result type (might be due to invalid IL or missing references)
		//IL_0cae: Unknown result type (might be due to invalid IL or missing references)
		//IL_0cb4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0cb6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0cc5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0cca: Unknown result type (might be due to invalid IL or missing references)
		//IL_0ccf: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b58: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b5d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b5f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b76: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b7c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a27: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a63: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a69: Unknown result type (might be due to invalid IL or missing references)
		//IL_0e32: Unknown result type (might be due to invalid IL or missing references)
		//IL_0e37: Unknown result type (might be due to invalid IL or missing references)
		//IL_0cea: Unknown result type (might be due to invalid IL or missing references)
		//IL_0cef: Unknown result type (might be due to invalid IL or missing references)
		//IL_0cf1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0d05: Unknown result type (might be due to invalid IL or missing references)
		//IL_0d0b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a95: Unknown result type (might be due to invalid IL or missing references)
		//IL_0ab9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0abf: Unknown result type (might be due to invalid IL or missing references)
		//IL_0f9c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0fa7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0e64: Unknown result type (might be due to invalid IL or missing references)
		//IL_0e69: Unknown result type (might be due to invalid IL or missing references)
		//IL_0e6d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0e72: Unknown result type (might be due to invalid IL or missing references)
		//IL_11b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_11c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_1041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0e7a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0e7f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0e96: Unknown result type (might be due to invalid IL or missing references)
		//IL_0e9c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0eb0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0eb2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0eb9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0ec3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0ec8: Unknown result type (might be due to invalid IL or missing references)
		//IL_125a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0fb8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0ff2: Unknown result type (might be due to invalid IL or missing references)
		//IL_1003: Unknown result type (might be due to invalid IL or missing references)
		//IL_100d: Unknown result type (might be due to invalid IL or missing references)
		//IL_1012: Unknown result type (might be due to invalid IL or missing references)
		//IL_11d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_120b: Unknown result type (might be due to invalid IL or missing references)
		//IL_121c: Unknown result type (might be due to invalid IL or missing references)
		//IL_1226: Unknown result type (might be due to invalid IL or missing references)
		//IL_122b: Unknown result type (might be due to invalid IL or missing references)
		//IL_105c: Unknown result type (might be due to invalid IL or missing references)
		//IL_1096: Unknown result type (might be due to invalid IL or missing references)
		//IL_10a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_10b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_10b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_14ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_150c: Unknown result type (might be due to invalid IL or missing references)
		//IL_1512: Unknown result type (might be due to invalid IL or missing references)
		//IL_1514: Unknown result type (might be due to invalid IL or missing references)
		//IL_1519: Unknown result type (might be due to invalid IL or missing references)
		//IL_1275: Unknown result type (might be due to invalid IL or missing references)
		//IL_12af: Unknown result type (might be due to invalid IL or missing references)
		//IL_12c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_12ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_12cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_10ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_1121: Unknown result type (might be due to invalid IL or missing references)
		//IL_1132: Unknown result type (might be due to invalid IL or missing references)
		//IL_113c: Unknown result type (might be due to invalid IL or missing references)
		//IL_1141: Unknown result type (might be due to invalid IL or missing references)
		//IL_155a: Unknown result type (might be due to invalid IL or missing references)
		//IL_157e: Unknown result type (might be due to invalid IL or missing references)
		//IL_1581: Unknown result type (might be due to invalid IL or missing references)
		//IL_1586: Unknown result type (might be due to invalid IL or missing references)
		//IL_158b: Unknown result type (might be due to invalid IL or missing references)
		//IL_158d: Unknown result type (might be due to invalid IL or missing references)
		//IL_15a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_15a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_15bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_15bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_15da: Unknown result type (might be due to invalid IL or missing references)
		//IL_15df: Unknown result type (might be due to invalid IL or missing references)
		//IL_12fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_1320: Unknown result type (might be due to invalid IL or missing references)
		//IL_1331: Unknown result type (might be due to invalid IL or missing references)
		//IL_133b: Unknown result type (might be due to invalid IL or missing references)
		//IL_1340: Unknown result type (might be due to invalid IL or missing references)
		if (CCed)
		{
			channel = false;
			itemAnimation = (itemAnimationMax = 0);
			return;
		}
		float heightOffsetHitboxCenter = HeightOffsetHitboxCenter;
		Item item = inventory[selectedItem];
		ItemCheckContext context = default(ItemCheckContext);
		bool flag = false;
		if (Main.myPlayer == whoAmI)
		{
			if (PlayerInput.ShouldFastUseItem)
			{
				controlUseItem = true;
				flag = true;
			}
			if (!cursorItemIconEnabled && item.stack > 0 && item.fishingPole > 0)
			{
				Fishing_GetBait(out var bait);
				if (bait != null)
				{
					cursorItemIconEnabled = true;
					cursorItemIconID = bait.type;
					cursorItemIconPush = 6;
				}
			}
			if (!cursorItemIconEnabled && item.stack > 0 && (item.type == 779 || item.type == 5134))
			{
				for (int i = 54; i < 58; i++)
				{
					if (inventory[i].ammo == item.useAmmo && inventory[i].stack > 0)
					{
						cursorItemIconEnabled = true;
						cursorItemIconID = inventory[i].type;
						cursorItemIconPush = 10;
						break;
					}
				}
				if (!cursorItemIconEnabled)
				{
					for (int j = 0; j < 54; j++)
					{
						if (inventory[j].ammo == item.useAmmo && inventory[j].stack > 0)
						{
							cursorItemIconEnabled = true;
							cursorItemIconID = inventory[j].type;
							cursorItemIconPush = 10;
							break;
						}
					}
				}
			}
		}
		if (itemAnimation > 0)
		{
			itemAnimation--;
			if (itemAnimation == 0 && whoAmI == Main.myPlayer)
			{
				PlayerInput.TryEndingFastUse();
			}
		}
		if (itemTime > 0)
		{
			itemTime--;
			if (ItemTimeIsZero && whoAmI == Main.myPlayer && !JustDroppedAnItem)
			{
				int type = item.type;
				if (type == 65 || type == 724 || type == 989 || type == 1226)
				{
					EmitMaxManaEffect();
				}
			}
		}
		if (itemAnimation == 0 && reuseDelay == 0 && (!controlUseItem || selectItemOnNextUse))
		{
			selectItemOnNextUse = false;
			int num = selectedItem;
			SmartSelectLookup();
			if (selectedItem != num)
			{
				item = inventory[selectedItem];
				releaseUseItem = true;
				itemTime = (itemTimeMax = 0);
			}
		}
		ItemCheck_HandleMount();
		int weaponDamage = GetWeaponDamage(item);
		ItemCheck_HandleMPItemAnimation(item);
		ItemCheck_HackHoldStyles(item);
		if (itemAnimation < 0)
		{
			itemAnimation = 0;
		}
		if (itemTime < 0)
		{
			itemTime = 0;
		}
		if (itemAnimation == 0 && reuseDelay > 0)
		{
			ApplyReuseDelay();
		}
		UpdatePlacementPreview(item);
		if (itemAnimation == 0 && altFunctionUse == 2)
		{
			altFunctionUse = 0;
		}
		bool flag2 = true;
		if (gravDir == -1f && GolfHelper.IsPlayerHoldingClub(this))
		{
			flag2 = false;
		}
		if (flag2 && controlUseItem && releaseUseItem && itemAnimation == 0 && item.useStyle != 0)
		{
			if (altFunctionUse == 1)
			{
				altFunctionUse = 2;
			}
			if (item.shoot == 0)
			{
				itemRotation = 0f;
			}
			bool flag3 = ItemCheck_CheckCanUse(item);
			if (item.potion && flag3)
			{
				ApplyPotionDelay(item);
			}
			if (item.mana > 0 && flag3 && whoAmI == Main.myPlayer && item.buffType != 0 && item.buffTime != 0)
			{
				AddBuff(item.buffType, item.buffTime);
			}
			if (item.shoot <= 0 || !ProjectileID.Sets.MinionTargettingFeature[item.shoot] || altFunctionUse != 2)
			{
				ItemCheck_ApplyPetBuffs(item);
			}
			if (whoAmI == Main.myPlayer && gravDir == 1f && item.mountType != -1 && mount.CanMount(item.mountType, this))
			{
				mount.SetMount(item.mountType, this);
			}
			if ((item.shoot <= 0 || !ProjectileID.Sets.MinionTargettingFeature[item.shoot] || altFunctionUse != 2) && flag3 && whoAmI == Main.myPlayer && item.shoot >= 0 && (ProjectileID.Sets.LightPet[item.shoot] || Main.projPet[item.shoot]))
			{
				FreeUpPetsAndMinions(item);
			}
			if (flag3)
			{
				ItemCheck_StartActualUse(item);
			}
		}
		bool flag4 = controlUseItem;
		if (mount.Active && mount.Type == 8)
		{
			flag4 = controlUseItem || controlUseTile;
		}
		if (!flag4)
		{
			channel = false;
		}
		Item item2 = ((itemAnimation > 0) ? lastVisualizedSelectedItem : item);
		Rectangle drawHitbox = Item.GetDrawHitbox(item2.type, this);
		compositeFrontArm.enabled = false;
		compositeBackArm.enabled = false;
		if (itemAnimation > 0)
		{
			if (item.mana > 0)
			{
				ItemCheck_ApplyManaRegenDelay(item);
			}
			if (Main.dedServ)
			{
				itemHeight = item.height;
				itemWidth = item.width;
			}
			else
			{
				itemHeight = drawHitbox.Height;
				itemWidth = drawHitbox.Width;
			}
		}
		releaseUseItem = !controlUseItem;
		ItemLoader.HoldItem(item, this);
		if (itemAnimation > 0)
		{
			ItemCheck_ApplyUseStyle(heightOffsetHitboxCenter, item2, drawHitbox);
		}
		else
		{
			ItemCheck_ApplyHoldStyle(heightOffsetHitboxCenter, item2, drawHitbox);
		}
		if (!JustDroppedAnItem)
		{
			ItemCheck_EmitHeldItemLight(item);
			ItemCheck_EmitFoodParticles(item);
			ItemCheck_EmitDrinkParticles(item);
			_ = whoAmI;
			_ = Main.myPlayer;
			ItemCheck_OwnerOnlyCode(ref context, item, weaponDamage, drawHitbox);
			if (ItemTimeIsZero && itemAnimation > 0)
			{
				if (ItemLoader.UseItem(item, this) == true)
				{
					ApplyItemTime(item, 1f, false);
				}
				if (item.hairDye >= 0)
				{
					ApplyItemTime(item);
					if (whoAmI == Main.myPlayer)
					{
						hairDye = item.hairDye;
						NetMessage.SendData(4, -1, -1, null, whoAmI);
					}
				}
				if (item.healLife > 0 || item.healMana > 0)
				{
					ApplyLifeAndOrMana(item);
					ApplyItemTime(item);
					if (Main.myPlayer == whoAmI && item.type == 126 && breath == 0)
					{
						AchievementsHelper.HandleSpecialEvent(this, 25);
					}
				}
				if (item.buffType > 0)
				{
					if (whoAmI == Main.myPlayer && item.buffType != 90 && item.buffType != 27)
					{
						AddBuff(item.buffType, item.buffTime);
					}
					ApplyItemTime(item);
				}
				if (item.type == 678)
				{
					if (Main.getGoodWorld)
					{
						ApplyItemTime(item);
						if (whoAmI == Main.myPlayer)
						{
							for (int k = 0; k < 3; k++)
							{
								int type2 = 0;
								int timeToAdd = 108000;
								switch (Main.rand.Next(18))
								{
								case 0:
									type2 = 16;
									break;
								case 1:
									type2 = 111;
									break;
								case 2:
									type2 = 114;
									break;
								case 3:
									type2 = 8;
									break;
								case 4:
									type2 = 105;
									break;
								case 5:
									type2 = 17;
									break;
								case 6:
									type2 = 116;
									break;
								case 7:
									type2 = 5;
									break;
								case 8:
									type2 = 113;
									break;
								case 9:
									type2 = 7;
									break;
								case 10:
									type2 = 6;
									break;
								case 11:
									type2 = 104;
									break;
								case 12:
									type2 = 115;
									break;
								case 13:
									type2 = 2;
									break;
								case 14:
									type2 = 9;
									break;
								case 15:
									type2 = 3;
									break;
								case 16:
									type2 = 117;
									break;
								case 17:
									type2 = 1;
									break;
								}
								AddBuff(type2, timeToAdd);
							}
						}
					}
					else
					{
						ApplyItemTime(item);
						if (whoAmI == Main.myPlayer)
						{
							AddBuff(20, 216000);
							AddBuff(22, 216000);
							AddBuff(23, 216000);
							AddBuff(24, 216000);
							AddBuff(30, 216000);
							AddBuff(31, 216000);
							AddBuff(32, 216000);
							AddBuff(33, 216000);
							AddBuff(35, 216000);
							AddBuff(36, 216000);
							AddBuff(68, 216000);
						}
					}
				}
			}
			if ((item.type == 50 || item.type == 3124 || item.type == 3199 || item.type == 5358) && itemAnimation > 0)
			{
				if (Main.rand.Next(2) == 0)
				{
					Dust.NewDust(position, width, height, 15, 0f, 0f, 150, default(Color), 1.1f);
				}
				if (ItemTimeIsZero)
				{
					ApplyItemTime(item);
				}
				else if (itemTime == itemTimeMax / 2)
				{
					for (int l = 0; l < 70; l++)
					{
						Dust.NewDust(position, width, height, 15, velocity.X * 0.5f, velocity.Y * 0.5f, 150, default(Color), 1.5f);
					}
					RemoveAllGrapplingHooks();
					Spawn(PlayerSpawnContext.RecallFromItem);
					for (int m = 0; m < 70; m++)
					{
						Dust.NewDust(position, width, height, 15, 0f, 0f, 150, default(Color), 1.5f);
					}
				}
			}
			if ((item.type == 4263 || item.type == 5360) && itemAnimation > 0)
			{
				Vector2 val = Vector2.UnitY.RotatedBy((float)itemAnimation * ((float)Math.PI * 2f) / 30f) * new Vector2(15f, 0f);
				for (int n = 0; n < 2; n++)
				{
					if (Main.rand.Next(3) == 0)
					{
						Dust dust = Dust.NewDustPerfect(base.Bottom + val, Dust.dustWater());
						dust.velocity.Y *= 0f;
						dust.velocity.Y -= 4.5f;
						dust.velocity.X *= 1.5f;
						dust.scale = 0.8f;
						dust.alpha = 130;
						dust.noGravity = true;
						dust.fadeIn = 1.1f;
					}
				}
				if (ItemTimeIsZero)
				{
					ApplyItemTime(item);
				}
				else if (itemTime == item.useTime / 2)
				{
					if (Main.netMode == 0)
					{
						MagicConch();
					}
					else if (Main.netMode == 1 && whoAmI == Main.myPlayer)
					{
						NetMessage.SendData(73, -1, -1, null, 1);
					}
				}
			}
			if ((item.type == 4819 || item.type == 5361) && itemAnimation > 0)
			{
				Vector2 val2 = Vector2.UnitY.RotatedBy((float)itemAnimation * ((float)Math.PI * 2f) / 30f) * new Vector2(15f, 0f);
				for (int num2 = 0; num2 < 2; num2++)
				{
					if (Main.rand.Next(3) == 0)
					{
						Dust dust2 = Dust.NewDustPerfect(base.Bottom + val2, 35);
						dust2.velocity.Y *= 0f;
						dust2.velocity.Y -= 4.5f;
						dust2.velocity.X *= 1.5f;
						dust2.scale = 0.8f;
						dust2.alpha = 130;
						dust2.noGravity = true;
						dust2.fadeIn = 1.1f;
					}
				}
				if (ItemTimeIsZero)
				{
					ApplyItemTime(item);
				}
				else if (itemTime == item.useTime / 2)
				{
					if (Main.netMode == 0)
					{
						DemonConch();
					}
					else if (Main.netMode == 1 && whoAmI == Main.myPlayer)
					{
						NetMessage.SendData(73, -1, -1, null, 2);
					}
				}
			}
			if (item.type == 5359 && itemAnimation > 0)
			{
				if (Main.rand.Next(2) == 0)
				{
					int num3 = Main.rand.Next(4);
					Color color = Color.Green;
					switch (num3)
					{
					case 0:
					case 1:
						((Color)(ref color))..ctor(100, 255, 100);
						break;
					case 2:
						color = Color.Yellow;
						break;
					case 3:
						color = Color.White;
						break;
					}
					Dust dust3 = Dust.NewDustPerfect(Main.rand.NextVector2FromRectangle(base.Hitbox), 267);
					dust3.noGravity = true;
					dust3.color = color;
					dust3.velocity *= 2f;
					dust3.scale = 0.8f + Main.rand.NextFloat() * 0.6f;
				}
				if (ItemTimeIsZero)
				{
					ApplyItemTime(item);
				}
				else if (itemTime == item.useTime / 2)
				{
					if (Main.netMode == 0)
					{
						Shellphone_Spawn();
					}
					else if (Main.netMode == 1 && whoAmI == Main.myPlayer)
					{
						NetMessage.SendData(73, -1, -1, null, 3);
					}
				}
			}
			if (item.type == 2350 && itemAnimation > 0)
			{
				if (ItemTimeIsZero)
				{
					ApplyItemTime(item);
					SoundEngine.PlaySound(in SoundID.Item3, position);
					for (int num4 = 0; num4 < 10; num4++)
					{
						Dust obj = Main.dust[Dust.NewDust(position, width, height, 15, velocity.X * 0.2f, velocity.Y * 0.2f, 150, Color.Cyan, 1.2f)];
						obj.velocity *= 0.5f;
					}
				}
				else if (itemTime == 20)
				{
					SoundEngine.PlaySound(HeldItem.UseSound, position);
					for (int num5 = 0; num5 < 70; num5++)
					{
						Dust obj2 = Main.dust[Dust.NewDust(position, width, height, 15, velocity.X * 0.2f, velocity.Y * 0.2f, 150, Color.Cyan, 1.2f)];
						obj2.velocity *= 0.5f;
					}
					RemoveAllGrapplingHooks();
					bool flag5 = immune;
					int num6 = immuneTime;
					Spawn(PlayerSpawnContext.RecallFromItem);
					immune = flag5;
					immuneTime = num6;
					for (int num7 = 0; num7 < 70; num7++)
					{
						Dust obj3 = Main.dust[Dust.NewDust(position, width, height, 15, 0f, 0f, 150, Color.Cyan, 1.2f)];
						obj3.velocity *= 0.5f;
					}
					if (ItemLoader.ConsumeItem(item, this) && item.stack > 0)
					{
						item.stack--;
					}
				}
			}
			if (item.type == 4870 && itemAnimation > 0)
			{
				if (ItemTimeIsZero)
				{
					ApplyItemTime(item);
					SoundEngine.PlaySound(in SoundID.Item3, position);
					for (int num8 = 0; num8 < 10; num8++)
					{
						Dust obj4 = Main.dust[Dust.NewDust(position, width, height, 15, velocity.X * 0.2f, velocity.Y * 0.2f, 150, Color.Cyan, 1.2f)];
						obj4.velocity *= 0.5f;
					}
				}
				else if (itemTime == 20)
				{
					SoundEngine.PlaySound(HeldItem.UseSound, position);
					for (int num9 = 0; num9 < 70; num9++)
					{
						Dust obj5 = Main.dust[Dust.NewDust(position, width, height, 15, velocity.X * 0.2f, velocity.Y * 0.2f, 150, Color.Cyan, 1.2f)];
						obj5.velocity *= 0.5f;
					}
					if (whoAmI == Main.myPlayer)
					{
						DoPotionOfReturnTeleportationAndSetTheComebackPoint();
					}
					for (int num10 = 0; num10 < 70; num10++)
					{
						Dust obj6 = Main.dust[Dust.NewDust(position, width, height, 15, 0f, 0f, 150, Color.Cyan, 1.2f)];
						obj6.velocity *= 0.5f;
					}
					if (ItemLoader.ConsumeItem(item, this) && item.stack > 0)
					{
						item.stack--;
					}
				}
			}
			if (item.type == 2351 && itemAnimation > 0)
			{
				if (ItemTimeIsZero)
				{
					ApplyItemTime(item);
				}
				else if (itemTime == 2)
				{
					if (Main.netMode == 0)
					{
						TeleportationPotion();
					}
					else if (Main.netMode == 1 && whoAmI == Main.myPlayer)
					{
						NetMessage.SendData(73);
					}
					if (ItemLoader.ConsumeItem(item, this) && item.stack > 0)
					{
						item.stack--;
					}
				}
			}
			if (item.type == 2756 && itemAnimation > 0)
			{
				if (ItemTimeIsZero)
				{
					ApplyItemTime(item);
				}
				else if (itemTime == 2)
				{
					if (whoAmI == Main.myPlayer)
					{
						Male = !Male;
						if (Main.netMode == 1)
						{
							NetMessage.SendData(4, -1, -1, null, whoAmI);
						}
					}
					if (ItemLoader.ConsumeItem(item, this) && item.stack > 0)
					{
						item.stack--;
					}
				}
				else
				{
					float num11 = itemTimeMax;
					num11 = (num11 - (float)itemTime) / num11;
					float num12 = 44f;
					float num13 = (float)Math.PI * 3f;
					Vector2 val3 = Utils.RotatedBy(new Vector2(15f, 0f), (double)(num13 * num11), default(Vector2));
					val3.X *= direction;
					Vector2 val4 = default(Vector2);
					for (int num14 = 0; num14 < 2; num14++)
					{
						int type3 = 221;
						if (num14 == 1)
						{
							val3.X *= -1f;
							type3 = 219;
						}
						((Vector2)(ref val4))..ctor(val3.X, num12 * (1f - num11) - num12 + (float)(height / 2));
						val4 += base.Center;
						int num15 = Dust.NewDust(val4, 0, 0, type3, 0f, 0f, 100);
						Main.dust[num15].position = val4;
						Main.dust[num15].noGravity = true;
						Main.dust[num15].velocity = Vector2.Zero;
						Main.dust[num15].scale = 1.3f;
						Main.dust[num15].customData = this;
					}
				}
			}
			if (whoAmI == Main.myPlayer)
			{
				if ((itemTimeMax != 0 && itemTime == itemTimeMax) | (!item.IsAir && item.IsNotTheSameAs(lastVisualizedSelectedItem)))
				{
					lastVisualizedSelectedItem = item.Clone();
				}
			}
			else
			{
				lastVisualizedSelectedItem = item.Clone();
			}
			if (whoAmI == Main.myPlayer)
			{
				if (!dontConsumeWand && itemTimeMax != 0 && itemTime == itemTimeMax && item.tileWand > 0)
				{
					int tileWand = item.tileWand;
					for (int num16 = 0; num16 < 58; num16++)
					{
						if (tileWand == inventory[num16].type && inventory[num16].stack > 0)
						{
							if (ItemLoader.ConsumeItem(inventory[num16], this))
							{
								inventory[num16].stack--;
							}
							if (inventory[num16].stack <= 0)
							{
								inventory[num16] = new Item();
							}
							break;
						}
					}
				}
				if (itemTimeMax != 0 && itemTime == itemTimeMax && item.consumable && !context.SkipItemConsumption)
				{
					bool flag6 = true;
					if (item.ranged)
					{
						if (huntressAmmoCost90 && Main.rand.Next(10) == 0)
						{
							flag6 = false;
						}
						if (chloroAmmoCost80 && Main.rand.Next(5) == 0)
						{
							flag6 = false;
						}
						if (ammoCost80 && Main.rand.Next(5) == 0)
						{
							flag6 = false;
						}
						if (ammoCost75 && Main.rand.Next(4) == 0)
						{
							flag6 = false;
						}
					}
					if (item.CountsAsClass(DamageClass.Throwing))
					{
						if (ThrownCost50 && Main.rand.Next(100) < 50)
						{
							flag6 = false;
						}
						if (ThrownCost33 && Main.rand.Next(100) < 33)
						{
							flag6 = false;
						}
					}
					if (item.IsACoin)
					{
						flag6 = true;
					}
					bool? flag7 = ItemID.Sets.ForceConsumption[item.type];
					if (flag7.HasValue)
					{
						flag6 = flag7.Value;
					}
					if (flag6 && ItemLoader.ConsumeItem(item, this))
					{
						if (item.stack > 0)
						{
							item.stack--;
						}
						if (item.stack <= 0)
						{
							itemTime = itemAnimation;
							Main.blockMouse = true;
						}
					}
				}
				if (item.stack <= 0 && itemAnimation == 0)
				{
					inventory[selectedItem] = new Item();
				}
				if (selectedItem == 58 && itemAnimation != 0)
				{
					Main.mouseItem = item.Clone();
				}
			}
		}
		if (itemAnimation == 0)
		{
			JustDroppedAnItem = false;
		}
		if (whoAmI == Main.myPlayer && flag)
		{
			PlayerInput.TryEndingFastUse();
		}
	}

	private void UpdatePlacementPreview(Item sItem)
	{
		if (Main.myPlayer == whoAmI && itemAnimation == 0)
		{
			Tile targetTile = Main.tile[tileTargetX, tileTargetY];
			FigureOutWhatToPlace(targetTile, sItem, out var tileToCreate, out var previewPlaceStyle, out var overrideCanPlace, out var forcedRandom);
			PlantLoader.CheckAndInjectModSapling(tileTargetX, tileTargetY, ref tileToCreate, ref previewPlaceStyle);
			if ((!overrideCanPlace.HasValue || overrideCanPlace.Value) && TileObjectData.CustomPlace(tileToCreate, previewPlaceStyle))
			{
				TileObject.CanPlace(tileTargetX, tileTargetY, tileToCreate, previewPlaceStyle, direction, out var _, onlyCheck: true, forcedRandom);
			}
		}
	}

	private void FigureOutWhatToPlace(Tile targetTile, Item sItem, out int tileToCreate, out int previewPlaceStyle, out bool? overrideCanPlace, out int? forcedRandom)
	{
		tileToCreate = sItem.createTile;
		previewPlaceStyle = sItem.placeStyle;
		overrideCanPlace = null;
		forcedRandom = null;
		if (UsingBiomeTorches && tileToCreate == 215 && previewPlaceStyle == 0)
		{
			BiomeCampfirePlaceStyle(ref tileToCreate, ref previewPlaceStyle);
		}
		if (targetTile != null && targetTile.active())
		{
			ushort type = targetTile.type;
			if (tileToCreate == 23 && type == 59)
			{
				tileToCreate = 661;
			}
			if (tileToCreate == 199 && type == 59)
			{
				tileToCreate = 662;
			}
		}
		if (!ModifyFlexibleWandPlacementInfo(ref tileToCreate, ref previewPlaceStyle, ref forcedRandom))
		{
			overrideCanPlace = false;
		}
	}

	private void ItemCheck_OwnerOnlyCode(ref ItemCheckContext context, Item sItem, int weaponDamage, Rectangle heldItemFrame)
	{
		//IL_04a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_04b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_04bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_04c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_03fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_040a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0411: Unknown result type (might be due to invalid IL or missing references)
		//IL_0418: Unknown result type (might be due to invalid IL or missing references)
		//IL_041f: Unknown result type (might be due to invalid IL or missing references)
		//IL_050d: Unknown result type (might be due to invalid IL or missing references)
		//IL_04df: Unknown result type (might be due to invalid IL or missing references)
		//IL_04e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_04e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_053f: Unknown result type (might be due to invalid IL or missing references)
		//IL_054a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0556: Unknown result type (might be due to invalid IL or missing references)
		//IL_0568: Unknown result type (might be due to invalid IL or missing references)
		bool flag = true;
		int type = sItem.type;
		if ((type == 65 || type == 676 || type == 723 || type == 724 || type == 757 || type == 674 || type == 675 || type == 989 || type == 1226 || type == 1227) && !ItemAnimationJustStarted)
		{
			flag = false;
		}
		if (type == 5097 && ItemAnimationJustStarted)
		{
			_batbatCanHeal = true;
		}
		if (type == 5094 && ItemAnimationJustStarted)
		{
			_spawnTentacleSpikes = true;
		}
		if (type == 795 && ItemAnimationJustStarted)
		{
			_spawnBloodButcherer = true;
		}
		if (type == 121 && ItemAnimationJustStarted)
		{
			_spawnVolcanoExplosion = true;
		}
		if (type == 155 && ItemAnimationJustStarted)
		{
			_spawnMuramasaCut = true;
		}
		if (type == 3852 && altFunctionUse == 2 && !ItemAnimationJustStarted)
		{
			flag = false;
		}
		if (type == 5451 && ownedProjectileCounts[1020] > 0)
		{
			flag = false;
		}
		if (sItem.useLimitPerAnimation.HasValue && ItemUsesThisAnimation >= sItem.useLimitPerAnimation.Value)
		{
			flag = false;
		}
		ItemCheck_TurretAltFeatureUse(sItem, flag);
		ItemCheck_MinionAltFeatureUse(sItem, flag);
		bool flag2 = itemAnimation > 0 && ItemTimeIsZero && flag;
		if (sItem.shootsEveryUse)
		{
			flag2 = ItemAnimationJustStarted;
		}
		if (sItem.shoot > 0 && flag2)
		{
			ItemCheck_Shoot(whoAmI, sItem, weaponDamage);
		}
		if (whoAmI != Main.myPlayer)
		{
			return;
		}
		ItemCheck_UseWiringTools(sItem);
		ItemCheck_UseLawnMower(sItem);
		ItemCheck_PlayInstruments(sItem);
		ItemCheck_UseBuckets(sItem);
		if (!channel)
		{
			toolTime = itemTime;
		}
		else
		{
			toolTime--;
			if (toolTime < 0)
			{
				toolTime = CombinedHooks.TotalUseTime(sItem.useTime, this, sItem);
			}
		}
		ItemCheck_TryDestroyingDrones(sItem);
		ItemCheck_UseMiningTools(sItem);
		ItemCheck_UseTeleportRod(sItem);
		ItemCheck_UseLifeCrystal(sItem);
		ItemCheck_UseLifeFruit(sItem);
		ItemCheck_UseManaCrystal(sItem);
		ItemCheck_UseDemonHeart(sItem);
		ItemCheck_UseMinecartPowerUp(sItem);
		ItemCheck_UseTorchGodsFavor(sItem);
		ItemCheck_UseArtisanLoaf(sItem);
		ItemCheck_UseEventItems(sItem);
		ItemCheck_UseBossSpawners(whoAmI, sItem);
		ItemCheck_UseCombatBook(sItem);
		ItemCheck_UsePeddlersSatchel(sItem);
		ItemCheck_UsePetLicenses(sItem);
		ItemCheck_UseShimmerPermanentItems(sItem);
		if (sItem.type == 4095 && itemAnimation == 2)
		{
			Main.LocalGolfState.ResetGolfBall();
		}
		PlaceThing(ref context);
		if (sItem.makeNPC > 0)
		{
			if (!Main.GamepadDisableCursorItemIcon && position.X / 16f - (float)tileRangeX - (float)sItem.tileBoost <= (float)tileTargetX && (position.X + (float)width) / 16f + (float)tileRangeX + (float)sItem.tileBoost - 1f >= (float)tileTargetX && position.Y / 16f - (float)tileRangeY - (float)sItem.tileBoost <= (float)tileTargetY && (position.Y + (float)height) / 16f + (float)tileRangeY + (float)sItem.tileBoost - 2f >= (float)tileTargetY)
			{
				cursorItemIconEnabled = true;
				Main.ItemIconCacheUpdate(sItem.type);
			}
			if (ItemTimeIsZero && itemAnimation > 0 && controlUseItem)
			{
				ItemCheck_ReleaseCritter(sItem);
			}
		}
		if (boneGloveItem != null && !boneGloveItem.IsAir && boneGloveTimer == 0 && itemAnimation > 0 && sItem.damage > 0)
		{
			boneGloveTimer = 60;
			Vector2 center = base.Center;
			Vector2 val = DirectionTo(ApplyRangeCompensation(0.2f, center, Main.MouseWorld)) * 10f;
			Projectile.NewProjectile(GetProjectileSource_Accessory(boneGloveItem), center.X, center.Y, val.X, val.Y, 532, 25, 5f, whoAmI);
		}
		if (((sItem.damage < 0 || sItem.type <= 0 || sItem.noMelee) && sItem.type != 1450 && !ItemID.Sets.CatchingTool[sItem.type] && sItem.type != 3542 && sItem.type != 3779) || itemAnimation <= 0)
		{
			return;
		}
		ItemCheck_GetMeleeHitbox(sItem, heldItemFrame, out var dontAttack, out var itemRectangle);
		if (!dontAttack)
		{
			itemRectangle = ItemCheck_EmitUseVisuals(sItem, itemRectangle);
			if (Main.myPlayer == whoAmI && ItemID.Sets.CatchingTool[sItem.type])
			{
				itemRectangle = ItemCheck_CatchCritters(sItem, itemRectangle);
			}
			if (sItem.type == 3183 || sItem.type == 4821)
			{
				bool[] shouldIgnore = ItemCheck_GetTileCutIgnoreList(sItem);
				ItemCheck_CutTiles(sItem, itemRectangle, shouldIgnore);
			}
			if (sItem.damage > 0)
			{
				UpdateMeleeHitCooldowns();
				float weaponKnockback = GetWeaponKnockback(sItem, sItem.knockBack);
				bool[] shouldIgnore2 = ItemCheck_GetTileCutIgnoreList(sItem);
				ItemCheck_CutTiles(sItem, itemRectangle, shouldIgnore2);
				ItemCheck_MeleeHitNPCs(sItem, itemRectangle, weaponDamage, weaponKnockback);
				ItemCheck_MeleeHitPVP(sItem, itemRectangle, weaponDamage, weaponKnockback);
				ItemCheck_EmitHammushProjectiles(whoAmI, sItem, itemRectangle, weaponDamage);
			}
		}
	}

	private void ItemCheck_EmitFoodParticles(Item sItem)
	{
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		if (itemAnimation < 1)
		{
			return;
		}
		Color[] array = ItemID.Sets.FoodParticleColors[sItem.type];
		if (array != null && array.Length != 0 && Main.rand.Next(2) != 0)
		{
			Vector2? mouthPosition = MouthPosition;
			if (mouthPosition.HasValue)
			{
				Vector2 val = mouthPosition.Value + Main.rand.NextVector2Square(-4f, 4f);
				Vector2 spinningpoint = default(Vector2);
				((Vector2)(ref spinningpoint))..ctor((float)direction, (0f - gravDir) * 0.8f);
				Dust.NewDustPerfect(val, 284, 1.3f * spinningpoint.RotatedBy((float)Math.PI / 5f * Main.rand.NextFloatDirection()), 0, array[Main.rand.Next(array.Length)], 0.8f + 0.2f * Main.rand.NextFloat()).fadeIn = 0f;
			}
		}
	}

	private void ItemCheck_EmitDrinkParticles(Item sItem)
	{
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		if (itemAnimation < 1)
		{
			return;
		}
		Color[] array = ItemID.Sets.DrinkParticleColors[sItem.type];
		if (array != null && array.Length != 0)
		{
			Vector2? mouthPosition = MouthPosition;
			if (mouthPosition.HasValue)
			{
				Vector2 val = mouthPosition.Value + Main.rand.NextVector2Square(-4f, 4f);
				Vector2 spinningpoint = default(Vector2);
				((Vector2)(ref spinningpoint))..ctor((float)direction * 0.1f, (0f - gravDir) * 0.1f);
				Dust.NewDustPerfect(val, 284, 1.3f * spinningpoint.RotatedBy(-(float)Math.PI / 5f * Main.rand.NextFloatDirection()), 0, array[Main.rand.Next(array.Length)] * 0.7f, 0.8f + 0.2f * Main.rand.NextFloat()).fadeIn = 0f;
			}
		}
	}

	private void ItemCheck_UseBossSpawners(int onWhichPlayer, Item sItem)
	{
		if (!ItemTimeIsZero || itemAnimation <= 0 || (sItem.type != 43 && sItem.type != 70 && sItem.type != 544 && sItem.type != 556 && sItem.type != 557 && sItem.type != 560 && sItem.type != 1133 && sItem.type != 1331 && sItem.type != 4988 && sItem.type != 5120 && sItem.type != 5334) || !SummonItemCheck(sItem))
		{
			return;
		}
		if (sItem.type == 560)
		{
			ApplyItemTime(sItem);
			SoundEngine.PlaySound(15, (int)position.X, (int)position.Y, 0);
			if (Main.netMode != 1)
			{
				NPC.SpawnOnPlayer(onWhichPlayer, 50);
			}
			else
			{
				NetMessage.SendData(61, -1, -1, null, whoAmI, 50f);
			}
		}
		else if (sItem.type == 43)
		{
			if (!Main.IsItDay())
			{
				ApplyItemTime(sItem);
				SoundEngine.PlaySound(15, (int)position.X, (int)position.Y, 0);
				if (Main.netMode != 1)
				{
					NPC.SpawnOnPlayer(onWhichPlayer, 4);
				}
				else
				{
					NetMessage.SendData(61, -1, -1, null, whoAmI, 4f);
				}
			}
		}
		else if (sItem.type == 70)
		{
			if (ZoneCorrupt)
			{
				ApplyItemTime(sItem);
				SoundEngine.PlaySound(15, (int)position.X, (int)position.Y, 0);
				if (Main.netMode != 1)
				{
					NPC.SpawnOnPlayer(onWhichPlayer, 13);
				}
				else
				{
					NetMessage.SendData(61, -1, -1, null, whoAmI, 13f);
				}
			}
		}
		else if (sItem.type == 544)
		{
			if (!Main.IsItDay() && sItem.Variant != ItemVariants.DisabledBossSummonVariant)
			{
				ApplyItemTime(sItem);
				SoundEngine.PlaySound(15, (int)position.X, (int)position.Y, 0);
				if (Main.netMode != 1)
				{
					NPC.SpawnOnPlayer(onWhichPlayer, 125);
					NPC.SpawnOnPlayer(onWhichPlayer, 126);
				}
				else
				{
					NetMessage.SendData(61, -1, -1, null, whoAmI, 125f);
					NetMessage.SendData(61, -1, -1, null, whoAmI, 126f);
				}
			}
		}
		else if (sItem.type == 556)
		{
			if (!Main.IsItDay() && sItem.Variant != ItemVariants.DisabledBossSummonVariant)
			{
				ApplyItemTime(sItem);
				SoundEngine.PlaySound(15, (int)position.X, (int)position.Y, 0);
				if (Main.netMode != 1)
				{
					NPC.SpawnOnPlayer(onWhichPlayer, 134);
				}
				else
				{
					NetMessage.SendData(61, -1, -1, null, whoAmI, 134f);
				}
			}
		}
		else if (sItem.type == 557)
		{
			if (!Main.IsItDay() && sItem.Variant != ItemVariants.DisabledBossSummonVariant)
			{
				ApplyItemTime(sItem);
				SoundEngine.PlaySound(15, (int)position.X, (int)position.Y, 0);
				if (Main.netMode != 1)
				{
					NPC.SpawnOnPlayer(onWhichPlayer, 127);
				}
				else
				{
					NetMessage.SendData(61, -1, -1, null, whoAmI, 127f);
				}
			}
		}
		else if (sItem.type == 5334)
		{
			if (NPC.SpawnMechQueen(whoAmI))
			{
				ApplyItemTime(sItem);
				SoundEngine.PlaySound(15, (int)position.X, (int)position.Y, 0);
			}
		}
		else if (sItem.type == 1133)
		{
			ApplyItemTime(sItem);
			SoundEngine.PlaySound(SoundID.Item173, (int)position.X, (int)position.Y);
			if (Main.netMode != 1)
			{
				NPC.SpawnOnPlayer(onWhichPlayer, 222);
			}
			else
			{
				NetMessage.SendData(61, -1, -1, null, whoAmI, 222f);
			}
		}
		else if (sItem.type == 1331)
		{
			if (ZoneCrimson)
			{
				ApplyItemTime(sItem);
				SoundEngine.PlaySound(15, (int)position.X, (int)position.Y, 0);
				if (Main.netMode != 1)
				{
					NPC.SpawnOnPlayer(onWhichPlayer, 266);
				}
				else
				{
					NetMessage.SendData(61, -1, -1, null, whoAmI, 266f);
				}
			}
		}
		else if (sItem.type == 4988)
		{
			if (ZoneHallow)
			{
				ApplyItemTime(sItem);
				SoundEngine.PlaySound(15, (int)position.X, (int)position.Y, 0);
				if (Main.netMode != 1)
				{
					NPC.SpawnOnPlayer(onWhichPlayer, 657);
				}
				else
				{
					NetMessage.SendData(61, -1, -1, null, whoAmI, 657f);
				}
			}
		}
		else if (sItem.type == 5120 && ZoneSnow)
		{
			ApplyItemTime(sItem);
			SoundEngine.PlaySound(15, (int)position.X, (int)position.Y, 0);
			if (Main.netMode != 1)
			{
				NPC.SpawnOnPlayer(onWhichPlayer, 668);
			}
			else
			{
				NetMessage.SendData(61, -1, -1, null, whoAmI, 668f);
			}
		}
	}

	private void ItemCheck_UseEventItems(Item sItem)
	{
		if (ItemTimeIsZero && itemAnimation > 0 && sItem.type == 361 && Main.CanStartInvasion(1, ignoreDelay: true))
		{
			ApplyItemTime(sItem);
			SoundEngine.PlaySound(15, (int)position.X, (int)position.Y, 0);
			if (Main.netMode != 1)
			{
				if (Main.invasionType == 0)
				{
					Main.invasionDelay = 0;
					Main.StartInvasion();
				}
			}
			else
			{
				NetMessage.SendData(61, -1, -1, null, whoAmI, -1f);
			}
		}
		if (ItemTimeIsZero && itemAnimation > 0 && sItem.type == 602 && Main.CanStartInvasion(2, ignoreDelay: true))
		{
			ApplyItemTime(sItem);
			SoundEngine.PlaySound(15, (int)position.X, (int)position.Y, 0);
			if (Main.netMode != 1)
			{
				if (Main.invasionType == 0)
				{
					Main.invasionDelay = 0;
					Main.StartInvasion(2);
				}
			}
			else
			{
				NetMessage.SendData(61, -1, -1, null, whoAmI, -2f);
			}
		}
		if (ItemTimeIsZero && itemAnimation > 0 && sItem.type == 1315 && Main.CanStartInvasion(3, ignoreDelay: true))
		{
			ApplyItemTime(sItem);
			SoundEngine.PlaySound(15, (int)position.X, (int)position.Y, 0);
			if (Main.netMode != 1)
			{
				if (Main.invasionType == 0)
				{
					Main.invasionDelay = 0;
					Main.StartInvasion(3);
				}
			}
			else
			{
				NetMessage.SendData(61, -1, -1, null, whoAmI, -3f);
			}
		}
		if (ItemTimeIsZero && itemAnimation > 0 && sItem.type == 1844 && !Main.dayTime && !Main.pumpkinMoon && !Main.snowMoon && !DD2Event.Ongoing)
		{
			ApplyItemTime(sItem);
			SoundEngine.PlaySound(15, (int)position.X, (int)position.Y, 0);
			if (Main.netMode != 1)
			{
				Main.NewText(Lang.misc[31].Value, 50, byte.MaxValue, 130);
				Main.startPumpkinMoon();
			}
			else
			{
				NetMessage.SendData(61, -1, -1, null, whoAmI, -4f);
			}
		}
		if (ItemTimeIsZero && itemAnimation > 0 && sItem.type == 2767 && Main.dayTime && !Main.eclipse)
		{
			SoundEngine.PlaySound(15, (int)position.X, (int)position.Y, 0);
			ApplyItemTime(sItem);
			if (Main.netMode == 0)
			{
				Main.eclipse = true;
				if (Main.remixWorld)
				{
					Main.NewText(Lang.misc[106].Value, 50, byte.MaxValue, 130);
				}
				else
				{
					Main.NewText(Lang.misc[20].Value, 50, byte.MaxValue, 130);
				}
			}
			else
			{
				NetMessage.SendData(61, -1, -1, null, whoAmI, -6f);
			}
		}
		if (ItemTimeIsZero && itemAnimation > 0 && sItem.type == 4271 && !Main.dayTime && !Main.bloodMoon)
		{
			SoundEngine.PlaySound(15, (int)position.X, (int)position.Y, 0);
			ApplyItemTime(sItem);
			if (Main.netMode == 0)
			{
				AchievementsHelper.NotifyProgressionEvent(4);
				Main.bloodMoon = true;
				if (Main.GetMoonPhase() == MoonPhase.Empty)
				{
					Main.moonPhase = 5;
				}
				Main.NewText(Lang.misc[8].Value, 50, byte.MaxValue, 130);
			}
			else
			{
				NetMessage.SendData(61, -1, -1, null, whoAmI, -10f);
			}
		}
		if (ItemTimeIsZero && itemAnimation > 0 && sItem.type == 3601 && NPC.downedGolemBoss && Main.hardMode && !NPC.AnyDanger() && !NPC.AnyoneNearCultists())
		{
			SoundEngine.PlaySound(15, (int)position.X, (int)position.Y, 0);
			ApplyItemTime(sItem);
			if (Main.netMode == 0)
			{
				WorldGen.StartImpendingDoom(720);
			}
			else
			{
				NetMessage.SendData(61, -1, -1, null, whoAmI, -8f);
			}
		}
		if (ItemTimeIsZero && itemAnimation > 0 && sItem.type == 1958 && !Main.dayTime && !Main.pumpkinMoon && !Main.snowMoon && !DD2Event.Ongoing)
		{
			ApplyItemTime(sItem);
			SoundEngine.PlaySound(15, (int)position.X, (int)position.Y, 0);
			if (Main.netMode != 1)
			{
				Main.NewText(Lang.misc[34].Value, 50, byte.MaxValue, 130);
				Main.startSnowMoon();
			}
			else
			{
				NetMessage.SendData(61, -1, -1, null, whoAmI, -5f);
			}
		}
	}

	private void ItemCheck_ReleaseCritter(Item sItem)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		if (sItem.makeNPC == 614)
		{
			ApplyItemTime(sItem);
			NPC.ReleaseNPC((int)base.Center.X, (int)base.Bottom.Y, sItem.makeNPC, sItem.placeStyle, whoAmI);
		}
		else if (position.X / 16f - (float)tileRangeX - (float)sItem.tileBoost <= (float)tileTargetX && (position.X + (float)width) / 16f + (float)tileRangeX + (float)sItem.tileBoost - 1f >= (float)tileTargetX && position.Y / 16f - (float)tileRangeY - (float)sItem.tileBoost <= (float)tileTargetY && (position.Y + (float)height) / 16f + (float)tileRangeY + (float)sItem.tileBoost - 2f >= (float)tileTargetY)
		{
			int num = (int)Main.MouseWorld.X;
			int num2 = (int)Main.MouseWorld.Y;
			int i = num / 16;
			int j = num2 / 16;
			if (!WorldGen.SolidTile(i, j))
			{
				ApplyItemTime(sItem);
				NPC.ReleaseNPC(num, num2, sItem.makeNPC, sItem.placeStyle, whoAmI);
			}
		}
	}

	private void ItemCheck_MeleeHitPVP(Item sItem, Rectangle itemRectangle, int damage, float knockBack)
	{
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_014a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0161: Unknown result type (might be due to invalid IL or missing references)
		//IL_0166: Unknown result type (might be due to invalid IL or missing references)
		//IL_016a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0175: Unknown result type (might be due to invalid IL or missing references)
		//IL_0182: Unknown result type (might be due to invalid IL or missing references)
		//IL_018d: Unknown result type (might be due to invalid IL or missing references)
		//IL_019f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0263: Unknown result type (might be due to invalid IL or missing references)
		//IL_026e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0348: Unknown result type (might be due to invalid IL or missing references)
		//IL_034e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0358: Unknown result type (might be due to invalid IL or missing references)
		//IL_035e: Unknown result type (might be due to invalid IL or missing references)
		if (!hostile)
		{
			return;
		}
		Vector2 val = default(Vector2);
		Vector2 val2 = default(Vector2);
		for (int i = 0; i < 255; i++)
		{
			Player player = Main.player[i];
			if (i == whoAmI || !player.active || !player.hostile || player.immune || player.dead || (team != 0 && team == player.team) || !((Rectangle)(ref itemRectangle)).Intersects(player.Hitbox) || !CanHit(player) || !CombinedHooks.CanHitPvp(this, sItem, player))
			{
				continue;
			}
			bool flag = false;
			int num = Main.DamageVar(damage, luck);
			StatusToPlayerPvP(sItem.type, i);
			OnHit(player.Center.X, player.Center.Y, player);
			PlayerDeathReason playerDeathReason = PlayerDeathReason.ByPlayerItem(whoAmI, sItem);
			int num2 = (int)player.Hurt(playerDeathReason, num, direction, pvp: true, quiet: false, flag, -1);
			if (inventory[selectedItem].type == 3211)
			{
				((Vector2)(ref val))..ctor((float)(direction * 100 + Main.rand.Next(-25, 26)), (float)Main.rand.Next(-75, 76));
				((Vector2)(ref val)).Normalize();
				val *= (float)Main.rand.Next(30, 41) * 0.1f;
				((Vector2)(ref val2))..ctor((float)(itemRectangle.X + Main.rand.Next(itemRectangle.Width)), (float)(itemRectangle.Y + Main.rand.Next(itemRectangle.Height)));
				val2 = (val2 + player.Center * 2f) / 3f;
				Projectile.NewProjectile(GetProjectileSource_Item(HeldItem), val2.X, val2.Y, val.X, val.Y, 524, (int)((double)damage * 0.7), knockBack * 0.7f, whoAmI);
			}
			if (sItem.type == 5097)
			{
				BatBat_TryLifeLeeching(player);
			}
			if (beetleOffense)
			{
				beetleCounter += num2;
				beetleCountdown = 0;
			}
			if (meleeEnchant == 7)
			{
				Projectile.NewProjectile(GetProjectileSource_Misc(8), player.Center.X, player.Center.Y, player.velocity.X, player.velocity.Y, 289, 0, 0f, whoAmI);
			}
			if (sItem.type == 1123)
			{
				int num3 = Main.rand.Next(1, 4);
				if (strongBees && Main.rand.Next(3) == 0)
				{
					num3++;
				}
				for (int j = 0; j < num3; j++)
				{
					float num4 = (float)(direction * 2) + (float)Main.rand.Next(-35, 36) * 0.02f;
					float num5 = (float)Main.rand.Next(-35, 36) * 0.02f;
					num4 *= 0.2f;
					num5 *= 0.2f;
					int num6 = Projectile.NewProjectile(GetProjectileSource_Item(sItem), itemRectangle.X + itemRectangle.Width / 2, itemRectangle.Y + itemRectangle.Height / 2, num4, num5, beeType(), beeDamage(num / 3), beeKB(0f), whoAmI);
					Main.projectile[num6].melee = true;
				}
			}
			if (inventory[selectedItem].type == 3106)
			{
				stealth = 1f;
				if (Main.netMode == 1)
				{
					NetMessage.SendData(84, -1, -1, null, whoAmI);
				}
			}
			if (Main.netMode != 0)
			{
				NetMessage.SendPlayerHurt(i, playerDeathReason, num, direction, flag, pvp: true, -1);
			}
			ApplyAttackCooldown();
		}
	}

	private void Volcano_TrySpawningVolcano(NPC npc, Item sItem, float damage, float knockBack, Rectangle itemRectangle)
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		if (_spawnVolcanoExplosion && Main.myPlayer == whoAmI && (npc == null || npc.HittableForOnHitRewards()))
		{
			Vector2 center = npc.Center;
			int num = 2;
			Projectile.NewProjectile(GetProjectileSource_Item(sItem), center.X, center.Y, 0f, -1f * gravDir, 978, (int)damage, knockBack, whoAmI, 0f, num);
			_spawnVolcanoExplosion = false;
		}
	}

	private void TentacleSpike_TrySpiking(NPC npc, Item sItem, float damage, float knockBack)
	{
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		if (_spawnTentacleSpikes && Main.myPlayer == whoAmI && (npc == null || npc.CanBeChasedBy(this)))
		{
			Vector2 v = npc.Center - MountedCenter;
			v = v.SafeNormalize(Vector2.Zero);
			Vector2 val = npc.Hitbox.ClosestPointInRect(MountedCenter) + v;
			Vector2 val2 = (npc.Center - val) * 0.8f;
			int num = Projectile.NewProjectile(GetProjectileSource_Item(sItem), val.X, val.Y, val2.X, val2.Y, 971, (int)damage, knockBack, whoAmI, 1f, npc.whoAmI);
			Main.projectile[num].StatusNPC(npc.whoAmI);
			Projectile.KillOldestJavelin(num, 971, npc.whoAmI, _tentacleSpikesMax5);
			_spawnTentacleSpikes = false;
		}
	}

	private void BloodButcherer_TryButchering(NPC npc, Item sItem, float damage, float knockBack)
	{
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		if (_spawnBloodButcherer && Main.myPlayer == whoAmI && (npc == null || npc.CanBeChasedBy(this)))
		{
			Vector2 v = npc.Center - MountedCenter;
			v = v.SafeNormalize(Vector2.Zero);
			Vector2 val = npc.Hitbox.ClosestPointInRect(MountedCenter) + v;
			Vector2 spinningpoint = (npc.Center - val) * 0.8f;
			spinningpoint = spinningpoint.RotatedBy(Main.rand.NextFloatDirection() * (float)Math.PI * 0.25f);
			int num = Projectile.NewProjectile(GetProjectileSource_Item(sItem), val.X, val.Y, spinningpoint.X, spinningpoint.Y, 975, (int)damage, knockBack, whoAmI, 1f, npc.whoAmI);
			Main.projectile[num].StatusNPC(npc.whoAmI);
			Projectile.KillOldestJavelin(num, 975, npc.whoAmI, _bloodButchererMax5);
			_spawnBloodButcherer = false;
		}
	}

	private void BatBat_TryLifeLeeching(Entity entity)
	{
		if (_batbatCanHeal && statLife < statLifeMax2 && (!(entity is NPC nPC) || nPC.HittableForOnHitRewards()))
		{
			_batbatCanHeal = false;
			Heal(1);
		}
	}

	public bool HasNPCBannerBuff(int bannerType)
	{
		return Main.SceneMetrics.NPCBannerBuff[bannerType];
	}

	public void ResetMeleeHitCooldowns()
	{
		if (Main.myPlayer == whoAmI)
		{
			for (int i = 0; i < 200; i++)
			{
				meleeNPCHitCooldown[i] = 0;
			}
		}
	}

	public void UpdateMeleeHitCooldowns()
	{
		if (Main.myPlayer == whoAmI)
		{
			for (int i = 0; i < 200; i++)
			{
				meleeNPCHitCooldown[i]--;
			}
		}
	}

	public bool CanHitNPCWithMeleeHit(int npcIndex)
	{
		return meleeNPCHitCooldown[npcIndex] <= 0;
	}

	public void SetMeleeHitCooldown(int npcIndex, int timeInFrames)
	{
		meleeNPCHitCooldown[npcIndex] = timeInFrames;
	}

	private void ItemCheck_MeleeHitNPCs(Item sItem, Rectangle itemRectangle, int originalDamage, float knockBack)
	{
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < 200; i++)
		{
			NPC nPC = Main.npc[i];
			if (nPC.active && nPC.immune[whoAmI] == 0 && CanHitNPCWithMeleeHit(i) && attackCD <= 0)
			{
				nPC.position += nPC.netOffset;
				ProcessHitAgainstNPC(sItem, itemRectangle, originalDamage, knockBack, i);
				nPC.position -= nPC.netOffset;
			}
		}
	}

	public void TakeDamageFromJellyfish(int npcIndex)
	{
		NPC nPC = Main.npc[npcIndex];
		Hurt(PlayerDeathReason.ByNPC(npcIndex), (int)((double)nPC.damage * 1.3), -direction);
		SetMeleeHitCooldown(npcIndex, itemAnimation);
		ApplyAttackCooldown();
	}

	private void ProcessHitAgainstNPC(Item sItem, Rectangle itemRectangle, int originalDamage, float knockBack, int npcIndex)
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0172: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_014a: Unknown result type (might be due to invalid IL or missing references)
		//IL_014c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0337: Unknown result type (might be due to invalid IL or missing references)
		//IL_033c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0341: Unknown result type (might be due to invalid IL or missing references)
		//IL_0344: Unknown result type (might be due to invalid IL or missing references)
		//IL_0349: Unknown result type (might be due to invalid IL or missing references)
		//IL_034b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0350: Unknown result type (might be due to invalid IL or missing references)
		//IL_035e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0360: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_03fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0432: Unknown result type (might be due to invalid IL or missing references)
		//IL_0437: Unknown result type (might be due to invalid IL or missing references)
		//IL_046d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0472: Unknown result type (might be due to invalid IL or missing references)
		//IL_053e: Unknown result type (might be due to invalid IL or missing references)
		//IL_04a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_04b4: Unknown result type (might be due to invalid IL or missing references)
		NPC nPC = Main.npc[npcIndex];
		if (nPC.dontTakeDamage || !CanNPCBeHitByPlayerOrPlayerProjectile(nPC))
		{
			if (NPCID.Sets.ZappingJellyfish[nPC.type] && ((Rectangle)(ref itemRectangle)).Intersects(nPC.Hitbox) && (nPC.noTileCollide || CanHit(nPC)))
			{
				TakeDamageFromJellyfish(npcIndex);
			}
			return;
		}
		bool? flag = CombinedHooks.CanPlayerHitNPCWithItem(this, sItem, nPC);
		if (!(flag ?? true) || (!(flag ?? false) && nPC.friendly && (nPC.type != 22 || !killGuide) && (nPC.type != 54 || !killClothier) && (!nPC.isLikeATownNPC || sItem.type != 5129)))
		{
			return;
		}
		Rectangle val = default(Rectangle);
		((Rectangle)(ref val))..ctor((int)nPC.position.X, (int)nPC.position.Y, nPC.width, nPC.height);
		bool flag2 = ((Rectangle)(ref itemRectangle)).Intersects(val);
		if (sItem.type == 121)
		{
			GetPointOnSwungItemPath(70f, 70f, 0f, GetAdjustedItemScale(sItem), out var location, out var outwardDirection);
			GetPointOnSwungItemPath(70f, 70f, 0.9f, GetAdjustedItemScale(sItem), out var location2, out outwardDirection);
			bool flag3 = Utils.LineRectangleDistance(val, location, location2) <= 16f;
			flag2 = ((!_spawnVolcanoExplosion) ? (flag2 || flag3) : flag3);
		}
		bool? flag4 = CombinedHooks.CanPlayerMeleeAttackCollideWithNPC(this, sItem, itemRectangle, nPC);
		if (flag4 == false)
		{
			return;
		}
		if (flag4 == true)
		{
			flag2 = true;
		}
		if (!flag2 || (!nPC.noTileCollide && !CanHit(nPC)))
		{
			return;
		}
		NPC.HitModifiers modifiers = nPC.GetIncomingStrikeModifiers(sItem.DamageType, direction);
		float num = 1000f;
		bool crit = false;
		if (sItem.DamageType.UseStandardCritCalcs)
		{
			int weaponCrit = GetWeaponCrit(sItem);
			if (Main.rand.Next(1, 101) <= weaponCrit)
			{
				crit = true;
			}
		}
		ApplyBannerOffenseBuff(nPC, ref modifiers);
		if (parryDamageBuff && sItem.melee)
		{
			modifiers.ScalingBonusDamage += 4f;
			parryDamageBuff = false;
			ClearBuff(198);
		}
		if (sItem.type == 426 && (float)nPC.life >= (float)nPC.lifeMax * 0.9f)
		{
			num = (int)(num * 2.5f);
		}
		if (sItem.type == 5096)
		{
			int num2 = 0;
			if (FindBuffIndex(26) != -1)
			{
				num2 = 1;
			}
			if (FindBuffIndex(206) != -1)
			{
				num2 = 2;
			}
			if (FindBuffIndex(207) != -1)
			{
				num2 = 3;
			}
			float num3 = 1f + 0.05f * (float)num2;
			num = (int)(num * num3);
		}
		if (sItem.type == 671)
		{
			float t = (float)nPC.life / (float)nPC.lifeMax;
			float lerpValue = Utils.GetLerpValue(1f, 0.1f, t, clamped: true);
			float num4 = 1f * lerpValue;
			num = (int)(num * (1f + num4));
			Vector2 point = ((Rectangle)(ref itemRectangle)).Center.ToVector2();
			Vector2 positionInWorld = nPC.Hitbox.ClosestPointInRect(point);
			ParticleOrchestrator.RequestParticleSpawn(clientOnly: false, ParticleOrchestraType.Keybrand, new ParticleOrchestraSettings
			{
				PositionInWorld = positionInWorld
			}, whoAmI);
		}
		modifiers.SourceDamage *= num / 1000f;
		float num5 = 0f;
		if (sItem.type == 5129 && nPC.isLikeATownNPC)
		{
			num5 = 1f;
			if (nPC.type == 18)
			{
				modifiers.TargetDamageMultiplier *= 2f;
			}
		}
		if (sItem.type == 3258)
		{
			ParticleOrchestraSettings settings = new ParticleOrchestraSettings
			{
				PositionInWorld = nPC.Center
			};
			ParticleOrchestrator.RequestParticleSpawn(clientOnly: false, ParticleOrchestraType.SlapHand, settings, whoAmI);
		}
		if (sItem.type == 5382)
		{
			ParticleOrchestraSettings settings2 = new ParticleOrchestraSettings
			{
				PositionInWorld = nPC.Center
			};
			ParticleOrchestrator.RequestParticleSpawn(clientOnly: false, ParticleOrchestraType.WaffleIron, settings2, whoAmI);
		}
		if (sItem.type == 5129)
		{
			ParticleOrchestraSettings settings3 = new ParticleOrchestraSettings
			{
				PositionInWorld = nPC.Center
			};
			ParticleOrchestrator.RequestParticleSpawn(clientOnly: false, ParticleOrchestraType.FlyMeal, settings3, whoAmI);
		}
		StatusToNPC(sItem.type, npcIndex);
		if (nPC.life > 5)
		{
			OnHit(nPC.Center.X, nPC.Center.Y, nPC);
		}
		modifiers.ArmorPenetration += (float)GetWeaponArmorPenetration(sItem);
		modifiers.ScalingArmorPenetration += num5;
		CombinedHooks.ModifyPlayerHitNPCWithItem(this, sItem, nPC, ref modifiers);
		NPC.HitInfo hit = modifiers.ToHitInfo(originalDamage, crit, knockBack, damageVariation: true, luck);
		NPCKillAttempt attempt = new NPCKillAttempt(nPC);
		int num6 = nPC.StrikeNPC(hit);
		CombinedHooks.OnPlayerHitNPCWithItem(this, sItem, nPC, in hit, num6);
		ApplyNPCOnHitEffects(sItem, itemRectangle, hit.SourceDamage, hit.Knockback, npcIndex, hit.SourceDamage, num6);
		int num7 = Item.NPCtoBanner(nPC.BannerID());
		if (num7 >= 0)
		{
			lastCreatureHit = num7;
		}
		if (Main.netMode != 0)
		{
			NetMessage.SendStrikeNPC(nPC, in hit);
		}
		if (accDreamCatcher && !nPC.HideStrikeDamage)
		{
			addDPS(num6);
		}
		SetMeleeHitCooldown(npcIndex, itemAnimation);
		if (attempt.DidNPCDie())
		{
			OnKillNPC(ref attempt, sItem);
		}
		ApplyAttackCooldown();
	}

	public void ApplyAttackCooldown()
	{
		attackCD = Math.Max(1, (int)((double)itemAnimationMax * 0.33));
	}

	public void ApplyAttackCooldown(int frames)
	{
		if (attackCD < frames)
		{
			attackCD = frames;
		}
	}

	private void ApplyNPCOnHitEffects(Item sItem, Rectangle itemRectangle, int damage, float knockBack, int npcIndex, int dmgRandomized, int dmgDone)
	{
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_015f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0171: Unknown result type (might be due to invalid IL or missing references)
		//IL_0267: Unknown result type (might be due to invalid IL or missing references)
		//IL_031d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0323: Unknown result type (might be due to invalid IL or missing references)
		//IL_032d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0333: Unknown result type (might be due to invalid IL or missing references)
		//IL_03df: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0402: Unknown result type (might be due to invalid IL or missing references)
		//IL_0404: Unknown result type (might be due to invalid IL or missing references)
		//IL_0409: Unknown result type (might be due to invalid IL or missing references)
		//IL_040d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0412: Unknown result type (might be due to invalid IL or missing references)
		//IL_0417: Unknown result type (might be due to invalid IL or missing references)
		//IL_0418: Unknown result type (might be due to invalid IL or missing references)
		//IL_041a: Unknown result type (might be due to invalid IL or missing references)
		//IL_042c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0431: Unknown result type (might be due to invalid IL or missing references)
		//IL_043b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0440: Unknown result type (might be due to invalid IL or missing references)
		//IL_0480: Unknown result type (might be due to invalid IL or missing references)
		//IL_048d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0493: Unknown result type (might be due to invalid IL or missing references)
		//IL_0495: Unknown result type (might be due to invalid IL or missing references)
		//IL_049a: Unknown result type (might be due to invalid IL or missing references)
		//IL_04b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_04b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_04b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_04bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_04c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_04c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_04d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_04d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_04db: Unknown result type (might be due to invalid IL or missing references)
		//IL_04e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_04ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_04f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_04fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_04ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0504: Unknown result type (might be due to invalid IL or missing references)
		//IL_050d: Unknown result type (might be due to invalid IL or missing references)
		//IL_050f: Unknown result type (might be due to invalid IL or missing references)
		bool flag = !Main.npc[npcIndex].immortal;
		if (sItem.type == 3211)
		{
			Vector2 val = default(Vector2);
			((Vector2)(ref val))..ctor((float)(direction * 100 + Main.rand.Next(-25, 26)), (float)Main.rand.Next(-75, 76));
			((Vector2)(ref val)).Normalize();
			val *= (float)Main.rand.Next(30, 41) * 0.1f;
			Vector2 val2 = default(Vector2);
			((Vector2)(ref val2))..ctor((float)(itemRectangle.X + Main.rand.Next(itemRectangle.Width)), (float)(itemRectangle.Y + Main.rand.Next(itemRectangle.Height)));
			val2 = (val2 + Main.npc[npcIndex].Center * 2f) / 3f;
			Projectile.NewProjectile(GetProjectileSource_Item(sItem), val2.X, val2.Y, val.X, val.Y, 524, (int)((double)damage * 0.5), knockBack * 0.7f, whoAmI);
		}
		if (beetleOffense && flag)
		{
			beetleCounter += dmgDone;
			beetleCountdown = 0;
		}
		if (meleeEnchant == 7)
		{
			Projectile.NewProjectile(GetProjectileSource_Misc(8), Main.npc[npcIndex].Center.X, Main.npc[npcIndex].Center.Y, Main.npc[npcIndex].velocity.X, Main.npc[npcIndex].velocity.Y, 289, 0, 0f, whoAmI);
		}
		if (sItem.type == 3106)
		{
			stealth = 1f;
			if (Main.netMode == 1)
			{
				NetMessage.SendData(84, -1, -1, null, whoAmI);
			}
		}
		if (sItem.type == 5094)
		{
			TentacleSpike_TrySpiking(Main.npc[npcIndex], sItem, damage, knockBack);
		}
		if (sItem.type == 795)
		{
			BloodButcherer_TryButchering(Main.npc[npcIndex], sItem, damage, knockBack);
		}
		if (sItem.type == 121)
		{
			Volcano_TrySpawningVolcano(Main.npc[npcIndex], sItem, (int)((float)damage * 0.75f), knockBack, itemRectangle);
		}
		if (sItem.type == 5097)
		{
			BatBat_TryLifeLeeching(Main.npc[npcIndex]);
		}
		if (sItem.type == 1123 && flag)
		{
			int num = Main.rand.Next(1, 4);
			if (strongBees && Main.rand.Next(3) == 0)
			{
				num++;
			}
			for (int i = 0; i < num; i++)
			{
				float num2 = (float)(direction * 2) + (float)Main.rand.Next(-35, 36) * 0.02f;
				float num3 = (float)Main.rand.Next(-35, 36) * 0.02f;
				num2 *= 0.2f;
				num3 *= 0.2f;
				int num4 = Projectile.NewProjectile(GetProjectileSource_Item(sItem), itemRectangle.X + itemRectangle.Width / 2, itemRectangle.Y + itemRectangle.Height / 2, num2, num3, beeType(), beeDamage(dmgRandomized / 3), beeKB(0f), whoAmI);
				Main.projectile[num4].melee = true;
			}
		}
		if (sItem.type == 155 && flag && _spawnMuramasaCut)
		{
			_spawnMuramasaCut = false;
			int num5 = Main.rand.Next(1, 4);
			num5 = 1;
			for (int j = 0; j < num5; j++)
			{
				NPC nPC = Main.npc[npcIndex];
				Rectangle hitbox = nPC.Hitbox;
				((Rectangle)(ref hitbox)).Inflate(30, 16);
				hitbox.Y -= 8;
				Vector2 val3 = Main.rand.NextVector2FromRectangle(hitbox);
				Vector2 val4 = ((Rectangle)(ref hitbox)).Center.ToVector2();
				Vector2 spinningpoint = (val4 - val3).SafeNormalize(new Vector2((float)direction, gravDir)) * 8f;
				Main.rand.NextFloat();
				float num6 = (float)(Main.rand.Next(2) * 2 - 1) * ((float)Math.PI / 5f + (float)Math.PI * 4f / 5f * Main.rand.NextFloat());
				num6 *= 0.5f;
				spinningpoint = spinningpoint.RotatedBy(0.7853981852531433);
				int num7 = 3;
				int num8 = 10 * num7;
				int num9 = 5;
				int num10 = num9 * num7;
				val3 = val4;
				for (int k = 0; k < num10; k++)
				{
					val3 -= spinningpoint;
					spinningpoint = spinningpoint.RotatedBy((0f - num6) / (float)num8);
				}
				val3 += nPC.velocity * (float)num9;
				Projectile.NewProjectile(GetProjectileSource_Item(sItem), val3, spinningpoint, 977, (int)((float)dmgRandomized * 0.5f), 0f, whoAmI, num6);
			}
		}
		if (Main.npc[npcIndex].value > 0f && hasLuckyCoin && Main.rand.Next(5) == 0)
		{
			int type = 71;
			if (Main.rand.Next(10) == 0)
			{
				type = 72;
			}
			if (Main.rand.Next(100) == 0)
			{
				type = 73;
			}
			int num11 = Item.NewItem(GetItemSource_OnHit(Main.npc[npcIndex], 2), (int)Main.npc[npcIndex].position.X, (int)Main.npc[npcIndex].position.Y, Main.npc[npcIndex].width, Main.npc[npcIndex].height, type);
			Main.item[num11].stack = Main.rand.Next(1, 11);
			Main.item[num11].velocity.Y = (float)Main.rand.Next(-20, 1) * 0.2f;
			Main.item[num11].velocity.X = (float)Main.rand.Next(10, 31) * 0.2f * (float)direction;
			Main.item[num11].timeLeftInWhichTheItemCannotBeTakenByEnemies = 60;
			if (Main.netMode == 1)
			{
				NetMessage.SendData(148, -1, -1, null, num11);
			}
		}
	}

	private void ItemCheck_EmitHammushProjectiles(int i, Item sItem, Rectangle itemRectangle, int damage)
	{
		//IL_0204: Unknown result type (might be due to invalid IL or missing references)
		//IL_020a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0217: Unknown result type (might be due to invalid IL or missing references)
		//IL_021d: Unknown result type (might be due to invalid IL or missing references)
		if (sItem.type != 787)
		{
			return;
		}
		int num = itemAnimationMax;
		if (itemAnimation != (int)((double)num * 0.1) && itemAnimation != (int)((double)num * 0.3) && itemAnimation != (int)((double)num * 0.5) && itemAnimation != (int)((double)num * 0.7) && itemAnimation != (int)((double)num * 0.9))
		{
			return;
		}
		float num2 = 0f;
		float num3 = 0f;
		float num4 = 0f;
		float num5 = 0f;
		if (itemAnimation == (int)((double)num * 0.9))
		{
			num2 = -7f;
		}
		if (itemAnimation == (int)((double)num * 0.7))
		{
			num2 = -6f;
			num3 = 2f;
		}
		if (itemAnimation == (int)((double)num * 0.5))
		{
			num2 = -4f;
			num3 = 4f;
		}
		if (itemAnimation == (int)((double)num * 0.3))
		{
			num2 = -2f;
			num3 = 6f;
		}
		if (itemAnimation == (int)((double)num * 0.1))
		{
			num3 = 7f;
		}
		if (itemAnimation == (int)((double)num * 0.7))
		{
			num5 = 26f;
		}
		if (itemAnimation == (int)((double)num * 0.3))
		{
			num5 -= 4f;
			num4 -= 20f;
		}
		if (itemAnimation == (int)((double)num * 0.1))
		{
			num4 += 6f;
		}
		if (direction == -1)
		{
			if (itemAnimation == (int)((double)num * 0.9))
			{
				num5 -= 8f;
			}
			if (itemAnimation == (int)((double)num * 0.7))
			{
				num5 -= 6f;
			}
		}
		num2 *= 1.5f;
		num3 *= 1.5f;
		num5 *= (float)direction;
		num4 *= gravDir;
		Projectile.NewProjectile(GetProjectileSource_Item(sItem), (float)(itemRectangle.X + itemRectangle.Width / 2) + num5, (float)(itemRectangle.Y + itemRectangle.Height / 2) + num4, (float)direction * num3, num2 * gravDir, 131, damage / 2, 0f, i);
	}

	private bool[] ItemCheck_GetTileCutIgnoreList(Item sItem)
	{
		bool allowRegrowth = false;
		int type = sItem.type;
		if (type == 213 || type == 5295)
		{
			allowRegrowth = true;
		}
		return GetTileCutIgnorance(allowRegrowth, fromTrap: false);
	}

	public bool[] GetTileCutIgnorance(bool allowRegrowth, bool fromTrap)
	{
		bool[] result = TileID.Sets.TileCutIgnore.None;
		if (allowRegrowth)
		{
			result = TileID.Sets.TileCutIgnore.Regrowth;
		}
		if (!fromTrap && dontHurtNature)
		{
			result = TileID.Sets.TileCutIgnore.IgnoreDontHurtNature;
		}
		return result;
	}

	private void ItemCheck_CutTiles(Item sItem, Rectangle itemRectangle, bool[] shouldIgnore)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		int minX = itemRectangle.X / 16;
		int maxX = (itemRectangle.X + itemRectangle.Width) / 16 + 1;
		int minY = itemRectangle.Y / 16;
		int maxY = (itemRectangle.Y + itemRectangle.Height) / 16 + 1;
		Utils.ClampWithinWorld(ref minX, ref minY, ref maxX, ref maxY);
		for (int i = minX; i < maxX; i++)
		{
			for (int j = minY; j < maxY; j++)
			{
				if (Main.tile[i, j] == null || !Main.tileCut[Main.tile[i, j].type] || shouldIgnore[Main.tile[i, j].type] || !WorldGen.CanCutTile(i, j, TileCuttingContext.AttackMelee))
				{
					continue;
				}
				if (sItem.type == 1786)
				{
					ushort type = Main.tile[i, j].type;
					WorldGen.KillTile(i, j);
					if (!Main.tile[i, j].active())
					{
						int num = 0;
						switch (type)
						{
						case 3:
						case 24:
						case 61:
						case 110:
						case 201:
						case 529:
						case 637:
							num = Main.rand.Next(1, 3);
							break;
						case 73:
						case 74:
						case 113:
							num = Main.rand.Next(2, 5);
							break;
						}
						if (num > 0)
						{
							int number = Item.NewItem(new EntitySource_ItemUse(this, sItem), i * 16, j * 16, 16, 16, 1727, num);
							if (Main.netMode == 1)
							{
								NetMessage.SendData(21, -1, -1, null, number, 1f);
							}
						}
					}
					if (Main.netMode == 1)
					{
						NetMessage.SendData(17, -1, -1, null, 0, i, j);
					}
				}
				else
				{
					WorldGen.KillTile(i, j);
					if (Main.netMode == 1)
					{
						NetMessage.SendData(17, -1, -1, null, 0, i, j);
					}
				}
			}
		}
	}

	private Rectangle ItemCheck_CatchCritters(Item sItem, Rectangle itemRectangle)
	{
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < 200; i++)
		{
			if (Main.npc[i].active && Main.npc[i].catchItem > 0)
			{
				NPC.CheckCatchNPC(Main.npc[i], itemRectangle, sItem, this, ItemID.Sets.LavaproofCatchingTool[sItem.type]);
			}
		}
		return itemRectangle;
	}

	private void GetPointOnSwungItemPath(float spriteWidth, float spriteHeight, float normalizedPointOnPath, float itemScale, out Vector2 location, out Vector2 outwardDirection)
	{
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		float num = (float)Math.Sqrt(spriteWidth * spriteWidth + spriteHeight * spriteHeight);
		float num2 = (float)(direction == 1).ToInt() * ((float)Math.PI / 2f);
		if (gravDir == -1f)
		{
			num2 += (float)Math.PI / 2f * (float)direction;
		}
		outwardDirection = itemRotation.ToRotationVector2().RotatedBy(3.926991f + num2);
		location = RotatedRelativePoint(itemLocation + outwardDirection * num * normalizedPointOnPath * itemScale);
	}

	private Rectangle ItemCheck_EmitUseVisuals(Item sItem, Rectangle itemRectangle)
	{
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_0143: Unknown result type (might be due to invalid IL or missing references)
		//IL_0148: Unknown result type (might be due to invalid IL or missing references)
		//IL_0191: Unknown result type (might be due to invalid IL or missing references)
		//IL_0198: Unknown result type (might be due to invalid IL or missing references)
		//IL_019f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0204: Unknown result type (might be due to invalid IL or missing references)
		//IL_020a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0227: Unknown result type (might be due to invalid IL or missing references)
		//IL_022d: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02be: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_02fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0302: Unknown result type (might be due to invalid IL or missing references)
		//IL_0263: Unknown result type (might be due to invalid IL or missing references)
		//IL_026a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0271: Unknown result type (might be due to invalid IL or missing references)
		//IL_0276: Unknown result type (might be due to invalid IL or missing references)
		//IL_027c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0299: Unknown result type (might be due to invalid IL or missing references)
		//IL_029f: Unknown result type (might be due to invalid IL or missing references)
		//IL_036d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0374: Unknown result type (might be due to invalid IL or missing references)
		//IL_037b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0380: Unknown result type (might be due to invalid IL or missing references)
		//IL_0386: Unknown result type (might be due to invalid IL or missing references)
		//IL_039f: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0472: Unknown result type (might be due to invalid IL or missing references)
		//IL_0479: Unknown result type (might be due to invalid IL or missing references)
		//IL_0480: Unknown result type (might be due to invalid IL or missing references)
		//IL_0485: Unknown result type (might be due to invalid IL or missing references)
		//IL_048b: Unknown result type (might be due to invalid IL or missing references)
		//IL_04a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_04aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_04c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_04ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_04cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_03da: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_040c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0412: Unknown result type (might be due to invalid IL or missing references)
		//IL_056b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0572: Unknown result type (might be due to invalid IL or missing references)
		//IL_0579: Unknown result type (might be due to invalid IL or missing references)
		//IL_057e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0584: Unknown result type (might be due to invalid IL or missing references)
		//IL_05bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_05c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_04e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_04f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_04fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0502: Unknown result type (might be due to invalid IL or missing references)
		//IL_0508: Unknown result type (might be due to invalid IL or missing references)
		//IL_0521: Unknown result type (might be due to invalid IL or missing references)
		//IL_052b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0530: Unknown result type (might be due to invalid IL or missing references)
		//IL_053e: Unknown result type (might be due to invalid IL or missing references)
		//IL_054f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0554: Unknown result type (might be due to invalid IL or missing references)
		//IL_0559: Unknown result type (might be due to invalid IL or missing references)
		//IL_042c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0433: Unknown result type (might be due to invalid IL or missing references)
		//IL_043a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0441: Unknown result type (might be due to invalid IL or missing references)
		//IL_0447: Unknown result type (might be due to invalid IL or missing references)
		//IL_05fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0602: Unknown result type (might be due to invalid IL or missing references)
		//IL_0609: Unknown result type (might be due to invalid IL or missing references)
		//IL_060e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0614: Unknown result type (might be due to invalid IL or missing references)
		//IL_064a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0650: Unknown result type (might be due to invalid IL or missing references)
		//IL_072d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0734: Unknown result type (might be due to invalid IL or missing references)
		//IL_073b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0740: Unknown result type (might be due to invalid IL or missing references)
		//IL_0746: Unknown result type (might be due to invalid IL or missing references)
		//IL_077d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0783: Unknown result type (might be due to invalid IL or missing references)
		//IL_06b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_06ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_06d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_06d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_06d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_06d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_06dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_06e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_06f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_06f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_07ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_07b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_07bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_07c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_07c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0802: Unknown result type (might be due to invalid IL or missing references)
		//IL_0808: Unknown result type (might be due to invalid IL or missing references)
		//IL_082c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0836: Unknown result type (might be due to invalid IL or missing references)
		//IL_083b: Unknown result type (might be due to invalid IL or missing references)
		//IL_08ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0900: Unknown result type (might be due to invalid IL or missing references)
		//IL_0905: Unknown result type (might be due to invalid IL or missing references)
		//IL_090b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0922: Unknown result type (might be due to invalid IL or missing references)
		//IL_0954: Unknown result type (might be due to invalid IL or missing references)
		//IL_0959: Unknown result type (might be due to invalid IL or missing references)
		//IL_0975: Unknown result type (might be due to invalid IL or missing references)
		//IL_097f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0984: Unknown result type (might be due to invalid IL or missing references)
		//IL_0860: Unknown result type (might be due to invalid IL or missing references)
		//IL_0867: Unknown result type (might be due to invalid IL or missing references)
		//IL_086e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0873: Unknown result type (might be due to invalid IL or missing references)
		//IL_0879: Unknown result type (might be due to invalid IL or missing references)
		//IL_08b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_08b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_08db: Unknown result type (might be due to invalid IL or missing references)
		//IL_08e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_08ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_0996: Unknown result type (might be due to invalid IL or missing references)
		//IL_0997: Unknown result type (might be due to invalid IL or missing references)
		//IL_099c: Unknown result type (might be due to invalid IL or missing references)
		//IL_09a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_09d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_09ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_09f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_09fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a2d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a34: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a3b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a40: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a46: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a7e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a84: Unknown result type (might be due to invalid IL or missing references)
		//IL_0aa8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0ab2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0ab7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c91: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c98: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c9f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0ca4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0caa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0ce2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0ce8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0d65: Unknown result type (might be due to invalid IL or missing references)
		//IL_0d6c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0d73: Unknown result type (might be due to invalid IL or missing references)
		//IL_0d78: Unknown result type (might be due to invalid IL or missing references)
		//IL_0d7e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0d97: Unknown result type (might be due to invalid IL or missing references)
		//IL_0d9d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0db3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0dbd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0dc2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b15: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b2e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b34: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b36: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b3b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b3d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b40: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b47: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b55: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b5b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b89: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b90: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b97: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b9c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0ba2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0bdd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0be3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0bf8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0bfa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c28: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c32: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c37: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c45: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c4a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c51: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c56: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c5b: Unknown result type (might be due to invalid IL or missing references)
		//IL_19bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_19c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_1069: Unknown result type (might be due to invalid IL or missing references)
		//IL_1070: Unknown result type (might be due to invalid IL or missing references)
		//IL_1077: Unknown result type (might be due to invalid IL or missing references)
		//IL_107c: Unknown result type (might be due to invalid IL or missing references)
		//IL_1082: Unknown result type (might be due to invalid IL or missing references)
		//IL_10bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_10c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_10e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_10f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_10f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_1914: Unknown result type (might be due to invalid IL or missing references)
		//IL_191b: Unknown result type (might be due to invalid IL or missing references)
		//IL_1922: Unknown result type (might be due to invalid IL or missing references)
		//IL_1927: Unknown result type (might be due to invalid IL or missing references)
		//IL_192d: Unknown result type (might be due to invalid IL or missing references)
		//IL_1964: Unknown result type (might be due to invalid IL or missing references)
		//IL_196a: Unknown result type (might be due to invalid IL or missing references)
		//IL_115f: Unknown result type (might be due to invalid IL or missing references)
		//IL_1166: Unknown result type (might be due to invalid IL or missing references)
		//IL_116d: Unknown result type (might be due to invalid IL or missing references)
		//IL_1172: Unknown result type (might be due to invalid IL or missing references)
		//IL_1178: Unknown result type (might be due to invalid IL or missing references)
		//IL_1191: Unknown result type (might be due to invalid IL or missing references)
		//IL_1197: Unknown result type (might be due to invalid IL or missing references)
		//IL_11cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_11d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_11dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_1202: Unknown result type (might be due to invalid IL or missing references)
		//IL_1209: Unknown result type (might be due to invalid IL or missing references)
		//IL_1210: Unknown result type (might be due to invalid IL or missing references)
		//IL_1215: Unknown result type (might be due to invalid IL or missing references)
		//IL_121b: Unknown result type (might be due to invalid IL or missing references)
		//IL_1253: Unknown result type (might be due to invalid IL or missing references)
		//IL_1259: Unknown result type (might be due to invalid IL or missing references)
		//IL_127d: Unknown result type (might be due to invalid IL or missing references)
		//IL_1287: Unknown result type (might be due to invalid IL or missing references)
		//IL_128c: Unknown result type (might be due to invalid IL or missing references)
		//IL_12cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_12d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_12db: Unknown result type (might be due to invalid IL or missing references)
		//IL_12e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_12e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_131d: Unknown result type (might be due to invalid IL or missing references)
		//IL_1323: Unknown result type (might be due to invalid IL or missing references)
		//IL_1347: Unknown result type (might be due to invalid IL or missing references)
		//IL_1351: Unknown result type (might be due to invalid IL or missing references)
		//IL_1356: Unknown result type (might be due to invalid IL or missing references)
		//IL_139a: Unknown result type (might be due to invalid IL or missing references)
		//IL_13a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_13a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_13ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_13b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_13eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_13f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_1463: Unknown result type (might be due to invalid IL or missing references)
		//IL_146a: Unknown result type (might be due to invalid IL or missing references)
		//IL_1471: Unknown result type (might be due to invalid IL or missing references)
		//IL_1476: Unknown result type (might be due to invalid IL or missing references)
		//IL_147c: Unknown result type (might be due to invalid IL or missing references)
		//IL_1495: Unknown result type (might be due to invalid IL or missing references)
		//IL_149b: Unknown result type (might be due to invalid IL or missing references)
		//IL_150f: Unknown result type (might be due to invalid IL or missing references)
		//IL_1516: Unknown result type (might be due to invalid IL or missing references)
		//IL_151d: Unknown result type (might be due to invalid IL or missing references)
		//IL_1522: Unknown result type (might be due to invalid IL or missing references)
		//IL_1528: Unknown result type (might be due to invalid IL or missing references)
		//IL_1541: Unknown result type (might be due to invalid IL or missing references)
		//IL_1547: Unknown result type (might be due to invalid IL or missing references)
		//IL_15d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_15d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_15e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_15e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_15eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_160c: Unknown result type (might be due to invalid IL or missing references)
		//IL_1612: Unknown result type (might be due to invalid IL or missing references)
		//IL_1859: Unknown result type (might be due to invalid IL or missing references)
		//IL_1860: Unknown result type (might be due to invalid IL or missing references)
		//IL_1867: Unknown result type (might be due to invalid IL or missing references)
		//IL_186c: Unknown result type (might be due to invalid IL or missing references)
		//IL_1872: Unknown result type (might be due to invalid IL or missing references)
		//IL_1888: Unknown result type (might be due to invalid IL or missing references)
		//IL_188e: Unknown result type (might be due to invalid IL or missing references)
		//IL_18c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_18ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_18d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_172d: Unknown result type (might be due to invalid IL or missing references)
		//IL_1734: Unknown result type (might be due to invalid IL or missing references)
		//IL_173b: Unknown result type (might be due to invalid IL or missing references)
		//IL_1741: Unknown result type (might be due to invalid IL or missing references)
		if (sItem.type == 989 && Main.rand.Next(5) == 0)
		{
			int num = Main.rand.Next(3);
			int num2 = Dust.NewDust(new Vector2((float)itemRectangle.X, (float)itemRectangle.Y), itemRectangle.Width, itemRectangle.Height, num switch
			{
				0 => 15, 
				1 => 57, 
				_ => 58, 
			}, direction * 2, 0f, 150, default(Color), 1.3f);
			Dust obj = Main.dust[num2];
			obj.velocity *= 0.2f;
		}
		if (sItem.type == 2880 && Main.rand.Next(2) == 0)
		{
			int type = Utils.SelectRandom<int>(Main.rand, 226, 229);
			int num3 = Dust.NewDust(new Vector2((float)itemRectangle.X, (float)itemRectangle.Y), itemRectangle.Width, itemRectangle.Height, type, direction * 2, 0f, 150);
			Dust obj2 = Main.dust[num3];
			obj2.velocity *= 0.2f;
			Main.dust[num3].noGravity = true;
		}
		if ((sItem.type == 44 || sItem.type == 45 || sItem.type == 103 || sItem.type == 104) && Main.rand.Next(15) == 0)
		{
			Dust.NewDust(new Vector2((float)itemRectangle.X, (float)itemRectangle.Y), itemRectangle.Width, itemRectangle.Height, 14, direction * 2, 0f, 150, default(Color), 1.3f);
		}
		if (sItem.type == 46 && Main.rand.Next(15) == 0)
		{
			Dust.NewDust(new Vector2((float)itemRectangle.X, (float)itemRectangle.Y), itemRectangle.Width, itemRectangle.Height, 14, direction * 2, 0f, 150, default(Color), 1.3f);
		}
		if (sItem.type == 273 || sItem.type == 675)
		{
			if (Main.rand.Next(5) == 0)
			{
				Dust.NewDust(new Vector2((float)itemRectangle.X, (float)itemRectangle.Y), itemRectangle.Width, itemRectangle.Height, 14, direction * 2, 0f, 150, default(Color), 1.4f);
			}
			int num4 = Dust.NewDust(new Vector2((float)itemRectangle.X, (float)itemRectangle.Y), itemRectangle.Width, itemRectangle.Height, 27, velocity.X * 0.2f + (float)(direction * 3), velocity.Y * 0.2f, 100, default(Color), 1.2f);
			Main.dust[num4].noGravity = true;
			Main.dust[num4].velocity.X /= 2f;
			Main.dust[num4].velocity.Y /= 2f;
		}
		if (sItem.type == 723 && Main.rand.Next(2) == 0)
		{
			int num5 = Dust.NewDust(new Vector2((float)itemRectangle.X, (float)itemRectangle.Y), itemRectangle.Width, itemRectangle.Height, 64, 0f, 0f, 150, default(Color), 1.2f);
			Main.dust[num5].noGravity = true;
		}
		if (sItem.type == 65)
		{
			if (Main.rand.Next(5) == 0)
			{
				Dust.NewDust(new Vector2((float)itemRectangle.X, (float)itemRectangle.Y), itemRectangle.Width, itemRectangle.Height, 58, 0f, 0f, 150, default(Color), 1.2f);
			}
			if (Main.rand.Next(10) == 0)
			{
				Gore.NewGore(new Vector2((float)itemRectangle.X, (float)itemRectangle.Y), default(Vector2), Main.rand.Next(16, 18));
			}
		}
		if (sItem.type == 3065)
		{
			int num6 = Dust.NewDust(new Vector2((float)itemRectangle.X, (float)itemRectangle.Y), itemRectangle.Width, itemRectangle.Height, 58, 0f, 0f, 150, default(Color), 1.2f);
			Dust obj3 = Main.dust[num6];
			obj3.velocity *= 0.5f;
			if (Main.rand.Next(8) == 0)
			{
				int num7 = Gore.NewGore(new Vector2((float)((Rectangle)(ref itemRectangle)).Center.X, (float)((Rectangle)(ref itemRectangle)).Center.Y), default(Vector2), 16);
				Gore obj4 = Main.gore[num7];
				obj4.velocity *= 0.5f;
				Gore obj5 = Main.gore[num7];
				obj5.velocity += new Vector2((float)direction, 0f);
			}
		}
		if (sItem.type == 190)
		{
			int num8 = Dust.NewDust(new Vector2((float)itemRectangle.X, (float)itemRectangle.Y), itemRectangle.Width, itemRectangle.Height, 40, velocity.X * 0.2f + (float)(direction * 3), velocity.Y * 0.2f, 0, default(Color), 1.2f);
			Main.dust[num8].noGravity = true;
		}
		else if (sItem.type == 213 || sItem.type == 5295)
		{
			int num9 = Dust.NewDust(new Vector2((float)itemRectangle.X, (float)itemRectangle.Y), itemRectangle.Width, itemRectangle.Height, 3, velocity.X * 0.2f + (float)(direction * 3), velocity.Y * 0.2f, 0, default(Color), 1.2f);
			Main.dust[num9].noGravity = true;
		}
		if (sItem.type == 121)
		{
			for (int i = 0; i < 2; i++)
			{
				GetPointOnSwungItemPath(70f, 70f, 0.2f + 0.8f * Main.rand.NextFloat(), GetAdjustedItemScale(sItem), out var location, out var outwardDirection);
				Vector2 val = outwardDirection.RotatedBy((float)Math.PI / 2f * (float)direction * gravDir);
				Dust.NewDustPerfect(location, 6, val * 4f, 100, default(Color), 2.5f).noGravity = true;
			}
		}
		if (sItem.type == 122 || sItem.type == 217)
		{
			int num10 = Dust.NewDust(new Vector2((float)itemRectangle.X, (float)itemRectangle.Y), itemRectangle.Width, itemRectangle.Height, 6, velocity.X * 0.2f + (float)(direction * 3), velocity.Y * 0.2f, 100, default(Color), 1.9f);
			Main.dust[num10].noGravity = true;
		}
		if (sItem.type == 155)
		{
			int num11 = Dust.NewDust(new Vector2((float)itemRectangle.X, (float)itemRectangle.Y), itemRectangle.Width, itemRectangle.Height, 172, velocity.X * 0.2f + (float)(direction * 3), velocity.Y * 0.2f, 100, default(Color), 0.9f);
			Main.dust[num11].noGravity = true;
			Dust obj6 = Main.dust[num11];
			obj6.velocity *= 0.1f;
		}
		if (sItem.type == 676 && Main.rand.Next(3) == 0)
		{
			int num12 = Dust.NewDust(new Vector2((float)itemRectangle.X, (float)itemRectangle.Y), itemRectangle.Width, itemRectangle.Height, 67, velocity.X * 0.2f + (float)(direction * 3), velocity.Y * 0.2f, 90, default(Color), 1.5f);
			Main.dust[num12].noGravity = true;
			Dust obj7 = Main.dust[num12];
			obj7.velocity *= 0.2f;
		}
		if (sItem.type == 3063)
		{
			int num13 = Dust.NewDust(itemRectangle.TopLeft(), itemRectangle.Width, itemRectangle.Height, 66, 0f, 0f, 150, Color.Transparent, 0.85f);
			Main.dust[num13].color = Main.hslToRgb(Main.rand.NextFloat(), 1f, 0.5f);
			Main.dust[num13].noGravity = true;
			Dust obj8 = Main.dust[num13];
			obj8.velocity /= 2f;
		}
		if (sItem.type == 3823)
		{
			Dust dust = Dust.NewDustDirect(itemRectangle.TopLeft(), itemRectangle.Width, itemRectangle.Height, 6, velocity.X * 0.2f + (float)(direction * 3), velocity.Y * 0.2f, 100, Color.Transparent, 0.7f);
			dust.noGravity = true;
			dust.velocity *= 2f;
			dust.fadeIn = 0.9f;
		}
		if (sItem.type == 724 && Main.rand.Next(5) == 0)
		{
			int num14 = Dust.NewDust(new Vector2((float)itemRectangle.X, (float)itemRectangle.Y), itemRectangle.Width, itemRectangle.Height, 67, velocity.X * 0.2f + (float)(direction * 3), velocity.Y * 0.2f, 90, default(Color), 1.5f);
			Main.dust[num14].noGravity = true;
			Dust obj9 = Main.dust[num14];
			obj9.velocity *= 0.2f;
		}
		if (sItem.type >= 795 && sItem.type <= 802)
		{
			for (int j = 0; j < 2; j++)
			{
				GetPointOnSwungItemPath(60f, 60f, 0.2f + 0.8f * Main.rand.NextFloat(), GetAdjustedItemScale(sItem), out var location2, out var outwardDirection2);
				Vector2 val2 = outwardDirection2.RotatedBy((float)Math.PI / 2f * (float)direction * gravDir);
				Dust.NewDustPerfect(location2, 5, val2 * 2f, 100, default(Color), 0.7f + Main.rand.NextFloat() * 0.6f);
				if (Main.rand.Next(20) == 0)
				{
					int num15 = Dust.NewDust(new Vector2((float)itemRectangle.X, (float)itemRectangle.Y), itemRectangle.Width, itemRectangle.Height, 115, velocity.X * 0.2f + (float)(direction * 3), velocity.Y * 0.2f, 140, default(Color), 0.7f);
					Main.dust[num15].position = location2;
					Main.dust[num15].fadeIn = 1.2f;
					Main.dust[num15].noGravity = true;
					Dust obj10 = Main.dust[num15];
					obj10.velocity *= 0.25f;
					Dust obj11 = Main.dust[num15];
					obj11.velocity += val2 * 5f;
				}
			}
		}
		if (sItem.type == 367)
		{
			int num16 = 0;
			if (Main.rand.Next(3) == 0)
			{
				num16 = Dust.NewDust(new Vector2((float)itemRectangle.X, (float)itemRectangle.Y), itemRectangle.Width, itemRectangle.Height, 57, velocity.X * 0.2f + (float)(direction * 3), velocity.Y * 0.2f, 100, default(Color), 1.1f);
				Main.dust[num16].noGravity = true;
				Main.dust[num16].velocity.X /= 2f;
				Main.dust[num16].velocity.Y /= 2f;
				Main.dust[num16].velocity.X += direction * 2;
			}
			if (Main.rand.Next(4) == 0)
			{
				num16 = Dust.NewDust(new Vector2((float)itemRectangle.X, (float)itemRectangle.Y), itemRectangle.Width, itemRectangle.Height, 43, 0f, 0f, 254, default(Color), 0.3f);
				Dust obj12 = Main.dust[num16];
				obj12.velocity *= 0f;
			}
		}
		else if (sItem.type != 368)
		{
			_ = sItem.type;
		}
		if (sItem.type == 4258 || sItem.type == 4259 || (sItem.type >= 198 && sItem.type <= 203) || (sItem.type >= 3764 && sItem.type <= 3769))
		{
			float num17 = 0.5f;
			float num18 = 0.5f;
			float num19 = 0.5f;
			if (sItem.type == 198 || sItem.type == 3764)
			{
				num17 *= 0.1f;
				num18 *= 0.5f;
				num19 *= 1.2f;
			}
			else if (sItem.type == 199 || sItem.type == 3765)
			{
				num17 *= 1f;
				num18 *= 0.2f;
				num19 *= 0.1f;
			}
			else if (sItem.type == 200 || sItem.type == 3766)
			{
				num17 *= 0.1f;
				num18 *= 1f;
				num19 *= 0.2f;
			}
			else if (sItem.type == 201 || sItem.type == 3767)
			{
				num17 *= 0.8f;
				num18 *= 0.1f;
				num19 *= 1f;
			}
			else if (sItem.type == 202 || sItem.type == 3768)
			{
				num17 *= 0.8f;
				num18 *= 0.9f;
				num19 *= 1f;
			}
			else if (sItem.type == 203 || sItem.type == 3769)
			{
				num17 *= 0.8f;
				num18 *= 0.8f;
				num19 *= 0f;
			}
			else if (sItem.type == 4258 || sItem.type == 4259)
			{
				num17 *= 0.9f;
				num18 *= 0.5f;
				num19 *= 0f;
			}
			Lighting.AddLight((int)((itemLocation.X + 6f + velocity.X) / 16f), (int)((itemLocation.Y - 14f) / 16f), num17, num18, num19);
		}
		if (frostBurn && sItem.melee && !sItem.noMelee && !sItem.noUseGraphic && Main.rand.Next(2) == 0)
		{
			int num20 = Dust.NewDust(new Vector2((float)itemRectangle.X, (float)itemRectangle.Y), itemRectangle.Width, itemRectangle.Height, 135, velocity.X * 0.2f + (float)(direction * 3), velocity.Y * 0.2f, 100, default(Color), 2.5f);
			Main.dust[num20].noGravity = true;
			Dust obj13 = Main.dust[num20];
			obj13.velocity *= 0.7f;
			Main.dust[num20].velocity.Y -= 0.5f;
		}
		if (sItem.melee && !sItem.noMelee && !sItem.noUseGraphic && meleeEnchant > 0)
		{
			if (meleeEnchant == 1)
			{
				if (Main.rand.Next(3) == 0)
				{
					int num21 = Dust.NewDust(new Vector2((float)itemRectangle.X, (float)itemRectangle.Y), itemRectangle.Width, itemRectangle.Height, 171, 0f, 0f, 100);
					Main.dust[num21].noGravity = true;
					Main.dust[num21].fadeIn = 1.5f;
					Dust obj14 = Main.dust[num21];
					obj14.velocity *= 0.25f;
				}
			}
			else if (meleeEnchant == 2)
			{
				if (Main.rand.Next(2) == 0)
				{
					int num22 = Dust.NewDust(new Vector2((float)itemRectangle.X, (float)itemRectangle.Y), itemRectangle.Width, itemRectangle.Height, 75, velocity.X * 0.2f + (float)(direction * 3), velocity.Y * 0.2f, 100, default(Color), 2.5f);
					Main.dust[num22].noGravity = true;
					Dust obj15 = Main.dust[num22];
					obj15.velocity *= 0.7f;
					Main.dust[num22].velocity.Y -= 0.5f;
				}
			}
			else if (meleeEnchant == 3)
			{
				if (Main.rand.Next(2) == 0)
				{
					int num23 = Dust.NewDust(new Vector2((float)itemRectangle.X, (float)itemRectangle.Y), itemRectangle.Width, itemRectangle.Height, 6, velocity.X * 0.2f + (float)(direction * 3), velocity.Y * 0.2f, 100, default(Color), 2.5f);
					Main.dust[num23].noGravity = true;
					Dust obj16 = Main.dust[num23];
					obj16.velocity *= 0.7f;
					Main.dust[num23].velocity.Y -= 0.5f;
				}
			}
			else if (meleeEnchant == 4)
			{
				int num24 = 0;
				if (Main.rand.Next(2) == 0)
				{
					num24 = Dust.NewDust(new Vector2((float)itemRectangle.X, (float)itemRectangle.Y), itemRectangle.Width, itemRectangle.Height, 57, velocity.X * 0.2f + (float)(direction * 3), velocity.Y * 0.2f, 100, default(Color), 1.1f);
					Main.dust[num24].noGravity = true;
					Main.dust[num24].velocity.X /= 2f;
					Main.dust[num24].velocity.Y /= 2f;
				}
			}
			else if (meleeEnchant == 5)
			{
				if (Main.rand.Next(2) == 0)
				{
					int num25 = Dust.NewDust(new Vector2((float)itemRectangle.X, (float)itemRectangle.Y), itemRectangle.Width, itemRectangle.Height, 169, 0f, 0f, 100);
					Main.dust[num25].velocity.X += direction;
					Main.dust[num25].velocity.Y += 0.2f;
					Main.dust[num25].noGravity = true;
				}
			}
			else if (meleeEnchant == 6)
			{
				if (Main.rand.Next(2) == 0)
				{
					int num26 = Dust.NewDust(new Vector2((float)itemRectangle.X, (float)itemRectangle.Y), itemRectangle.Width, itemRectangle.Height, 135, 0f, 0f, 100);
					Main.dust[num26].velocity.X += direction;
					Main.dust[num26].velocity.Y += 0.2f;
					Main.dust[num26].noGravity = true;
				}
			}
			else if (meleeEnchant == 7)
			{
				if (Main.rand.Next(20) == 0)
				{
					int type2 = Main.rand.Next(139, 143);
					int num27 = Dust.NewDust(new Vector2((float)itemRectangle.X, (float)itemRectangle.Y), itemRectangle.Width, itemRectangle.Height, type2, velocity.X, velocity.Y, 0, default(Color), 1.2f);
					Main.dust[num27].velocity.X *= 1f + (float)Main.rand.Next(-50, 51) * 0.01f;
					Main.dust[num27].velocity.Y *= 1f + (float)Main.rand.Next(-50, 51) * 0.01f;
					Main.dust[num27].velocity.X += (float)Main.rand.Next(-50, 51) * 0.05f;
					Main.dust[num27].velocity.Y += (float)Main.rand.Next(-50, 51) * 0.05f;
					Main.dust[num27].scale *= 1f + (float)Main.rand.Next(-30, 31) * 0.01f;
				}
				if (Main.rand.Next(40) == 0)
				{
					int type3 = Main.rand.Next(276, 283);
					int num28 = Gore.NewGore(new Vector2((float)itemRectangle.X, (float)itemRectangle.Y), velocity, type3);
					Main.gore[num28].velocity.X *= 1f + (float)Main.rand.Next(-50, 51) * 0.01f;
					Main.gore[num28].velocity.Y *= 1f + (float)Main.rand.Next(-50, 51) * 0.01f;
					Main.gore[num28].scale *= 1f + (float)Main.rand.Next(-20, 21) * 0.01f;
					Main.gore[num28].velocity.X += (float)Main.rand.Next(-50, 51) * 0.05f;
					Main.gore[num28].velocity.Y += (float)Main.rand.Next(-50, 51) * 0.05f;
				}
			}
			else if (meleeEnchant == 8 && Main.rand.Next(4) == 0)
			{
				int num29 = Dust.NewDust(new Vector2((float)itemRectangle.X, (float)itemRectangle.Y), itemRectangle.Width, itemRectangle.Height, 46, 0f, 0f, 100);
				Main.dust[num29].noGravity = true;
				Main.dust[num29].fadeIn = 1.5f;
				Dust obj17 = Main.dust[num29];
				obj17.velocity *= 0.25f;
			}
		}
		if (magmaStone && sItem.melee && !sItem.noMelee && !sItem.noUseGraphic && Main.rand.Next(3) != 0)
		{
			int num30 = Dust.NewDust(new Vector2((float)itemRectangle.X, (float)itemRectangle.Y), itemRectangle.Width, itemRectangle.Height, 6, velocity.X * 0.2f + (float)(direction * 3), velocity.Y * 0.2f, 100, default(Color), 2.5f);
			Main.dust[num30].noGravity = true;
			Main.dust[num30].velocity.X *= 2f;
			Main.dust[num30].velocity.Y *= 2f;
		}
		CombinedHooks.MeleeEffects(this, sItem, itemRectangle);
		return itemRectangle;
	}

	private void ItemCheck_GetMeleeHitbox(Item sItem, Rectangle heldItemFrame, out bool dontAttack, out Rectangle itemRectangle)
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0598: Unknown result type (might be due to invalid IL or missing references)
		//IL_05ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_05b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_05b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_05b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_05bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_05c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_05c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0434: Unknown result type (might be due to invalid IL or missing references)
		//IL_043b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0441: Unknown result type (might be due to invalid IL or missing references)
		//IL_05d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_05d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_05db: Unknown result type (might be due to invalid IL or missing references)
		//IL_05eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_05f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_05f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_05f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_05fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0605: Unknown result type (might be due to invalid IL or missing references)
		//IL_0607: Unknown result type (might be due to invalid IL or missing references)
		//IL_0611: Unknown result type (might be due to invalid IL or missing references)
		//IL_0616: Unknown result type (might be due to invalid IL or missing references)
		//IL_062e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0634: Unknown result type (might be due to invalid IL or missing references)
		//IL_0649: Unknown result type (might be due to invalid IL or missing references)
		//IL_064b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0668: Unknown result type (might be due to invalid IL or missing references)
		//IL_066d: Unknown result type (might be due to invalid IL or missing references)
		//IL_047b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0482: Unknown result type (might be due to invalid IL or missing references)
		//IL_0488: Unknown result type (might be due to invalid IL or missing references)
		//IL_04c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_04c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_04cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_0505: Unknown result type (might be due to invalid IL or missing references)
		//IL_050c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0512: Unknown result type (might be due to invalid IL or missing references)
		dontAttack = false;
		itemRectangle = new Rectangle((int)itemLocation.X, (int)itemLocation.Y, 32, 32);
		if (!Main.dedServ)
		{
			int num = heldItemFrame.Width;
			int num2 = heldItemFrame.Height;
			switch (sItem.type)
			{
			case 5094:
				num -= 10;
				num2 -= 10;
				break;
			case 5095:
				num -= 10;
				num2 -= 10;
				break;
			case 5096:
				num -= 12;
				num2 -= 12;
				break;
			case 5097:
				num -= 8;
				num2 -= 8;
				break;
			}
			itemRectangle = new Rectangle((int)itemLocation.X, (int)itemLocation.Y, num, num2);
		}
		float adjustedItemScale = GetAdjustedItemScale(sItem);
		itemRectangle.Width = (int)((float)itemRectangle.Width * adjustedItemScale);
		itemRectangle.Height = (int)((float)itemRectangle.Height * adjustedItemScale);
		if (direction == -1)
		{
			itemRectangle.X -= itemRectangle.Width;
		}
		if (gravDir == 1f)
		{
			itemRectangle.Y -= itemRectangle.Height;
		}
		if (sItem.useStyle == 1)
		{
			if ((double)itemAnimation < (double)itemAnimationMax * 0.333)
			{
				if (direction == -1)
				{
					itemRectangle.X -= (int)((double)itemRectangle.Width * 1.4 - (double)itemRectangle.Width);
				}
				itemRectangle.Width = (int)((double)itemRectangle.Width * 1.4);
				itemRectangle.Y += (int)((double)itemRectangle.Height * 0.5 * (double)gravDir);
				itemRectangle.Height = (int)((double)itemRectangle.Height * 1.1);
			}
			else if (!((double)itemAnimation < (double)itemAnimationMax * 0.666))
			{
				if (direction == 1)
				{
					itemRectangle.X -= (int)((double)itemRectangle.Width * 1.2);
				}
				itemRectangle.Width *= 2;
				itemRectangle.Y -= (int)(((double)itemRectangle.Height * 1.4 - (double)itemRectangle.Height) * (double)gravDir);
				itemRectangle.Height = (int)((double)itemRectangle.Height * 1.4);
			}
		}
		else if (sItem.useStyle == 3)
		{
			if ((double)itemAnimation > (double)itemAnimationMax * 0.666)
			{
				dontAttack = true;
			}
			else
			{
				if (direction == -1)
				{
					itemRectangle.X -= (int)((double)itemRectangle.Width * 1.4 - (double)itemRectangle.Width);
				}
				itemRectangle.Width = (int)((double)itemRectangle.Width * 1.4);
				itemRectangle.Y += (int)((double)itemRectangle.Height * 0.6);
				itemRectangle.Height = (int)((double)itemRectangle.Height * 0.6);
				if (sItem.type == 946 || sItem.type == 4707)
				{
					itemRectangle.Height += 14;
					itemRectangle.Width -= 10;
					if (direction == -1)
					{
						itemRectangle.X += 10;
					}
				}
			}
		}
		ItemLoader.UseItemHitbox(sItem, this, ref itemRectangle, ref dontAttack);
		if (sItem.type == 1450 && Main.rand.Next(3) == 0)
		{
			int num3 = -1;
			float num4 = itemRectangle.X + Main.rand.Next(itemRectangle.Width);
			float num5 = itemRectangle.Y + Main.rand.Next(itemRectangle.Height);
			if (Main.rand.Next(500) == 0)
			{
				num3 = Gore.NewGore(new Vector2(num4, num5), default(Vector2), 415, (float)Main.rand.Next(51, 101) * 0.01f);
			}
			else if (Main.rand.Next(250) == 0)
			{
				num3 = Gore.NewGore(new Vector2(num4, num5), default(Vector2), 414, (float)Main.rand.Next(51, 101) * 0.01f);
			}
			else if (Main.rand.Next(80) == 0)
			{
				num3 = Gore.NewGore(new Vector2(num4, num5), default(Vector2), 413, (float)Main.rand.Next(51, 101) * 0.01f);
			}
			else if (Main.rand.Next(10) == 0)
			{
				num3 = Gore.NewGore(new Vector2(num4, num5), default(Vector2), 412, (float)Main.rand.Next(51, 101) * 0.01f);
			}
			else if (Main.rand.Next(3) == 0)
			{
				num3 = Gore.NewGore(new Vector2(num4, num5), default(Vector2), 411, (float)Main.rand.Next(51, 101) * 0.01f);
			}
			if (num3 >= 0)
			{
				Main.gore[num3].velocity.X += direction * 2;
				Main.gore[num3].velocity.Y *= 0.3f;
			}
		}
		if (sItem.type == 3542)
		{
			dontAttack = true;
		}
		if (sItem.type == 3779)
		{
			dontAttack = true;
			Vector2 val = itemLocation + new Vector2((float)(direction * 30), -8f);
			Vector2 val2 = val - position;
			for (float num6 = 0f; num6 < 1f; num6 += 0.2f)
			{
				Vector2 val3 = Vector2.Lerp(oldPosition + val2 + new Vector2(0f, gfxOffY), val, num6);
				Dust obj = Main.dust[Dust.NewDust(val - Vector2.One * 8f, 16, 16, 27, 0f, -2f)];
				obj.noGravity = true;
				obj.position = val3;
				obj.velocity = new Vector2(0f, (0f - gravDir) * 2f);
				obj.scale = 1.2f;
				obj.alpha = 200;
			}
		}
	}

	private void ItemCheck_UseDemonHeart(Item sItem)
	{
		if (sItem.type == 3335 && itemAnimation > 0 && !extraAccessory && Main.expertMode && ItemTimeIsZero)
		{
			ApplyItemTime(sItem);
			extraAccessory = true;
			NetMessage.SendData(4, -1, -1, null, whoAmI);
		}
	}

	private void ItemCheck_UseMinecartPowerUp(Item sItem)
	{
		if (sItem.type == 5289 && itemAnimation > 0 && ItemTimeIsZero)
		{
			ApplyItemTime(sItem);
			if (!unlockedSuperCart)
			{
				unlockedSuperCart = true;
				NetMessage.SendData(4, -1, -1, null, whoAmI);
			}
			QuickSpawnItem(GetItemSource_OpenItem(5289), 3353);
		}
	}

	private void ItemCheck_UseArtisanLoaf(Item sItem)
	{
		if (sItem.type == 5326 && itemAnimation > 0 && !ateArtisanBread && ItemTimeIsZero)
		{
			ApplyItemTime(sItem);
			ateArtisanBread = true;
			NetMessage.SendData(4, -1, -1, null, whoAmI);
		}
	}

	private void ItemCheck_UseTorchGodsFavor(Item sItem)
	{
		if (sItem.type == 5043 && itemAnimation > 0 && !unlockedBiomeTorches && ItemTimeIsZero)
		{
			ApplyItemTime(sItem);
			unlockedBiomeTorches = true;
			UsingBiomeTorches = true;
			AchievementsHelper.HandleSpecialEvent(this, 24);
			if (Main.netMode == 0)
			{
				NPC nPC = new NPC();
				nPC.SetDefaults(664);
				Main.BestiaryTracker.Kills.RegisterKill(nPC);
			}
			NetMessage.SendData(4, -1, -1, null, whoAmI);
			NetMessage.SendData(51, -1, -1, null, whoAmI, 5f);
		}
	}

	private void ItemCheck_TryDestroyingDrones(Item sItem)
	{
		if (sItem.type != 5451 || ownedProjectileCounts[1020] <= 0 || !controlUseItem || !ItemTimeIsZero || mouseInterface)
		{
			return;
		}
		for (int i = 0; i < 1000; i++)
		{
			Projectile projectile = Main.projectile[i];
			if (projectile.owner == whoAmI && projectile.type == 1020)
			{
				projectile.Kill();
			}
		}
		releaseUseItem = false;
	}

	public void UseManaMaxIncreasingItem(int increase)
	{
		if (increase < 0)
		{
			increase = 0;
		}
		statManaMax += increase;
		statManaMax2 += increase;
		statMana += increase;
		if (Main.myPlayer == whoAmI)
		{
			ManaEffect(increase);
		}
	}

	private void ItemCheck_UseManaCrystal(Item sItem)
	{
		if (sItem.type == 109 && itemAnimation > 0 && ConsumedManaCrystals < 9 && ItemTimeIsZero)
		{
			ApplyItemTime(sItem);
			UseManaMaxIncreasingItem(20);
			ConsumedManaCrystals++;
			AchievementsHelper.HandleSpecialEvent(this, 1);
		}
	}

	public void UseHealthMaxIncreasingItem(int increase)
	{
		if (increase < 0)
		{
			increase = 0;
		}
		statLifeMax += increase;
		statLifeMax2 += increase;
		statLife += increase;
		if (Main.myPlayer == whoAmI)
		{
			HealEffect(increase);
		}
	}

	private void ItemCheck_UseLifeFruit(Item sItem)
	{
		if (sItem.type == 1291 && itemAnimation > 0 && ConsumedLifeCrystals == 15 && ConsumedLifeFruit < 20 && ItemTimeIsZero)
		{
			ApplyItemTime(sItem);
			UseHealthMaxIncreasingItem(5);
			ConsumedLifeFruit++;
			AchievementsHelper.HandleSpecialEvent(this, 2);
		}
	}

	private void ItemCheck_UseLifeCrystal(Item sItem)
	{
		if (sItem.type == 29 && itemAnimation > 0 && ConsumedLifeCrystals < 15 && ItemTimeIsZero)
		{
			ApplyItemTime(sItem);
			UseHealthMaxIncreasingItem(20);
			ConsumedLifeCrystals++;
			AchievementsHelper.HandleSpecialEvent(this, 0);
		}
	}

	private void ItemCheck_UseCombatBook(Item sItem)
	{
		if (!NPC.combatBookWasUsed && sItem.type == 4382 && itemAnimation > 0 && ItemTimeIsZero)
		{
			ApplyItemTime(sItem);
			if (Main.netMode == 0)
			{
				NPC.combatBookWasUsed = true;
				Main.NewText(Language.GetTextValue("Misc.CombatBookUsed"), 50, byte.MaxValue, 130);
			}
			else
			{
				NetMessage.SendData(61, -1, -1, null, whoAmI, -11f);
			}
		}
		if (!NPC.combatBookVolumeTwoWasUsed && sItem.type == 5336 && itemAnimation > 0 && ItemTimeIsZero)
		{
			ApplyItemTime(sItem);
			if (Main.netMode == 0)
			{
				NPC.combatBookVolumeTwoWasUsed = true;
				Main.NewText(Language.GetTextValue("Misc.CombatBookVolumeTwoUsed"), 50, byte.MaxValue, 130);
			}
			else
			{
				NetMessage.SendData(61, -1, -1, null, whoAmI, -17f);
			}
		}
	}

	private void ItemCheck_UsePetLicenses(Item sItem)
	{
		if (sItem.type == 4829 && itemAnimation > 0)
		{
			LicenseOrExchangePet(sItem, ref NPC.boughtCat, 637, "Misc.LicenseCatUsed", -12);
		}
		if (sItem.type == 4830 && itemAnimation > 0)
		{
			LicenseOrExchangePet(sItem, ref NPC.boughtDog, 638, "Misc.LicenseDogUsed", -13);
		}
		if (sItem.type == 4910 && itemAnimation > 0)
		{
			LicenseOrExchangePet(sItem, ref NPC.boughtBunny, 656, "Misc.LicenseBunnyUsed", -14);
		}
	}

	private void ItemCheck_UsePeddlersSatchel(Item sItem)
	{
		if (!NPC.peddlersSatchelWasUsed && sItem.type == 5343 && itemAnimation > 0 && ItemTimeIsZero)
		{
			ApplyItemTime(sItem);
			if (Main.netMode == 0)
			{
				NPC.peddlersSatchelWasUsed = true;
				Main.NewText(Language.GetTextValue("Misc.PeddlersSatchelUsed"), 50, byte.MaxValue, 130);
			}
			else
			{
				NetMessage.SendData(61, -1, -1, null, whoAmI, -18f);
			}
		}
	}

	private void ItemCheck_UseShimmerPermanentItems(Item sItem)
	{
		if (sItem.type == 5337 && itemAnimation > 0 && !usedAegisCrystal && ItemTimeIsZero)
		{
			ApplyItemTime(sItem);
			usedAegisCrystal = true;
			NetMessage.SendData(4, -1, -1, null, whoAmI);
		}
		if (sItem.type == 5338 && itemAnimation > 0 && !usedAegisFruit && ItemTimeIsZero)
		{
			ApplyItemTime(sItem);
			usedAegisFruit = true;
			NetMessage.SendData(4, -1, -1, null, whoAmI);
		}
		if (sItem.type == 5339 && itemAnimation > 0 && !usedArcaneCrystal && ItemTimeIsZero)
		{
			ApplyItemTime(sItem);
			usedArcaneCrystal = true;
			NetMessage.SendData(4, -1, -1, null, whoAmI);
		}
		if (sItem.type == 5340 && itemAnimation > 0 && !usedGalaxyPearl && ItemTimeIsZero)
		{
			ApplyItemTime(sItem);
			usedGalaxyPearl = true;
			NetMessage.SendData(4, -1, -1, null, whoAmI);
		}
		if (sItem.type == 5341 && itemAnimation > 0 && !usedGummyWorm && ItemTimeIsZero)
		{
			ApplyItemTime(sItem);
			usedGummyWorm = true;
			NetMessage.SendData(4, -1, -1, null, whoAmI);
		}
		if (sItem.type == 5342 && itemAnimation > 0 && !usedAmbrosia && ItemTimeIsZero)
		{
			ApplyItemTime(sItem);
			usedAmbrosia = true;
			NetMessage.SendData(4, -1, -1, null, whoAmI);
		}
	}

	private void LicenseOrExchangePet(Item sItem, ref bool petBoughtFlag, int npcType, string textKeyForLicense, int netMessageData)
	{
		if (ItemTimeIsZero && (!petBoughtFlag || NPC.AnyNPCs(npcType)))
		{
			ApplyItemTime(sItem);
			NPC.UnlockOrExchangePet(ref petBoughtFlag, npcType, textKeyForLicense, netMessageData);
		}
	}

	/// <summary>
	/// Clamps the provided world position to the normal gameplay range (<see cref="F:Terraria.Main.LogicCheckScreenWidth" />, <see cref="F:Terraria.Main.LogicCheckScreenHeight" />) from this player.
	/// <br /><br /> This is used to limit the ranges of various items (teleport, minion, sentry, magic missile, etc) to prevent users with high resolution screens from having a gameplay advantage.
	/// </summary>
	public void LimitPointToPlayerReachableArea(ref Vector2 pointPoisition)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		Vector2 center = base.Center;
		Vector2 val = pointPoisition - center;
		float num = Math.Abs(val.X);
		float num2 = Math.Abs(val.Y);
		float num3 = 1f;
		if (num > 960f)
		{
			float num4 = 960f / num;
			if (num3 > num4)
			{
				num3 = num4;
			}
		}
		if (num2 > 600f)
		{
			float num5 = 600f / num2;
			if (num3 > num5)
			{
				num3 = num5;
			}
		}
		Vector2 val2 = val * num3;
		pointPoisition = center + val2;
	}

	private void ItemCheck_UseTeleportRod(Item sItem)
	{
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_0168: Unknown result type (might be due to invalid IL or missing references)
		//IL_017e: Unknown result type (might be due to invalid IL or missing references)
		//IL_018f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01aa: Unknown result type (might be due to invalid IL or missing references)
		if (Main.myPlayer != whoAmI || (sItem.type != 1326 && sItem.type != 5335) || itemAnimation <= 0 || !ItemTimeIsZero)
		{
			return;
		}
		ApplyItemTime(sItem);
		Vector2 pointPoisition = new Vector2
		{
			X = (float)Main.mouseX + Main.screenPosition.X
		};
		if (gravDir == 1f)
		{
			pointPoisition.Y = (float)Main.mouseY + Main.screenPosition.Y - (float)height;
		}
		else
		{
			pointPoisition.Y = Main.screenPosition.Y + (float)Main.screenHeight - (float)Main.mouseY;
		}
		pointPoisition.X -= width / 2;
		LimitPointToPlayerReachableArea(ref pointPoisition);
		if (!(pointPoisition.X > 50f) || !(pointPoisition.X < (float)(Main.maxTilesX * 16 - 50)) || !(pointPoisition.Y > 50f) || !(pointPoisition.Y < (float)(Main.maxTilesY * 16 - 50)))
		{
			return;
		}
		int num = (int)(pointPoisition.X / 16f);
		int num2 = (int)(pointPoisition.Y / 16f);
		if ((Main.tile[num, num2].wall == 87 && !NPC.downedPlantBoss && (Main.remixWorld || (double)num2 > Main.worldSurface)) || Collision.SolidCollision(pointPoisition, width, height) || !CombinedHooks.CanBeTeleportedTo(this, pointPoisition, num, num2, "TeleportRod"))
		{
			return;
		}
		Teleport(pointPoisition, 1);
		NetMessage.SendData(65, -1, -1, null, 0, whoAmI, pointPoisition.X, pointPoisition.Y, 1);
		if (sItem.type != 1326)
		{
			return;
		}
		if (chaosState)
		{
			statLife -= statLifeMax2 / 7;
			PlayerDeathReason damageSource = PlayerDeathReason.ByOther(13);
			if (Main.rand.Next(2) == 0)
			{
				damageSource = PlayerDeathReason.ByOther(Male ? 14 : 15);
			}
			if (statLife <= 0)
			{
				KillMe(damageSource, 1.0, 0);
			}
			lifeRegenCount = 0;
			lifeRegenTime = 0f;
		}
		AddBuff(88, 360);
	}

	private bool IsTilePoundable(Tile targetTile)
	{
		if (!Main.tileHammer[targetTile.type] && !Main.tileSolid[targetTile.type] && targetTile.type != 314 && targetTile.type != 424 && targetTile.type != 442)
		{
			return targetTile.type != 351;
		}
		return false;
	}

	private void UseShovel(Player user, Item item, int sX, int sY)
	{
		for (int i = sX - 1; i <= sX + 1; i++)
		{
			for (int j = sY - 1; j <= sY + 1; j++)
			{
				DamageTileWithShovel(user, item, i, j);
			}
		}
		ApplyItemTime(item, pickSpeed);
	}

	private void DamageTileWithShovel(Player user, Item item, int x, int y)
	{
		Tile tileSafely = Framing.GetTileSafely(x, y);
		if (TileID.Sets.CanBeDugByShovel[tileSafely.type])
		{
			int pickPower = 30;
			if (tileSafely.active() && (TileID.Sets.Conversion.Grass[tileSafely.type] || TileID.Sets.Conversion.JungleGrass[tileSafely.type] || tileSafely.type == 70 || tileSafely.type == 633))
			{
				PickTile(x, y, 100);
			}
			PickTile(x, y, pickPower);
		}
	}

	private void ItemCheck_UseMiningTools(Item sItem)
	{
		SpecialToolUsageSettings specialToolUsageSettings = default(SpecialToolUsageSettings);
		if (sItem.type == 4711)
		{
			specialToolUsageSettings = new SpecialToolUsageSettings
			{
				IsAValidTool = true,
				UsageAction = UseShovel
			};
		}
		if (sItem.pick <= 0 && sItem.axe <= 0 && sItem.hammer <= 0 && !specialToolUsageSettings.IsAValidTool)
		{
			return;
		}
		bool flag = IsTargetTileInItemRange(sItem);
		if (noBuilding)
		{
			flag = false;
		}
		if (flag && specialToolUsageSettings.UsageCondition != null)
		{
			flag = specialToolUsageSettings.UsageCondition(this, sItem, tileTargetX, tileTargetY);
		}
		if (toolTime == 0 && itemAnimation > 0 && controlUseItem)
		{
			Tile targetTile = Main.tile[tileTargetX, tileTargetY];
			if (!targetTile.active() || (IsTilePoundable(targetTile) && !TileID.Sets.CanBeSloped[targetTile.type]))
			{
				poundRelease = false;
			}
		}
		if (!flag)
		{
			return;
		}
		if (!Main.GamepadDisableCursorItemIcon)
		{
			cursorItemIconEnabled = true;
			Main.ItemIconCacheUpdate(sItem.type);
		}
		bool canHitWalls = false;
		if (toolTime == 0 && itemAnimation > 0 && controlUseItem)
		{
			if (specialToolUsageSettings.UsageAction != null)
			{
				specialToolUsageSettings.UsageAction(this, sItem, tileTargetX, tileTargetY);
				return;
			}
			ItemCheck_UseMiningTools_ActuallyUseMiningTool(sItem, out canHitWalls, tileTargetX, tileTargetY);
		}
		if (releaseUseItem)
		{
			poundRelease = true;
		}
		if (toolTime == 0 && itemAnimation > 0 && controlUseItem && canHitWalls)
		{
			ItemCheck_UseMiningTools_TryFindingWallToHammer(out var wX, out var wY);
			ItemCheck_UseMiningTools_TryHittingWall(sItem, wX, wY);
		}
	}

	private void ItemCheck_UseMiningTools_ActuallyUseMiningTool(Item sItem, out bool canHitWalls, int x, int y)
	{
		//IL_038f: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0368: Unknown result type (might be due to invalid IL or missing references)
		//IL_037b: Unknown result type (might be due to invalid IL or missing references)
		int num = -1;
		int num2 = 0;
		canHitWalls = true;
		Tile tile = Main.tile[x, y];
		if (!tile.active())
		{
			return;
		}
		if ((sItem.pick > 0 && !Main.tileAxe[tile.type] && !Main.tileHammer[tile.type]) || (sItem.axe > 0 && Main.tileAxe[tile.type]) || (sItem.hammer > 0 && Main.tileHammer[tile.type]))
		{
			canHitWalls = false;
		}
		num = hitTile.HitObject(x, y, 1);
		if (Main.tileNoFail[tile.type])
		{
			num2 = 100;
		}
		if (Main.tileHammer[tile.type])
		{
			canHitWalls = false;
			if (sItem.hammer > 0)
			{
				ModTile tile2 = TileLoader.GetTile(tile.type);
				num2 = ((tile2 == null) ? (num2 + sItem.hammer) : (num2 + (int)((float)sItem.hammer / tile2.MineResist)));
				if (!WorldGen.CanKillTile(x, y))
				{
					num2 = 0;
				}
				if (tile.type == 26 && (sItem.hammer < 80 || !Main.hardMode))
				{
					num2 = 0;
					Hurt(PlayerDeathReason.ByOther(4), statLife / 2, -direction);
				}
				AchievementsHelper.CurrentlyMining = true;
				if (hitTile.AddDamage(num, num2) >= 100)
				{
					ClearMiningCacheAt(x, y, 1);
					WorldGen.KillTile(x, y);
					if (Main.netMode == 1)
					{
						NetMessage.SendData(17, -1, -1, null, 0, x, y);
					}
				}
				else
				{
					WorldGen.KillTile(x, y, fail: true);
					if (Main.netMode == 1)
					{
						NetMessage.SendData(17, -1, -1, null, 0, x, y, 1f);
					}
				}
				if (num2 != 0)
				{
					hitTile.Prune();
				}
				ApplyItemTime(sItem);
				AchievementsHelper.CurrentlyMining = false;
			}
		}
		else if (Main.tileAxe[tile.type])
		{
			ModTile tile3 = TileLoader.GetTile(tile.type);
			if (tile3 != null)
			{
				num2 += (int)((float)sItem.axe / tile3.MineResist);
			}
			else
			{
				num2 = ((tile.type != 80) ? (num2 + (int)((float)sItem.axe * 1.2f)) : (num2 + (int)((float)(sItem.axe * 3) * 1.2f)));
				if (Main.getGoodWorld)
				{
					num2 = (int)((double)num2 * 1.3);
				}
			}
			if (sItem.axe > 0)
			{
				AchievementsHelper.CurrentlyMining = true;
				if (!WorldGen.CanKillTile(x, y))
				{
					num2 = 0;
				}
				if (Main.dontStarveWorld && Main.myPlayer == whoAmI && num2 > 0 && tile.type == 80)
				{
					Hurt(PlayerDeathReason.ByOther(3), Main.DamageVar(6f, luck), 0, pvp: false, quiet: false, Crit: false, 0);
				}
				if (hitTile.AddDamage(num, num2) >= 100)
				{
					if (whoAmI == Main.myPlayer && sItem.type == 5095 && (TileID.Sets.IsATreeTrunk[tile.type] || tile.type == 323 || tile.type == 80))
					{
						LucyAxeMessage.MessageSource source = LucyAxeMessage.MessageSource.ChoppedTree;
						if (TileID.Sets.CountsAsGemTree[tile.type])
						{
							source = LucyAxeMessage.MessageSource.ChoppedGemTree;
						}
						if (tile.type == 80)
						{
							source = LucyAxeMessage.MessageSource.ChoppedCactus;
							LucyAxeMessage.TryCreatingMessageWithCooldown(source, base.Top, new Vector2((float)(direction * 7), -7f), 420);
						}
						else
						{
							LucyAxeMessage.Create(source, base.Top, new Vector2((float)(direction * 7), -7f));
						}
					}
					ClearMiningCacheAt(x, y, 1);
					bool flag = IsBottomOfTreeTrunkNoRoots(x, y);
					WorldGen.KillTile(x, y);
					if (Main.netMode == 1)
					{
						NetMessage.SendData(17, -1, -1, null, 0, x, y);
					}
					if (sItem.type == 5295 && flag)
					{
						TryReplantingTree(x, y);
					}
				}
				else
				{
					WorldGen.KillTile(x, y, fail: true);
					if (Main.netMode == 1)
					{
						NetMessage.SendData(17, -1, -1, null, 0, x, y, 1f);
					}
				}
				if (num2 != 0)
				{
					hitTile.Prune();
				}
				ApplyItemTime(sItem);
				AchievementsHelper.CurrentlyMining = false;
			}
		}
		else if (sItem.pick > 0)
		{
			PickTile(x, y, sItem.pick);
		}
		if (sItem.pick > 0)
		{
			ApplyItemTime(sItem, pickSpeed);
		}
		ItemCheck_UseMiningTools_TryPoundingTile(sItem, num, ref canHitWalls, x, y);
	}

	private bool IsBottomOfTreeTrunkNoRoots(int x, int y)
	{
		Tile tile = Main.tile[x, y];
		if (!tile.active())
		{
			return false;
		}
		if (!TileID.Sets.IsATreeTrunk[tile.type] && tile.type != 323)
		{
			return false;
		}
		short frameX = tile.frameX;
		short frameY = tile.frameY;
		if (tile.type != 323 && frameY >= 132 && frameY <= 176 && (frameX == 22 || frameX == 44))
		{
			return false;
		}
		return true;
	}

	private void TryReplantingTree(int x, int y)
	{
		int tileToCreate = 20;
		int previewPlaceStyle = 0;
		PlantLoader.CheckAndInjectModSapling(x, y, ref tileToCreate, ref previewPlaceStyle);
		if (!TileObject.CanPlace(tileTargetX, tileTargetY, tileToCreate, previewPlaceStyle, direction, out var objectData))
		{
			return;
		}
		bool num = TileObject.Place(objectData);
		WorldGen.SquareTileFrame(tileTargetX, tileTargetY);
		if (num)
		{
			TileObjectData.CallPostPlacementPlayerHook(tileTargetX, tileTargetY, tileToCreate, previewPlaceStyle, direction, objectData.alternate, objectData);
			if (Main.netMode == 1)
			{
				NetMessage.SendObjectPlacement(-1, tileTargetX, tileTargetY, objectData.type, objectData.style, objectData.alternate, objectData.random, direction);
			}
		}
	}

	private static void ItemCheck_UseMiningTools_TryFindingWallToHammer(out int wX, out int wY)
	{
		wX = tileTargetX;
		wY = tileTargetY;
		bool flag = true;
		if (Main.tile[wX, wY].wall > 0)
		{
			if (!Main.wallHouse[Main.tile[wX, wY].wall])
			{
				for (int i = wX - 1; i < wX + 2; i++)
				{
					for (int j = wY - 1; j < wY + 2; j++)
					{
						if (Main.tile[i, j].wall != Main.tile[wX, wY].wall)
						{
							flag = false;
							break;
						}
					}
				}
			}
			else
			{
				flag = false;
			}
		}
		if (!flag || Main.tile[wX, wY].active())
		{
			return;
		}
		int num = -1;
		if ((double)(((float)Main.mouseX + Main.screenPosition.X) / 16f) < Math.Round(((float)Main.mouseX + Main.screenPosition.X) / 16f))
		{
			num = 0;
		}
		int num2 = -1;
		if ((double)(((float)Main.mouseY + Main.screenPosition.Y) / 16f) < Math.Round(((float)Main.mouseY + Main.screenPosition.Y) / 16f))
		{
			num2 = 0;
		}
		for (int k = tileTargetX + num; k <= tileTargetX + num + 1; k++)
		{
			for (int l = tileTargetY + num2; l <= tileTargetY + num2 + 1; l++)
			{
				if (!flag)
				{
					continue;
				}
				wX = k;
				wY = l;
				if (Main.tile[wX, wY].wall <= 0)
				{
					continue;
				}
				if (!Main.wallHouse[Main.tile[wX, wY].wall])
				{
					for (int m = wX - 1; m < wX + 2; m++)
					{
						for (int n = wY - 1; n < wY + 2; n++)
						{
							if (Main.tile[m, n].wall != Main.tile[wX, wY].wall)
							{
								flag = false;
								break;
							}
						}
					}
				}
				else
				{
					flag = false;
				}
			}
		}
	}

	private void ItemCheck_UseMiningTools_TryHittingWall(Item sItem, int wX, int wY)
	{
		if (Main.tile[wX, wY].wall > 0 && (!Main.tile[wX, wY].active() || wX != tileTargetX || wY != tileTargetY || (!Main.tileHammer[Main.tile[wX, wY].type] && !poundRelease)) && toolTime == 0 && itemAnimation > 0 && controlUseItem && sItem.hammer > 0 && CanPlayerSmashWall(wX, wY))
		{
			int damage = (int)((float)sItem.hammer * 1.5f);
			PickWall(wX, wY, damage);
			itemTime = sItem.useTime / 2;
		}
	}

	public static bool CanPlayerSmashWall(int X, int Y)
	{
		bool result = true;
		if (!Main.wallHouse[Main.tile[X, Y].wall])
		{
			result = false;
			for (int i = X - 1; i < X + 2; i++)
			{
				for (int j = Y - 1; j < Y + 2; j++)
				{
					if (Main.tile[i, j].wall == 0 || Main.wallHouse[Main.tile[i, j].wall])
					{
						result = true;
						break;
					}
				}
			}
		}
		return result;
	}

	public void PickWall(int x, int y, int damage)
	{
		int tileId = hitTile.HitObject(x, y, 2);
		if (hitTile.AddDamage(tileId, damage) >= 100)
		{
			hitTile.Clear(tileId);
			ClearMiningCacheAt(x, y, 2);
			WorldGen.KillWall(x, y);
			if (Main.netMode == 1)
			{
				NetMessage.SendData(17, -1, -1, null, 2, x, y);
			}
		}
		else
		{
			WorldGen.KillWall(x, y, fail: true);
			if (Main.netMode == 1)
			{
				NetMessage.SendData(17, -1, -1, null, 2, x, y, 1f);
			}
		}
		if (damage != 0)
		{
			hitTile.Prune();
		}
	}

	private void ItemCheck_UseMiningTools_TryPoundingTile(Item sItem, int tileHitId, ref bool hitWall, int x, int y)
	{
		Tile tile = Main.tile[x, y];
		bool num = sItem.hammer > 0 && tile.active() && poundRelease;
		bool flag = Main.tileSolid[tile.type] || tile.type == 314 || tile.type == 351 || tile.type == 424 || tile.type == 442;
		if (num && (flag || TileID.Sets.CanBeSloped[tile.type]))
		{
			hitWall = false;
			ApplyItemTime(sItem);
			int damageAmount = 100;
			if (WorldGen.IsLockedDoor(x, y - 1) || WorldGen.IsLockedDoor(x, y + 1))
			{
				damageAmount = 0;
			}
			if (hitTile.AddDamage(tileHitId, damageAmount) >= 100)
			{
				ClearMiningCacheAt(x, y, 1);
				if (!poundRelease)
				{
					return;
				}
				if (!TileLoader.Slope(x, y, Main.tile[x, y].type))
				{
					if (TileID.Sets.Platforms[Main.tile[x, y].type])
					{
						if (tile.halfBrick())
						{
							WorldGen.PoundTile(x, y);
							if (Main.netMode == 1)
							{
								NetMessage.SendData(17, -1, -1, null, 7, x, y, 1f);
							}
						}
						else
						{
							int num2 = 1;
							int slope = 2;
							if (TileID.Sets.Platforms[Main.tile[x + 1, y - 1].type] || TileID.Sets.Platforms[Main.tile[x - 1, y + 1].type] || (WorldGen.SolidTile(x + 1, y) && !WorldGen.SolidTile(x - 1, y)))
							{
								num2 = 2;
								slope = 1;
							}
							if (Main.tile[x, y].slope() == 0)
							{
								WorldGen.SlopeTile(x, y, num2);
								int num3 = Main.tile[x, y].slope();
								if (Main.netMode == 1)
								{
									NetMessage.SendData(17, -1, -1, null, 14, x, y, num3);
								}
							}
							else if (Main.tile[x, y].slope() == num2)
							{
								WorldGen.SlopeTile(x, y, slope);
								int num4 = Main.tile[x, y].slope();
								if (Main.netMode == 1)
								{
									NetMessage.SendData(17, -1, -1, null, 14, x, y, num4);
								}
							}
							else
							{
								WorldGen.SlopeTile(x, y);
								int num5 = Main.tile[x, y].slope();
								if (Main.netMode == 1)
								{
									NetMessage.SendData(17, -1, -1, null, 14, x, y, num5);
								}
								WorldGen.PoundTile(x, y);
								if (Main.netMode == 1)
								{
									NetMessage.SendData(17, -1, -1, null, 7, x, y, 1f);
								}
							}
						}
					}
					else if (Main.tile[x, y].type == 314)
					{
						if (Minecart.FrameTrack(x, y, pound: true) && Main.netMode == 1)
						{
							NetMessage.SendData(17, -1, -1, null, 15, x, y, 1f);
						}
					}
					else if (Main.tile[x, y].type == 137)
					{
						int num6 = 0;
						switch (Main.tile[x, y].frameY / 18)
						{
						case 0:
						case 1:
						case 2:
						case 5:
							switch (Main.tile[x, y].frameX / 18)
							{
							case 0:
								num6 = 2;
								break;
							case 1:
								num6 = 3;
								break;
							case 2:
								num6 = 4;
								break;
							case 3:
								num6 = 5;
								break;
							case 4:
								num6 = 1;
								break;
							case 5:
								num6 = 0;
								break;
							}
							break;
						case 3:
						case 4:
							switch (Main.tile[x, y].frameX / 18)
							{
							case 0:
							case 1:
								num6 = 3;
								break;
							case 3:
								num6 = 2;
								break;
							case 2:
								num6 = 4;
								break;
							case 4:
								num6 = 0;
								break;
							}
							break;
						}
						Main.tile[x, y].frameX = (short)(num6 * 18);
						if (Main.netMode == 1)
						{
							NetMessage.SendTileSquare(-1, x, y);
						}
					}
					else if (Main.tile[x, y].type == 424)
					{
						if (Main.tile[x, y].frameX == 0)
						{
							Main.tile[x, y].frameX = 18;
						}
						else if (Main.tile[x, y].frameX == 18)
						{
							Main.tile[x, y].frameX = 36;
						}
						else
						{
							Main.tile[x, y].frameX = 0;
						}
						if (Main.netMode == 1)
						{
							NetMessage.SendTileSquare(-1, x, y);
						}
					}
					else if (Main.tile[x, y].type == 442)
					{
						Tile tile2 = Main.tile[x, y - 1];
						Tile tile3 = Main.tile[x, y + 1];
						Tile tile4 = Main.tile[x - 1, y];
						Tile tile5 = Main.tile[x + 1, y];
						Tile tile6 = Main.tile[x - 1, y + 1];
						Tile tile7 = Main.tile[x + 1, y + 1];
						Tile tile8 = Main.tile[x - 1, y - 1];
						Tile tile9 = Main.tile[x + 1, y - 1];
						int num7 = -1;
						int num8 = -1;
						int num9 = -1;
						int num10 = -1;
						int tree = -1;
						int tree2 = -1;
						int tree3 = -1;
						int tree4 = -1;
						if (tile2 != null && tile2.nactive() && !tile2.bottomSlope())
						{
							num8 = tile2.type;
						}
						if (tile3 != null && tile3.nactive() && !tile3.halfBrick() && !tile3.topSlope())
						{
							num7 = tile3.type;
						}
						if (tile4 != null && tile4.nactive() && (tile4.slope() == 0 || tile4.slope() % 2 != 1))
						{
							num9 = tile4.type;
						}
						if (tile5 != null && tile5.nactive() && (tile5.slope() == 0 || tile5.slope() % 2 != 0))
						{
							num10 = tile5.type;
						}
						if (tile6 != null && tile6.nactive())
						{
							tree = tile6.type;
						}
						if (tile7 != null && tile7.nactive())
						{
							tree2 = tile7.type;
						}
						if (tile8 != null && tile8.nactive())
						{
							tree3 = tile8.type;
						}
						if (tile9 != null && tile9.nactive())
						{
							tree4 = tile9.type;
						}
						bool flag2 = false;
						bool flag3 = false;
						bool flag4 = false;
						bool flag5 = false;
						if (num7 >= 0 && Main.tileSolid[num7] && (!Main.tileNoAttach[num7] || TileID.Sets.Platforms[num7]) && (tile3.bottomSlope() || tile3.slope() == 0) && !tile3.halfBrick())
						{
							flag5 = true;
						}
						if (num8 >= 0 && Main.tileSolid[num8] && (!Main.tileNoAttach[num8] || (TileID.Sets.Platforms[num8] && tile2.halfBrick())) && (tile2.topSlope() || tile2.slope() == 0 || tile2.halfBrick()))
						{
							flag2 = true;
						}
						if ((num9 >= 0 && Main.tileSolid[num9] && !Main.tileNoAttach[num9] && (tile4.leftSlope() || tile4.slope() == 0) && !tile4.halfBrick()) || (num9 >= 0 && TileID.Sets.IsBeam[num9]) || (WorldGen.IsTreeType(num9) && WorldGen.IsTreeType(tree3) && WorldGen.IsTreeType(tree)))
						{
							flag3 = true;
						}
						if ((num10 >= 0 && Main.tileSolid[num10] && !Main.tileNoAttach[num10] && (tile5.rightSlope() || tile5.slope() == 0) && !tile5.halfBrick()) || (num10 >= 0 && TileID.Sets.IsBeam[num10]) || (WorldGen.IsTreeType(num10) && WorldGen.IsTreeType(tree4) && WorldGen.IsTreeType(tree2)))
						{
							flag4 = true;
						}
						int num11 = Main.tile[x, y].frameX / 22;
						short num12 = -2;
						switch (num11)
						{
						case 0:
							num12 = (short)(flag3 ? 2 : (flag2 ? 1 : ((!flag4) ? (-1) : 3)));
							break;
						case 2:
							num12 = (short)(flag2 ? 1 : (flag4 ? 3 : ((!flag5) ? (-1) : 0)));
							break;
						case 1:
							num12 = (short)(flag4 ? 3 : ((!flag5) ? ((!flag3) ? (-1) : 2) : 0));
							break;
						case 3:
							num12 = (short)((!flag5) ? (flag3 ? 2 : (flag2 ? 1 : (-1))) : 0);
							break;
						}
						if (num12 != -1)
						{
							if (num12 == -2)
							{
								num12 = 0;
							}
							Main.tile[x, y].frameX = (short)(22 * num12);
							if (Main.netMode == 1)
							{
								NetMessage.SendTileSquare(-1, x, y);
							}
						}
					}
					else if ((Main.tile[x, y].halfBrick() || Main.tile[x, y].slope() != 0) && !Main.tileSolidTop[Main.tile[x, y].type])
					{
						int num13 = 1;
						int num14 = 1;
						int num15 = 2;
						if ((WorldGen.SolidTile(x + 1, y) || Main.tile[x + 1, y].slope() == 1 || Main.tile[x + 1, y].slope() == 3) && !WorldGen.SolidTile(x - 1, y))
						{
							num14 = 2;
							num15 = 1;
						}
						if (WorldGen.SolidTile(x, y - 1) && !WorldGen.SolidTile(x, y + 1))
						{
							num13 = -1;
						}
						if (num13 == 1)
						{
							if (Main.tile[x, y].slope() == 0)
							{
								WorldGen.SlopeTile(x, y, num14);
							}
							else if (Main.tile[x, y].slope() == num14)
							{
								WorldGen.SlopeTile(x, y, num15);
							}
							else if (Main.tile[x, y].slope() == num15)
							{
								WorldGen.SlopeTile(x, y, num14 + 2);
							}
							else if (Main.tile[x, y].slope() == num14 + 2)
							{
								WorldGen.SlopeTile(x, y, num15 + 2);
							}
							else
							{
								WorldGen.SlopeTile(x, y);
							}
						}
						else if (Main.tile[x, y].slope() == 0)
						{
							WorldGen.SlopeTile(x, y, num14 + 2);
						}
						else if (Main.tile[x, y].slope() == num14 + 2)
						{
							WorldGen.SlopeTile(x, y, num15 + 2);
						}
						else if (Main.tile[x, y].slope() == num15 + 2)
						{
							WorldGen.SlopeTile(x, y, num14);
						}
						else if (Main.tile[x, y].slope() == num14)
						{
							WorldGen.SlopeTile(x, y, num15);
						}
						else
						{
							WorldGen.SlopeTile(x, y);
						}
						int num16 = Main.tile[x, y].slope();
						if (Main.netMode == 1)
						{
							NetMessage.SendData(17, -1, -1, null, 14, x, y, num16);
						}
					}
					else
					{
						WorldGen.PoundTile(x, y);
						if (Main.netMode == 1)
						{
							NetMessage.SendData(17, -1, -1, null, 7, x, y, 1f);
						}
					}
				}
				poundRelease = false;
			}
			else
			{
				WorldGen.KillTile(x, y, fail: true, effectOnly: true);
				SoundEngine.PlaySound(0, x * 16, y * 16);
			}
		}
		else
		{
			poundRelease = false;
		}
	}

	public bool IsTargetTileInItemRange(Item sItem)
	{
		if (position.X / 16f - (float)tileRangeX - (float)sItem.tileBoost <= (float)tileTargetX && (position.X + (float)width) / 16f + (float)tileRangeX + (float)sItem.tileBoost - 1f >= (float)tileTargetX && position.Y / 16f - (float)tileRangeY - (float)sItem.tileBoost <= (float)tileTargetY)
		{
			return (position.Y + (float)height) / 16f + (float)tileRangeY + (float)sItem.tileBoost - 2f >= (float)tileTargetY;
		}
		return false;
	}

	private void ItemCheck_UseBuckets(Item sItem)
	{
		if (((sItem.type < 205 || sItem.type > 207) && sItem.type != 1128 && sItem.type != 3031 && sItem.type != 3032 && sItem.type != 4820 && sItem.type != 4872 && sItem.type != 5302 && sItem.type != 5303 && sItem.type != 5304 && sItem.type != 5364) || noBuilding || !(position.X / 16f - (float)tileRangeX - (float)sItem.tileBoost <= (float)tileTargetX) || !((position.X + (float)width) / 16f + (float)tileRangeX + (float)sItem.tileBoost - 1f >= (float)tileTargetX) || !(position.Y / 16f - (float)tileRangeY - (float)sItem.tileBoost <= (float)tileTargetY) || !((position.Y + (float)height) / 16f + (float)tileRangeY + (float)sItem.tileBoost - 2f >= (float)tileTargetY))
		{
			return;
		}
		if (!Main.GamepadDisableCursorItemIcon)
		{
			cursorItemIconEnabled = true;
			Main.ItemIconCacheUpdate(sItem.type);
		}
		if (!ItemTimeIsZero || itemAnimation <= 0 || !controlUseItem)
		{
			return;
		}
		Tile tile;
		if (sItem.type == 205)
		{
			tile = Main.tile[tileTargetX, tileTargetY];
			if (!tile.shimmer())
			{
				goto IL_027d;
			}
		}
		if (sItem.type == 3032)
		{
			tile = Main.tile[tileTargetX, tileTargetY];
			if (tile.liquidType() == 0)
			{
				goto IL_027d;
			}
		}
		if (sItem.type == 3032)
		{
			tile = Main.tile[tileTargetX, tileTargetY];
			if (tile.shimmer())
			{
				goto IL_027d;
			}
		}
		if (sItem.type == 4872)
		{
			tile = Main.tile[tileTargetX, tileTargetY];
			if (tile.lava())
			{
				goto IL_027d;
			}
		}
		if (sItem.type == 5303)
		{
			tile = Main.tile[tileTargetX, tileTargetY];
			if (tile.honey())
			{
				goto IL_027d;
			}
		}
		if (sItem.type != 5304)
		{
			tile = Main.tile[tileTargetX, tileTargetY];
			if (tile.liquid >= 200)
			{
				return;
			}
			tile = Main.tile[tileTargetX, tileTargetY];
			if (tile.nactive())
			{
				bool[] tileSolid = Main.tileSolid;
				tile = Main.tile[tileTargetX, tileTargetY];
				if (tileSolid[tile.type])
				{
					bool[] tileSolidTop = Main.tileSolidTop;
					tile = Main.tile[tileTargetX, tileTargetY];
					if (!tileSolidTop[tile.type])
					{
						tile = Main.tile[tileTargetX, tileTargetY];
						if (tile.type != 546)
						{
							return;
						}
					}
				}
			}
			if (sItem.type == 207 || sItem.type == 4820)
			{
				tile = Main.tile[tileTargetX, tileTargetY];
				if (tile.liquid != 0)
				{
					tile = Main.tile[tileTargetX, tileTargetY];
					if (tile.liquidType() != 1)
					{
						return;
					}
				}
				SoundEngine.PlaySound(19, (int)position.X, (int)position.Y);
				tile = Main.tile[tileTargetX, tileTargetY];
				tile.liquidType(1);
				tile = Main.tile[tileTargetX, tileTargetY];
				tile.liquid = byte.MaxValue;
				WorldGen.SquareTileFrame(tileTargetX, tileTargetY);
				if (sItem.type != 4820)
				{
					sItem.stack--;
					PutItemInInventoryFromItemUsage(205, selectedItem);
				}
				ApplyItemTime(sItem);
				if (Main.netMode == 1)
				{
					NetMessage.sendWater(tileTargetX, tileTargetY);
				}
			}
			else if (sItem.type == 206 || sItem.type == 3031)
			{
				tile = Main.tile[tileTargetX, tileTargetY];
				if (tile.liquid != 0)
				{
					tile = Main.tile[tileTargetX, tileTargetY];
					if (tile.liquidType() != 0)
					{
						return;
					}
				}
				SoundEngine.PlaySound(19, (int)position.X, (int)position.Y);
				tile = Main.tile[tileTargetX, tileTargetY];
				tile.liquidType(0);
				tile = Main.tile[tileTargetX, tileTargetY];
				tile.liquid = byte.MaxValue;
				WorldGen.SquareTileFrame(tileTargetX, tileTargetY);
				if (sItem.type != 3031)
				{
					sItem.stack--;
					PutItemInInventoryFromItemUsage(205, selectedItem);
				}
				ApplyItemTime(sItem);
				if (Main.netMode == 1)
				{
					NetMessage.sendWater(tileTargetX, tileTargetY);
				}
			}
			else if (sItem.type == 1128 || sItem.type == 5302)
			{
				tile = Main.tile[tileTargetX, tileTargetY];
				if (tile.liquid != 0)
				{
					tile = Main.tile[tileTargetX, tileTargetY];
					if (tile.liquidType() != 2)
					{
						return;
					}
				}
				SoundEngine.PlaySound(19, (int)position.X, (int)position.Y);
				tile = Main.tile[tileTargetX, tileTargetY];
				tile.liquidType(2);
				tile = Main.tile[tileTargetX, tileTargetY];
				tile.liquid = byte.MaxValue;
				WorldGen.SquareTileFrame(tileTargetX, tileTargetY);
				if (sItem.type != 5302)
				{
					sItem.stack--;
					PutItemInInventoryFromItemUsage(205, selectedItem);
				}
				ApplyItemTime(sItem);
				if (Main.netMode == 1)
				{
					NetMessage.sendWater(tileTargetX, tileTargetY);
				}
			}
			else
			{
				if (sItem.type != 5364)
				{
					return;
				}
				tile = Main.tile[tileTargetX, tileTargetY];
				if (tile.liquid != 0)
				{
					tile = Main.tile[tileTargetX, tileTargetY];
					if (tile.liquidType() != 3)
					{
						return;
					}
				}
				SoundEngine.PlaySound(19, (int)position.X, (int)position.Y);
				tile = Main.tile[tileTargetX, tileTargetY];
				tile.liquidType(3);
				tile = Main.tile[tileTargetX, tileTargetY];
				tile.liquid = byte.MaxValue;
				WorldGen.SquareTileFrame(tileTargetX, tileTargetY);
				ApplyItemTime(sItem);
				if (Main.netMode == 1)
				{
					NetMessage.sendWater(tileTargetX, tileTargetY);
				}
			}
			return;
		}
		goto IL_027d;
		IL_027d:
		tile = Main.tile[tileTargetX, tileTargetY];
		int num = tile.liquidType();
		int num2 = 0;
		for (int i = tileTargetX - 1; i <= tileTargetX + 1; i++)
		{
			for (int j = tileTargetY - 1; j <= tileTargetY + 1; j++)
			{
				tile = Main.tile[i, j];
				if (tile.liquidType() == num)
				{
					int num3 = num2;
					tile = Main.tile[i, j];
					num2 = num3 + tile.liquid;
				}
			}
		}
		tile = Main.tile[tileTargetX, tileTargetY];
		if (tile.liquid <= 0 || (num2 <= 100 && sItem.type != 3032 && sItem.type != 4872 && sItem.type != 5303 && sItem.type != 5304))
		{
			return;
		}
		tile = Main.tile[tileTargetX, tileTargetY];
		int liquidType = tile.liquidType();
		if (sItem.type != 3032 && sItem.type != 4872 && sItem.type != 5303 && sItem.type != 5304)
		{
			tile = Main.tile[tileTargetX, tileTargetY];
			if (tile.honey() && sItem.type == 205)
			{
				sItem.stack--;
				PutItemInInventoryFromItemUsage(1128, selectedItem);
			}
			else
			{
				tile = Main.tile[tileTargetX, tileTargetY];
				if (tile.lava() && sItem.type == 205)
				{
					sItem.stack--;
					PutItemInInventoryFromItemUsage(207, selectedItem);
				}
				else
				{
					tile = Main.tile[tileTargetX, tileTargetY];
					if (tile.shimmer() && sItem.type == 205)
					{
						return;
					}
					sItem.stack--;
					PutItemInInventoryFromItemUsage(206, selectedItem);
				}
			}
		}
		SoundEngine.PlaySound(19, (int)position.X, (int)position.Y);
		ApplyItemTime(sItem);
		tile = Main.tile[tileTargetX, tileTargetY];
		int num4 = tile.liquid;
		tile = Main.tile[tileTargetX, tileTargetY];
		tile.liquid = 0;
		tile = Main.tile[tileTargetX, tileTargetY];
		tile.lava(lava: false);
		tile = Main.tile[tileTargetX, tileTargetY];
		tile.honey(honey: false);
		WorldGen.SquareTileFrame(tileTargetX, tileTargetY, resetFrame: false);
		if (Main.netMode == 1)
		{
			NetMessage.sendWater(tileTargetX, tileTargetY);
		}
		else
		{
			Liquid.AddWater(tileTargetX, tileTargetY);
		}
		if (num4 >= 255)
		{
			return;
		}
		for (int k = tileTargetX - 1; k <= tileTargetX + 1; k++)
		{
			for (int l = tileTargetY - 1; l <= tileTargetY + 1; l++)
			{
				if (k == tileTargetX && l == tileTargetY)
				{
					continue;
				}
				tile = Main.tile[k, l];
				if (tile.liquid <= 0)
				{
					continue;
				}
				tile = Main.tile[k, l];
				if (tile.liquidType() == num)
				{
					tile = Main.tile[k, l];
					int num5 = tile.liquid;
					if (num5 + num4 > 255)
					{
						num5 = 255 - num4;
					}
					num4 += num5;
					tile = Main.tile[k, l];
					tile.liquid -= (byte)num5;
					tile = Main.tile[k, l];
					tile.liquidType(liquidType);
					tile = Main.tile[k, l];
					if (tile.liquid == 0)
					{
						tile = Main.tile[k, l];
						tile.lava(lava: false);
						tile = Main.tile[k, l];
						tile.honey(honey: false);
					}
					WorldGen.SquareTileFrame(k, l, resetFrame: false);
					if (Main.netMode == 1)
					{
						NetMessage.sendWater(k, l);
					}
					else
					{
						Liquid.AddWater(k, l);
					}
				}
			}
		}
	}

	private void ItemCheck_PlayInstruments(Item sItem)
	{
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0142: Unknown result type (might be due to invalid IL or missing references)
		//IL_015b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0181: Unknown result type (might be due to invalid IL or missing references)
		//IL_05ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_05df: Unknown result type (might be due to invalid IL or missing references)
		//IL_02cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_030b: Unknown result type (might be due to invalid IL or missing references)
		//IL_042a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0443: Unknown result type (might be due to invalid IL or missing references)
		//IL_0469: Unknown result type (might be due to invalid IL or missing references)
		//IL_021c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0227: Unknown result type (might be due to invalid IL or missing references)
		//IL_052f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0548: Unknown result type (might be due to invalid IL or missing references)
		//IL_056e: Unknown result type (might be due to invalid IL or missing references)
		//IL_038e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0399: Unknown result type (might be due to invalid IL or missing references)
		//IL_06a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_06be: Unknown result type (might be due to invalid IL or missing references)
		//IL_06e4: Unknown result type (might be due to invalid IL or missing references)
		Vector2 val = default(Vector2);
		((Vector2)(ref val))..ctor(position.X + (float)width * 0.5f, position.Y + (float)height * 0.5f);
		float num = (float)Main.mouseX + Main.screenPosition.X - val.X;
		float num2 = (float)Main.mouseY + Main.screenPosition.Y - val.Y;
		float num3 = (float)Math.Sqrt(num * num + num2 * num2);
		float num4 = (float)Main.screenHeight / Main.GameViewMatrix.Zoom.Y;
		num3 /= num4 / 2f;
		if (num3 > 1f)
		{
			num3 = 1f;
		}
		musicDist = num3;
		if (itemAnimation > 0 && ItemTimeIsZero && (sItem.type == 508 || sItem.type == 507))
		{
			ApplyItemTime(sItem);
			Vector2 val2 = default(Vector2);
			((Vector2)(ref val2))..ctor(position.X + (float)width * 0.5f, position.Y + (float)height * 0.5f);
			float num5 = (float)Main.mouseX + Main.screenPosition.X - val2.X;
			float num6 = (float)Main.mouseY + Main.screenPosition.Y - val2.Y;
			float num7 = (float)Math.Sqrt(num5 * num5 + num6 * num6);
			float num8 = (float)Main.screenHeight / Main.GameViewMatrix.Zoom.Y;
			num7 /= num8 / 2f;
			if (num7 > 1f)
			{
				num7 = 1f;
			}
			num7 = num7 * 2f - 1f;
			if (num7 < -1f)
			{
				num7 = -1f;
			}
			if (num7 > 1f)
			{
				num7 = 1f;
			}
			num7 = (float)Math.Round(num7 * (float)musicNotes);
			num7 = (Main.musicPitch = num7 / (float)musicNotes);
			SoundStyle style = SoundID.Item26;
			if (sItem.type == 507)
			{
				style = SoundID.Item35;
			}
			SoundEngine.PlaySound(in style, position);
			NetMessage.SendData(58, -1, -1, null, whoAmI, num7);
		}
		if (itemAnimation <= 0 || mouseInterface)
		{
			return;
		}
		if (Main.mouseLeft && Main.mouseLeftRelease)
		{
			if (sItem.type == 1305)
			{
				Vector2 val3 = default(Vector2);
				((Vector2)(ref val3))..ctor(position.X + (float)width * 0.5f, position.Y + (float)height * 0.5f);
				float num9 = (float)Main.mouseX + Main.screenPosition.X - val3.X;
				float num10 = (float)Main.mouseY + Main.screenPosition.Y - val3.Y;
				float num11 = (float)Math.Sqrt(num9 * num9 + num10 * num10);
				float num12 = (float)Main.screenHeight / Main.GameViewMatrix.Zoom.Y;
				num11 /= num12 / 2f;
				if (num11 > 1f)
				{
					num11 = 1f;
				}
				num11 = num11 * 2f - 1f;
				if (num11 < -1f)
				{
					num11 = -1f;
				}
				if (num11 > 1f)
				{
					num11 = 1f;
				}
				num11 = (float)Math.Round(num11 * (float)musicNotes);
				num11 = (Main.musicPitch = num11 / (float)musicNotes);
				SoundEngine.PlaySound(in SoundID.Item47, position);
				NetMessage.SendData(58, -1, -1, null, whoAmI, num11);
			}
			else if (sItem.type == 4057 || sItem.type == 4372)
			{
				Vector2 val4 = default(Vector2);
				((Vector2)(ref val4))..ctor(position.X + (float)width * 0.5f, position.Y + (float)height * 0.5f);
				float num13 = (float)Main.mouseX + Main.screenPosition.X - val4.X;
				float num14 = (float)Main.mouseY + Main.screenPosition.Y - val4.Y;
				float num15 = (float)Math.Sqrt(num13 * num13 + num14 * num14);
				float num16 = (float)Main.screenHeight / Main.GameViewMatrix.Zoom.Y;
				num15 /= num16 / 2f;
				if (num15 > 1f)
				{
					num15 = 1f;
				}
				PlayGuitarChord(num15);
				NetMessage.SendData(58, -1, -1, null, whoAmI, num15);
			}
		}
		if (sItem.type == 4715 && ((Main.mouseLeft && Main.mouseLeftRelease) | ItemAnimationJustStarted))
		{
			Vector2 val5 = default(Vector2);
			((Vector2)(ref val5))..ctor(position.X + (float)width * 0.5f, position.Y + (float)height * 0.5f);
			float num17 = (float)Main.mouseX + Main.screenPosition.X - val5.X;
			float num18 = (float)Main.mouseY + Main.screenPosition.Y - val5.Y;
			float num19 = (float)Math.Sqrt(num17 * num17 + num18 * num18);
			float num20 = (float)Main.screenHeight / Main.GameViewMatrix.Zoom.Y;
			num19 /= num20 / 2f;
			if (num19 > 1f)
			{
				num19 = 1f;
			}
			PlayGuitarChord(num19);
			NetMessage.SendData(58, -1, -1, null, whoAmI, num19);
		}
		if (sItem.type != 4673)
		{
			return;
		}
		int x = (int)base.Center.X / 16;
		int y = (int)base.Center.Y / 16;
		if (WorldGen.InWorld(x, y) && Main.tile[x, y] != null && Main.tile[x, y].type == 486 && ((Main.mouseLeft && Main.mouseLeftRelease) || (Main.mouseRight && Main.mouseRightRelease)))
		{
			Vector2 val6 = default(Vector2);
			((Vector2)(ref val6))..ctor(position.X + (float)width * 0.5f, position.Y + (float)height * 0.5f);
			float num21 = (float)Main.mouseX + Main.screenPosition.X - val6.X;
			float num22 = (float)Main.mouseY + Main.screenPosition.Y - val6.Y;
			float num23 = (float)Math.Sqrt(num21 * num21 + num22 * num22);
			float num24 = (float)Main.screenHeight / Main.GameViewMatrix.Zoom.Y;
			num23 /= num24 / 2f;
			if (num23 > 1f)
			{
				num23 = 1f;
			}
			PlayDrums(num23);
			NetMessage.SendData(58, -1, -1, null, whoAmI, num23);
		}
	}

	private bool GetSparkleGuitarTarget(out List<NPC> validTargets)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		validTargets = new List<NPC>();
		Rectangle val = Utils.CenteredRectangle(base.Center, new Vector2(1000f, 800f));
		for (int i = 0; i < 200; i++)
		{
			NPC nPC = Main.npc[i];
			if (nPC.CanBeChasedBy(this))
			{
				Rectangle hitbox = nPC.Hitbox;
				if (((Rectangle)(ref hitbox)).Intersects(val))
				{
					validTargets.Add(nPC);
				}
			}
		}
		if (validTargets.Count == 0)
		{
			return false;
		}
		return true;
	}

	private bool GetZenithTarget(Vector2 searchCenter, float maxDistance, out int npcTargetIndex)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		npcTargetIndex = 0;
		int? num = null;
		float num2 = maxDistance;
		for (int i = 0; i < 200; i++)
		{
			NPC nPC = Main.npc[i];
			if (nPC.CanBeChasedBy(this))
			{
				float num3 = searchCenter.Distance(nPC.Center);
				if (!(num2 <= num3))
				{
					num = i;
					num2 = num3;
				}
			}
		}
		if (!num.HasValue)
		{
			return false;
		}
		npcTargetIndex = num.Value;
		return true;
	}

	public void PlayGuitarChord(float range)
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		int num = 6;
		float num2 = 1f / (float)num;
		if (range > num2 * 5f)
		{
			SoundEngine.PlaySound(49, base.Center);
		}
		else if (range > num2 * 4f)
		{
			SoundEngine.PlaySound(48, base.Center);
		}
		else if (range > num2 * 3f)
		{
			SoundEngine.PlaySound(47, base.Center);
		}
		else if (range > num2 * 2f)
		{
			SoundEngine.PlaySound(51, base.Center);
		}
		else if (range > num2 * 1f)
		{
			SoundEngine.PlaySound(52, base.Center);
		}
		else
		{
			SoundEngine.PlaySound(50, base.Center);
		}
	}

	public void PlayDrums(float range)
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		int num = 10;
		float num2 = 1f / (float)num;
		if (range > num2 * 9f)
		{
			SoundEngine.PlaySound(59, base.Center);
		}
		else if (range > num2 * 8f)
		{
			SoundEngine.PlaySound(58, base.Center);
		}
		else if (range > num2 * 7f)
		{
			SoundEngine.PlaySound(53, base.Center);
		}
		else if (range > num2 * 6f)
		{
			SoundEngine.PlaySound(57, base.Center);
		}
		else if (range > num2 * 5f)
		{
			SoundEngine.PlaySound(62, base.Center);
		}
		else if (range > num2 * 4f)
		{
			SoundEngine.PlaySound(61, base.Center);
		}
		else if (range > num2 * 3f)
		{
			SoundEngine.PlaySound(54, base.Center);
		}
		else if (range > num2 * 2f)
		{
			SoundEngine.PlaySound(56, base.Center);
		}
		else if (range > num2 * 1f)
		{
			SoundEngine.PlaySound(55, base.Center);
		}
		else
		{
			SoundEngine.PlaySound(60, base.Center);
		}
	}

	private void ItemCheck_UseWiringTools(Item sItem)
	{
		//IL_082e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0830: Unknown result type (might be due to invalid IL or missing references)
		//IL_0801: Unknown result type (might be due to invalid IL or missing references)
		//IL_0808: Unknown result type (might be due to invalid IL or missing references)
		//IL_0810: Unknown result type (might be due to invalid IL or missing references)
		//IL_0818: Unknown result type (might be due to invalid IL or missing references)
		if ((sItem.type != 509 && sItem.type != 510 && sItem.type != 849 && sItem.type != 850 && sItem.type != 851 && sItem.type != 3612 && sItem.type != 3620 && sItem.type != 3625) || !(position.X / 16f - (float)tileRangeX - (float)sItem.tileBoost - (float)blockRange <= (float)tileTargetX) || !((position.X + (float)width) / 16f + (float)tileRangeX + (float)sItem.tileBoost - 1f + (float)blockRange >= (float)tileTargetX) || !(position.Y / 16f - (float)tileRangeY - (float)sItem.tileBoost - (float)blockRange <= (float)tileTargetY) || !((position.Y + (float)height) / 16f + (float)tileRangeY + (float)sItem.tileBoost - 2f + (float)blockRange >= (float)tileTargetY))
		{
			return;
		}
		if (!Main.GamepadDisableCursorItemIcon)
		{
			cursorItemIconEnabled = true;
			Main.ItemIconCacheUpdate(sItem.type);
		}
		if (!CanDoWireStuffHere(tileTargetX, tileTargetY) || itemAnimation <= 0 || !ItemTimeIsZero || !controlUseItem)
		{
			return;
		}
		int num = tileTargetX;
		int num2 = tileTargetY;
		if (sItem.type == 509)
		{
			int num3 = -1;
			for (int i = 0; i < 58; i++)
			{
				if (inventory[i].stack > 0 && inventory[i].type == 530)
				{
					num3 = i;
					break;
				}
			}
			if (num3 >= 0 && WorldGen.PlaceWire(num, num2))
			{
				if (ItemLoader.ConsumeItem(inventory[num3], this))
				{
					inventory[num3].stack--;
				}
				if (inventory[num3].stack <= 0)
				{
					inventory[num3].SetDefaults();
				}
				ApplyItemTime(sItem);
				NetMessage.SendData(17, -1, -1, null, 5, tileTargetX, tileTargetY);
			}
		}
		else if (sItem.type == 850)
		{
			int num4 = -1;
			for (int j = 0; j < 58; j++)
			{
				if (inventory[j].stack > 0 && inventory[j].type == 530)
				{
					num4 = j;
					break;
				}
			}
			if (num4 >= 0 && WorldGen.PlaceWire2(num, num2))
			{
				if (ItemLoader.ConsumeItem(inventory[num4], this))
				{
					inventory[num4].stack--;
				}
				if (inventory[num4].stack <= 0)
				{
					inventory[num4].SetDefaults();
				}
				ApplyItemTime(sItem);
				NetMessage.SendData(17, -1, -1, null, 10, tileTargetX, tileTargetY);
			}
		}
		if (sItem.type == 851)
		{
			int num5 = -1;
			for (int k = 0; k < 58; k++)
			{
				if (inventory[k].stack > 0 && inventory[k].type == 530)
				{
					num5 = k;
					break;
				}
			}
			if (num5 >= 0 && WorldGen.PlaceWire3(num, num2))
			{
				if (ItemLoader.ConsumeItem(inventory[num5], this))
				{
					inventory[num5].stack--;
				}
				if (inventory[num5].stack <= 0)
				{
					inventory[num5].SetDefaults();
				}
				ApplyItemTime(sItem);
				NetMessage.SendData(17, -1, -1, null, 12, tileTargetX, tileTargetY);
			}
		}
		if (sItem.type == 3612)
		{
			int num6 = -1;
			for (int l = 0; l < 58; l++)
			{
				if (inventory[l].stack > 0 && inventory[l].type == 530)
				{
					num6 = l;
					break;
				}
			}
			if (num6 >= 0 && WorldGen.PlaceWire4(num, num2))
			{
				if (ItemLoader.ConsumeItem(inventory[num6], this))
				{
					inventory[num6].stack--;
				}
				if (inventory[num6].stack <= 0)
				{
					inventory[num6].SetDefaults();
				}
				ApplyItemTime(sItem);
				NetMessage.SendData(17, -1, -1, null, 16, tileTargetX, tileTargetY);
			}
		}
		else if (sItem.type == 510)
		{
			if (WorldGen.KillActuator(num, num2))
			{
				ApplyItemTime(sItem);
				NetMessage.SendData(17, -1, -1, null, 9, tileTargetX, tileTargetY);
			}
			else if (WorldGen.KillWire4(num, num2))
			{
				ApplyItemTime(sItem);
				NetMessage.SendData(17, -1, -1, null, 17, tileTargetX, tileTargetY);
			}
			else if (WorldGen.KillWire3(num, num2))
			{
				ApplyItemTime(sItem);
				NetMessage.SendData(17, -1, -1, null, 13, tileTargetX, tileTargetY);
			}
			else if (WorldGen.KillWire2(num, num2))
			{
				ApplyItemTime(sItem);
				NetMessage.SendData(17, -1, -1, null, 11, tileTargetX, tileTargetY);
			}
			else if (WorldGen.KillWire(num, num2))
			{
				ApplyItemTime(sItem);
				NetMessage.SendData(17, -1, -1, null, 6, tileTargetX, tileTargetY);
			}
		}
		else if (sItem.type == 849 && sItem.stack > 0 && WorldGen.PlaceActuator(num, num2))
		{
			ApplyItemTime(sItem);
			NetMessage.SendData(17, -1, -1, null, 8, tileTargetX, tileTargetY);
			if (ItemLoader.ConsumeItem(sItem, this))
			{
				sItem.stack--;
			}
			if (sItem.stack <= 0)
			{
				sItem.SetDefaults();
			}
		}
		if (sItem.type == 3620)
		{
			Tile tile = Main.tile[num, num2];
			if (tile != null && tile.actuator())
			{
				bool flag = tile.inActive();
				if ((!ActuationRodLock || ActuationRodLockSetting == tile.inActive()) && Wiring.Actuate(num, num2) && flag != tile.inActive())
				{
					ActuationRodLock = true;
					ActuationRodLockSetting = !tile.inActive();
					ApplyItemTime(sItem);
					NetMessage.SendData(17, -1, -1, null, 19, tileTargetX, tileTargetY);
				}
			}
		}
		if (sItem.type == 3625)
		{
			Point val = default(Point);
			((Point)(ref val))..ctor(tileTargetX, tileTargetY);
			ApplyItemTime(sItem);
			WiresUI.Settings.MultiToolMode toolMode = WiresUI.Settings.ToolMode;
			WiresUI.Settings.ToolMode &= ~WiresUI.Settings.MultiToolMode.Actuator;
			if (Main.netMode == 1)
			{
				NetMessage.SendData(109, -1, -1, null, val.X, val.Y, val.X, val.Y, (int)WiresUI.Settings.ToolMode);
			}
			else
			{
				Wiring.MassWireOperation(val, val, this);
			}
			WiresUI.Settings.ToolMode = toolMode;
		}
	}

	public bool CanDoWireStuffHere(int x, int y)
	{
		if (!WorldGen.InWorld(x, y))
		{
			return false;
		}
		if (!NPC.downedGolemBoss && Main.tile[x, y].wall == 87)
		{
			return false;
		}
		return true;
	}

	private void ItemCheck_UseLawnMower(Item sItem)
	{
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_0128: Unknown result type (might be due to invalid IL or missing references)
		if (sItem.type == 4049 && position.X / 16f - (float)tileRangeX - (float)sItem.tileBoost - (float)blockRange <= (float)tileTargetX && (position.X + (float)width) / 16f + (float)tileRangeX + (float)sItem.tileBoost - 1f + (float)blockRange >= (float)tileTargetX && position.Y / 16f - (float)tileRangeY - (float)sItem.tileBoost - (float)blockRange <= (float)tileTargetY && (position.Y + (float)height) / 16f + (float)tileRangeY + (float)sItem.tileBoost - 2f + (float)blockRange >= (float)tileTargetY && itemAnimation > 0 && ItemTimeIsZero && controlUseItem)
		{
			MowGrassTile(Utils.ToWorldCoordinates(new Point(tileTargetX, tileTargetY), 8f, 8f));
			ApplyItemTime(sItem);
		}
	}

	private void DestroyOldestProximityMinesOverMinesCap(int minesCap)
	{
		_oldestProjCheckList.Clear();
		for (int i = 0; i < 1000; i++)
		{
			Projectile projectile = Main.projectile[i];
			if (projectile.active && projectile.owner == whoAmI)
			{
				switch (projectile.type)
				{
				case 135:
				case 138:
				case 141:
				case 144:
				case 778:
				case 782:
				case 786:
				case 789:
				case 792:
				case 795:
				case 798:
				case 801:
					_oldestProjCheckList.Add(projectile);
					break;
				}
			}
		}
		while (_oldestProjCheckList.Count > minesCap)
		{
			Projectile projectile2 = _oldestProjCheckList[0];
			for (int j = 1; j < _oldestProjCheckList.Count; j++)
			{
				if (_oldestProjCheckList[j].timeLeft < projectile2.timeLeft)
				{
					projectile2 = _oldestProjCheckList[j];
				}
			}
			projectile2.Kill();
			_oldestProjCheckList.Remove(projectile2);
		}
		_oldestProjCheckList.Clear();
	}

	private void ItemCheck_Shoot(int i, Item sItem, int weaponDamage)
	{
		//IL_02aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_02db: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_02fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0308: Unknown result type (might be due to invalid IL or missing references)
		//IL_030d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0339: Unknown result type (might be due to invalid IL or missing references)
		//IL_033b: Unknown result type (might be due to invalid IL or missing references)
		//IL_034e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0324: Unknown result type (might be due to invalid IL or missing references)
		//IL_0332: Unknown result type (might be due to invalid IL or missing references)
		//IL_0337: Unknown result type (might be due to invalid IL or missing references)
		//IL_0438: Unknown result type (might be due to invalid IL or missing references)
		//IL_043a: Unknown result type (might be due to invalid IL or missing references)
		//IL_043c: Unknown result type (might be due to invalid IL or missing references)
		//IL_043e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0469: Unknown result type (might be due to invalid IL or missing references)
		//IL_046b: Unknown result type (might be due to invalid IL or missing references)
		//IL_046d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0472: Unknown result type (might be due to invalid IL or missing references)
		//IL_0487: Unknown result type (might be due to invalid IL or missing references)
		//IL_048d: Unknown result type (might be due to invalid IL or missing references)
		//IL_048f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0499: Unknown result type (might be due to invalid IL or missing references)
		//IL_049e: Unknown result type (might be due to invalid IL or missing references)
		//IL_04a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0451: Unknown result type (might be due to invalid IL or missing references)
		//IL_0453: Unknown result type (might be due to invalid IL or missing references)
		//IL_0455: Unknown result type (might be due to invalid IL or missing references)
		//IL_045a: Unknown result type (might be due to invalid IL or missing references)
		//IL_04fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_05b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_05ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_0623: Unknown result type (might be due to invalid IL or missing references)
		//IL_05ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_05ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_0761: Unknown result type (might be due to invalid IL or missing references)
		//IL_0768: Unknown result type (might be due to invalid IL or missing references)
		//IL_076e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0778: Unknown result type (might be due to invalid IL or missing references)
		//IL_077d: Unknown result type (might be due to invalid IL or missing references)
		//IL_07b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_07b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_07bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_07c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_07cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_078b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0791: Unknown result type (might be due to invalid IL or missing references)
		//IL_079b: Unknown result type (might be due to invalid IL or missing references)
		//IL_07a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_07a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0806: Unknown result type (might be due to invalid IL or missing references)
		//IL_081b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0826: Unknown result type (might be due to invalid IL or missing references)
		//IL_082b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0835: Unknown result type (might be due to invalid IL or missing references)
		//IL_083b: Unknown result type (might be due to invalid IL or missing references)
		//IL_083d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0842: Unknown result type (might be due to invalid IL or missing references)
		//IL_0847: Unknown result type (might be due to invalid IL or missing references)
		//IL_0849: Unknown result type (might be due to invalid IL or missing references)
		//IL_084d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0853: Unknown result type (might be due to invalid IL or missing references)
		//IL_085d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0862: Unknown result type (might be due to invalid IL or missing references)
		//IL_07de: Unknown result type (might be due to invalid IL or missing references)
		//IL_07e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_07ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_07f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_07f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_07f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_07fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_08b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_08b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_08b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_08d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_08d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_08db: Unknown result type (might be due to invalid IL or missing references)
		//IL_08f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_08fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0870: Unknown result type (might be due to invalid IL or missing references)
		//IL_0876: Unknown result type (might be due to invalid IL or missing references)
		//IL_0880: Unknown result type (might be due to invalid IL or missing references)
		//IL_0885: Unknown result type (might be due to invalid IL or missing references)
		//IL_088a: Unknown result type (might be due to invalid IL or missing references)
		//IL_092d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0936: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c42: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c44: Unknown result type (might be due to invalid IL or missing references)
		//IL_0979: Unknown result type (might be due to invalid IL or missing references)
		//IL_0999: Unknown result type (might be due to invalid IL or missing references)
		//IL_09ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_09bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a4f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a6f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a83: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a93: Unknown result type (might be due to invalid IL or missing references)
		//IL_0ce5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0d5f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0d66: Unknown result type (might be due to invalid IL or missing references)
		//IL_12c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_12d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_133a: Unknown result type (might be due to invalid IL or missing references)
		//IL_1341: Unknown result type (might be due to invalid IL or missing references)
		//IL_10df: Unknown result type (might be due to invalid IL or missing references)
		//IL_10f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_1104: Unknown result type (might be due to invalid IL or missing references)
		//IL_1156: Unknown result type (might be due to invalid IL or missing references)
		//IL_1171: Unknown result type (might be due to invalid IL or missing references)
		//IL_0ebd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0ed4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0ee2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0f2d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0f48: Unknown result type (might be due to invalid IL or missing references)
		//IL_13ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_13b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_140e: Unknown result type (might be due to invalid IL or missing references)
		//IL_1411: Unknown result type (might be due to invalid IL or missing references)
		//IL_1416: Unknown result type (might be due to invalid IL or missing references)
		//IL_141b: Unknown result type (might be due to invalid IL or missing references)
		//IL_1230: Unknown result type (might be due to invalid IL or missing references)
		//IL_1237: Unknown result type (might be due to invalid IL or missing references)
		//IL_100a: Unknown result type (might be due to invalid IL or missing references)
		//IL_1011: Unknown result type (might be due to invalid IL or missing references)
		//IL_142f: Unknown result type (might be due to invalid IL or missing references)
		//IL_16aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_16ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_16b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_1741: Unknown result type (might be due to invalid IL or missing references)
		//IL_1745: Unknown result type (might be due to invalid IL or missing references)
		//IL_174a: Unknown result type (might be due to invalid IL or missing references)
		//IL_174c: Unknown result type (might be due to invalid IL or missing references)
		//IL_1755: Unknown result type (might be due to invalid IL or missing references)
		//IL_1760: Unknown result type (might be due to invalid IL or missing references)
		//IL_1767: Unknown result type (might be due to invalid IL or missing references)
		//IL_1778: Unknown result type (might be due to invalid IL or missing references)
		//IL_177f: Unknown result type (might be due to invalid IL or missing references)
		//IL_14fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_1503: Unknown result type (might be due to invalid IL or missing references)
		//IL_1508: Unknown result type (might be due to invalid IL or missing references)
		//IL_17a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_17ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_17b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_17c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_17c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_17c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_17cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_17cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_17cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_154c: Unknown result type (might be due to invalid IL or missing references)
		//IL_1554: Unknown result type (might be due to invalid IL or missing references)
		//IL_1559: Unknown result type (might be due to invalid IL or missing references)
		//IL_153a: Unknown result type (might be due to invalid IL or missing references)
		//IL_153c: Unknown result type (might be due to invalid IL or missing references)
		//IL_153e: Unknown result type (might be due to invalid IL or missing references)
		//IL_1543: Unknown result type (might be due to invalid IL or missing references)
		//IL_1462: Unknown result type (might be due to invalid IL or missing references)
		//IL_1469: Unknown result type (might be due to invalid IL or missing references)
		//IL_144e: Unknown result type (might be due to invalid IL or missing references)
		//IL_1455: Unknown result type (might be due to invalid IL or missing references)
		//IL_17ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_17dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_17df: Unknown result type (might be due to invalid IL or missing references)
		//IL_17e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_17e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_1492: Unknown result type (might be due to invalid IL or missing references)
		//IL_1499: Unknown result type (might be due to invalid IL or missing references)
		//IL_1a06: Unknown result type (might be due to invalid IL or missing references)
		//IL_1a0d: Unknown result type (might be due to invalid IL or missing references)
		//IL_1979: Unknown result type (might be due to invalid IL or missing references)
		//IL_1980: Unknown result type (might be due to invalid IL or missing references)
		//IL_15c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_15ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_15d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_15dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_1845: Unknown result type (might be due to invalid IL or missing references)
		//IL_1864: Unknown result type (might be due to invalid IL or missing references)
		//IL_186a: Unknown result type (might be due to invalid IL or missing references)
		//IL_186c: Unknown result type (might be due to invalid IL or missing references)
		//IL_1873: Unknown result type (might be due to invalid IL or missing references)
		//IL_1878: Unknown result type (might be due to invalid IL or missing references)
		//IL_187c: Unknown result type (might be due to invalid IL or missing references)
		//IL_1883: Unknown result type (might be due to invalid IL or missing references)
		//IL_188a: Unknown result type (might be due to invalid IL or missing references)
		//IL_1891: Unknown result type (might be due to invalid IL or missing references)
		//IL_1ac2: Unknown result type (might be due to invalid IL or missing references)
		//IL_1adb: Unknown result type (might be due to invalid IL or missing references)
		//IL_1ba5: Unknown result type (might be due to invalid IL or missing references)
		//IL_1bbc: Unknown result type (might be due to invalid IL or missing references)
		//IL_1bc4: Unknown result type (might be due to invalid IL or missing references)
		//IL_1c12: Unknown result type (might be due to invalid IL or missing references)
		//IL_1c2d: Unknown result type (might be due to invalid IL or missing references)
		//IL_2102: Unknown result type (might be due to invalid IL or missing references)
		//IL_2108: Unknown result type (might be due to invalid IL or missing references)
		//IL_210d: Unknown result type (might be due to invalid IL or missing references)
		//IL_210f: Unknown result type (might be due to invalid IL or missing references)
		//IL_2114: Unknown result type (might be due to invalid IL or missing references)
		//IL_2118: Unknown result type (might be due to invalid IL or missing references)
		//IL_211a: Unknown result type (might be due to invalid IL or missing references)
		//IL_1d99: Unknown result type (might be due to invalid IL or missing references)
		//IL_1db0: Unknown result type (might be due to invalid IL or missing references)
		//IL_1db8: Unknown result type (might be due to invalid IL or missing references)
		//IL_1e06: Unknown result type (might be due to invalid IL or missing references)
		//IL_1e37: Unknown result type (might be due to invalid IL or missing references)
		//IL_1c5c: Unknown result type (might be due to invalid IL or missing references)
		//IL_2148: Unknown result type (might be due to invalid IL or missing references)
		//IL_2159: Unknown result type (might be due to invalid IL or missing references)
		//IL_215e: Unknown result type (might be due to invalid IL or missing references)
		//IL_2163: Unknown result type (might be due to invalid IL or missing references)
		//IL_2165: Unknown result type (might be due to invalid IL or missing references)
		//IL_2171: Unknown result type (might be due to invalid IL or missing references)
		//IL_1fb0: Unknown result type (might be due to invalid IL or missing references)
		//IL_1fc7: Unknown result type (might be due to invalid IL or missing references)
		//IL_1fcf: Unknown result type (might be due to invalid IL or missing references)
		//IL_201d: Unknown result type (might be due to invalid IL or missing references)
		//IL_2038: Unknown result type (might be due to invalid IL or missing references)
		//IL_2044: Unknown result type (might be due to invalid IL or missing references)
		//IL_1e66: Unknown result type (might be due to invalid IL or missing references)
		//IL_22ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_22d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_22d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_22d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_22dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_22de: Unknown result type (might be due to invalid IL or missing references)
		//IL_22e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_2184: Unknown result type (might be due to invalid IL or missing references)
		//IL_1ce7: Unknown result type (might be due to invalid IL or missing references)
		//IL_1cee: Unknown result type (might be due to invalid IL or missing references)
		//IL_23d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_23db: Unknown result type (might be due to invalid IL or missing references)
		//IL_209d: Unknown result type (might be due to invalid IL or missing references)
		//IL_20a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_20ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_20b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_20b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_20be: Unknown result type (might be due to invalid IL or missing references)
		//IL_20c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_1edb: Unknown result type (might be due to invalid IL or missing references)
		//IL_1ee2: Unknown result type (might be due to invalid IL or missing references)
		//IL_2445: Unknown result type (might be due to invalid IL or missing references)
		//IL_244c: Unknown result type (might be due to invalid IL or missing references)
		//IL_230b: Unknown result type (might be due to invalid IL or missing references)
		//IL_2315: Unknown result type (might be due to invalid IL or missing references)
		//IL_231b: Unknown result type (might be due to invalid IL or missing references)
		//IL_231d: Unknown result type (might be due to invalid IL or missing references)
		//IL_2322: Unknown result type (might be due to invalid IL or missing references)
		//IL_219f: Unknown result type (might be due to invalid IL or missing references)
		//IL_21c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_21c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_21cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_21df: Unknown result type (might be due to invalid IL or missing references)
		//IL_21e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_21e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_21e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_21ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_24be: Unknown result type (might be due to invalid IL or missing references)
		//IL_24c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_2335: Unknown result type (might be due to invalid IL or missing references)
		//IL_233c: Unknown result type (might be due to invalid IL or missing references)
		//IL_2344: Unknown result type (might be due to invalid IL or missing references)
		//IL_234b: Unknown result type (might be due to invalid IL or missing references)
		//IL_2328: Unknown result type (might be due to invalid IL or missing references)
		//IL_232a: Unknown result type (might be due to invalid IL or missing references)
		//IL_232c: Unknown result type (might be due to invalid IL or missing references)
		//IL_2331: Unknown result type (might be due to invalid IL or missing references)
		//IL_2208: Unknown result type (might be due to invalid IL or missing references)
		//IL_2537: Unknown result type (might be due to invalid IL or missing references)
		//IL_253e: Unknown result type (might be due to invalid IL or missing references)
		//IL_2229: Unknown result type (might be due to invalid IL or missing references)
		//IL_222c: Unknown result type (might be due to invalid IL or missing references)
		//IL_2231: Unknown result type (might be due to invalid IL or missing references)
		//IL_2233: Unknown result type (might be due to invalid IL or missing references)
		//IL_223c: Unknown result type (might be due to invalid IL or missing references)
		//IL_2265: Unknown result type (might be due to invalid IL or missing references)
		//IL_226c: Unknown result type (might be due to invalid IL or missing references)
		//IL_257d: Unknown result type (might be due to invalid IL or missing references)
		//IL_2584: Unknown result type (might be due to invalid IL or missing references)
		//IL_27cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_27e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_27e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_27ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_27ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_292a: Unknown result type (might be due to invalid IL or missing references)
		//IL_2931: Unknown result type (might be due to invalid IL or missing references)
		//IL_2936: Unknown result type (might be due to invalid IL or missing references)
		//IL_2938: Unknown result type (might be due to invalid IL or missing references)
		//IL_293c: Unknown result type (might be due to invalid IL or missing references)
		//IL_293e: Unknown result type (might be due to invalid IL or missing references)
		//IL_2940: Unknown result type (might be due to invalid IL or missing references)
		//IL_282c: Unknown result type (might be due to invalid IL or missing references)
		//IL_2847: Unknown result type (might be due to invalid IL or missing references)
		//IL_284c: Unknown result type (might be due to invalid IL or missing references)
		//IL_2851: Unknown result type (might be due to invalid IL or missing references)
		//IL_2853: Unknown result type (might be due to invalid IL or missing references)
		//IL_2855: Unknown result type (might be due to invalid IL or missing references)
		//IL_285a: Unknown result type (might be due to invalid IL or missing references)
		//IL_2861: Unknown result type (might be due to invalid IL or missing references)
		//IL_2868: Unknown result type (might be due to invalid IL or missing references)
		//IL_25e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_25e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_25ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_2985: Unknown result type (might be due to invalid IL or missing references)
		//IL_298f: Unknown result type (might be due to invalid IL or missing references)
		//IL_2995: Unknown result type (might be due to invalid IL or missing references)
		//IL_2997: Unknown result type (might be due to invalid IL or missing references)
		//IL_299c: Unknown result type (might be due to invalid IL or missing references)
		//IL_28c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_28ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_28d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_28d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_2bae: Unknown result type (might be due to invalid IL or missing references)
		//IL_2bb5: Unknown result type (might be due to invalid IL or missing references)
		//IL_29ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_29b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_29b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_29b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_29b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_29bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_29bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_29bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_29c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_29c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_29cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_29d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_29d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_29d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_29de: Unknown result type (might be due to invalid IL or missing references)
		//IL_29e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_29ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_29f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_29f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_29fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_2a00: Unknown result type (might be due to invalid IL or missing references)
		//IL_2a05: Unknown result type (might be due to invalid IL or missing references)
		//IL_2a11: Unknown result type (might be due to invalid IL or missing references)
		//IL_2a14: Unknown result type (might be due to invalid IL or missing references)
		//IL_29a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_29a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_29a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_29a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_25fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_2605: Unknown result type (might be due to invalid IL or missing references)
		//IL_261c: Unknown result type (might be due to invalid IL or missing references)
		//IL_2621: Unknown result type (might be due to invalid IL or missing references)
		//IL_2ceb: Unknown result type (might be due to invalid IL or missing references)
		//IL_2cf0: Unknown result type (might be due to invalid IL or missing references)
		//IL_2cfa: Unknown result type (might be due to invalid IL or missing references)
		//IL_2d0b: Unknown result type (might be due to invalid IL or missing references)
		//IL_2d10: Unknown result type (might be due to invalid IL or missing references)
		//IL_2d15: Unknown result type (might be due to invalid IL or missing references)
		//IL_2d18: Unknown result type (might be due to invalid IL or missing references)
		//IL_2d1a: Unknown result type (might be due to invalid IL or missing references)
		//IL_2d39: Unknown result type (might be due to invalid IL or missing references)
		//IL_2d3e: Unknown result type (might be due to invalid IL or missing references)
		//IL_2d40: Unknown result type (might be due to invalid IL or missing references)
		//IL_2d42: Unknown result type (might be due to invalid IL or missing references)
		//IL_2d44: Unknown result type (might be due to invalid IL or missing references)
		//IL_2d49: Unknown result type (might be due to invalid IL or missing references)
		//IL_2d4e: Unknown result type (might be due to invalid IL or missing references)
		//IL_2d53: Unknown result type (might be due to invalid IL or missing references)
		//IL_2d5d: Unknown result type (might be due to invalid IL or missing references)
		//IL_2d62: Unknown result type (might be due to invalid IL or missing references)
		//IL_2d66: Unknown result type (might be due to invalid IL or missing references)
		//IL_2d6d: Unknown result type (might be due to invalid IL or missing references)
		//IL_2d74: Unknown result type (might be due to invalid IL or missing references)
		//IL_2d7b: Unknown result type (might be due to invalid IL or missing references)
		//IL_2b5b: Unknown result type (might be due to invalid IL or missing references)
		//IL_2b62: Unknown result type (might be due to invalid IL or missing references)
		//IL_2a59: Unknown result type (might be due to invalid IL or missing references)
		//IL_2a5c: Unknown result type (might be due to invalid IL or missing references)
		//IL_2a61: Unknown result type (might be due to invalid IL or missing references)
		//IL_2a2f: Unknown result type (might be due to invalid IL or missing references)
		//IL_2a31: Unknown result type (might be due to invalid IL or missing references)
		//IL_2a35: Unknown result type (might be due to invalid IL or missing references)
		//IL_2a3e: Unknown result type (might be due to invalid IL or missing references)
		//IL_2a43: Unknown result type (might be due to invalid IL or missing references)
		//IL_2a48: Unknown result type (might be due to invalid IL or missing references)
		//IL_2a4d: Unknown result type (might be due to invalid IL or missing references)
		//IL_2a52: Unknown result type (might be due to invalid IL or missing references)
		//IL_2a57: Unknown result type (might be due to invalid IL or missing references)
		//IL_2632: Unknown result type (might be due to invalid IL or missing references)
		//IL_2643: Unknown result type (might be due to invalid IL or missing references)
		//IL_264a: Unknown result type (might be due to invalid IL or missing references)
		//IL_2dbf: Unknown result type (might be due to invalid IL or missing references)
		//IL_2dc4: Unknown result type (might be due to invalid IL or missing references)
		//IL_2bf7: Unknown result type (might be due to invalid IL or missing references)
		//IL_2bf9: Unknown result type (might be due to invalid IL or missing references)
		//IL_2bfb: Unknown result type (might be due to invalid IL or missing references)
		//IL_2c00: Unknown result type (might be due to invalid IL or missing references)
		//IL_2c15: Unknown result type (might be due to invalid IL or missing references)
		//IL_2c1b: Unknown result type (might be due to invalid IL or missing references)
		//IL_2c1d: Unknown result type (might be due to invalid IL or missing references)
		//IL_2c2c: Unknown result type (might be due to invalid IL or missing references)
		//IL_2c36: Unknown result type (might be due to invalid IL or missing references)
		//IL_2c3b: Unknown result type (might be due to invalid IL or missing references)
		//IL_2c40: Unknown result type (might be due to invalid IL or missing references)
		//IL_2c42: Unknown result type (might be due to invalid IL or missing references)
		//IL_2c44: Unknown result type (might be due to invalid IL or missing references)
		//IL_2c49: Unknown result type (might be due to invalid IL or missing references)
		//IL_2c50: Unknown result type (might be due to invalid IL or missing references)
		//IL_2c55: Unknown result type (might be due to invalid IL or missing references)
		//IL_2c57: Unknown result type (might be due to invalid IL or missing references)
		//IL_2c60: Unknown result type (might be due to invalid IL or missing references)
		//IL_2c9f: Unknown result type (might be due to invalid IL or missing references)
		//IL_2ca6: Unknown result type (might be due to invalid IL or missing references)
		//IL_2675: Unknown result type (might be due to invalid IL or missing references)
		//IL_2f37: Unknown result type (might be due to invalid IL or missing references)
		//IL_2f3c: Unknown result type (might be due to invalid IL or missing references)
		//IL_2e0a: Unknown result type (might be due to invalid IL or missing references)
		//IL_2e0d: Unknown result type (might be due to invalid IL or missing references)
		//IL_2e12: Unknown result type (might be due to invalid IL or missing references)
		//IL_2e17: Unknown result type (might be due to invalid IL or missing references)
		//IL_2ded: Unknown result type (might be due to invalid IL or missing references)
		//IL_2df4: Unknown result type (might be due to invalid IL or missing references)
		//IL_2dfe: Unknown result type (might be due to invalid IL or missing references)
		//IL_2e03: Unknown result type (might be due to invalid IL or missing references)
		//IL_2e08: Unknown result type (might be due to invalid IL or missing references)
		//IL_2acb: Unknown result type (might be due to invalid IL or missing references)
		//IL_2acd: Unknown result type (might be due to invalid IL or missing references)
		//IL_2a90: Unknown result type (might be due to invalid IL or missing references)
		//IL_2a92: Unknown result type (might be due to invalid IL or missing references)
		//IL_2a97: Unknown result type (might be due to invalid IL or missing references)
		//IL_2aa3: Unknown result type (might be due to invalid IL or missing references)
		//IL_2aa8: Unknown result type (might be due to invalid IL or missing references)
		//IL_2aac: Unknown result type (might be due to invalid IL or missing references)
		//IL_2aae: Unknown result type (might be due to invalid IL or missing references)
		//IL_28ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_28bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_26c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_3174: Unknown result type (might be due to invalid IL or missing references)
		//IL_317a: Unknown result type (might be due to invalid IL or missing references)
		//IL_317e: Unknown result type (might be due to invalid IL or missing references)
		//IL_3184: Unknown result type (might be due to invalid IL or missing references)
		//IL_2f85: Unknown result type (might be due to invalid IL or missing references)
		//IL_2f88: Unknown result type (might be due to invalid IL or missing references)
		//IL_2f8d: Unknown result type (might be due to invalid IL or missing references)
		//IL_2f92: Unknown result type (might be due to invalid IL or missing references)
		//IL_2fa3: Unknown result type (might be due to invalid IL or missing references)
		//IL_2fa8: Unknown result type (might be due to invalid IL or missing references)
		//IL_2f68: Unknown result type (might be due to invalid IL or missing references)
		//IL_2f6f: Unknown result type (might be due to invalid IL or missing references)
		//IL_2f79: Unknown result type (might be due to invalid IL or missing references)
		//IL_2f7e: Unknown result type (might be due to invalid IL or missing references)
		//IL_2f83: Unknown result type (might be due to invalid IL or missing references)
		//IL_2e7a: Unknown result type (might be due to invalid IL or missing references)
		//IL_2e7f: Unknown result type (might be due to invalid IL or missing references)
		//IL_2e81: Unknown result type (might be due to invalid IL or missing references)
		//IL_2e1b: Unknown result type (might be due to invalid IL or missing references)
		//IL_2e2c: Unknown result type (might be due to invalid IL or missing references)
		//IL_2e31: Unknown result type (might be due to invalid IL or missing references)
		//IL_2e36: Unknown result type (might be due to invalid IL or missing references)
		//IL_268b: Unknown result type (might be due to invalid IL or missing references)
		//IL_31a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_31aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_31ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_31b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_2e9d: Unknown result type (might be due to invalid IL or missing references)
		//IL_2e8f: Unknown result type (might be due to invalid IL or missing references)
		//IL_2e96: Unknown result type (might be due to invalid IL or missing references)
		//IL_2e9b: Unknown result type (might be due to invalid IL or missing references)
		//IL_2e46: Unknown result type (might be due to invalid IL or missing references)
		//IL_2e55: Unknown result type (might be due to invalid IL or missing references)
		//IL_2e5a: Unknown result type (might be due to invalid IL or missing references)
		//IL_2e5d: Unknown result type (might be due to invalid IL or missing references)
		//IL_2e62: Unknown result type (might be due to invalid IL or missing references)
		//IL_2e64: Unknown result type (might be due to invalid IL or missing references)
		//IL_2e69: Unknown result type (might be due to invalid IL or missing references)
		//IL_31d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_31da: Unknown result type (might be due to invalid IL or missing references)
		//IL_31de: Unknown result type (might be due to invalid IL or missing references)
		//IL_31e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_2ed3: Unknown result type (might be due to invalid IL or missing references)
		//IL_2ee2: Unknown result type (might be due to invalid IL or missing references)
		//IL_2ee7: Unknown result type (might be due to invalid IL or missing references)
		//IL_2eeb: Unknown result type (might be due to invalid IL or missing references)
		//IL_2ef2: Unknown result type (might be due to invalid IL or missing references)
		//IL_2ef9: Unknown result type (might be due to invalid IL or missing references)
		//IL_2f00: Unknown result type (might be due to invalid IL or missing references)
		//IL_2f0d: Unknown result type (might be due to invalid IL or missing references)
		//IL_2f14: Unknown result type (might be due to invalid IL or missing references)
		//IL_26a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_30b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_30b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_30b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_30cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_30ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_2fc3: Unknown result type (might be due to invalid IL or missing references)
		//IL_2fd4: Unknown result type (might be due to invalid IL or missing references)
		//IL_2fd9: Unknown result type (might be due to invalid IL or missing references)
		//IL_2fde: Unknown result type (might be due to invalid IL or missing references)
		//IL_2750: Unknown result type (might be due to invalid IL or missing references)
		//IL_275d: Unknown result type (might be due to invalid IL or missing references)
		//IL_2780: Unknown result type (might be due to invalid IL or missing references)
		//IL_3032: Unknown result type (might be due to invalid IL or missing references)
		//IL_303c: Unknown result type (might be due to invalid IL or missing references)
		//IL_3041: Unknown result type (might be due to invalid IL or missing references)
		//IL_3043: Unknown result type (might be due to invalid IL or missing references)
		//IL_3045: Unknown result type (might be due to invalid IL or missing references)
		//IL_3049: Unknown result type (might be due to invalid IL or missing references)
		//IL_304e: Unknown result type (might be due to invalid IL or missing references)
		//IL_3053: Unknown result type (might be due to invalid IL or missing references)
		//IL_3055: Unknown result type (might be due to invalid IL or missing references)
		//IL_3057: Unknown result type (might be due to invalid IL or missing references)
		//IL_305c: Unknown result type (might be due to invalid IL or missing references)
		//IL_3061: Unknown result type (might be due to invalid IL or missing references)
		//IL_2fee: Unknown result type (might be due to invalid IL or missing references)
		//IL_2ffd: Unknown result type (might be due to invalid IL or missing references)
		//IL_3002: Unknown result type (might be due to invalid IL or missing references)
		//IL_3005: Unknown result type (might be due to invalid IL or missing references)
		//IL_300a: Unknown result type (might be due to invalid IL or missing references)
		//IL_300c: Unknown result type (might be due to invalid IL or missing references)
		//IL_3011: Unknown result type (might be due to invalid IL or missing references)
		//IL_345d: Unknown result type (might be due to invalid IL or missing references)
		//IL_3464: Unknown result type (might be due to invalid IL or missing references)
		//IL_30d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_30d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_30d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_30de: Unknown result type (might be due to invalid IL or missing references)
		//IL_30e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_30e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_30ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_30ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_30f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_3103: Unknown result type (might be due to invalid IL or missing references)
		//IL_3105: Unknown result type (might be due to invalid IL or missing references)
		//IL_310a: Unknown result type (might be due to invalid IL or missing references)
		//IL_310c: Unknown result type (might be due to invalid IL or missing references)
		//IL_310e: Unknown result type (might be due to invalid IL or missing references)
		//IL_3110: Unknown result type (might be due to invalid IL or missing references)
		//IL_3115: Unknown result type (might be due to invalid IL or missing references)
		//IL_3134: Unknown result type (might be due to invalid IL or missing references)
		//IL_3136: Unknown result type (might be due to invalid IL or missing references)
		//IL_3388: Unknown result type (might be due to invalid IL or missing references)
		//IL_3391: Unknown result type (might be due to invalid IL or missing references)
		//IL_34ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_34f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_32aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_32b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_381c: Unknown result type (might be due to invalid IL or missing references)
		//IL_3823: Unknown result type (might be due to invalid IL or missing references)
		//IL_35f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_3600: Unknown result type (might be due to invalid IL or missing references)
		//IL_3b1d: Unknown result type (might be due to invalid IL or missing references)
		//IL_3b24: Unknown result type (might be due to invalid IL or missing references)
		//IL_3bb8: Unknown result type (might be due to invalid IL or missing references)
		//IL_3bbf: Unknown result type (might be due to invalid IL or missing references)
		//IL_3c42: Unknown result type (might be due to invalid IL or missing references)
		//IL_3c49: Unknown result type (might be due to invalid IL or missing references)
		//IL_3a5f: Unknown result type (might be due to invalid IL or missing references)
		//IL_3a66: Unknown result type (might be due to invalid IL or missing references)
		//IL_396e: Unknown result type (might be due to invalid IL or missing references)
		//IL_3975: Unknown result type (might be due to invalid IL or missing references)
		//IL_3ccb: Unknown result type (might be due to invalid IL or missing references)
		//IL_3cd2: Unknown result type (might be due to invalid IL or missing references)
		//IL_3e78: Unknown result type (might be due to invalid IL or missing references)
		//IL_3e8f: Unknown result type (might be due to invalid IL or missing references)
		//IL_3e94: Unknown result type (might be due to invalid IL or missing references)
		//IL_3ed8: Unknown result type (might be due to invalid IL or missing references)
		//IL_3edf: Unknown result type (might be due to invalid IL or missing references)
		//IL_3ee6: Unknown result type (might be due to invalid IL or missing references)
		//IL_3eed: Unknown result type (might be due to invalid IL or missing references)
		//IL_3d54: Unknown result type (might be due to invalid IL or missing references)
		//IL_3d5b: Unknown result type (might be due to invalid IL or missing references)
		//IL_3ddd: Unknown result type (might be due to invalid IL or missing references)
		//IL_3de4: Unknown result type (might be due to invalid IL or missing references)
		//IL_4031: Unknown result type (might be due to invalid IL or missing references)
		//IL_4037: Unknown result type (might be due to invalid IL or missing references)
		//IL_403b: Unknown result type (might be due to invalid IL or missing references)
		//IL_4041: Unknown result type (might be due to invalid IL or missing references)
		//IL_4076: Unknown result type (might be due to invalid IL or missing references)
		//IL_407c: Unknown result type (might be due to invalid IL or missing references)
		//IL_4080: Unknown result type (might be due to invalid IL or missing references)
		//IL_4086: Unknown result type (might be due to invalid IL or missing references)
		//IL_3fd7: Unknown result type (might be due to invalid IL or missing references)
		//IL_3fde: Unknown result type (might be due to invalid IL or missing references)
		//IL_40b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_40b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_40bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_40c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_40f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_40ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_4105: Unknown result type (might be due to invalid IL or missing references)
		//IL_4107: Unknown result type (might be due to invalid IL or missing references)
		//IL_410c: Unknown result type (might be due to invalid IL or missing references)
		//IL_4116: Unknown result type (might be due to invalid IL or missing references)
		//IL_4118: Unknown result type (might be due to invalid IL or missing references)
		//IL_4120: Unknown result type (might be due to invalid IL or missing references)
		//IL_412d: Unknown result type (might be due to invalid IL or missing references)
		//IL_4133: Unknown result type (might be due to invalid IL or missing references)
		//IL_4135: Unknown result type (might be due to invalid IL or missing references)
		//IL_413a: Unknown result type (might be due to invalid IL or missing references)
		//IL_4146: Unknown result type (might be due to invalid IL or missing references)
		//IL_4148: Unknown result type (might be due to invalid IL or missing references)
		//IL_416f: Unknown result type (might be due to invalid IL or missing references)
		//IL_4175: Unknown result type (might be due to invalid IL or missing references)
		//IL_4179: Unknown result type (might be due to invalid IL or missing references)
		//IL_417f: Unknown result type (might be due to invalid IL or missing references)
		//IL_41c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_41cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_41d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_41d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_41f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_41fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_4201: Unknown result type (might be due to invalid IL or missing references)
		//IL_4207: Unknown result type (might be due to invalid IL or missing references)
		//IL_425b: Unknown result type (might be due to invalid IL or missing references)
		//IL_4261: Unknown result type (might be due to invalid IL or missing references)
		//IL_4265: Unknown result type (might be due to invalid IL or missing references)
		//IL_426b: Unknown result type (might be due to invalid IL or missing references)
		//IL_46e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_46ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_46f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_46f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_43ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_43b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_43e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_43e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_441a: Unknown result type (might be due to invalid IL or missing references)
		//IL_4421: Unknown result type (might be due to invalid IL or missing references)
		//IL_4452: Unknown result type (might be due to invalid IL or missing references)
		//IL_4459: Unknown result type (might be due to invalid IL or missing references)
		//IL_4539: Unknown result type (might be due to invalid IL or missing references)
		//IL_4540: Unknown result type (might be due to invalid IL or missing references)
		//IL_4571: Unknown result type (might be due to invalid IL or missing references)
		//IL_4578: Unknown result type (might be due to invalid IL or missing references)
		//IL_4899: Unknown result type (might be due to invalid IL or missing references)
		//IL_489f: Unknown result type (might be due to invalid IL or missing references)
		//IL_48a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_48a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_48af: Unknown result type (might be due to invalid IL or missing references)
		//IL_48f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_48fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_4913: Unknown result type (might be due to invalid IL or missing references)
		//IL_4bbb: Unknown result type (might be due to invalid IL or missing references)
		//IL_4bc2: Unknown result type (might be due to invalid IL or missing references)
		//IL_4982: Unknown result type (might be due to invalid IL or missing references)
		//IL_4993: Unknown result type (might be due to invalid IL or missing references)
		//IL_4c25: Unknown result type (might be due to invalid IL or missing references)
		//IL_4c2c: Unknown result type (might be due to invalid IL or missing references)
		//IL_4c33: Unknown result type (might be due to invalid IL or missing references)
		//IL_4c3e: Unknown result type (might be due to invalid IL or missing references)
		//IL_494a: Unknown result type (might be due to invalid IL or missing references)
		//IL_494c: Unknown result type (might be due to invalid IL or missing references)
		//IL_4952: Unknown result type (might be due to invalid IL or missing references)
		//IL_4957: Unknown result type (might be due to invalid IL or missing references)
		//IL_49a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_49b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_485b: Unknown result type (might be due to invalid IL or missing references)
		//IL_4862: Unknown result type (might be due to invalid IL or missing references)
		//IL_4977: Unknown result type (might be due to invalid IL or missing references)
		//IL_497d: Unknown result type (might be due to invalid IL or missing references)
		//IL_4e29: Unknown result type (might be due to invalid IL or missing references)
		//IL_4e2b: Unknown result type (might be due to invalid IL or missing references)
		//IL_4cbd: Unknown result type (might be due to invalid IL or missing references)
		//IL_4cc2: Unknown result type (might be due to invalid IL or missing references)
		//IL_4cd4: Unknown result type (might be due to invalid IL or missing references)
		//IL_4cdb: Unknown result type (might be due to invalid IL or missing references)
		//IL_4ce0: Unknown result type (might be due to invalid IL or missing references)
		//IL_4ce5: Unknown result type (might be due to invalid IL or missing references)
		//IL_4d01: Unknown result type (might be due to invalid IL or missing references)
		//IL_4f3a: Unknown result type (might be due to invalid IL or missing references)
		//IL_4f45: Unknown result type (might be due to invalid IL or missing references)
		//IL_4f4a: Unknown result type (might be due to invalid IL or missing references)
		//IL_4f50: Unknown result type (might be due to invalid IL or missing references)
		//IL_4f56: Unknown result type (might be due to invalid IL or missing references)
		//IL_4f5b: Unknown result type (might be due to invalid IL or missing references)
		//IL_4f60: Unknown result type (might be due to invalid IL or missing references)
		//IL_4f65: Unknown result type (might be due to invalid IL or missing references)
		//IL_4ef1: Unknown result type (might be due to invalid IL or missing references)
		//IL_4ef3: Unknown result type (might be due to invalid IL or missing references)
		//IL_4e74: Unknown result type (might be due to invalid IL or missing references)
		//IL_4e7f: Unknown result type (might be due to invalid IL or missing references)
		//IL_4e84: Unknown result type (might be due to invalid IL or missing references)
		//IL_4eb8: Unknown result type (might be due to invalid IL or missing references)
		//IL_4eba: Unknown result type (might be due to invalid IL or missing references)
		//IL_4d31: Unknown result type (might be due to invalid IL or missing references)
		//IL_4d37: Unknown result type (might be due to invalid IL or missing references)
		//IL_4d3c: Unknown result type (might be due to invalid IL or missing references)
		//IL_4d41: Unknown result type (might be due to invalid IL or missing references)
		//IL_4d9b: Unknown result type (might be due to invalid IL or missing references)
		//IL_4da6: Unknown result type (might be due to invalid IL or missing references)
		//IL_4dab: Unknown result type (might be due to invalid IL or missing references)
		//IL_4dc8: Unknown result type (might be due to invalid IL or missing references)
		//IL_4dca: Unknown result type (might be due to invalid IL or missing references)
		//IL_5025: Unknown result type (might be due to invalid IL or missing references)
		//IL_502a: Unknown result type (might be due to invalid IL or missing references)
		//IL_5034: Unknown result type (might be due to invalid IL or missing references)
		//IL_503f: Unknown result type (might be due to invalid IL or missing references)
		//IL_5044: Unknown result type (might be due to invalid IL or missing references)
		//IL_504a: Unknown result type (might be due to invalid IL or missing references)
		//IL_504e: Unknown result type (might be due to invalid IL or missing references)
		//IL_5050: Unknown result type (might be due to invalid IL or missing references)
		//IL_5056: Unknown result type (might be due to invalid IL or missing references)
		//IL_5082: Unknown result type (might be due to invalid IL or missing references)
		//IL_508d: Unknown result type (might be due to invalid IL or missing references)
		//IL_5092: Unknown result type (might be due to invalid IL or missing references)
		//IL_5098: Unknown result type (might be due to invalid IL or missing references)
		//IL_509e: Unknown result type (might be due to invalid IL or missing references)
		//IL_50a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_50a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_50ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_5064: Unknown result type (might be due to invalid IL or missing references)
		//IL_5066: Unknown result type (might be due to invalid IL or missing references)
		//IL_506c: Unknown result type (might be due to invalid IL or missing references)
		//IL_5071: Unknown result type (might be due to invalid IL or missing references)
		//IL_4f8e: Unknown result type (might be due to invalid IL or missing references)
		//IL_4f90: Unknown result type (might be due to invalid IL or missing references)
		//IL_4f96: Unknown result type (might be due to invalid IL or missing references)
		//IL_4fa2: Unknown result type (might be due to invalid IL or missing references)
		//IL_4fac: Unknown result type (might be due to invalid IL or missing references)
		//IL_4fb1: Unknown result type (might be due to invalid IL or missing references)
		//IL_4fc6: Unknown result type (might be due to invalid IL or missing references)
		//IL_4fcc: Unknown result type (might be due to invalid IL or missing references)
		//IL_4fce: Unknown result type (might be due to invalid IL or missing references)
		//IL_4d76: Unknown result type (might be due to invalid IL or missing references)
		//IL_4d8b: Unknown result type (might be due to invalid IL or missing references)
		//IL_4d90: Unknown result type (might be due to invalid IL or missing references)
		//IL_4d95: Unknown result type (might be due to invalid IL or missing references)
		//IL_4b43: Unknown result type (might be due to invalid IL or missing references)
		//IL_4b67: Unknown result type (might be due to invalid IL or missing references)
		//IL_4b6e: Unknown result type (might be due to invalid IL or missing references)
		//IL_53d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_53d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_53f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_53fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_5402: Unknown result type (might be due to invalid IL or missing references)
		//IL_5187: Unknown result type (might be due to invalid IL or missing references)
		//IL_518b: Unknown result type (might be due to invalid IL or missing references)
		//IL_5191: Unknown result type (might be due to invalid IL or missing references)
		//IL_519f: Unknown result type (might be due to invalid IL or missing references)
		//IL_51a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_51a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_51b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_51b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_5202: Unknown result type (might be due to invalid IL or missing references)
		//IL_5210: Unknown result type (might be due to invalid IL or missing references)
		//IL_5216: Unknown result type (might be due to invalid IL or missing references)
		//IL_5218: Unknown result type (might be due to invalid IL or missing references)
		//IL_5233: Unknown result type (might be due to invalid IL or missing references)
		//IL_5238: Unknown result type (might be due to invalid IL or missing references)
		//IL_5240: Unknown result type (might be due to invalid IL or missing references)
		//IL_5247: Unknown result type (might be due to invalid IL or missing references)
		//IL_524e: Unknown result type (might be due to invalid IL or missing references)
		//IL_5259: Unknown result type (might be due to invalid IL or missing references)
		//IL_50d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_50d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_50da: Unknown result type (might be due to invalid IL or missing references)
		//IL_50e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_50f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_50f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_510c: Unknown result type (might be due to invalid IL or missing references)
		//IL_5112: Unknown result type (might be due to invalid IL or missing references)
		//IL_5114: Unknown result type (might be due to invalid IL or missing references)
		//IL_52af: Unknown result type (might be due to invalid IL or missing references)
		//IL_52b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_52b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_52c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_52cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_52cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_52d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_52de: Unknown result type (might be due to invalid IL or missing references)
		//IL_531e: Unknown result type (might be due to invalid IL or missing references)
		//IL_532c: Unknown result type (might be due to invalid IL or missing references)
		//IL_5332: Unknown result type (might be due to invalid IL or missing references)
		//IL_5334: Unknown result type (might be due to invalid IL or missing references)
		//IL_534f: Unknown result type (might be due to invalid IL or missing references)
		//IL_5354: Unknown result type (might be due to invalid IL or missing references)
		//IL_535c: Unknown result type (might be due to invalid IL or missing references)
		//IL_535e: Unknown result type (might be due to invalid IL or missing references)
		//IL_5369: Unknown result type (might be due to invalid IL or missing references)
		//IL_536e: Unknown result type (might be due to invalid IL or missing references)
		//IL_5373: Unknown result type (might be due to invalid IL or missing references)
		//IL_570e: Unknown result type (might be due to invalid IL or missing references)
		//IL_5714: Unknown result type (might be due to invalid IL or missing references)
		//IL_5414: Unknown result type (might be due to invalid IL or missing references)
		//IL_541c: Unknown result type (might be due to invalid IL or missing references)
		//IL_543c: Unknown result type (might be due to invalid IL or missing references)
		//IL_5441: Unknown result type (might be due to invalid IL or missing references)
		//IL_5446: Unknown result type (might be due to invalid IL or missing references)
		//IL_544c: Unknown result type (might be due to invalid IL or missing references)
		//IL_5450: Unknown result type (might be due to invalid IL or missing references)
		//IL_5456: Unknown result type (might be due to invalid IL or missing references)
		//IL_545c: Unknown result type (might be due to invalid IL or missing references)
		//IL_545e: Unknown result type (might be due to invalid IL or missing references)
		//IL_5463: Unknown result type (might be due to invalid IL or missing references)
		//IL_5468: Unknown result type (might be due to invalid IL or missing references)
		//IL_5472: Unknown result type (might be due to invalid IL or missing references)
		//IL_5477: Unknown result type (might be due to invalid IL or missing references)
		//IL_54b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_54bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_54c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_54c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_54d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_54d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_54da: Unknown result type (might be due to invalid IL or missing references)
		//IL_54e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_54e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_54eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_54f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_54f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_54fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_5502: Unknown result type (might be due to invalid IL or missing references)
		//IL_5508: Unknown result type (might be due to invalid IL or missing references)
		//IL_550e: Unknown result type (might be due to invalid IL or missing references)
		//IL_5519: Unknown result type (might be due to invalid IL or missing references)
		//IL_551e: Unknown result type (might be due to invalid IL or missing references)
		//IL_5526: Unknown result type (might be due to invalid IL or missing references)
		//IL_552c: Unknown result type (might be due to invalid IL or missing references)
		//IL_5586: Unknown result type (might be due to invalid IL or missing references)
		//IL_5588: Unknown result type (might be due to invalid IL or missing references)
		//IL_558e: Unknown result type (might be due to invalid IL or missing references)
		//IL_5594: Unknown result type (might be due to invalid IL or missing references)
		//IL_5599: Unknown result type (might be due to invalid IL or missing references)
		//IL_55be: Unknown result type (might be due to invalid IL or missing references)
		//IL_55c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_55c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_55d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_55df: Unknown result type (might be due to invalid IL or missing references)
		//IL_55e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_5606: Unknown result type (might be due to invalid IL or missing references)
		//IL_5608: Unknown result type (might be due to invalid IL or missing references)
		//IL_560e: Unknown result type (might be due to invalid IL or missing references)
		//IL_5614: Unknown result type (might be due to invalid IL or missing references)
		//IL_5619: Unknown result type (might be due to invalid IL or missing references)
		//IL_5644: Unknown result type (might be due to invalid IL or missing references)
		//IL_564a: Unknown result type (might be due to invalid IL or missing references)
		//IL_564c: Unknown result type (might be due to invalid IL or missing references)
		//IL_565b: Unknown result type (might be due to invalid IL or missing references)
		//IL_5665: Unknown result type (might be due to invalid IL or missing references)
		//IL_566a: Unknown result type (might be due to invalid IL or missing references)
		//IL_56a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_56a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_56ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_56ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_56bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_56cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_5755: Unknown result type (might be due to invalid IL or missing references)
		//IL_575a: Unknown result type (might be due to invalid IL or missing references)
		//IL_575f: Unknown result type (might be due to invalid IL or missing references)
		//IL_577d: Unknown result type (might be due to invalid IL or missing references)
		//IL_5783: Unknown result type (might be due to invalid IL or missing references)
		//IL_5785: Unknown result type (might be due to invalid IL or missing references)
		//IL_578a: Unknown result type (might be due to invalid IL or missing references)
		//IL_5791: Unknown result type (might be due to invalid IL or missing references)
		//IL_57a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_57a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_57ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_57b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_57b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_57c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_57c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_57ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_57d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_5913: Unknown result type (might be due to invalid IL or missing references)
		//IL_5924: Unknown result type (might be due to invalid IL or missing references)
		//IL_5953: Unknown result type (might be due to invalid IL or missing references)
		//IL_595c: Unknown result type (might be due to invalid IL or missing references)
		//IL_5839: Unknown result type (might be due to invalid IL or missing references)
		//IL_584e: Unknown result type (might be due to invalid IL or missing references)
		//IL_5853: Unknown result type (might be due to invalid IL or missing references)
		//IL_5858: Unknown result type (might be due to invalid IL or missing references)
		//IL_5801: Unknown result type (might be due to invalid IL or missing references)
		//IL_5827: Unknown result type (might be due to invalid IL or missing references)
		//IL_582c: Unknown result type (might be due to invalid IL or missing references)
		//IL_5831: Unknown result type (might be due to invalid IL or missing references)
		//IL_59cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_59dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_5a49: Unknown result type (might be due to invalid IL or missing references)
		//IL_5a5a: Unknown result type (might be due to invalid IL or missing references)
		//IL_5892: Unknown result type (might be due to invalid IL or missing references)
		//IL_5898: Unknown result type (might be due to invalid IL or missing references)
		//IL_58a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_5ac9: Unknown result type (might be due to invalid IL or missing references)
		//IL_5ada: Unknown result type (might be due to invalid IL or missing references)
		//IL_5b0d: Unknown result type (might be due to invalid IL or missing references)
		//IL_5b16: Unknown result type (might be due to invalid IL or missing references)
		//IL_5b85: Unknown result type (might be due to invalid IL or missing references)
		//IL_5b96: Unknown result type (might be due to invalid IL or missing references)
		//IL_5bc5: Unknown result type (might be due to invalid IL or missing references)
		//IL_5bd6: Unknown result type (might be due to invalid IL or missing references)
		//IL_5c48: Unknown result type (might be due to invalid IL or missing references)
		//IL_5c59: Unknown result type (might be due to invalid IL or missing references)
		//IL_5c8c: Unknown result type (might be due to invalid IL or missing references)
		//IL_5c95: Unknown result type (might be due to invalid IL or missing references)
		//IL_5c9f: Unknown result type (might be due to invalid IL or missing references)
		//IL_5cfd: Unknown result type (might be due to invalid IL or missing references)
		//IL_5d0c: Unknown result type (might be due to invalid IL or missing references)
		//IL_5d12: Unknown result type (might be due to invalid IL or missing references)
		//IL_5d17: Unknown result type (might be due to invalid IL or missing references)
		//IL_5d1c: Unknown result type (might be due to invalid IL or missing references)
		//IL_5d21: Unknown result type (might be due to invalid IL or missing references)
		//IL_5d28: Unknown result type (might be due to invalid IL or missing references)
		//IL_6064: Unknown result type (might be due to invalid IL or missing references)
		//IL_606b: Unknown result type (might be due to invalid IL or missing references)
		//IL_5d7b: Unknown result type (might be due to invalid IL or missing references)
		//IL_5d90: Unknown result type (might be due to invalid IL or missing references)
		//IL_5d95: Unknown result type (might be due to invalid IL or missing references)
		//IL_5d9a: Unknown result type (might be due to invalid IL or missing references)
		//IL_5d69: Unknown result type (might be due to invalid IL or missing references)
		//IL_5d6e: Unknown result type (might be due to invalid IL or missing references)
		//IL_5d73: Unknown result type (might be due to invalid IL or missing references)
		//IL_60b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_60b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_5da1: Unknown result type (might be due to invalid IL or missing references)
		//IL_5dc7: Unknown result type (might be due to invalid IL or missing references)
		//IL_5dcd: Unknown result type (might be due to invalid IL or missing references)
		//IL_5dd2: Unknown result type (might be due to invalid IL or missing references)
		//IL_5dd7: Unknown result type (might be due to invalid IL or missing references)
		//IL_5ddc: Unknown result type (might be due to invalid IL or missing references)
		//IL_5de2: Unknown result type (might be due to invalid IL or missing references)
		//IL_5de8: Unknown result type (might be due to invalid IL or missing references)
		//IL_5dee: Unknown result type (might be due to invalid IL or missing references)
		//IL_5df3: Unknown result type (might be due to invalid IL or missing references)
		//IL_60fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_6103: Unknown result type (might be due to invalid IL or missing references)
		//IL_5e89: Unknown result type (might be due to invalid IL or missing references)
		//IL_5e94: Unknown result type (might be due to invalid IL or missing references)
		//IL_5e99: Unknown result type (might be due to invalid IL or missing references)
		//IL_5e9f: Unknown result type (might be due to invalid IL or missing references)
		//IL_5ea5: Unknown result type (might be due to invalid IL or missing references)
		//IL_61df: Unknown result type (might be due to invalid IL or missing references)
		//IL_61e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_5f1c: Unknown result type (might be due to invalid IL or missing references)
		//IL_5f2d: Unknown result type (might be due to invalid IL or missing references)
		//IL_5f33: Unknown result type (might be due to invalid IL or missing references)
		//IL_5f38: Unknown result type (might be due to invalid IL or missing references)
		//IL_5f53: Unknown result type (might be due to invalid IL or missing references)
		//IL_5f59: Unknown result type (might be due to invalid IL or missing references)
		//IL_5f5b: Unknown result type (might be due to invalid IL or missing references)
		//IL_5f66: Unknown result type (might be due to invalid IL or missing references)
		//IL_5f6b: Unknown result type (might be due to invalid IL or missing references)
		//IL_61a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_61a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_5f8b: Unknown result type (might be due to invalid IL or missing references)
		//IL_5f96: Unknown result type (might be due to invalid IL or missing references)
		//IL_5f9b: Unknown result type (might be due to invalid IL or missing references)
		//IL_5ec2: Unknown result type (might be due to invalid IL or missing references)
		//IL_5ec8: Unknown result type (might be due to invalid IL or missing references)
		//IL_5ece: Unknown result type (might be due to invalid IL or missing references)
		//IL_5ed3: Unknown result type (might be due to invalid IL or missing references)
		//IL_5ed9: Unknown result type (might be due to invalid IL or missing references)
		//IL_5ee8: Unknown result type (might be due to invalid IL or missing references)
		//IL_5eee: Unknown result type (might be due to invalid IL or missing references)
		//IL_5ef0: Unknown result type (might be due to invalid IL or missing references)
		//IL_5ef5: Unknown result type (might be due to invalid IL or missing references)
		//IL_6396: Unknown result type (might be due to invalid IL or missing references)
		//IL_639d: Unknown result type (might be due to invalid IL or missing references)
		//IL_63ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_63b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_63ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_5ffc: Unknown result type (might be due to invalid IL or missing references)
		//IL_6002: Unknown result type (might be due to invalid IL or missing references)
		//IL_5fc4: Unknown result type (might be due to invalid IL or missing references)
		//IL_5fe7: Unknown result type (might be due to invalid IL or missing references)
		//IL_5fed: Unknown result type (might be due to invalid IL or missing references)
		//IL_5fef: Unknown result type (might be due to invalid IL or missing references)
		//IL_5ff4: Unknown result type (might be due to invalid IL or missing references)
		//IL_63e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_63eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_63c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_63d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_63db: Unknown result type (might be due to invalid IL or missing references)
		//IL_63e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_6281: Unknown result type (might be due to invalid IL or missing references)
		//IL_628f: Unknown result type (might be due to invalid IL or missing references)
		//IL_62a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_62aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_62ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_62b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_62bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_62c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_62c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_62cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_62d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_64a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_64a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_6450: Unknown result type (might be due to invalid IL or missing references)
		//IL_6458: Unknown result type (might be due to invalid IL or missing references)
		//IL_66fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_6700: Unknown result type (might be due to invalid IL or missing references)
		//IL_6705: Unknown result type (might be due to invalid IL or missing references)
		//IL_670b: Unknown result type (might be due to invalid IL or missing references)
		//IL_6711: Unknown result type (might be due to invalid IL or missing references)
		//IL_6717: Unknown result type (might be due to invalid IL or missing references)
		//IL_6719: Unknown result type (might be due to invalid IL or missing references)
		//IL_671f: Unknown result type (might be due to invalid IL or missing references)
		//IL_672e: Unknown result type (might be due to invalid IL or missing references)
		//IL_6733: Unknown result type (might be due to invalid IL or missing references)
		//IL_6738: Unknown result type (might be due to invalid IL or missing references)
		//IL_67cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_67d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_6761: Unknown result type (might be due to invalid IL or missing references)
		//IL_676c: Unknown result type (might be due to invalid IL or missing references)
		//IL_680d: Unknown result type (might be due to invalid IL or missing references)
		//IL_6814: Unknown result type (might be due to invalid IL or missing references)
		//IL_6789: Unknown result type (might be due to invalid IL or missing references)
		//IL_678b: Unknown result type (might be due to invalid IL or missing references)
		//IL_679c: Unknown result type (might be due to invalid IL or missing references)
		//IL_6775: Unknown result type (might be due to invalid IL or missing references)
		//IL_677b: Unknown result type (might be due to invalid IL or missing references)
		//IL_687a: Unknown result type (might be due to invalid IL or missing references)
		//IL_6881: Unknown result type (might be due to invalid IL or missing references)
		//IL_684a: Unknown result type (might be due to invalid IL or missing references)
		//IL_6851: Unknown result type (might be due to invalid IL or missing references)
		//IL_6740: Unknown result type (might be due to invalid IL or missing references)
		//IL_6746: Unknown result type (might be due to invalid IL or missing references)
		//IL_6751: Unknown result type (might be due to invalid IL or missing references)
		//IL_6756: Unknown result type (might be due to invalid IL or missing references)
		//IL_675b: Unknown result type (might be due to invalid IL or missing references)
		if (!CombinedHooks.CanShoot(this, sItem))
		{
			return;
		}
		int projToShoot = sItem.shoot;
		float speed = sItem.shootSpeed;
		int damage = sItem.damage;
		if (sItem.melee && !ProjectileID.Sets.NoMeleeSpeedVelocityScaling[projToShoot])
		{
			speed /= inverseMeleeSpeed;
		}
		if (sItem.CountsAsClass(DamageClass.Throwing) && speed < 16f)
		{
			speed *= ThrownVelocity;
			if (speed > 16f)
			{
				speed = 16f;
			}
		}
		bool canShoot = false;
		int totalDamage = weaponDamage;
		float KnockBack = sItem.knockBack;
		int usedAmmoItemId = 0;
		if (sItem.useAmmo > 0)
		{
			PickAmmo(sItem, ref projToShoot, ref speed, ref canShoot, ref totalDamage, ref KnockBack, out usedAmmoItemId, ItemID.Sets.gunProj[sItem.type]);
		}
		else
		{
			canShoot = true;
		}
		if (ItemID.Sets.gunProj[sItem.type])
		{
			KnockBack = sItem.knockBack;
			totalDamage = weaponDamage;
			speed = sItem.shootSpeed;
		}
		if (sItem.IsACoin)
		{
			canShoot = false;
		}
		if (sItem.type == 1254 && projToShoot == 14)
		{
			projToShoot = 242;
		}
		if (sItem.type == 1255 && projToShoot == 14)
		{
			projToShoot = 242;
		}
		if (sItem.type == 1265 && projToShoot == 14)
		{
			projToShoot = 242;
		}
		if (sItem.type == 3542)
		{
			if (Main.rand.Next(100) < 20)
			{
				projToShoot++;
				totalDamage *= 3;
			}
			else
			{
				speed -= 1f;
			}
		}
		if (sItem.type == 1928)
		{
			totalDamage = (int)((float)totalDamage * 1f);
		}
		if (sItem.type == 3063)
		{
			totalDamage = (int)((float)totalDamage * 1.25f);
		}
		if (sItem.type == 1306)
		{
			totalDamage = (int)((double)totalDamage * 0.67);
		}
		if (sItem.type == 1227)
		{
			totalDamage = (int)((double)totalDamage * 0.7);
		}
		if (!canShoot)
		{
			return;
		}
		if (whoAmI != Main.myPlayer)
		{
			ApplyItemTime(sItem);
			return;
		}
		KnockBack = GetWeaponKnockback(sItem, KnockBack);
		IEntitySource projectileSource_Item_WithPotentialAmmo = GetProjectileSource_Item_WithPotentialAmmo(sItem, usedAmmoItemId);
		if (projToShoot == 228)
		{
			KnockBack = 0f;
		}
		if (projToShoot == 1 && sItem.type == 120)
		{
			projToShoot = 2;
		}
		if (sItem.type == 682)
		{
			projToShoot = 117;
		}
		if (sItem.type == 725)
		{
			projToShoot = 120;
		}
		if (sItem.type == 2796)
		{
			projToShoot = 442;
		}
		if (sItem.type == 3546)
		{
			projToShoot = 167;
		}
		if (sItem.type == 2223)
		{
			projToShoot = 357;
		}
		if (sItem.type == 5117)
		{
			projToShoot = 968;
		}
		if (sItem.fishingPole > 0 && overrideFishingBobber > -1)
		{
			projToShoot = overrideFishingBobber;
		}
		ApplyItemTime(sItem);
		Vector2 pointPoisition = RotatedRelativePoint(MountedCenter);
		bool flag = true;
		_ = sItem.type;
		if (!sItem.ChangePlayerDirectionOnShoot)
		{
			flag = false;
		}
		Vector2 unitX = Vector2.UnitX;
		double radians = fullRotation;
		Vector2 val = default(Vector2);
		Vector2 val2 = unitX.RotatedBy(radians, val);
		Vector2 val3 = Main.MouseWorld - pointPoisition;
		Vector2 v = itemRotation.ToRotationVector2() * (float)direction;
		if (sItem.type == 3852 && !ItemAnimationJustStarted)
		{
			val3 = (v.ToRotation() + fullRotation).ToRotationVector2();
		}
		if (val3 != Vector2.Zero)
		{
			((Vector2)(ref val3)).Normalize();
		}
		float num = Vector2.Dot(val2, val3);
		if (flag)
		{
			if (num > 0f)
			{
				ChangeDir(1);
			}
			else
			{
				ChangeDir(-1);
			}
		}
		if (sItem.type == 3094 || sItem.type == 3378 || sItem.type == 3543)
		{
			pointPoisition.Y = base.position.Y + (float)(height / 3);
		}
		if (sItem.type == 5117)
		{
			pointPoisition.Y = base.position.Y + (float)(height / 3);
		}
		if (sItem.type == 517)
		{
			pointPoisition.X += (float)Main.rand.Next(-3, 4) * 3.5f;
			pointPoisition.Y += (float)Main.rand.Next(-3, 4) * 3.5f;
		}
		if (sItem.type == 2611)
		{
			Vector2 val4 = val3;
			if (val4 != Vector2.Zero)
			{
				((Vector2)(ref val4)).Normalize();
			}
			pointPoisition += val4;
		}
		if (sItem.type == 3827)
		{
			Vector2 val5 = pointPoisition;
			Vector2 spinningpoint = val3.SafeNormalize(Vector2.Zero);
			double radians2 = (float)direction * (-(float)Math.PI / 2f);
			val = default(Vector2);
			pointPoisition = val5 + spinningpoint.RotatedBy(radians2, val) * 24f;
		}
		if (projToShoot == 9)
		{
			((Vector2)(ref pointPoisition))..ctor(base.position.X + (float)width * 0.5f + (float)(Main.rand.Next(201) * -direction) + ((float)Main.mouseX + Main.screenPosition.X - base.position.X), MountedCenter.Y - 600f);
			KnockBack = 0f;
			totalDamage = (int)((float)totalDamage * 1.5f);
		}
		if (sItem.type == 986 || sItem.type == 281)
		{
			pointPoisition.X += 6 * direction;
			pointPoisition.Y -= 6f * gravDir;
		}
		if (sItem.type == 3007)
		{
			pointPoisition.X -= 4 * direction;
			pointPoisition.Y -= 2f * gravDir;
		}
		float num2 = (float)Main.mouseX + Main.screenPosition.X - pointPoisition.X;
		float num3 = (float)Main.mouseY + Main.screenPosition.Y - pointPoisition.Y;
		if (sItem.type == 3852 && !ItemAnimationJustStarted)
		{
			Vector2 val6 = val3;
			num2 = val6.X;
			num3 = val6.Y;
		}
		if (gravDir == -1f)
		{
			num3 = Main.screenPosition.Y + (float)Main.screenHeight - (float)Main.mouseY - pointPoisition.Y;
		}
		float num4 = (float)Math.Sqrt(num2 * num2 + num3 * num3);
		float num5 = num4;
		if ((float.IsNaN(num2) && float.IsNaN(num3)) || (num2 == 0f && num3 == 0f))
		{
			num2 = direction;
			num3 = 0f;
			num4 = speed;
		}
		else
		{
			num4 = speed / num4;
		}
		if (sItem.type == 1929 || sItem.type == 2270)
		{
			num2 += (float)Main.rand.Next(-50, 51) * 0.03f / num4;
			num3 += (float)Main.rand.Next(-50, 51) * 0.03f / num4;
		}
		num2 *= num4;
		num3 *= num4;
		if (projToShoot == 250)
		{
			for (int j = 0; j < 1000; j++)
			{
				if (Main.projectile[j].active && Main.projectile[j].owner == whoAmI && (Main.projectile[j].type == 250 || Main.projectile[j].type == 251))
				{
					Main.projectile[j].Kill();
				}
			}
		}
		if (projToShoot == 12 && Collision.CanHitLine(base.Center, 0, 0, pointPoisition + new Vector2(num2, num3) * 4f, 0, 0))
		{
			pointPoisition += new Vector2(num2, num3) * 3f;
		}
		if (projToShoot == 728 && !Collision.CanHitLine(base.Center, 0, 0, pointPoisition + new Vector2(num2, num3) * 2f, 0, 0))
		{
			Vector2 val7 = new Vector2(num2, num3) * 0.25f;
			pointPoisition = base.Center - val7;
		}
		if (projToShoot == 85)
		{
			Vector2 val8 = pointPoisition;
			Vector2 spinningpoint2 = new Vector2(0f, -6f * (float)direction * Directions.Y);
			double radians3 = val3.ToRotation();
			val = default(Vector2);
			pointPoisition = val8 + Utils.RotatedBy(spinningpoint2, radians3, val);
			if (Collision.CanHitLine(pointPoisition, 0, 0, pointPoisition + new Vector2(num2, num3) * 5f, 0, 0))
			{
				pointPoisition += new Vector2(num2, num3) * 4f;
			}
		}
		if (projToShoot == 802 || projToShoot == 842)
		{
			Vector2 v2 = default(Vector2);
			((Vector2)(ref v2))..ctor(num2, num3);
			float num6 = (float)Math.PI / 4f;
			Vector2 spinningpoint3 = v2.SafeNormalize(Vector2.Zero);
			double radians4 = num6 * (Main.rand.NextFloat() - 0.5f);
			val = default(Vector2);
			Vector2 val9 = spinningpoint3.RotatedBy(radians4, val) * (((Vector2)(ref v2)).Length() - Main.rand.NextFloatDirection() * 0.7f);
			num2 = val9.X;
			num3 = val9.Y;
		}
		if (projToShoot == 17)
		{
			pointPoisition.X = (float)Main.mouseX + Main.screenPosition.X;
			pointPoisition.Y = (float)Main.mouseY + Main.screenPosition.Y;
			if (gravDir == -1f)
			{
				pointPoisition.Y = Main.screenPosition.Y + (float)Main.screenHeight - (float)Main.mouseY;
			}
			LimitPointToPlayerReachableArea(ref pointPoisition);
		}
		Vector2 val10 = default(Vector2);
		((Vector2)(ref val10))..ctor(num2, num3);
		CombinedHooks.ModifyShootStats(this, sItem, ref pointPoisition, ref val10, ref projToShoot, ref totalDamage, ref KnockBack);
		num2 = val10.X;
		num3 = val10.Y;
		if (sItem.useStyle == 5)
		{
			if (sItem.type == 3029)
			{
				Vector2 val11 = default(Vector2);
				((Vector2)(ref val11))..ctor(num2, num3);
				val11.X = (float)Main.mouseX + Main.screenPosition.X - pointPoisition.X;
				val11.Y = (float)Main.mouseY + Main.screenPosition.Y - pointPoisition.Y - 1000f;
				itemRotation = (float)Math.Atan2(val11.Y * (float)direction, val11.X * (float)direction);
				NetMessage.SendData(13, -1, -1, null, whoAmI);
				NetMessage.SendData(41, -1, -1, null, whoAmI);
			}
			else if (sItem.type == 4381)
			{
				Vector2 val12 = default(Vector2);
				((Vector2)(ref val12))..ctor(num2, num3);
				val12.X = (float)Main.mouseX + Main.screenPosition.X - pointPoisition.X;
				val12.Y = (float)Main.mouseY + Main.screenPosition.Y - pointPoisition.Y - 1000f;
				itemRotation = (float)Math.Atan2(val12.Y * (float)direction, val12.X * (float)direction);
				NetMessage.SendData(13, -1, -1, null, whoAmI);
				NetMessage.SendData(41, -1, -1, null, whoAmI);
			}
			else if (sItem.type == 3779)
			{
				itemRotation = 0f;
				NetMessage.SendData(13, -1, -1, null, whoAmI);
				NetMessage.SendData(41, -1, -1, null, whoAmI);
			}
			else
			{
				itemRotation = (float)Math.Atan2(num3 * (float)direction, num2 * (float)direction) - fullRotation;
				NetMessage.SendData(13, -1, -1, null, whoAmI);
				NetMessage.SendData(41, -1, -1, null, whoAmI);
			}
		}
		if (sItem.useStyle == 13)
		{
			itemRotation = (float)Math.Atan2(num3 * (float)direction, num2 * (float)direction) - fullRotation;
			NetMessage.SendData(13, -1, -1, null, whoAmI);
			NetMessage.SendData(41, -1, -1, null, whoAmI);
		}
		if (!CombinedHooks.Shoot(this, sItem, (EntitySource_ItemUse_WithAmmo)projectileSource_Item_WithPotentialAmmo, pointPoisition, val10, projToShoot, totalDamage, KnockBack))
		{
			return;
		}
		if (projToShoot == 76)
		{
			projToShoot += Main.rand.Next(3);
			float num7 = (float)Main.screenHeight / Main.GameViewMatrix.Zoom.Y;
			num5 /= num7 / 2f;
			if (num5 > 1f)
			{
				num5 = 1f;
			}
			float num8 = num2 + (float)Main.rand.Next(-40, 41) * 0.01f;
			float num9 = num3 + (float)Main.rand.Next(-40, 41) * 0.01f;
			num8 *= num5 + 0.25f;
			num9 *= num5 + 0.25f;
			int num10 = Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, num8, num9, projToShoot, totalDamage, KnockBack, i);
			Main.projectile[num10].ai[1] = 1f;
			num5 = num5 * 2f - 1f;
			if (num5 < -1f)
			{
				num5 = -1f;
			}
			if (num5 > 1f)
			{
				num5 = 1f;
			}
			num5 = (float)Math.Round(num5 * (float)musicNotes);
			num5 /= (float)musicNotes;
			Main.projectile[num10].ai[0] = num5;
			NetMessage.SendData(27, -1, -1, null, num10);
		}
		else if (sItem.type == 3029)
		{
			int num11 = 3;
			if (ProjectileID.Sets.FiresFewerFromDaedalusStormbow[projToShoot])
			{
				if (Main.rand.Next(3) == 0)
				{
					num11--;
				}
			}
			else if (Main.rand.Next(3) == 0)
			{
				num11++;
			}
			for (int k = 0; k < num11; k++)
			{
				((Vector2)(ref pointPoisition))..ctor(base.position.X + (float)width * 0.5f + (float)(Main.rand.Next(201) * -direction) + ((float)Main.mouseX + Main.screenPosition.X - base.position.X), MountedCenter.Y - 600f);
				pointPoisition.X = (pointPoisition.X * 10f + base.Center.X) / 11f + (float)Main.rand.Next(-100, 101);
				pointPoisition.Y -= 150 * k;
				num2 = (float)Main.mouseX + Main.screenPosition.X - pointPoisition.X;
				num3 = (float)Main.mouseY + Main.screenPosition.Y - pointPoisition.Y;
				if (num3 < 0f)
				{
					num3 *= -1f;
				}
				if (num3 < 20f)
				{
					num3 = 20f;
				}
				num4 = (float)Math.Sqrt(num2 * num2 + num3 * num3);
				num4 = speed / num4;
				num2 *= num4;
				num3 *= num4;
				float num12 = num2 + (float)Main.rand.Next(-40, 41) * 0.03f;
				float speedY = num3 + (float)Main.rand.Next(-40, 41) * 0.03f;
				num12 *= (float)Main.rand.Next(75, 150) * 0.01f;
				pointPoisition.X += Main.rand.Next(-50, 51);
				int num13 = Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, num12, speedY, projToShoot, totalDamage, KnockBack, i);
				Main.projectile[num13].noDropItem = true;
			}
		}
		else if (sItem.type == 4381)
		{
			int num14 = Main.rand.Next(1, 3);
			if (Main.rand.Next(3) == 0)
			{
				num14++;
			}
			for (int l = 0; l < num14; l++)
			{
				((Vector2)(ref pointPoisition))..ctor(base.position.X + (float)width * 0.5f + (float)(Main.rand.Next(61) * -direction) + ((float)Main.mouseX + Main.screenPosition.X - base.position.X), MountedCenter.Y - 600f);
				pointPoisition.X = (pointPoisition.X * 10f + base.Center.X) / 11f + (float)Main.rand.Next(-30, 31);
				pointPoisition.Y -= 150f * Main.rand.NextFloat();
				num2 = (float)Main.mouseX + Main.screenPosition.X - pointPoisition.X;
				num3 = (float)Main.mouseY + Main.screenPosition.Y - pointPoisition.Y;
				if (num3 < 0f)
				{
					num3 *= -1f;
				}
				if (num3 < 20f)
				{
					num3 = 20f;
				}
				num4 = (float)Math.Sqrt(num2 * num2 + num3 * num3);
				num4 = speed / num4;
				num2 *= num4;
				num3 *= num4;
				float num15 = num2 + (float)Main.rand.Next(-20, 21) * 0.03f;
				float speedY2 = num3 + (float)Main.rand.Next(-40, 41) * 0.03f;
				num15 *= (float)Main.rand.Next(55, 80) * 0.01f;
				pointPoisition.X += Main.rand.Next(-50, 51);
				int num16 = Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, num15, speedY2, projToShoot, totalDamage, KnockBack, i);
				Main.projectile[num16].noDropItem = true;
			}
		}
		else if (sItem.type == 98 || sItem.type == 533)
		{
			float speedX = num2 + (float)Main.rand.Next(-40, 41) * 0.01f;
			float speedY3 = num3 + (float)Main.rand.Next(-40, 41) * 0.01f;
			Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, speedX, speedY3, projToShoot, totalDamage, KnockBack, i);
		}
		else if (sItem.type == 1319)
		{
			float speedX2 = num2 + (float)Main.rand.Next(-40, 41) * 0.02f;
			float speedY4 = num3 + (float)Main.rand.Next(-40, 41) * 0.02f;
			Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, speedX2, speedY4, projToShoot, totalDamage, KnockBack, i);
		}
		else if (sItem.type == 3107)
		{
			float speedX3 = num2 + (float)Main.rand.Next(-40, 41) * 0.02f;
			float speedY5 = num3 + (float)Main.rand.Next(-40, 41) * 0.02f;
			Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, speedX3, speedY5, projToShoot, totalDamage, KnockBack, i);
		}
		else if (ProjectileID.Sets.IsAGolfBall[projToShoot])
		{
			Vector2 val13 = default(Vector2);
			((Vector2)(ref val13))..ctor((float)Main.mouseX + Main.screenPosition.X, (float)Main.mouseY + Main.screenPosition.Y);
			Vector2 val14 = val13 - base.Center;
			bool flag2 = false;
			if (((Vector2)(ref val14)).Length() < 100f)
			{
				flag2 = TryPlacingAGolfBallNearANearbyTee(val13);
			}
			if (!flag2)
			{
				if (((Vector2)(ref val14)).Length() > 100f || !Collision.CanHit(base.Center, 1, 1, val13, 1, 1))
				{
					Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, num2, num3, projToShoot, totalDamage, KnockBack, i);
				}
				else
				{
					Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, val13.X, val13.Y, 0f, 0f, projToShoot, totalDamage, KnockBack, i);
				}
			}
		}
		else if (sItem.type == 3053)
		{
			bool flag3 = false;
			if (itemAnimation <= itemTimeMax)
			{
				flag3 = true;
			}
			Vector2 val15 = default(Vector2);
			((Vector2)(ref val15))..ctor(num2, num3);
			((Vector2)(ref val15)).Normalize();
			val15 *= 4f;
			if (!flag3)
			{
				Vector2 val16 = default(Vector2);
				((Vector2)(ref val16))..ctor((float)Main.rand.Next(-100, 101), (float)Main.rand.Next(-100, 101));
				((Vector2)(ref val16)).Normalize();
				val15 += val16;
			}
			((Vector2)(ref val15)).Normalize();
			val15 *= sItem.shootSpeed;
			float num17 = (float)Main.rand.Next(10, 80) * 0.001f;
			if (Main.rand.Next(2) == 0)
			{
				num17 *= -1f;
			}
			float num18 = (float)Main.rand.Next(10, 80) * 0.001f;
			if (Main.rand.Next(2) == 0)
			{
				num18 *= -1f;
			}
			if (flag3)
			{
				num18 = (num17 = 0f);
			}
			Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, val15.X, val15.Y, projToShoot, totalDamage, KnockBack, i, num18, num17);
		}
		else if (sItem.type == 3019)
		{
			Vector2 val17 = default(Vector2);
			((Vector2)(ref val17))..ctor(num2, num3);
			float num19 = ((Vector2)(ref val17)).Length();
			val17.X += (float)Main.rand.Next(-100, 101) * 0.01f * num19 * 0.15f;
			val17.Y += (float)Main.rand.Next(-100, 101) * 0.01f * num19 * 0.15f;
			float num20 = num2 + (float)Main.rand.Next(-40, 41) * 0.03f;
			float num21 = num3 + (float)Main.rand.Next(-40, 41) * 0.03f;
			((Vector2)(ref val17)).Normalize();
			val17 *= num19;
			num20 *= (float)Main.rand.Next(50, 150) * 0.01f;
			num21 *= (float)Main.rand.Next(50, 150) * 0.01f;
			Vector2 val18 = default(Vector2);
			((Vector2)(ref val18))..ctor(num20, num21);
			val18.X += (float)Main.rand.Next(-100, 101) * 0.025f;
			val18.Y += (float)Main.rand.Next(-100, 101) * 0.025f;
			((Vector2)(ref val18)).Normalize();
			val18 *= num19;
			num20 = val18.X;
			num21 = val18.Y;
			Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, num20, num21, projToShoot, totalDamage, KnockBack, i, val17.X, val17.Y);
		}
		else if (sItem.type == 2797)
		{
			Vector2 val19 = Vector2.Normalize(new Vector2(num2, num3)) * 40f * sItem.scale;
			if (Collision.CanHit(pointPoisition, 0, 0, pointPoisition + val19, 0, 0))
			{
				pointPoisition += val19;
			}
			float ai = Utils.ToRotation(new Vector2(num2, num3));
			float num22 = (float)Math.PI * 2f / 3f;
			int num23 = Main.rand.Next(4, 5);
			if (Main.rand.Next(4) == 0)
			{
				num23++;
			}
			for (int m = 0; m < num23; m++)
			{
				float num24 = (float)Main.rand.NextDouble() * 0.2f + 0.05f;
				Vector2 spinningpoint4 = new Vector2(num2, num3);
				double radians5 = num22 * (float)Main.rand.NextDouble() - num22 / 2f;
				val = default(Vector2);
				Vector2 val20 = Utils.RotatedBy(spinningpoint4, radians5, val) * num24;
				int num25 = Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, val20.X, val20.Y, 444, totalDamage, KnockBack, i, ai);
				Main.projectile[num25].localAI[0] = projToShoot;
				Main.projectile[num25].localAI[1] = speed;
			}
		}
		else if (sItem.type == 2270)
		{
			float num26 = num2 + (float)Main.rand.Next(-40, 41) * 0.05f;
			float num27 = num3 + (float)Main.rand.Next(-40, 41) * 0.05f;
			if (Main.rand.Next(3) == 0)
			{
				num26 *= 1f + (float)Main.rand.Next(-30, 31) * 0.02f;
				num27 *= 1f + (float)Main.rand.Next(-30, 31) * 0.02f;
			}
			Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, num26, num27, projToShoot, totalDamage, KnockBack, i);
		}
		else if (sItem.type == 5117)
		{
			float speedX4 = num2 + (float)Main.rand.Next(-15, 16) * 0.075f;
			float speedY6 = num3 + (float)Main.rand.Next(-15, 16) * 0.075f;
			int num28 = Main.rand.Next(Main.projFrames[sItem.shoot]);
			int damage2 = totalDamage;
			Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, speedX4, speedY6, projToShoot, damage2, KnockBack, i, 0f, num28);
		}
		else if (sItem.type == 1930)
		{
			int num29 = 2 + Main.rand.Next(3);
			for (int n = 0; n < num29; n++)
			{
				float num30 = num2;
				float num31 = num3;
				float num32 = 0.025f * (float)n;
				num30 += (float)Main.rand.Next(-35, 36) * num32;
				num31 += (float)Main.rand.Next(-35, 36) * num32;
				num4 = (float)Math.Sqrt(num30 * num30 + num31 * num31);
				num4 = speed / num4;
				num30 *= num4;
				num31 *= num4;
				float x = pointPoisition.X + num2 * (float)(num29 - n) * 1.75f;
				float y = pointPoisition.Y + num3 * (float)(num29 - n) * 1.75f;
				Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, x, y, num30, num31, projToShoot, totalDamage, KnockBack, i, Main.rand.Next(0, 10 * (n + 1)));
			}
		}
		else if (sItem.type == 1931)
		{
			int num33 = 2;
			for (int num34 = 0; num34 < num33; num34++)
			{
				((Vector2)(ref pointPoisition))..ctor(base.position.X + (float)width * 0.5f + (float)(Main.rand.Next(201) * -direction) + ((float)Main.mouseX + Main.screenPosition.X - base.position.X), MountedCenter.Y - 600f);
				pointPoisition.X = (pointPoisition.X + base.Center.X) / 2f + (float)Main.rand.Next(-200, 201);
				pointPoisition.Y -= 100 * num34;
				num2 = (float)Main.mouseX + Main.screenPosition.X - pointPoisition.X;
				num3 = (float)Main.mouseY + Main.screenPosition.Y - pointPoisition.Y;
				if (gravDir == -1f)
				{
					num3 = Main.screenPosition.Y + (float)Main.screenHeight - (float)Main.mouseY - pointPoisition.Y;
				}
				if (num3 < 0f)
				{
					num3 *= -1f;
				}
				if (num3 < 20f)
				{
					num3 = 20f;
				}
				num4 = (float)Math.Sqrt(num2 * num2 + num3 * num3);
				num4 = speed / num4;
				num2 *= num4;
				num3 *= num4;
				float speedX5 = num2 + (float)Main.rand.Next(-40, 41) * 0.02f;
				float speedY7 = num3 + (float)Main.rand.Next(-40, 41) * 0.02f;
				Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, speedX5, speedY7, projToShoot, totalDamage, KnockBack, i, 0f, Main.rand.Next(5));
			}
		}
		else if (sItem.type == 2750)
		{
			int num35 = 1;
			for (int num36 = 0; num36 < num35; num36++)
			{
				((Vector2)(ref pointPoisition))..ctor(base.position.X + (float)width * 0.5f + (float)(Main.rand.Next(201) * -direction) + ((float)Main.mouseX + Main.screenPosition.X - base.position.X), MountedCenter.Y - 600f);
				pointPoisition.X = (pointPoisition.X + base.Center.X) / 2f + (float)Main.rand.Next(-200, 201);
				pointPoisition.Y -= 100 * num36;
				num2 = (float)Main.mouseX + Main.screenPosition.X - pointPoisition.X + (float)Main.rand.Next(-40, 41) * 0.03f;
				num3 = (float)Main.mouseY + Main.screenPosition.Y - pointPoisition.Y;
				if (gravDir == -1f)
				{
					num3 = Main.screenPosition.Y + (float)Main.screenHeight - (float)Main.mouseY - pointPoisition.Y;
				}
				if (num3 < 0f)
				{
					num3 *= -1f;
				}
				if (num3 < 20f)
				{
					num3 = 20f;
				}
				num4 = (float)Math.Sqrt(num2 * num2 + num3 * num3);
				num4 = speed / num4;
				num2 *= num4;
				num3 *= num4;
				float num37 = num2;
				float num38 = num3 + (float)Main.rand.Next(-40, 41) * 0.02f;
				Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, num37 * 0.75f, num38 * 0.75f, projToShoot + Main.rand.Next(3), totalDamage, KnockBack, i, 0f, 0.5f + (float)Main.rand.NextDouble() * 0.3f);
			}
		}
		else if (sItem.type == 3570)
		{
			int num39 = 3;
			for (int num40 = 0; num40 < num39; num40++)
			{
				((Vector2)(ref pointPoisition))..ctor(base.position.X + (float)width * 0.5f + (float)(Main.rand.Next(201) * -direction) + ((float)Main.mouseX + Main.screenPosition.X - base.position.X), MountedCenter.Y - 600f);
				pointPoisition.X = (pointPoisition.X + base.Center.X) / 2f + (float)Main.rand.Next(-200, 201);
				pointPoisition.Y -= 100 * num40;
				num2 = (float)Main.mouseX + Main.screenPosition.X - pointPoisition.X;
				num3 = (float)Main.mouseY + Main.screenPosition.Y - pointPoisition.Y;
				float ai2 = num3 + pointPoisition.Y;
				if (num3 < 0f)
				{
					num3 *= -1f;
				}
				if (num3 < 20f)
				{
					num3 = 20f;
				}
				num4 = (float)Math.Sqrt(num2 * num2 + num3 * num3);
				num4 = speed / num4;
				num2 *= num4;
				num3 *= num4;
				Vector2 val21 = new Vector2(num2, num3) / 2f;
				Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, val21.X, val21.Y, projToShoot, totalDamage, KnockBack, i, 0f, ai2);
			}
		}
		else if (sItem.type == 5065)
		{
			Vector2 farthestSpawnPositionOnLine = GetFarthestSpawnPositionOnLine(pointPoisition, num2, num3);
			Vector2 zero = Vector2.Zero;
			Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, farthestSpawnPositionOnLine, zero, projToShoot, totalDamage, KnockBack, i);
		}
		else if (sItem.type == 3065)
		{
			Vector2 val22 = Main.screenPosition + new Vector2((float)Main.mouseX, (float)Main.mouseY);
			float num41 = val22.Y;
			if (num41 > base.Center.Y - 200f)
			{
				num41 = base.Center.Y - 200f;
			}
			for (int num42 = 0; num42 < 3; num42++)
			{
				pointPoisition = base.Center + new Vector2((float)(-Main.rand.Next(0, 401) * direction), -600f);
				pointPoisition.Y -= 100 * num42;
				Vector2 val23 = val22 - pointPoisition;
				if (val23.Y < 0f)
				{
					val23.Y *= -1f;
				}
				if (val23.Y < 20f)
				{
					val23.Y = 20f;
				}
				((Vector2)(ref val23)).Normalize();
				val23 *= speed;
				num2 = val23.X;
				num3 = val23.Y;
				float speedX6 = num2;
				float speedY8 = num3 + (float)Main.rand.Next(-40, 41) * 0.02f;
				Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, speedX6, speedY8, projToShoot, totalDamage, KnockBack, i, 0f, num41);
			}
		}
		else if (sItem.type == 2624)
		{
			float num43 = (float)Math.PI / 10f;
			int num44 = 5;
			Vector2 val24 = default(Vector2);
			((Vector2)(ref val24))..ctor(num2, num3);
			((Vector2)(ref val24)).Normalize();
			val24 *= 40f;
			bool flag4 = Collision.CanHit(pointPoisition, 0, 0, pointPoisition + val24, 0, 0);
			for (int num45 = 0; num45 < num44; num45++)
			{
				float num46 = (float)num45 - ((float)num44 - 1f) / 2f;
				Vector2 spinningpoint5 = val24;
				double radians6 = num43 * num46;
				val = default(Vector2);
				Vector2 val25 = spinningpoint5.RotatedBy(radians6, val);
				if (!flag4)
				{
					val25 -= val24;
				}
				int num47 = Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X + val25.X, pointPoisition.Y + val25.Y, num2, num3, projToShoot, totalDamage, KnockBack, i);
				Main.projectile[num47].noDropItem = true;
			}
		}
		else if (sItem.type == 1929)
		{
			float speedX7 = num2 + (float)Main.rand.Next(-40, 41) * 0.03f;
			float speedY9 = num3 + (float)Main.rand.Next(-40, 41) * 0.03f;
			Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, speedX7, speedY9, projToShoot, totalDamage, KnockBack, i);
		}
		else if (sItem.type == 1553)
		{
			float speedX8 = num2 + (float)Main.rand.Next(-40, 41) * 0.005f;
			float speedY10 = num3 + (float)Main.rand.Next(-40, 41) * 0.005f;
			Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, speedX8, speedY10, projToShoot, totalDamage, KnockBack, i);
		}
		else if (sItem.type == 518)
		{
			float num48 = num2;
			float num49 = num3;
			num48 += (float)Main.rand.Next(-40, 41) * 0.04f;
			num49 += (float)Main.rand.Next(-40, 41) * 0.04f;
			Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, num48, num49, projToShoot, totalDamage, KnockBack, i);
		}
		else if (sItem.type == 1265)
		{
			float num50 = num2;
			float num51 = num3;
			num50 += (float)Main.rand.Next(-30, 31) * 0.03f;
			num51 += (float)Main.rand.Next(-30, 31) * 0.03f;
			Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, num50, num51, projToShoot, totalDamage, KnockBack, i);
		}
		else if (sItem.type == 4262)
		{
			float num52 = 2.6666667f;
			_ = base.Bottom;
			_ = (int)base.Bottom.X / 16;
			int num53 = 4;
			float num54 = Math.Abs((float)Main.mouseX + Main.screenPosition.X - base.position.X) / 16f;
			if (direction < 0)
			{
				num54 += 1f;
			}
			num53 = (int)num54;
			if (num53 > 15)
			{
				num53 = 15;
			}
			Point val26 = base.Center.ToTileCoordinates();
			int maxDistance = 31;
			for (int num55 = num53; num55 >= 0; num55--)
			{
				if (Collision.CanHitLine(base.Center, 1, 1, base.Center + new Vector2((float)(16 * num55 * direction), 0f), 1, 1) && WorldUtils.Find(new Point(val26.X + direction * num55, val26.Y), Searches.Chain(new Searches.Down(maxDistance), new Terraria.WorldBuilding.Conditions.MysticSnake()), out var result))
				{
					int num56 = result.Y;
					while (Main.tile[result.X, num56 - 1].active())
					{
						num56--;
						if (Main.tile[result.X, num56 - 1] == null || num56 < 10 || result.Y - num56 > 7)
						{
							num56 = -1;
							break;
						}
					}
					if (num56 >= 10)
					{
						result.Y = num56;
						for (int num57 = 0; num57 < 1000; num57++)
						{
							Projectile projectile = Main.projectile[num57];
							if (projectile.active && projectile.owner == whoAmI && projectile.type == projToShoot)
							{
								if (projectile.ai[1] == 2f)
								{
									projectile.timeLeft = 4;
								}
								else
								{
									projectile.Kill();
								}
							}
						}
						Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, result.X * 16 + 8, result.Y * 16 + 8 - 16, 0f, 0f - num52, projToShoot, totalDamage, KnockBack, i, result.Y * 16 + 8 - 16);
						break;
					}
				}
			}
		}
		else if (sItem.type == 4952)
		{
			Vector2 val27 = Main.rand.NextVector2Circular(1f, 1f) + Main.rand.NextVector2CircularEdge(3f, 3f);
			if (val27.Y > 0f)
			{
				val27.Y *= -1f;
			}
			float num58 = (float)itemAnimation / (float)itemAnimationMax * 0.66f + miscCounterNormalized;
			pointPoisition = MountedCenter + new Vector2((float)(direction * 15), gravDir * 3f);
			Point val28 = pointPoisition.ToTileCoordinates();
			Tile tile = Main.tile[val28.X, val28.Y];
			if (tile != null && tile.nactive() && Main.tileSolid[tile.type] && !Main.tileSolidTop[tile.type] && !TileID.Sets.Platforms[tile.type])
			{
				pointPoisition = MountedCenter;
			}
			Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, val27.X, val27.Y, projToShoot, totalDamage, KnockBack, i, -1f, num58 % 1f);
		}
		else if (sItem.type == 4953)
		{
			float num59 = (float)Math.PI / 10f;
			int num60 = 5;
			Vector2 val29 = default(Vector2);
			((Vector2)(ref val29))..ctor(num2, num3);
			((Vector2)(ref val29)).Normalize();
			val29 *= 40f;
			bool num61 = Collision.CanHit(pointPoisition, 0, 0, pointPoisition + val29, 0, 0);
			int num62 = (itemAnimationMax - itemAnimation) / 2;
			int num63 = num62;
			if (direction == 1)
			{
				num63 = 4 - num62;
			}
			float num64 = (float)num63 - ((float)num60 - 1f) / 2f;
			Vector2 spinningpoint6 = val29;
			double radians7 = num59 * num64;
			val = default(Vector2);
			Vector2 val30 = spinningpoint6.RotatedBy(radians7, val);
			if (!num61)
			{
				val30 -= val29;
			}
			Vector2 mouseWorld = Main.MouseWorld;
			Vector2 origin = pointPoisition + val30;
			Vector2 val31 = origin.DirectionTo(mouseWorld).SafeNormalize(-Vector2.UnitY);
			Vector2 val32 = base.Center.DirectionTo(base.Center + new Vector2(num2, num3)).SafeNormalize(-Vector2.UnitY);
			float lerpValue = Utils.GetLerpValue(100f, 40f, mouseWorld.Distance(base.Center), clamped: true);
			if (lerpValue > 0f)
			{
				val31 = Vector2.Lerp(val31, val32, lerpValue).SafeNormalize(Utils.SafeNormalize(new Vector2(num2, num3), -Vector2.UnitY));
			}
			Vector2 v3 = val31 * speed;
			if (num62 == 2)
			{
				projToShoot = 932;
				totalDamage *= 2;
			}
			if (projToShoot == 932)
			{
				float ai3 = miscCounterNormalized * 12f % 1f;
				v3 = v3.SafeNormalize(Vector2.Zero) * (speed * 2f);
				Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, origin, v3, projToShoot, totalDamage, KnockBack, i, 0f, ai3);
			}
			else
			{
				int num65 = Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, origin, v3, projToShoot, totalDamage, KnockBack, i);
				Main.projectile[num65].noDropItem = true;
			}
		}
		else if (sItem.type == 534)
		{
			int num66 = Main.rand.Next(4, 6);
			for (int num67 = 0; num67 < num66; num67++)
			{
				float num68 = num2;
				float num69 = num3;
				num68 += (float)Main.rand.Next(-40, 41) * 0.05f;
				num69 += (float)Main.rand.Next(-40, 41) * 0.05f;
				Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, num68, num69, projToShoot, totalDamage, KnockBack, i);
			}
		}
		else if (sItem.type == 4703)
		{
			float num70 = (float)Math.PI / 2f;
			Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, num2, num3, projToShoot, totalDamage, KnockBack, i);
			Vector2 val33 = default(Vector2);
			for (int num71 = 0; num71 < 7; num71++)
			{
				((Vector2)(ref val33))..ctor(num2, num3);
				float num72 = ((Vector2)(ref val33)).Length();
				Vector2 val34 = val33;
				Vector2 spinningpoint7 = val33.SafeNormalize(Vector2.Zero);
				double radians8 = num70 * Main.rand.NextFloat();
				val = default(Vector2);
				val33 = val34 + spinningpoint7.RotatedBy(radians8, val) * Main.rand.NextFloatDirection() * 5f;
				val33 = val33.SafeNormalize(Vector2.Zero) * num72;
				float x2 = val33.X;
				float y2 = val33.Y;
				x2 += (float)Main.rand.Next(-40, 41) * 0.05f;
				y2 += (float)Main.rand.Next(-40, 41) * 0.05f;
				Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, x2, y2, projToShoot, totalDamage, KnockBack, i);
			}
		}
		else if (sItem.type == 4270)
		{
			Vector2 pointPoisition2 = Main.MouseWorld;
			LimitPointToPlayerReachableArea(ref pointPoisition2);
			Vector2 val35 = pointPoisition2 + Main.rand.NextVector2Circular(8f, 8f);
			Vector2 val36 = FindSharpTearsSpot(val35).ToWorldCoordinates(Main.rand.Next(17), Main.rand.Next(17));
			Vector2 val37 = (val35 - val36).SafeNormalize(-Vector2.UnitY) * 16f;
			Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, val36.X, val36.Y, val37.X, val37.Y, projToShoot, totalDamage, KnockBack, i, 0f, Main.rand.NextFloat() * 0.5f + 0.6f);
		}
		else if (sItem.type == 4715)
		{
			Vector2 val38 = Main.MouseWorld;
			List<NPC> validTargets;
			bool sparkleGuitarTarget = GetSparkleGuitarTarget(out validTargets);
			if (sparkleGuitarTarget)
			{
				NPC nPC = validTargets[Main.rand.Next(validTargets.Count)];
				val38 = nPC.Center + nPC.velocity * 20f;
			}
			Vector2 val39 = val38 - base.Center;
			if (!sparkleGuitarTarget)
			{
				val38 += Main.rand.NextVector2Circular(24f, 24f);
				if (((Vector2)(ref val39)).Length() > 700f)
				{
					val39 *= 700f / ((Vector2)(ref val39)).Length();
					val38 = base.Center + val39;
				}
			}
			Vector2 val40 = Main.rand.NextVector2CircularEdge(1f, 1f);
			if (val40.Y > 0f)
			{
				val40 *= -1f;
			}
			if (Math.Abs(val40.Y) < 0.5f)
			{
				val40.Y = (0f - Main.rand.NextFloat()) * 0.5f - 0.5f;
			}
			val40 *= ((Vector2)(ref val39)).Length() * 2f;
			Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, val40.X, val40.Y, projToShoot, totalDamage, KnockBack, i, val38.X, val38.Y);
		}
		else if (sItem.type == 4722)
		{
			Vector2 val41 = Main.MouseWorld;
			List<NPC> validTargets2;
			bool sparkleGuitarTarget2 = GetSparkleGuitarTarget(out validTargets2);
			if (sparkleGuitarTarget2)
			{
				NPC nPC2 = validTargets2[Main.rand.Next(validTargets2.Count)];
				val41 = nPC2.Center + nPC2.velocity * 20f;
			}
			Vector2 val42 = val41 - base.Center;
			Vector2 val43 = Main.rand.NextVector2CircularEdge(1f, 1f);
			float num73 = 1f;
			int num74 = 1;
			Vector2 val45 = default(Vector2);
			for (int num75 = 0; num75 < num74; num75++)
			{
				if (!sparkleGuitarTarget2)
				{
					val41 += Main.rand.NextVector2Circular(24f, 24f);
					if (((Vector2)(ref val42)).Length() > 700f)
					{
						val42 *= 700f / ((Vector2)(ref val42)).Length();
						val41 = base.Center + val42;
					}
					float num76 = Utils.GetLerpValue(0f, 6f, ((Vector2)(ref val10)).Length(), clamped: true) * 0.8f;
					val43 *= 1f - num76;
					val43 += val10 * num76;
					val43 = val43.SafeNormalize(Vector2.UnitX);
				}
				float num77 = 60f;
				float num78 = Main.rand.NextFloatDirection() * (float)Math.PI * (1f / num77) * 0.5f * num73;
				float num79 = num77 / 2f;
				float num80 = 12f + Main.rand.NextFloat() * 2f;
				Vector2 val44 = val43 * num80;
				((Vector2)(ref val45))..ctor(0f, 0f);
				Vector2 val46 = val44;
				for (int num81 = 0; (float)num81 < num79; num81++)
				{
					val45 += val46;
					Vector2 spinningpoint8 = val46;
					double radians9 = num78;
					val = default(Vector2);
					val46 = spinningpoint8.RotatedBy(radians9, val);
				}
				Vector2 val47 = -val45;
				Vector2 val48 = val41 + val47;
				float lerpValue2 = Utils.GetLerpValue(itemAnimationMax, 0f, itemAnimation, clamped: true);
				Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, val48, val44, projToShoot, totalDamage, KnockBack, i, num78, lerpValue2);
			}
		}
		else if (sItem.type == 4607)
		{
			int minionProjectileId = projToShoot;
			float knockBack = KnockBack;
			val = default(Vector2);
			Vector2 offsetFromCursor = val;
			val = default(Vector2);
			SpawnMinionOnCursor(projectileSource_Item_WithPotentialAmmo, i, minionProjectileId, damage, knockBack, offsetFromCursor, val);
		}
		else if (sItem.type == 5069)
		{
			int minionProjectileId2 = projToShoot;
			float knockBack2 = KnockBack;
			val = default(Vector2);
			Vector2 offsetFromCursor2 = val;
			val = default(Vector2);
			SpawnMinionOnCursor(projectileSource_Item_WithPotentialAmmo, i, minionProjectileId2, damage, knockBack2, offsetFromCursor2, val);
		}
		else if (sItem.type == 5114)
		{
			int minionProjectileId3 = projToShoot;
			float knockBack3 = KnockBack;
			val = default(Vector2);
			Vector2 offsetFromCursor3 = val;
			val = default(Vector2);
			SpawnMinionOnCursor(projectileSource_Item_WithPotentialAmmo, i, minionProjectileId3, damage, knockBack3, offsetFromCursor3, val);
		}
		else if (sItem.type == 2188)
		{
			int num82 = 4;
			if (Main.rand.Next(3) == 0)
			{
				num82++;
			}
			if (Main.rand.Next(4) == 0)
			{
				num82++;
			}
			if (Main.rand.Next(5) == 0)
			{
				num82++;
			}
			for (int num83 = 0; num83 < num82; num83++)
			{
				float num84 = num2;
				float num85 = num3;
				float num86 = 0.05f * (float)num83;
				num84 += (float)Main.rand.Next(-35, 36) * num86;
				num85 += (float)Main.rand.Next(-35, 36) * num86;
				num4 = (float)Math.Sqrt(num84 * num84 + num85 * num85);
				num4 = speed / num4;
				num84 *= num4;
				num85 *= num4;
				float x3 = pointPoisition.X;
				float y3 = pointPoisition.Y;
				Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, x3, y3, num84, num85, projToShoot, totalDamage, KnockBack, i);
			}
		}
		else if (sItem.type == 1308)
		{
			int num87 = 3;
			if (Main.rand.Next(3) == 0)
			{
				num87++;
			}
			for (int num88 = 0; num88 < num87; num88++)
			{
				float num89 = num2;
				float num90 = num3;
				float num91 = 0.05f * (float)num88;
				num89 += (float)Main.rand.Next(-35, 36) * num91;
				num90 += (float)Main.rand.Next(-35, 36) * num91;
				num4 = (float)Math.Sqrt(num89 * num89 + num90 * num90);
				num4 = speed / num4;
				num89 *= num4;
				num90 *= num4;
				float x4 = pointPoisition.X;
				float y4 = pointPoisition.Y;
				Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, x4, y4, num89, num90, projToShoot, totalDamage, KnockBack, i);
			}
		}
		else if (sItem.type == 1258)
		{
			float num92 = num2;
			float num93 = num3;
			num92 += (float)Main.rand.Next(-40, 41) * 0.01f;
			num93 += (float)Main.rand.Next(-40, 41) * 0.01f;
			pointPoisition.X += (float)Main.rand.Next(-40, 41) * 0.05f;
			pointPoisition.Y += (float)Main.rand.Next(-45, 36) * 0.05f;
			Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, num92, num93, projToShoot, totalDamage, KnockBack, i);
		}
		else if (sItem.type == 964)
		{
			int num94 = Main.rand.Next(3, 5);
			for (int num95 = 0; num95 < num94; num95++)
			{
				float num96 = num2;
				float num97 = num3;
				num96 += (float)Main.rand.Next(-35, 36) * 0.04f;
				num97 += (float)Main.rand.Next(-35, 36) * 0.04f;
				Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, num96, num97, projToShoot, totalDamage, KnockBack, i);
			}
		}
		else if (sItem.type == 1569)
		{
			int num98 = 4;
			if (Main.rand.Next(2) == 0)
			{
				num98++;
			}
			if (Main.rand.Next(4) == 0)
			{
				num98++;
			}
			if (Main.rand.Next(8) == 0)
			{
				num98++;
			}
			if (Main.rand.Next(16) == 0)
			{
				num98++;
			}
			for (int num99 = 0; num99 < num98; num99++)
			{
				float num100 = num2;
				float num101 = num3;
				float num102 = 0.05f * (float)num99;
				num100 += (float)Main.rand.Next(-35, 36) * num102;
				num101 += (float)Main.rand.Next(-35, 36) * num102;
				num4 = (float)Math.Sqrt(num100 * num100 + num101 * num101);
				num4 = speed / num4;
				num100 *= num4;
				num101 *= num4;
				float x5 = pointPoisition.X;
				float y5 = pointPoisition.Y;
				Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, x5, y5, num100, num101, projToShoot, totalDamage, KnockBack, i);
			}
		}
		else if (sItem.type == 1572 || sItem.type == 2366 || sItem.type == 3571 || sItem.type == 3569 || sItem.type == 5119)
		{
			bool num103 = sItem.type == 3571 || sItem.type == 3569;
			int num104 = (int)((float)Main.mouseX + Main.screenPosition.X) / 16;
			int num105 = (int)((float)Main.mouseY + Main.screenPosition.Y) / 16;
			if (gravDir == -1f)
			{
				num105 = (int)(Main.screenPosition.Y + (float)Main.screenHeight - (float)Main.mouseY) / 16;
			}
			if (!num103)
			{
				for (; num105 < Main.maxTilesY - 10 && Main.tile[num104, num105] != null && !WorldGen.SolidTile2(num104, num105) && Main.tile[num104 - 1, num105] != null && !WorldGen.SolidTile2(num104 - 1, num105) && Main.tile[num104 + 1, num105] != null && !WorldGen.SolidTile2(num104 + 1, num105); num105++)
				{
				}
				num105--;
			}
			int num106 = 0;
			switch (sItem.type)
			{
			case 1572:
				num106 = 60;
				break;
			case 5119:
				num106 = 90;
				break;
			}
			int num107 = Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, (float)Main.mouseX + Main.screenPosition.X, num105 * 16 - 24, 0f, 15f, projToShoot, totalDamage, KnockBack, i, num106);
			Main.projectile[num107].originalDamage = damage;
			UpdateMaxTurrets();
		}
		else if (sItem.type == 1244 || sItem.type == 1256)
		{
			int num108 = Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, num2, num3, projToShoot, totalDamage, KnockBack, i);
			Main.projectile[num108].ai[0] = (float)Main.mouseX + Main.screenPosition.X;
			Main.projectile[num108].ai[1] = (float)Main.mouseY + Main.screenPosition.Y;
		}
		else if (sItem.type == 1229)
		{
			int num109 = 2;
			if (Main.rand.Next(3) == 0)
			{
				num109++;
			}
			for (int num110 = 0; num110 < num109; num110++)
			{
				float num111 = num2;
				float num112 = num3;
				if (num110 > 0)
				{
					num111 += (float)Main.rand.Next(-35, 36) * 0.04f;
					num112 += (float)Main.rand.Next(-35, 36) * 0.04f;
				}
				if (num110 > 1)
				{
					num111 += (float)Main.rand.Next(-35, 36) * 0.04f;
					num112 += (float)Main.rand.Next(-35, 36) * 0.04f;
				}
				if (num110 > 2)
				{
					num111 += (float)Main.rand.Next(-35, 36) * 0.04f;
					num112 += (float)Main.rand.Next(-35, 36) * 0.04f;
				}
				int num113 = Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, num111, num112, projToShoot, totalDamage, KnockBack, i);
				Main.projectile[num113].noDropItem = true;
			}
		}
		else if (sItem.type == 1121)
		{
			int num114 = Main.rand.Next(1, 4);
			if (Main.rand.Next(6) == 0)
			{
				num114++;
			}
			if (Main.rand.Next(6) == 0)
			{
				num114++;
			}
			if (strongBees && Main.rand.Next(3) == 0)
			{
				num114++;
			}
			for (int num115 = 0; num115 < num114; num115++)
			{
				float num116 = num2;
				float num117 = num3;
				num116 += (float)Main.rand.Next(-35, 36) * 0.02f;
				num117 += (float)Main.rand.Next(-35, 36) * 0.02f;
				int num118 = Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, num116, num117, beeType(), beeDamage(totalDamage), beeKB(KnockBack), i);
				Main.projectile[num118].magic = true;
			}
		}
		else if (sItem.type == 1155)
		{
			int num119 = Main.rand.Next(2, 5);
			for (int num120 = 0; num120 < num119; num120++)
			{
				float num121 = num2;
				float num122 = num3;
				num121 += (float)Main.rand.Next(-35, 36) * 0.02f;
				num122 += (float)Main.rand.Next(-35, 36) * 0.02f;
				Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, num121, num122, projToShoot, totalDamage, KnockBack, i);
			}
		}
		else if (sItem.type == 1801)
		{
			int num123 = Main.rand.Next(2, 4);
			for (int num124 = 0; num124 < num123; num124++)
			{
				float num125 = num2;
				float num126 = num3;
				num125 += (float)Main.rand.Next(-35, 36) * 0.05f;
				num126 += (float)Main.rand.Next(-35, 36) * 0.05f;
				Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, num125, num126, projToShoot, totalDamage, KnockBack, i);
			}
		}
		else if (sItem.type == 679)
		{
			for (int num127 = 0; num127 < 6; num127++)
			{
				float num128 = num2;
				float num129 = num3;
				num128 += (float)Main.rand.Next(-40, 41) * 0.05f;
				num129 += (float)Main.rand.Next(-40, 41) * 0.05f;
				Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, num128, num129, projToShoot, totalDamage, KnockBack, i);
			}
		}
		else if (sItem.type == 1156)
		{
			for (int num130 = 0; num130 < 3; num130++)
			{
				float num131 = num2;
				float num132 = num3;
				num131 += (float)Main.rand.Next(-40, 41) * 0.05f;
				num132 += (float)Main.rand.Next(-40, 41) * 0.05f;
				Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, num131, num132, projToShoot, totalDamage, KnockBack, i);
			}
		}
		else if (sItem.type == 4682)
		{
			for (int num133 = 0; num133 < 3; num133++)
			{
				float num134 = num2;
				float num135 = num3;
				num134 += (float)Main.rand.Next(-20, 21) * 0.1f;
				num135 += (float)Main.rand.Next(-20, 21) * 0.1f;
				Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, num134, num135, projToShoot, totalDamage, KnockBack, i);
			}
		}
		else if (sItem.type == 2623)
		{
			for (int num136 = 0; num136 < 3; num136++)
			{
				float num137 = num2;
				float num138 = num3;
				num137 += (float)Main.rand.Next(-40, 41) * 0.1f;
				num138 += (float)Main.rand.Next(-40, 41) * 0.1f;
				Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, num137, num138, projToShoot, totalDamage, KnockBack, i);
			}
		}
		else if (sItem.type == 3210)
		{
			Vector2 val49 = default(Vector2);
			((Vector2)(ref val49))..ctor(num2, num3);
			val49.X += (float)Main.rand.Next(-30, 31) * 0.04f;
			val49.Y += (float)Main.rand.Next(-30, 31) * 0.03f;
			((Vector2)(ref val49)).Normalize();
			val49 *= (float)Main.rand.Next(70, 91) * 0.1f;
			val49.X += (float)Main.rand.Next(-30, 31) * 0.04f;
			val49.Y += (float)Main.rand.Next(-30, 31) * 0.03f;
			Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, val49.X, val49.Y, projToShoot, totalDamage, KnockBack, i, Main.rand.Next(20));
		}
		else if (sItem.type == 434)
		{
			float num139 = num2;
			float num140 = num3;
			if (itemAnimation < 5)
			{
				num139 += (float)Main.rand.Next(-40, 41) * 0.01f;
				num140 += (float)Main.rand.Next(-40, 41) * 0.01f;
				num139 *= 1.1f;
				num140 *= 1.1f;
			}
			else if (itemAnimation < 10)
			{
				num139 += (float)Main.rand.Next(-20, 21) * 0.01f;
				num140 += (float)Main.rand.Next(-20, 21) * 0.01f;
				num139 *= 1.05f;
				num140 *= 1.05f;
			}
			Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, num139, num140, projToShoot, totalDamage, KnockBack, i);
		}
		else if (sItem.type == 1157)
		{
			projToShoot = Main.rand.Next(191, 195);
			int minionProjectileId4 = projToShoot;
			float knockBack4 = KnockBack;
			val = default(Vector2);
			Vector2 offsetFromCursor4 = val;
			val = default(Vector2);
			int num141 = SpawnMinionOnCursor(projectileSource_Item_WithPotentialAmmo, i, minionProjectileId4, damage, knockBack4, offsetFromCursor4, val);
			Main.projectile[num141].localAI[0] = 30f;
		}
		else if (sItem.type == 1802)
		{
			int minionProjectileId5 = projToShoot;
			float knockBack5 = KnockBack;
			val = default(Vector2);
			Vector2 offsetFromCursor5 = val;
			val = default(Vector2);
			SpawnMinionOnCursor(projectileSource_Item_WithPotentialAmmo, i, minionProjectileId5, damage, knockBack5, offsetFromCursor5, val);
		}
		else if (sItem.type == 2364 || sItem.type == 2365)
		{
			int minionProjectileId6 = projToShoot;
			float knockBack6 = KnockBack;
			val = default(Vector2);
			Vector2 offsetFromCursor6 = val;
			val = default(Vector2);
			SpawnMinionOnCursor(projectileSource_Item_WithPotentialAmmo, i, minionProjectileId6, damage, knockBack6, offsetFromCursor6, val);
		}
		else if (sItem.type == 2535)
		{
			num2 = 0f;
			num3 = 0f;
			Vector2 val50 = default(Vector2);
			((Vector2)(ref val50))..ctor(num2, num3);
			Vector2 spinningpoint9 = val50;
			val = default(Vector2);
			val50 = spinningpoint9.RotatedBy(1.5707963705062866, val);
			SpawnMinionOnCursor(projectileSource_Item_WithPotentialAmmo, i, projToShoot, damage, KnockBack, val50, val50);
			Vector2 spinningpoint10 = val50;
			val = default(Vector2);
			val50 = spinningpoint10.RotatedBy(-3.1415927410125732, val);
			SpawnMinionOnCursor(projectileSource_Item_WithPotentialAmmo, i, projToShoot + 1, damage, KnockBack, val50, val50);
		}
		else if (sItem.type == 2551)
		{
			int minionProjectileId7 = projToShoot + nextCycledSpiderMinionType;
			float knockBack7 = KnockBack;
			val = default(Vector2);
			Vector2 offsetFromCursor7 = val;
			val = default(Vector2);
			SpawnMinionOnCursor(projectileSource_Item_WithPotentialAmmo, i, minionProjectileId7, damage, knockBack7, offsetFromCursor7, val);
			nextCycledSpiderMinionType++;
			nextCycledSpiderMinionType %= 3;
		}
		else if (sItem.type == 2584)
		{
			int minionProjectileId8 = projToShoot + Main.rand.Next(3);
			float knockBack8 = KnockBack;
			val = default(Vector2);
			Vector2 offsetFromCursor8 = val;
			val = default(Vector2);
			SpawnMinionOnCursor(projectileSource_Item_WithPotentialAmmo, i, minionProjectileId8, damage, knockBack8, offsetFromCursor8, val);
		}
		else if (sItem.type == 2621)
		{
			int minionProjectileId9 = projToShoot;
			float knockBack9 = KnockBack;
			val = default(Vector2);
			Vector2 offsetFromCursor9 = val;
			val = default(Vector2);
			SpawnMinionOnCursor(projectileSource_Item_WithPotentialAmmo, i, minionProjectileId9, damage, knockBack9, offsetFromCursor9, val);
		}
		else if (sItem.type == 2749 || sItem.type == 3249 || sItem.type == 3474 || sItem.type == 4273 || sItem.type == 4281)
		{
			int minionProjectileId10 = projToShoot;
			float knockBack10 = KnockBack;
			val = default(Vector2);
			Vector2 offsetFromCursor10 = val;
			val = default(Vector2);
			SpawnMinionOnCursor(projectileSource_Item_WithPotentialAmmo, i, minionProjectileId10, damage, knockBack10, offsetFromCursor10, val);
		}
		else if (sItem.type == 3531)
		{
			int num142 = -1;
			int num143 = -1;
			for (int num144 = 0; num144 < 1000; num144++)
			{
				if (Main.projectile[num144].active && Main.projectile[num144].owner == Main.myPlayer)
				{
					if (num142 == -1 && Main.projectile[num144].type == 625)
					{
						num142 = num144;
					}
					if (num143 == -1 && Main.projectile[num144].type == 628)
					{
						num143 = num144;
					}
					if (num142 != -1 && num143 != -1)
					{
						break;
					}
				}
			}
			if (num142 == -1 && num143 == -1)
			{
				num2 = 0f;
				num3 = 0f;
				pointPoisition.X = (float)Main.mouseX + Main.screenPosition.X;
				pointPoisition.Y = (float)Main.mouseY + Main.screenPosition.Y;
				int num145 = Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, num2, num3, projToShoot, totalDamage, KnockBack, i);
				int num146 = Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, num2, num3, projToShoot + 1, totalDamage, KnockBack, i, num145);
				int num147 = Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, num2, num3, projToShoot + 2, totalDamage, KnockBack, i, num146);
				int num148 = Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, num2, num3, projToShoot + 3, totalDamage, KnockBack, i, num147);
				Main.projectile[num146].localAI[1] = num147;
				Main.projectile[num147].localAI[1] = num148;
				Main.projectile[num145].originalDamage = damage;
				Main.projectile[num146].originalDamage = damage;
				Main.projectile[num147].originalDamage = damage;
				Main.projectile[num148].originalDamage = damage;
			}
			else if (num142 != -1 && num143 != -1)
			{
				int num149 = (int)Main.projectile[num143].ai[0];
				int num150 = Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, num2, num3, projToShoot + 1, totalDamage, KnockBack, i, num149);
				int num151 = Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, num2, num3, projToShoot + 2, totalDamage, KnockBack, i, num150);
				Main.projectile[num150].localAI[1] = num151;
				Main.projectile[num150].netUpdate = true;
				Main.projectile[num150].ai[1] = 1f;
				Main.projectile[num151].localAI[1] = num143;
				Main.projectile[num151].netUpdate = true;
				Main.projectile[num151].ai[1] = 1f;
				Main.projectile[num143].ai[0] = num151;
				Main.projectile[num143].netUpdate = true;
				Main.projectile[num143].ai[1] = 1f;
				Main.projectile[num150].originalDamage = damage;
				Main.projectile[num151].originalDamage = damage;
				Main.projectile[num143].originalDamage = damage;
			}
		}
		else if (sItem.type == 1309 || sItem.type == 4758 || sItem.type == 4269 || sItem.type == 5005)
		{
			int minionProjectileId11 = projToShoot;
			float knockBack11 = KnockBack;
			val = default(Vector2);
			Vector2 offsetFromCursor11 = val;
			val = default(Vector2);
			SpawnMinionOnCursor(projectileSource_Item_WithPotentialAmmo, i, minionProjectileId11, damage, knockBack11, offsetFromCursor11, val);
		}
		else if (sItem.shoot > 0 && (Main.projPet[sItem.shoot] || sItem.shoot == 72 || sItem.shoot == 18 || sItem.shoot == 500 || sItem.shoot == 650) && !sItem.summon)
		{
			for (int num152 = 0; num152 < 1000; num152++)
			{
				Projectile projectile2 = Main.projectile[num152];
				if (projectile2.active && projectile2.owner == whoAmI)
				{
					if (sItem.shoot == 72 && (projectile2.type == 72 || projectile2.type == 86 || projectile2.type == 87))
					{
						projectile2.Kill();
					}
					else if (sItem.type == 5131 && (projectile2.type == 881 || projectile2.type == 934))
					{
						projectile2.Kill();
					}
					else if (sItem.shoot == projectile2.type)
					{
						projectile2.Kill();
					}
				}
			}
			Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, num2, num3, projToShoot, 0, 0f, i);
		}
		else if (sItem.type == 3006)
		{
			pointPoisition = GetFarthestSpawnPositionOnLine(pointPoisition, num2, num3);
			Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, 0f, 0f, projToShoot, totalDamage, KnockBack, i);
		}
		else if (sItem.type == 3014)
		{
			Vector2 pointPoisition3 = new Vector2
			{
				X = Main.MouseWorld.X,
				Y = Main.MouseWorld.Y
			};
			LimitPointToPlayerReachableArea(ref pointPoisition3);
			while (Collision.CanHitLine(base.position, width, height, pointPoisition, 1, 1))
			{
				pointPoisition.X += num2;
				pointPoisition.Y += num3;
				val = pointPoisition - pointPoisition3;
				if (((Vector2)(ref val)).Length() < 20f + Math.Abs(num2) + Math.Abs(num3))
				{
					pointPoisition = pointPoisition3;
					break;
				}
			}
			bool flag5 = false;
			int num153 = (int)pointPoisition.Y / 16;
			int num154 = (int)pointPoisition.X / 16;
			int num155;
			for (num155 = num153; num153 < Main.maxTilesY - 10 && num153 - num155 < 30 && !WorldGen.SolidTile(num154, num153) && !TileID.Sets.Platforms[Main.tile[num154, num153].type]; num153++)
			{
			}
			if (!WorldGen.SolidTile(num154, num153) && !TileID.Sets.Platforms[Main.tile[num154, num153].type])
			{
				flag5 = true;
			}
			float num156 = num153 * 16;
			num153 = num155;
			while (num153 > 10 && num155 - num153 < 30 && !WorldGen.SolidTile(num154, num153))
			{
				num153--;
			}
			float num157 = num153 * 16 + 16;
			float num158 = num156 - num157;
			int num159 = 15;
			if (num158 > (float)(16 * num159))
			{
				num158 = 16 * num159;
			}
			num157 = num156 - num158;
			pointPoisition.X = (int)(pointPoisition.X / 16f) * 16;
			if (!flag5)
			{
				Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, 0f, 0f, projToShoot, totalDamage, KnockBack, i, num157, num158);
			}
		}
		else if (sItem.type == 3384)
		{
			int num160 = ((altFunctionUse == 2) ? 1 : 0);
			Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, num2, num3, projToShoot, totalDamage, KnockBack, i, 0f, num160);
		}
		else if (sItem.type == 3473)
		{
			float ai4 = (Main.rand.NextFloat() - 0.5f) * ((float)Math.PI / 4f);
			Vector2 val51 = default(Vector2);
			((Vector2)(ref val51))..ctor(num2, num3);
			Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, val51.X, val51.Y, projToShoot, totalDamage, KnockBack, i, 0f, ai4);
		}
		else if (sItem.type == 4956)
		{
			int num161 = (itemAnimationMax - itemAnimation) / itemTime;
			Vector2 val52 = default(Vector2);
			((Vector2)(ref val52))..ctor(num2, num3);
			int num162 = FinalFractalHelper.GetRandomProfileIndex();
			if (num161 == 0)
			{
				num162 = 4956;
			}
			Vector2 pointPoisition4 = Main.MouseWorld;
			LimitPointToPlayerReachableArea(ref pointPoisition4);
			Vector2 val53 = pointPoisition4 - MountedCenter;
			if (num161 == 1 || num161 == 2)
			{
				int npcTargetIndex;
				bool zenithTarget = GetZenithTarget(pointPoisition4, 400f, out npcTargetIndex);
				if (zenithTarget)
				{
					val53 = Main.npc[npcTargetIndex].Center - MountedCenter;
				}
				bool flag6 = num161 == 2;
				if (num161 == 1 && !zenithTarget)
				{
					flag6 = true;
				}
				if (flag6)
				{
					val53 += Main.rand.NextVector2Circular(150f, 150f);
				}
			}
			val52 = val53 / 2f;
			float ai5 = Main.rand.Next(-100, 101);
			Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition, val52, projToShoot, totalDamage, KnockBack, i, ai5, num162);
		}
		else if (sItem.type == 3836)
		{
			float ai6 = Main.rand.NextFloat() * speed * 0.75f * (float)direction;
			((Vector2)(ref val))..ctor(num2, num3);
			Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition, val, projToShoot, totalDamage, KnockBack, i, ai6);
		}
		else if (sItem.type == 3858)
		{
			bool num163 = altFunctionUse == 2;
			Vector2 val54 = default(Vector2);
			((Vector2)(ref val54))..ctor(num2, num3);
			if (num163)
			{
				val54 *= 1.5f;
				float ai7 = (0.3f + 0.7f * Main.rand.NextFloat()) * speed * 1.75f * (float)direction;
				Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition, val54, 708, (int)((float)totalDamage * 0.5f), KnockBack + 4f, i, ai7);
			}
			else
			{
				Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition, val54, projToShoot, totalDamage, KnockBack, i);
			}
		}
		else if (sItem.type == 3859)
		{
			Vector2 val55 = default(Vector2);
			((Vector2)(ref val55))..ctor(num2, num3);
			projToShoot = 710;
			val55 *= 0.8f;
			Vector2 val56 = val55.SafeNormalize(-Vector2.UnitY);
			float num164 = (float)Math.PI / 180f * (float)(-direction);
			for (float num165 = -2.5f; num165 < 3f; num165 += 1f)
			{
				Vector2 val57 = pointPoisition;
				Vector2 spinningpoint11 = val55 + val56 * num165 * 0.5f;
				double radians10 = num165 * num164;
				val = default(Vector2);
				Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, val57, spinningpoint11.RotatedBy(radians10, val), projToShoot, totalDamage, KnockBack, i);
			}
		}
		else if (sItem.type == 3870)
		{
			Vector2 val58 = Vector2.Normalize(new Vector2(num2, num3)) * 40f * sItem.scale;
			if (Collision.CanHit(pointPoisition, 0, 0, pointPoisition + val58, 0, 0))
			{
				pointPoisition += val58;
			}
			Vector2 val59 = default(Vector2);
			((Vector2)(ref val59))..ctor(num2, num3);
			val59 *= 0.8f;
			Vector2 val60 = val59.SafeNormalize(-Vector2.UnitY);
			float num166 = (float)Math.PI / 180f * (float)(-direction);
			for (int num167 = 0; num167 <= 2; num167++)
			{
				Vector2 val61 = pointPoisition;
				Vector2 spinningpoint12 = val59 + val60 * (float)num167 * 1f;
				double radians11 = (float)num167 * num166;
				val = default(Vector2);
				Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, val61, spinningpoint12.RotatedBy(radians11, val), projToShoot, totalDamage, KnockBack, i);
			}
		}
		else if (sItem.type == 3542)
		{
			float num168 = (Main.rand.NextFloat() - 0.5f) * ((float)Math.PI / 4f) * 0.7f;
			for (int num169 = 0; num169 < 10; num169++)
			{
				Vector2 position = pointPoisition;
				Vector2 val62 = pointPoisition;
				Vector2 spinningpoint13 = new Vector2(num2, num3);
				double radians12 = num168;
				val = default(Vector2);
				if (Collision.CanHit(position, 0, 0, val62 + Utils.RotatedBy(spinningpoint13, radians12, val) * 100f, 0, 0))
				{
					break;
				}
				num168 = (Main.rand.NextFloat() - 0.5f) * ((float)Math.PI / 4f) * 0.7f;
			}
			Vector2 spinningpoint14 = new Vector2(num2, num3);
			double radians13 = num168;
			val = default(Vector2);
			Vector2 val63 = Utils.RotatedBy(spinningpoint14, radians13, val) * (0.95f + Main.rand.NextFloat() * 0.3f);
			Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, val63.X, val63.Y, projToShoot, totalDamage, KnockBack, i);
		}
		else if (sItem.type == 3779)
		{
			float num170 = Main.rand.NextFloat() * ((float)Math.PI * 2f);
			for (int num171 = 0; num171 < 10; num171++)
			{
				Vector2 position2 = pointPoisition;
				Vector2 val64 = pointPoisition;
				Vector2 spinningpoint15 = new Vector2(num2, num3);
				double radians14 = num170;
				val = default(Vector2);
				if (Collision.CanHit(position2, 0, 0, val64 + Utils.RotatedBy(spinningpoint15, radians14, val) * 100f, 0, 0))
				{
					break;
				}
				num170 = Main.rand.NextFloat() * ((float)Math.PI * 2f);
			}
			Vector2 spinningpoint16 = new Vector2(num2, num3);
			double radians15 = num170;
			val = default(Vector2);
			Vector2 val65 = Utils.RotatedBy(spinningpoint16, radians15, val) * (0.95f + Main.rand.NextFloat() * 0.3f);
			Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition + val65 * 30f, Vector2.Zero, projToShoot, totalDamage, KnockBack, i, -2f);
		}
		else if (sItem.type == 3787)
		{
			float f = Main.rand.NextFloat() * ((float)Math.PI * 2f);
			float num172 = 20f;
			float num173 = 60f;
			Vector2 val66 = pointPoisition + f.ToRotationVector2() * MathHelper.Lerp(num172, num173, Main.rand.NextFloat());
			for (int num174 = 0; num174 < 50; num174++)
			{
				val66 = pointPoisition + f.ToRotationVector2() * MathHelper.Lerp(num172, num173, Main.rand.NextFloat());
				if (Collision.CanHit(pointPoisition, 0, 0, val66 + (val66 - pointPoisition).SafeNormalize(Vector2.UnitX) * 8f, 0, 0))
				{
					break;
				}
				f = Main.rand.NextFloat() * ((float)Math.PI * 2f);
			}
			Vector2 v4 = Main.MouseWorld - val66;
			Vector2 val67 = Utils.SafeNormalize(new Vector2(num2, num3), Vector2.UnitY) * speed;
			v4 = v4.SafeNormalize(val67) * speed;
			v4 = Vector2.Lerp(v4, val67, 0.25f);
			Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, val66, v4, projToShoot, totalDamage, KnockBack, i);
		}
		else if (sItem.type == 3788)
		{
			Vector2 val68 = default(Vector2);
			((Vector2)(ref val68))..ctor(num2, num3);
			float num175 = (float)Math.PI / 4f;
			for (int num176 = 0; num176 < 2; num176++)
			{
				Vector2 val69 = pointPoisition;
				Vector2 val70 = val68;
				Vector2 spinningpoint17 = val68.SafeNormalize(Vector2.Zero);
				double radians16 = num175 * (Main.rand.NextFloat() * 0.5f + 0.5f);
				val = default(Vector2);
				Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, val69, val70 + spinningpoint17.RotatedBy(radians16, val) * Main.rand.NextFloatDirection() * 2f, projToShoot, totalDamage, KnockBack, i);
				Vector2 val71 = pointPoisition;
				Vector2 val72 = val68;
				Vector2 spinningpoint18 = val68.SafeNormalize(Vector2.Zero);
				double radians17 = (0f - num175) * (Main.rand.NextFloat() * 0.5f + 0.5f);
				val = default(Vector2);
				Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, val71, val72 + spinningpoint18.RotatedBy(radians17, val) * Main.rand.NextFloatDirection() * 2f, projToShoot, totalDamage, KnockBack, i);
			}
			Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition, val68.SafeNormalize(Vector2.UnitX * (float)direction) * (speed * 1.3f), 661, totalDamage * 2, KnockBack, i);
		}
		else if (sItem.type == 4463 || sItem.type == 486)
		{
			Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition, new Vector2(num2, num3), projToShoot, totalDamage, KnockBack, i);
		}
		else if (sItem.type == 46)
		{
			Vector2 spinningpoint19 = Utils.SafeNormalize(new Vector2((float)direction, gravDir * 4f), Vector2.UnitY);
			double radians18 = (float)Math.PI * 2f * Main.rand.NextFloatDirection() * 0.05f;
			val = default(Vector2);
			Vector2 val73 = spinningpoint19.RotatedBy(radians18, val);
			Vector2 val74 = MountedCenter + new Vector2(70f, -40f) * Directions + val73 * -10f;
			if (GetZenithTarget(val74, 50f, out var npcTargetIndex2))
			{
				NPC nPC3 = Main.npc[npcTargetIndex2];
				val74 = nPC3.Center + Main.rand.NextVector2Circular(nPC3.width / 2, nPC3.height / 2);
			}
			else
			{
				val74 += Main.rand.NextVector2Circular(20f, 20f);
			}
			float ai8 = 1f;
			if ((float)Main.rand.Next(100) < meleeCrit)
			{
				ai8 = 2f;
				totalDamage *= 2;
			}
			Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, val74, val73 * 0.001f, projToShoot, (int)((double)totalDamage * 0.5), KnockBack, i, ai8);
			NetMessage.SendData(13, -1, -1, null, whoAmI);
		}
		else if (sItem.type == 273)
		{
			float adjustedItemScale = GetAdjustedItemScale(sItem);
			Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, MountedCenter, new Vector2((float)direction, 0f), projToShoot, totalDamage, KnockBack, i, (float)direction * gravDir, itemAnimationMax, adjustedItemScale);
			Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, MountedCenter, new Vector2(num2, num3), projToShoot, totalDamage, KnockBack, i, (float)direction * gravDir * 0.1f, 30f, adjustedItemScale);
			NetMessage.SendData(13, -1, -1, null, whoAmI);
		}
		else if (sItem.type == 368)
		{
			float adjustedItemScale2 = GetAdjustedItemScale(sItem);
			Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, MountedCenter, new Vector2((float)direction, 0f), projToShoot, totalDamage, KnockBack, i, (float)direction * gravDir, itemAnimationMax, adjustedItemScale2);
			NetMessage.SendData(13, -1, -1, null, whoAmI);
		}
		else if (sItem.type == 1826)
		{
			float adjustedItemScale3 = GetAdjustedItemScale(sItem);
			Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, MountedCenter, new Vector2((float)direction, 0f), projToShoot, totalDamage, KnockBack, i, (float)direction * gravDir, itemAnimationMax, adjustedItemScale3);
			NetMessage.SendData(13, -1, -1, null, whoAmI);
		}
		else if (sItem.type == 675)
		{
			float adjustedItemScale4 = GetAdjustedItemScale(sItem);
			Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, MountedCenter, new Vector2((float)direction, 0f), 972, totalDamage, KnockBack, i, (float)direction * gravDir, itemAnimationMax, adjustedItemScale4);
			Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, MountedCenter, new Vector2(num2, num3), projToShoot, totalDamage / 2, KnockBack, i, (float)direction * gravDir, 32f, adjustedItemScale4);
			NetMessage.SendData(13, -1, -1, null, whoAmI);
		}
		else if (sItem.type == 674)
		{
			float adjustedItemScale5 = GetAdjustedItemScale(sItem);
			Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, MountedCenter, new Vector2((float)direction, 0f), projToShoot, totalDamage, KnockBack, i, (float)direction * gravDir, itemAnimationMax, adjustedItemScale5);
			Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, MountedCenter, new Vector2((float)direction, 0f), 982, 0, KnockBack, i, (float)direction * gravDir, itemAnimationMax, adjustedItemScale5);
			NetMessage.SendData(13, -1, -1, null, whoAmI);
		}
		else if (sItem.type == 757)
		{
			float adjustedItemScale6 = GetAdjustedItemScale(sItem);
			Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, MountedCenter, new Vector2((float)direction, 0f), 984, totalDamage, KnockBack, i, (float)direction * gravDir, itemAnimationMax, adjustedItemScale6);
			Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, MountedCenter, new Vector2(num2, num3) * 5f, projToShoot, totalDamage, KnockBack, i, (float)direction * gravDir, 18f, adjustedItemScale6);
			NetMessage.SendData(13, -1, -1, null, whoAmI);
		}
		else if (sItem.type == 190)
		{
			Vector2 val75 = MountedCenter + new Vector2(70f, -40f) * Directions;
			int npcTargetIndex3;
			bool zenithTarget2 = GetZenithTarget(val75, 150f, out npcTargetIndex3);
			if (zenithTarget2)
			{
				NPC nPC4 = Main.npc[npcTargetIndex3];
				val75 = Main.rand.NextVector2FromRectangle(nPC4.Hitbox);
			}
			else
			{
				val75 += Main.rand.NextVector2Circular(20f, 20f);
			}
			Vector2 val76 = base.Center + new Vector2(Main.rand.NextFloatDirection() * (float)width / 2f, (float)(height / 2)) * Directions;
			Vector2 v5 = val75 - val76;
			float num177 = ((float)Math.PI + (float)Math.PI * 2f * Main.rand.NextFloat() * 1.5f) * ((float)(-direction) * gravDir);
			int num178 = 60;
			float num179 = num177 / (float)num178;
			float num180 = 16f;
			float num181 = ((Vector2)(ref v5)).Length();
			if (Math.Abs(num179) >= 0.17f)
			{
				num179 *= 0.7f;
			}
			_ = direction;
			_ = gravDir;
			Vector2 val77 = Vector2.UnitX * num180;
			Vector2 val78 = val77;
			int num182 = 0;
			while (((Vector2)(ref val78)).Length() < num181 && num182 < num178)
			{
				num182++;
				val78 += val77;
				Vector2 spinningpoint20 = val77;
				double radians19 = num179;
				val = default(Vector2);
				val77 = spinningpoint20.RotatedBy(radians19, val);
			}
			float num183 = val78.ToRotation();
			Vector2 spinningpoint21 = v5.SafeNormalize(Vector2.UnitY);
			double radians20 = 0f - num183 - num179;
			val = default(Vector2);
			Vector2 val79 = spinningpoint21.RotatedBy(radians20, val) * num180;
			if (num182 == num178)
			{
				val79 = new Vector2((float)direction, 0f) * num180;
			}
			if (!zenithTarget2)
			{
				val76.Y -= gravDir * 24f;
				Vector2 spinningpoint22 = val79;
				double radians21 = (float)direction * gravDir * ((float)Math.PI * 2f) * 0.14f;
				val = default(Vector2);
				val79 = spinningpoint22.RotatedBy(radians21, val);
			}
			Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, val76, val79, projToShoot, (int)((double)totalDamage * 0.25), KnockBack, i, num179, num182);
			NetMessage.SendData(13, -1, -1, null, whoAmI);
		}
		else if (sItem.type == 3475)
		{
			Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, num2, num3, 615, totalDamage, KnockBack, i, 5 * Main.rand.Next(0, 20));
		}
		else if (sItem.type == 3930)
		{
			Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, num2, num3, 714, totalDamage, KnockBack, i, 5 * Main.rand.Next(0, 20));
		}
		else if (sItem.type == 3540)
		{
			Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, num2, num3, 630, totalDamage, KnockBack, i);
		}
		else if (sItem.type == 5451)
		{
			for (int num184 = 0; num184 < 1000; num184++)
			{
				Projectile projectile3 = Main.projectile[num184];
				if (projectile3.type == projToShoot && projectile3.owner == whoAmI)
				{
					projectile3.Kill();
				}
			}
			Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, num2, num3, projToShoot, totalDamage, KnockBack, i);
		}
		else if (sItem.type == 3854)
		{
			Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, num2, num3, 705, totalDamage, KnockBack, i);
		}
		else if (sItem.type == 3546)
		{
			for (int num185 = 0; num185 < 2; num185++)
			{
				float num186 = num2;
				float num187 = num3;
				num186 += (float)Main.rand.Next(-40, 41) * 0.05f;
				num187 += (float)Main.rand.Next(-40, 41) * 0.05f;
				Vector2 val80 = pointPoisition;
				Vector2 spinningpoint23 = new Vector2(num186, num187);
				double radians22 = -(float)Math.PI / 2f * (float)direction;
				val = default(Vector2);
				Vector2 val81 = val80 + Vector2.Normalize(Utils.RotatedBy(spinningpoint23, radians22, val)) * 6f;
				Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, val81.X, val81.Y, num186, num187, 167 + Main.rand.Next(4), totalDamage, KnockBack, i, 0f, 1f);
			}
		}
		else if (sItem.type == 3350)
		{
			float num188 = num2;
			float num189 = num3;
			num188 += (float)Main.rand.Next(-1, 2) * 0.5f;
			num189 += (float)Main.rand.Next(-1, 2) * 0.5f;
			if (Collision.CanHitLine(base.Center, 0, 0, pointPoisition + new Vector2(num188, num189) * 2f, 0, 0))
			{
				pointPoisition += new Vector2(num188, num189);
			}
			Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y - gravDir * 4f, num188, num189, projToShoot, totalDamage, KnockBack, i, 0f, (float)Main.rand.Next(12) / 6f);
		}
		else if (sItem.type == 3852)
		{
			if (altFunctionUse == 2)
			{
				Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, base.Bottom.Y - 100f, (float)direction * speed, 0f, 704, (int)((float)totalDamage * 1.75f), KnockBack, i);
			}
			else
			{
				Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, num2, num3, projToShoot, totalDamage, KnockBack, i);
			}
		}
		else if (sItem.type == 3818 || sItem.type == 3819 || sItem.type == 3820 || sItem.type == 3824 || sItem.type == 3825 || sItem.type == 3826 || sItem.type == 3829 || sItem.type == 3830 || sItem.type == 3831 || sItem.type == 3832 || sItem.type == 3833 || sItem.type == 3834)
		{
			PayDD2CrystalsBeforeUse(sItem);
			FindSentryRestingSpot(sItem.shoot, out var worldX, out var worldY, out var pushYUp);
			int num190 = 0;
			int num191 = 0;
			int num192 = 0;
			switch (sItem.type)
			{
			case 3824:
			case 3825:
			case 3826:
				num190 = 1;
				num191 = Projectile.GetBallistraShotDelay(this);
				break;
			case 3832:
			case 3833:
			case 3834:
				num192 = Projectile.GetExplosiveTrapCooldown(this);
				break;
			case 3818:
				num190 = 1;
				num191 = 80;
				break;
			case 3819:
				num190 = 1;
				num191 = 70;
				break;
			case 3820:
				num190 = 1;
				num191 = 60;
				break;
			}
			int num193 = Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, worldX, worldY - pushYUp, 0f, 0f, projToShoot, totalDamage, KnockBack, i, num190, num191);
			Main.projectile[num193].originalDamage = damage;
			Main.projectile[num193].localAI[0] = num192;
			UpdateMaxTurrets();
		}
		else if (sItem.type == 65)
		{
			Vector2 val82 = default(Vector2);
			((Vector2)(ref val82))..ctor(num2, num3);
			new Vector2(100f, 0f);
			Vector2 mouseWorld2 = Main.MouseWorld;
			Vector2 val83 = mouseWorld2;
			Vector2 val84 = (pointPoisition - mouseWorld2).SafeNormalize(new Vector2(0f, -1f));
			while (val83.Y > pointPoisition.Y && WorldGen.SolidTile(val83.ToTileCoordinates()))
			{
				val83 += val84 * 16f;
			}
			Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition, val82, projToShoot, totalDamage, KnockBack, i, 0f, val83.Y);
		}
		else if (sItem.type == 4923)
		{
			float adjustedItemScale7 = GetAdjustedItemScale(sItem);
			Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, num2, num3, projToShoot, totalDamage, KnockBack, i, 0f, adjustedItemScale7);
		}
		else if (sItem.type == 1910)
		{
			Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, num2, num3, projToShoot, totalDamage, KnockBack, i, 1f);
		}
		else if (sItem.type == 5134)
		{
			Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, num2, num3, projToShoot, totalDamage, KnockBack, i, 0f, 1f);
		}
		else
		{
			int num194 = Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, num2, num3, projToShoot, totalDamage, KnockBack, i);
			if (sItem.type == 726)
			{
				Main.projectile[num194].magic = true;
			}
			if (sItem.type == 724 || sItem.type == 676)
			{
				Main.projectile[num194].melee = true;
			}
			if (projToShoot == 80)
			{
				Main.projectile[num194].ai[0] = tileTargetX;
				Main.projectile[num194].ai[1] = tileTargetY;
			}
			if (sItem.type == 760)
			{
				DestroyOldestProximityMinesOverMinesCap(20);
			}
			if (projToShoot == 442)
			{
				Main.projectile[num194].ai[0] = tileTargetX;
				Main.projectile[num194].ai[1] = tileTargetY;
			}
			if (projToShoot == 826)
			{
				Main.projectile[num194].ai[1] = Main.rand.Next(3);
			}
			if (sItem.type == 949)
			{
				Main.projectile[num194].ai[1] = 1f;
			}
			if (Main.projectile[num194].aiStyle == 99)
			{
				AchievementsHelper.HandleSpecialEvent(this, 7);
			}
			if (Main.projectile[num194].aiStyle == 160 && Main.IsItAHappyWindyDay)
			{
				AchievementsHelper.HandleSpecialEvent(this, 17);
			}
			NetMessage.SendData(13, -1, -1, null, whoAmI);
		}
	}

	public Vector2 GetFarthestSpawnPositionOnLine(Vector2 startPos, float speedX, float speedY)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		Vector2 pointPoisition = Main.ReverseGravitySupport(Main.MouseScreen) + Main.screenPosition;
		LimitPointToPlayerReachableArea(ref pointPoisition);
		int num = 0;
		Vector2 val = new Vector2(speedX, speedY);
		float num2 = ((Vector2)(ref val)).Length();
		val = pointPoisition - startPos;
		float num3 = ((Vector2)(ref val)).Length();
		Vector2 center = base.Center;
		center.X += direction * 16;
		while (Collision.CanHitLine(center, 0, 0, startPos, 0, 0))
		{
			num++;
			startPos.X += speedX;
			startPos.Y += speedY;
			val = startPos - pointPoisition;
			if (((Vector2)(ref val)).Length() < 20f + Math.Abs(speedX) + Math.Abs(speedY))
			{
				startPos = pointPoisition;
				break;
			}
			if (num2 * (float)num >= num3)
			{
				startPos = pointPoisition;
				break;
			}
		}
		return startPos;
	}

	public int SpawnMinionOnCursor(IEntitySource projectileSource, int ownerIndex, int minionProjectileId, int originalDamageNotScaledByMinionDamage, float KnockBack, Vector2 offsetFromCursor = default(Vector2), Vector2 velocityOnSpawn = default(Vector2))
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		Vector2 mouseWorld = Main.MouseWorld;
		mouseWorld += offsetFromCursor;
		LimitPointToPlayerReachableArea(ref mouseWorld);
		float ai = 0f;
		if (projectileSource is EntitySource_ItemUse entitySource_ItemUse)
		{
			switch (entitySource_ItemUse.Item.type)
			{
			case 1157:
				ai = 60f;
				break;
			case 2364:
			case 2365:
			case 2535:
			case 2621:
			case 2749:
			case 3474:
				ai = 1f;
				break;
			}
		}
		int num = Projectile.NewProjectile(projectileSource, mouseWorld, velocityOnSpawn, minionProjectileId, originalDamageNotScaledByMinionDamage, KnockBack, ownerIndex, 0f, ai);
		Main.projectile[num].originalDamage = originalDamageNotScaledByMinionDamage;
		return num;
	}

	private Point FindSharpTearsSpot(Vector2 targetSpot)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0203: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_0131: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0162: Unknown result type (might be due to invalid IL or missing references)
		//IL_0150: Unknown result type (might be due to invalid IL or missing references)
		Point val = targetSpot.ToTileCoordinates();
		Vector2 center = base.Center;
		Vector2 endPoint = targetSpot;
		int samplesToTake = 3;
		float samplingWidth = 4f;
		Collision.AimingLaserScan(center, endPoint, samplingWidth, samplesToTake, out var vectorTowardsTarget, out var samples);
		float num = float.PositiveInfinity;
		for (int i = 0; i < samples.Length; i++)
		{
			if (samples[i] < num)
			{
				num = samples[i];
			}
		}
		targetSpot = center + vectorTowardsTarget.SafeNormalize(Vector2.Zero) * num;
		val = targetSpot.ToTileCoordinates();
		Rectangle val2 = default(Rectangle);
		((Rectangle)(ref val2))..ctor(val.X, val.Y, 1, 1);
		((Rectangle)(ref val2)).Inflate(6, 16);
		Rectangle val3 = default(Rectangle);
		((Rectangle)(ref val3))..ctor(0, 0, Main.maxTilesX, Main.maxTilesY);
		((Rectangle)(ref val3)).Inflate(-40, -40);
		val2 = Rectangle.Intersect(val2, val3);
		List<Point> list = new List<Point>();
		List<Point> list2 = new List<Point>();
		Vector2 val4 = default(Vector2);
		for (int j = ((Rectangle)(ref val2)).Left; j <= ((Rectangle)(ref val2)).Right; j++)
		{
			for (int k = ((Rectangle)(ref val2)).Top; k <= ((Rectangle)(ref val2)).Bottom; k++)
			{
				if (!WorldGen.SolidTile2(j, k))
				{
					continue;
				}
				((Vector2)(ref val4))..ctor((float)(j * 16 + 8), (float)(k * 16 + 8));
				if (!(Vector2.Distance(targetSpot, val4) > 200f))
				{
					if (FindSharpTearsOpening(j, k, j > val.X, j < val.X, k > val.Y, k < val.Y))
					{
						list.Add(new Point(j, k));
					}
					else
					{
						list2.Add(new Point(j, k));
					}
				}
			}
		}
		if (list.Count == 0 && list2.Count == 0)
		{
			list.Add((base.Center.ToTileCoordinates().ToVector2() + Main.rand.NextVector2Square(-2f, 2f)).ToPoint());
		}
		List<Point> list3 = list;
		if (list3.Count == 0)
		{
			list3 = list2;
		}
		int index = Main.rand.Next(list3.Count);
		return list3[index];
	}

	private bool FindSharpTearsOpening(int x, int y, bool acceptLeft, bool acceptRight, bool acceptUp, bool acceptDown)
	{
		if (acceptLeft && !WorldGen.SolidTile(x - 1, y))
		{
			return true;
		}
		if (acceptRight && !WorldGen.SolidTile(x + 1, y))
		{
			return true;
		}
		if (acceptUp && !WorldGen.SolidTile(x, y - 1))
		{
			return true;
		}
		if (acceptDown && !WorldGen.SolidTile(x, y + 1))
		{
			return true;
		}
		return false;
	}

	public bool TryPlacingAGolfBallNearANearbyTee(Vector2 placePosition)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01de: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e3: Unknown result type (might be due to invalid IL or missing references)
		int num = 0;
		int value = (int)(placePosition.X / 16f) - tileRangeX - num + 1;
		int value2 = (int)(placePosition.X / 16f) + tileRangeX + num - 1;
		int value3 = (int)(placePosition.Y / 16f) - tileRangeY - num + 1;
		int value4 = (int)(placePosition.Y / 16f) + tileRangeY + num - 2;
		value = Utils.Clamp(value, 10, Main.maxTilesX - 10);
		value2 = Utils.Clamp(value2, 10, Main.maxTilesX - 10);
		value3 = Utils.Clamp(value3, 10, Main.maxTilesY - 10);
		value4 = Utils.Clamp(value4, 10, Main.maxTilesY - 10);
		Vector2 val = Main.screenPosition + new Vector2((float)Main.mouseX, (float)Main.mouseY);
		if (gravDir == -1f)
		{
			val.Y = Main.screenPosition.Y + (float)Main.screenHeight - (float)Main.mouseY;
		}
		Point val2 = placePosition.ToTileCoordinates();
		List<Tuple<int, int>> list = new List<Tuple<int, int>>();
		for (int i = -2; i <= 2; i++)
		{
			for (int j = -2; j <= 2; j++)
			{
				int num2 = val2.X + i;
				int num3 = val2.Y + j;
				if (WorldGen.InWorld(num2, num3, 1))
				{
					Tile tileSafely = Framing.GetTileSafely(num2, num3);
					if (tileSafely.active() && tileSafely.type == 494)
					{
						list.Add(new Tuple<int, int>(num2, num3));
						break;
					}
				}
			}
		}
		bool result = false;
		if (list.Count > 0)
		{
			float num4 = -1f;
			Tuple<int, int> tuple = list[0];
			for (int k = 0; k < list.Count; k++)
			{
				float num5 = Vector2.Distance(new Vector2((float)list[k].Item1, (float)list[k].Item2) * 16f + Vector2.One * 8f, val);
				if (num4 == -1f || num5 < num4)
				{
					num4 = num5;
					tuple = list[k];
				}
			}
			if (Collision.InTileBounds(tuple.Item1, tuple.Item2, value, value3, value2, value4))
			{
				result = true;
				for (int l = 0; l < 1000; l++)
				{
					if (ProjectileID.Sets.IsAGolfBall[Main.projectile[l].type] && Main.projectile[l].owner == whoAmI)
					{
						Main.projectile[l].Kill();
					}
				}
				GetPreferredGolfBallToUse(out var projType);
				Projectile.NewProjectile(GetProjectileSource_TileInteraction(tuple.Item1, tuple.Item2), (float)(tuple.Item1 * 16) + 8.5f, tuple.Item2 * 16 + 6, 0f, 0f, projType, 0, 0f, whoAmI, 0f, -1f);
			}
		}
		return result;
	}

	public void GetPreferredGolfBallToUse(out int projType)
	{
		projType = 721;
		Item item = inventory[selectedItem];
		if (!item.IsAir && item.shoot > 0 && ProjectileID.Sets.IsAGolfBall[item.shoot])
		{
			projType = item.shoot;
		}
		else
		{
			if (LoaderManager.Get<AccessorySlotLoader>().PreferredGolfBall(ref projType))
			{
				return;
			}
			for (int num = 19; num >= 0; num--)
			{
				if (IsItemSlotUnlockedAndUsable(num))
				{
					_ = num % 10;
					Item item2 = armor[num];
					if (!item2.IsAir && item2.shoot > 0 && ProjectileID.Sets.IsAGolfBall[item2.shoot])
					{
						projType = item2.shoot;
						return;
					}
				}
			}
			for (int i = 0; i < 50; i++)
			{
				Item item3 = inventory[i];
				if (!item3.IsAir && item3.shoot > 0 && ProjectileID.Sets.IsAGolfBall[item3.shoot])
				{
					projType = item3.shoot;
					break;
				}
			}
		}
	}

	private void ItemCheck_MinionAltFeatureUse(Item sItem, bool cShoot)
	{
		if (sItem.shoot > 0 && ProjectileID.Sets.MinionTargettingFeature[sItem.shoot] && altFunctionUse == 2 && cShoot && ItemTimeIsZero)
		{
			ApplyItemTime(sItem);
			if (whoAmI == Main.myPlayer)
			{
				MinionNPCTargetAim(doNotDisableIfTheTargetIsTheSame: false);
			}
		}
	}

	private void ItemCheck_TurretAltFeatureUse(Item sItem, bool cShoot)
	{
		if (sItem.shoot <= 0 || !ProjectileID.Sets.TurretFeature[sItem.shoot] || altFunctionUse != 2 || !cShoot || !ItemTimeIsZero)
		{
			return;
		}
		ApplyItemTime(sItem);
		if (whoAmI != Main.myPlayer)
		{
			return;
		}
		for (int i = 0; i < 1000; i++)
		{
			Projectile projectile = Main.projectile[i];
			if (projectile.active && projectile.owner == Main.myPlayer && ProjectileID.Sets.TurretFeature[projectile.type])
			{
				projectile.Kill();
			}
		}
	}

	private void EmitMaxManaEffect()
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		SoundEngine.PlaySound(25);
		for (int i = 0; i < 5; i++)
		{
			int num = Dust.NewDust(position, width, height, 45, 0f, 0f, 255, default(Color), (float)Main.rand.Next(20, 26) * 0.1f);
			Main.dust[num].noLight = true;
			Main.dust[num].noGravity = true;
			Dust obj = Main.dust[num];
			obj.velocity *= 0.5f;
		}
	}

	private void ItemCheck_EmitHeldItemLight(Item sItem)
	{
		//IL_0738: Unknown result type (might be due to invalid IL or missing references)
		//IL_073f: Unknown result type (might be due to invalid IL or missing references)
		//IL_066a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0680: Unknown result type (might be due to invalid IL or missing references)
		//IL_0686: Unknown result type (might be due to invalid IL or missing references)
		//IL_060b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0612: Unknown result type (might be due to invalid IL or missing references)
		//IL_053d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0553: Unknown result type (might be due to invalid IL or missing references)
		//IL_0559: Unknown result type (might be due to invalid IL or missing references)
		//IL_06b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_06c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_06c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_06f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_06ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0704: Unknown result type (might be due to invalid IL or missing references)
		//IL_058b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0595: Unknown result type (might be due to invalid IL or missing references)
		//IL_059a: Unknown result type (might be due to invalid IL or missing references)
		//IL_05cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_05d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_05d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0e33: Unknown result type (might be due to invalid IL or missing references)
		//IL_0e3a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0de2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0de9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0d78: Unknown result type (might be due to invalid IL or missing references)
		//IL_0d7f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0d30: Unknown result type (might be due to invalid IL or missing references)
		//IL_0d37: Unknown result type (might be due to invalid IL or missing references)
		//IL_09dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_09e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_090a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0924: Unknown result type (might be due to invalid IL or missing references)
		//IL_092a: Unknown result type (might be due to invalid IL or missing references)
		//IL_08ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_08b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_07d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_07f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_07f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_04a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_04a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0390: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_033a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0341: Unknown result type (might be due to invalid IL or missing references)
		//IL_022a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0241: Unknown result type (might be due to invalid IL or missing references)
		//IL_0247: Unknown result type (might be due to invalid IL or missing references)
		//IL_0f03: Unknown result type (might be due to invalid IL or missing references)
		//IL_0f0a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0ebb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0ec2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c98: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c9f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0bc6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0be0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0be6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b67: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b6e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a95: Unknown result type (might be due to invalid IL or missing references)
		//IL_0aaf: Unknown result type (might be due to invalid IL or missing references)
		//IL_0ab5: Unknown result type (might be due to invalid IL or missing references)
		//IL_095c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0966: Unknown result type (might be due to invalid IL or missing references)
		//IL_096b: Unknown result type (might be due to invalid IL or missing references)
		//IL_099c: Unknown result type (might be due to invalid IL or missing references)
		//IL_09a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_09a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_082b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0835: Unknown result type (might be due to invalid IL or missing references)
		//IL_083a: Unknown result type (might be due to invalid IL or missing references)
		//IL_086b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0872: Unknown result type (might be due to invalid IL or missing references)
		//IL_0877: Unknown result type (might be due to invalid IL or missing references)
		//IL_03df: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_041f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0426: Unknown result type (might be due to invalid IL or missing references)
		//IL_042b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0279: Unknown result type (might be due to invalid IL or missing references)
		//IL_0283: Unknown result type (might be due to invalid IL or missing references)
		//IL_0288: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0ff3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0ffa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0fa2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0fa9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c18: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c22: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c27: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c58: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c5f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c64: Unknown result type (might be due to invalid IL or missing references)
		//IL_0ae7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0af1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0af6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b27: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b2e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b33: Unknown result type (might be due to invalid IL or missing references)
		//IL_044d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0452: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_1121: Unknown result type (might be due to invalid IL or missing references)
		//IL_1128: Unknown result type (might be due to invalid IL or missing references)
		//IL_112d: Unknown result type (might be due to invalid IL or missing references)
		//IL_10b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_10be: Unknown result type (might be due to invalid IL or missing references)
		//IL_1066: Unknown result type (might be due to invalid IL or missing references)
		//IL_106d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0f45: Unknown result type (might be due to invalid IL or missing references)
		//IL_1206: Unknown result type (might be due to invalid IL or missing references)
		//IL_120c: Unknown result type (might be due to invalid IL or missing references)
		//IL_1211: Unknown result type (might be due to invalid IL or missing references)
		//IL_1216: Unknown result type (might be due to invalid IL or missing references)
		//IL_1184: Unknown result type (might be due to invalid IL or missing references)
		//IL_1189: Unknown result type (might be due to invalid IL or missing references)
		//IL_118a: Unknown result type (might be due to invalid IL or missing references)
		//IL_118f: Unknown result type (might be due to invalid IL or missing references)
		//IL_1191: Unknown result type (might be due to invalid IL or missing references)
		//IL_1193: Unknown result type (might be due to invalid IL or missing references)
		//IL_1198: Unknown result type (might be due to invalid IL or missing references)
		//IL_119a: Unknown result type (might be due to invalid IL or missing references)
		//IL_119c: Unknown result type (might be due to invalid IL or missing references)
		//IL_11a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_11b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_11b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_1167: Unknown result type (might be due to invalid IL or missing references)
		//IL_116e: Unknown result type (might be due to invalid IL or missing references)
		//IL_1173: Unknown result type (might be due to invalid IL or missing references)
		//IL_11df: Unknown result type (might be due to invalid IL or missing references)
		//IL_11e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_1335: Unknown result type (might be due to invalid IL or missing references)
		//IL_134f: Unknown result type (might be due to invalid IL or missing references)
		//IL_1354: Unknown result type (might be due to invalid IL or missing references)
		//IL_1359: Unknown result type (might be due to invalid IL or missing references)
		//IL_1369: Unknown result type (might be due to invalid IL or missing references)
		//IL_1373: Unknown result type (might be due to invalid IL or missing references)
		//IL_1378: Unknown result type (might be due to invalid IL or missing references)
		//IL_137a: Unknown result type (might be due to invalid IL or missing references)
		//IL_137d: Unknown result type (might be due to invalid IL or missing references)
		//IL_1382: Unknown result type (might be due to invalid IL or missing references)
		//IL_1383: Unknown result type (might be due to invalid IL or missing references)
		//IL_1384: Unknown result type (might be due to invalid IL or missing references)
		//IL_1226: Unknown result type (might be due to invalid IL or missing references)
		//IL_1247: Unknown result type (might be due to invalid IL or missing references)
		//IL_124d: Unknown result type (might be due to invalid IL or missing references)
		//IL_125e: Unknown result type (might be due to invalid IL or missing references)
		//IL_1260: Unknown result type (might be due to invalid IL or missing references)
		//IL_1268: Unknown result type (might be due to invalid IL or missing references)
		//IL_1272: Unknown result type (might be due to invalid IL or missing references)
		//IL_1277: Unknown result type (might be due to invalid IL or missing references)
		//IL_1293: Unknown result type (might be due to invalid IL or missing references)
		//IL_1299: Unknown result type (might be due to invalid IL or missing references)
		//IL_129e: Unknown result type (might be due to invalid IL or missing references)
		//IL_12a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_13aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_13af: Unknown result type (might be due to invalid IL or missing references)
		//IL_13b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_13b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_13b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_13bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_13da: Unknown result type (might be due to invalid IL or missing references)
		//IL_13eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_13ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_12b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_12cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_12d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_12d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_13fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_13fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_1403: Unknown result type (might be due to invalid IL or missing references)
		//IL_140d: Unknown result type (might be due to invalid IL or missing references)
		//IL_1412: Unknown result type (might be due to invalid IL or missing references)
		Vector2? handPosition = HandPosition;
		if (((ItemID.Sets.Torches[sItem.type] && !wet) || ItemID.Sets.WaterTorches[BiomeTorchHoldStyle(sItem.type)]) && !pulley && !happyFunTorchTime)
		{
			float R = 1f;
			float G = 0.95f;
			float B = 0.8f;
			int num = 0;
			int num2 = BiomeTorchHoldStyle(sItem.type);
			if (num2 >= ItemID.Count)
			{
				ItemLoader.GetItem(num2).HoldItem(this);
			}
			else
			{
				if (num2 == 523)
				{
					num = 8;
				}
				else if (num2 == 974)
				{
					num = 9;
				}
				else if (num2 == 1245)
				{
					num = 10;
				}
				else if (num2 == 1333)
				{
					num = 11;
				}
				else if (num2 == 2274)
				{
					num = 12;
				}
				else if (num2 == 3004)
				{
					num = 13;
				}
				else if (num2 == 3045)
				{
					num = 14;
				}
				else if (num2 == 3114)
				{
					num = 15;
				}
				else if (num2 == 4383)
				{
					num = 16;
				}
				else if (num2 == 4384)
				{
					num = 17;
				}
				else if (num2 == 4385)
				{
					num = 18;
				}
				else if (num2 == 4386)
				{
					num = 19;
				}
				else if (num2 == 4387)
				{
					num = 20;
				}
				else if (num2 == 4388)
				{
					num = 21;
				}
				else if (num2 == 5293)
				{
					num = 22;
				}
				else if (num2 == 5353)
				{
					num = 23;
				}
				else if (num2 >= 427)
				{
					num = num2 - 426;
				}
				num = (int)MathHelper.Clamp((float)num, 0f, (float)(TorchID.Count - 1));
				TorchID.TorchColor(num, out R, out G, out B);
				int num3 = TorchID.Dust[num];
				int maxValue = 30;
				if (itemAnimation > 0)
				{
					maxValue = 7;
				}
				if (direction == -1)
				{
					if (Main.rand.Next(maxValue) == 0)
					{
						int num4 = Dust.NewDust(new Vector2(itemLocation.X - 16f, itemLocation.Y - 14f * gravDir), 4, 4, num3, 0f, 0f, 100);
						if (Main.rand.Next(3) != 0)
						{
							Main.dust[num4].noGravity = true;
						}
						Dust obj = Main.dust[num4];
						obj.velocity *= 0.3f;
						Main.dust[num4].velocity.Y -= 1.5f;
						Main.dust[num4].position = RotatedRelativePoint(Main.dust[num4].position);
						if (num3 == 66)
						{
							Main.dust[num4].color = new Color(Main.DiscoR, Main.DiscoG, Main.DiscoB);
							Main.dust[num4].noGravity = true;
						}
					}
					Lighting.AddLight(RotatedRelativePoint(new Vector2(itemLocation.X - 12f + velocity.X, itemLocation.Y - 14f + velocity.Y)), R, G, B);
				}
				else
				{
					if (Main.rand.Next(maxValue) == 0)
					{
						int num5 = Dust.NewDust(new Vector2(itemLocation.X + 6f, itemLocation.Y - 14f * gravDir), 4, 4, num3, 0f, 0f, 100);
						if (Main.rand.Next(3) != 0)
						{
							Main.dust[num5].noGravity = true;
						}
						Dust obj2 = Main.dust[num5];
						obj2.velocity *= 0.3f;
						Main.dust[num5].velocity.Y -= 1.5f;
						Main.dust[num5].position = RotatedRelativePoint(Main.dust[num5].position);
						if (num3 == 66)
						{
							Main.dust[num5].color = new Color(Main.DiscoR, Main.DiscoG, Main.DiscoB);
							Main.dust[num5].noGravity = true;
						}
					}
					Lighting.AddLight(RotatedRelativePoint(new Vector2(itemLocation.X + 12f + velocity.X, itemLocation.Y - 14f + velocity.Y)), R, G, B);
				}
			}
		}
		if ((sItem.type == 105 || sItem.type == 713) && !wet && !pulley)
		{
			int maxValue2 = 20;
			if (itemAnimation > 0)
			{
				maxValue2 = 7;
			}
			if (direction == -1)
			{
				if (Main.rand.Next(maxValue2) == 0)
				{
					int num6 = Dust.NewDust(new Vector2(itemLocation.X - 12f, itemLocation.Y - 20f * gravDir), 4, 4, 6, 0f, 0f, 100);
					if (Main.rand.Next(3) != 0)
					{
						Main.dust[num6].noGravity = true;
					}
					Dust obj3 = Main.dust[num6];
					obj3.velocity *= 0.3f;
					Main.dust[num6].velocity.Y -= 1.5f;
					Main.dust[num6].position = RotatedRelativePoint(Main.dust[num6].position);
				}
				Lighting.AddLight(RotatedRelativePoint(new Vector2(itemLocation.X - 16f + velocity.X, itemLocation.Y - 14f)), 1f, 0.95f, 0.8f);
			}
			else
			{
				if (Main.rand.Next(maxValue2) == 0)
				{
					int num7 = Dust.NewDust(new Vector2(itemLocation.X + 4f, itemLocation.Y - 20f * gravDir), 4, 4, 6, 0f, 0f, 100);
					if (Main.rand.Next(3) != 0)
					{
						Main.dust[num7].noGravity = true;
					}
					Dust obj4 = Main.dust[num7];
					obj4.velocity *= 0.3f;
					Main.dust[num7].velocity.Y -= 1.5f;
					Main.dust[num7].position = RotatedRelativePoint(Main.dust[num7].position);
				}
				Lighting.AddLight(RotatedRelativePoint(new Vector2(itemLocation.X + 6f + velocity.X, itemLocation.Y - 14f)), 1f, 0.95f, 0.8f);
			}
		}
		else if (sItem.type == 148 && !wet && !pulley)
		{
			int maxValue3 = 10;
			if (itemAnimation > 0)
			{
				maxValue3 = 7;
			}
			if (direction == -1)
			{
				if (Main.rand.Next(maxValue3) == 0)
				{
					int num8 = Dust.NewDust(new Vector2(itemLocation.X - 12f, itemLocation.Y - 20f * gravDir), 4, 4, 172, 0f, 0f, 100);
					if (Main.rand.Next(3) != 0)
					{
						Main.dust[num8].noGravity = true;
					}
					Dust obj5 = Main.dust[num8];
					obj5.velocity *= 0.3f;
					Main.dust[num8].velocity.Y -= 1.5f;
					Main.dust[num8].position = RotatedRelativePoint(Main.dust[num8].position);
				}
				Lighting.AddLight(RotatedRelativePoint(new Vector2(itemLocation.X - 16f + velocity.X, itemLocation.Y - 14f)), 0f, 0.5f, 1f);
			}
			else
			{
				if (Main.rand.Next(maxValue3) == 0)
				{
					int num9 = Dust.NewDust(new Vector2(itemLocation.X + 4f, itemLocation.Y - 20f * gravDir), 4, 4, 172, 0f, 0f, 100);
					if (Main.rand.Next(3) != 0)
					{
						Main.dust[num9].noGravity = true;
					}
					Dust obj6 = Main.dust[num9];
					obj6.velocity *= 0.3f;
					Main.dust[num9].velocity.Y -= 1.5f;
					Main.dust[num9].position = RotatedRelativePoint(Main.dust[num9].position);
				}
				Lighting.AddLight(RotatedRelativePoint(new Vector2(itemLocation.X + 6f + velocity.X, itemLocation.Y - 14f)), 0f, 0.5f, 1f);
			}
		}
		else if (sItem.type == 3117 && !wet && !pulley)
		{
			itemLocation.X -= direction * 4;
			int maxValue4 = 10;
			if (itemAnimation > 0)
			{
				maxValue4 = 7;
			}
			if (direction == -1)
			{
				if (Main.rand.Next(maxValue4) == 0)
				{
					int num10 = Dust.NewDust(new Vector2(itemLocation.X - 10f, itemLocation.Y - 20f * gravDir), 4, 4, 242, 0f, 0f, 100);
					if (Main.rand.Next(3) != 0)
					{
						Main.dust[num10].noGravity = true;
					}
					Dust obj7 = Main.dust[num10];
					obj7.velocity *= 0.3f;
					Main.dust[num10].velocity.Y -= 1.5f;
					Main.dust[num10].position = RotatedRelativePoint(Main.dust[num10].position);
				}
				Lighting.AddLight(RotatedRelativePoint(new Vector2(itemLocation.X - 16f + velocity.X, itemLocation.Y - 14f)), 0.9f, 0.1f, 0.75f);
			}
			else
			{
				if (Main.rand.Next(maxValue4) == 0)
				{
					int num11 = Dust.NewDust(new Vector2(itemLocation.X + 6f, itemLocation.Y - 20f * gravDir), 4, 4, 242, 0f, 0f, 100);
					if (Main.rand.Next(3) != 0)
					{
						Main.dust[num11].noGravity = true;
					}
					Dust obj8 = Main.dust[num11];
					obj8.velocity *= 0.3f;
					Main.dust[num11].velocity.Y -= 1.5f;
					Main.dust[num11].position = RotatedRelativePoint(Main.dust[num11].position);
				}
				Lighting.AddLight(RotatedRelativePoint(new Vector2(itemLocation.X + 6f + velocity.X, itemLocation.Y - 14f)), 0.9f, 0.1f, 0.75f);
			}
		}
		else if (sItem.type == 5322 && !wet && !pulley)
		{
			float r = 0.2f;
			float g = 0.3f;
			float b = 0.32f;
			if (direction == -1)
			{
				Lighting.AddLight(RotatedRelativePoint(new Vector2(itemLocation.X - 16f + velocity.X, itemLocation.Y - 14f)), r, g, b);
			}
			else
			{
				Lighting.AddLight(RotatedRelativePoint(new Vector2(itemLocation.X + 6f + velocity.X, itemLocation.Y - 14f)), r, g, b);
			}
		}
		if (sItem.type == 282 && !pulley)
		{
			if (direction == -1)
			{
				Lighting.AddLight(RotatedRelativePoint(new Vector2(itemLocation.X - 16f + velocity.X, itemLocation.Y - 14f)), 0.7f, 1f, 0.8f);
			}
			else
			{
				Lighting.AddLight(RotatedRelativePoint(new Vector2(itemLocation.X + 6f + velocity.X, itemLocation.Y - 14f)), 0.7f, 1f, 0.8f);
			}
		}
		if (sItem.type == 3002 && !pulley)
		{
			float r2 = 1.05f;
			float g2 = 0.95f;
			float b2 = 0.55f;
			if (direction == -1)
			{
				Lighting.AddLight(RotatedRelativePoint(new Vector2(itemLocation.X - 16f + velocity.X, itemLocation.Y - 14f)), r2, g2, b2);
			}
			else
			{
				Lighting.AddLight(RotatedRelativePoint(new Vector2(itemLocation.X + 6f + velocity.X, itemLocation.Y - 14f)), r2, g2, b2);
			}
			spelunkerTimer++;
			if (spelunkerTimer >= 10)
			{
				spelunkerTimer = 0;
				Main.instance.SpelunkerProjectileHelper.AddSpotToCheck(base.Center);
			}
		}
		if (sItem.type == 286 && !pulley)
		{
			if (direction == -1)
			{
				Lighting.AddLight(RotatedRelativePoint(new Vector2(itemLocation.X - 16f + velocity.X, itemLocation.Y - 14f)), 0.7f, 0.8f, 1f);
			}
			else
			{
				Lighting.AddLight(RotatedRelativePoint(new Vector2(itemLocation.X + 6f + velocity.X, itemLocation.Y - 14f)), 0.7f, 0.8f, 1f);
			}
		}
		if (sItem.type == 3112 && !pulley)
		{
			if (direction == -1)
			{
				Lighting.AddLight(RotatedRelativePoint(new Vector2(itemLocation.X - 16f + velocity.X, itemLocation.Y - 14f)), 1f, 0.6f, 0.85f);
			}
			else
			{
				Lighting.AddLight(RotatedRelativePoint(new Vector2(itemLocation.X + 6f + velocity.X, itemLocation.Y - 14f)), 1f, 0.6f, 0.85f);
			}
		}
		if (sItem.type == 4776 && !pulley)
		{
			Vector2 vec = RotatedRelativePoint(new Vector2(itemLocation.X + 6f + velocity.X, itemLocation.Y - 14f));
			if (direction == -1)
			{
				vec = RotatedRelativePoint(new Vector2(itemLocation.X - 16f + velocity.X, itemLocation.Y - 14f));
			}
			Vector3 rgb = (DelegateMethods.v3_1 = new Vector3(0.9f, 0.35f, 1f));
			Point val = vec.ToTileCoordinates();
			DelegateMethods.v2_1 = val.ToVector2();
			DelegateMethods.f_1 = 4.5f;
			Utils.PlotTileArea(val.X, val.Y, DelegateMethods.SpreadLightOpen_StopForSolids);
			Lighting.AddLight(vec, rgb);
		}
		if (sItem.type == 3542 && handPosition.HasValue)
		{
			Vector2 val2 = handPosition.Value - velocity;
			for (int i = 0; i < 4; i++)
			{
				Dust dust = Main.dust[Dust.NewDust(base.Center, 0, 0, 242, direction * 2, 0f, 150, default(Color), 1.3f)];
				dust.position = val2;
				dust.velocity *= 0f;
				dust.noGravity = true;
				dust.fadeIn = 1f;
				dust.velocity += velocity;
				if (Main.rand.Next(2) == 0)
				{
					dust.position += Utils.RandomVector2(Main.rand, -4f, 4f);
					dust.scale += Main.rand.NextFloat();
					if (Main.rand.Next(2) == 0)
					{
						dust.customData = this;
					}
				}
			}
		}
		if (sItem.type != 4952 || pulley || isPettingAnimal)
		{
			return;
		}
		Vector2 pos = itemLocation + new Vector2((float)(8 * direction), -10f * gravDir);
		Vector3 rgb2 = new Vector3(1f, 0.7f, 0.8f) * 1.3f;
		Vector2 val3 = RotatedRelativePoint(pos);
		Lighting.AddLight(val3, rgb2);
		if (Main.rand.Next(40) == 0)
		{
			Vector2 val4 = Main.rand.NextVector2Circular(4f, 4f);
			Dust dust2 = Dust.NewDustPerfect(val3 + val4, 43, Vector2.Zero, 254, new Color(255, 255, 0, 255), 0.3f);
			if (val4 != Vector2.Zero)
			{
				dust2.velocity = val3.DirectionTo(dust2.position) * 0.2f;
			}
			dust2.fadeIn = 0.3f;
			dust2.noLightEmittence = true;
			dust2.customData = this;
		}
	}

	public bool CanVisuallyHoldItem(Item item)
	{
		if (item.holdStyle == 4)
		{
			if (isPettingAnimal)
			{
				return false;
			}
			if (pulley)
			{
				return false;
			}
			if (gravDir == -1f)
			{
				return false;
			}
			if (velocity.Y != 0f)
			{
				return false;
			}
			if (mount.Active)
			{
				return false;
			}
		}
		if (item.holdStyle == 6 && isPettingAnimal)
		{
			return false;
		}
		if (item.holdStyle == 5 && isPettingAnimal)
		{
			return false;
		}
		return true;
	}

	private void ItemCheck_ApplyHoldStyle(float mountOffset, Item sItem, Rectangle heldItemFrame)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		ItemCheck_ApplyHoldStyle_Inner(mountOffset, sItem, heldItemFrame);
		ItemLoader.HoldStyle(sItem, this, heldItemFrame);
	}

	private void ItemCheck_ApplyHoldStyle_Inner(float mountOffset, Item sItem, Rectangle heldItemFrame)
	{
		//IL_0ca6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c58: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c62: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_037d: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0db1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0dfb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0e00: Unknown result type (might be due to invalid IL or missing references)
		//IL_0e04: Unknown result type (might be due to invalid IL or missing references)
		//IL_0e09: Unknown result type (might be due to invalid IL or missing references)
		//IL_0e0b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0e10: Unknown result type (might be due to invalid IL or missing references)
		//IL_05f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_05ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_0e81: Unknown result type (might be due to invalid IL or missing references)
		//IL_0ed1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0ed6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0eda: Unknown result type (might be due to invalid IL or missing references)
		//IL_0edf: Unknown result type (might be due to invalid IL or missing references)
		//IL_0ee1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0ee6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0d38: Unknown result type (might be due to invalid IL or missing references)
		//IL_0d42: Unknown result type (might be due to invalid IL or missing references)
		//IL_0d47: Unknown result type (might be due to invalid IL or missing references)
		//IL_0d4b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0d50: Unknown result type (might be due to invalid IL or missing references)
		//IL_0d55: Unknown result type (might be due to invalid IL or missing references)
		//IL_0d57: Unknown result type (might be due to invalid IL or missing references)
		//IL_0d5c: Unknown result type (might be due to invalid IL or missing references)
		//IL_075f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0780: Unknown result type (might be due to invalid IL or missing references)
		//IL_07a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_07c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_07f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0816: Unknown result type (might be due to invalid IL or missing references)
		//IL_0844: Unknown result type (might be due to invalid IL or missing references)
		//IL_0864: Unknown result type (might be due to invalid IL or missing references)
		//IL_0253: Unknown result type (might be due to invalid IL or missing references)
		//IL_026a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0270: Unknown result type (might be due to invalid IL or missing references)
		//IL_0893: Unknown result type (might be due to invalid IL or missing references)
		//IL_08b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_08bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_02df: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_030b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0315: Unknown result type (might be due to invalid IL or missing references)
		//IL_031a: Unknown result type (might be due to invalid IL or missing references)
		//IL_08ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_090a: Unknown result type (might be due to invalid IL or missing references)
		//IL_090f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0916: Unknown result type (might be due to invalid IL or missing references)
		//IL_0924: Unknown result type (might be due to invalid IL or missing references)
		//IL_092a: Unknown result type (might be due to invalid IL or missing references)
		//IL_094c: Unknown result type (might be due to invalid IL or missing references)
		//IL_095b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0960: Unknown result type (might be due to invalid IL or missing references)
		//IL_0965: Unknown result type (might be due to invalid IL or missing references)
		if (isPettingAnimal)
		{
			int num = miscCounter % 14 / 7;
			CompositeArmStretchAmount stretch = CompositeArmStretchAmount.ThreeQuarters;
			if (num == 1)
			{
				stretch = CompositeArmStretchAmount.Full;
			}
			float num2 = 0.3f;
			if (isTheAnimalBeingPetSmall)
			{
				num2 = 0.2f;
			}
			SetCompositeArmBack(enabled: true, stretch, (float)Math.PI * -2f * num2 * (float)direction);
		}
		if (!CanVisuallyHoldItem(sItem))
		{
			return;
		}
		if (sItem.holdStyle == 1 && !pulley)
		{
			if (Main.dedServ)
			{
				itemLocation.X = position.X + (float)width * 0.5f + 20f * (float)direction;
			}
			else if (sItem.type == 930)
			{
				itemLocation.X = position.X + (float)width * 0.5f - (float)(2 * direction);
				float x = position.X + (float)(width / 2) + (float)(38 * direction);
				if (direction == 1)
				{
					x -= 10f;
				}
				float y = MountedCenter.Y - 4f * gravDir;
				if (gravDir == -1f)
				{
					y -= 8f;
				}
				RotateRelativePoint(ref x, ref y);
				int num3 = 0;
				for (int i = 54; i < 58; i++)
				{
					if (inventory[i].stack > 0 && inventory[i].ammo == 931)
					{
						num3 = inventory[i].type;
						break;
					}
				}
				if (num3 == 0)
				{
					for (int j = 0; j < 54; j++)
					{
						if (inventory[j].stack > 0 && inventory[j].ammo == 931)
						{
							num3 = inventory[j].type;
							break;
						}
					}
				}
				switch (num3)
				{
				case 931:
					num3 = 127;
					break;
				case 1614:
					num3 = 187;
					break;
				case 5377:
					num3 = 169;
					break;
				case 5378:
					num3 = 75;
					break;
				case 5379:
					num3 = 66;
					break;
				case 5380:
					num3 = 310;
					break;
				}
				if (num3 > 0)
				{
					int num4 = Dust.NewDust(new Vector2(x, y + gfxOffY), 6, 6, num3, 0f, 0f, 100, default(Color), 1.6f);
					Main.dust[num4].noGravity = true;
					Main.dust[num4].velocity.Y -= 4f * gravDir;
					if (num3 == 66)
					{
						Main.dust[num4].color = Main.hslToRgb(Main.GlobalTimeWrappedHourly * 0.6f % 1f, 1f, 0.5f);
						Main.dust[num4].scale *= 0.5f;
						Dust obj = Main.dust[num4];
						obj.velocity *= 0.75f;
					}
				}
			}
			else if (sItem.type == 968)
			{
				itemLocation.X = position.X + (float)width * 0.5f + (float)(8 * direction);
				if (whoAmI == Main.myPlayer)
				{
					int x2 = (int)(itemLocation.X + (float)heldItemFrame.Width * 0.8f * (float)direction) / 16;
					int y2 = (int)(itemLocation.Y + mountOffset + (float)(heldItemFrame.Height / 2)) / 16;
					if (Main.tile[x2, y2] == null)
					{
						Main.tile[x2, y2] = default(Tile);
					}
					if (Main.tile[x2, y2].active() && TileID.Sets.Campfire[Main.tile[x2, y2].type] && Main.tile[x2, y2].frameY < 54)
					{
						miscTimer++;
						if (Main.rand.Next(5) == 0)
						{
							miscTimer++;
						}
						if (miscTimer > 900)
						{
							miscTimer = 0;
							sItem.SetDefaults(969);
							if (selectedItem == 58)
							{
								Main.mouseItem.SetDefaults(969);
							}
							for (int k = 0; k < 58; k++)
							{
								if (inventory[k].type == sItem.type && k != selectedItem && inventory[k].stack < inventory[k].maxStack)
								{
									SoundEngine.PlaySound(7);
									inventory[k].stack++;
									sItem.SetDefaults();
									if (selectedItem == 58)
									{
										Main.mouseItem.SetDefaults();
									}
								}
							}
						}
					}
					else
					{
						miscTimer = 0;
					}
				}
			}
			else if (sItem.type == 856)
			{
				itemLocation.X = position.X + (float)width * 0.5f + (float)(4 * direction);
			}
			else if (sItem.fishingPole > 0)
			{
				itemLocation.X = position.X + (float)width * 0.5f + (float)heldItemFrame.Width * 0.18f * (float)direction;
			}
			else
			{
				itemLocation.X = position.X + (float)width * 0.5f + ((float)heldItemFrame.Width * 0.5f + 2f) * (float)direction;
				if (sItem.type == 282 || sItem.type == 286 || sItem.type == 3112 || sItem.type == 4776)
				{
					itemLocation.X -= direction * 2;
					itemLocation.Y += 4f;
				}
				else if (sItem.type == 3002)
				{
					itemLocation.X -= 4 * direction;
					itemLocation.Y += 2f;
				}
			}
			itemLocation.Y = position.Y + 24f + mountOffset;
			if (sItem.type == 856)
			{
				itemLocation.Y = position.Y + 34f + mountOffset;
			}
			if (sItem.type == 930)
			{
				itemLocation.Y = position.Y + 9f + mountOffset;
			}
			if (sItem.fishingPole > 0)
			{
				itemLocation.Y += 4f;
			}
			else if (sItem.type == 3476)
			{
				itemLocation.X = base.Center.X + (float)(14 * direction);
				itemLocation.Y = MountedCenter.Y;
			}
			else if (sItem.type == 3779)
			{
				itemLocation.X = base.Center.X + (float)(6 * direction);
				itemLocation.Y = MountedCenter.Y + 6f;
			}
			else if (sItem.type == 4952)
			{
				itemLocation.X = base.Center.X + (float)(2 * direction);
				itemLocation.Y = MountedCenter.Y + 26f;
			}
			else if (sItem.type == 353)
			{
				itemLocation.X = base.Center.X + (float)(6 * direction);
				itemLocation.Y = MountedCenter.Y + 11f;
			}
			else if (ItemID.Sets.IsFood[sItem.type])
			{
				itemLocation.X = base.Center.X + (float)(4 * direction);
				itemLocation.Y = MountedCenter.Y + (float)(heldItemFrame.Height / 2);
			}
			else if (sItem.type == 4049 && Main.rand.Next(4) == 0)
			{
				Dust dust = Dust.NewDustPerfect(base.Center + new Vector2((float)(direction * 23), gravDir * 6f), 31, Vector2.Zero, 127, default(Color), 0.7f);
				dust.noGravity = true;
				dust.velocity = Main.rand.NextVector2Circular(1f, 1f) + new Vector2(0f, -1f);
			}
			itemRotation = 0f;
			if (gravDir == -1f)
			{
				itemRotation = 0f - itemRotation;
				itemLocation.Y = position.Y + (float)height + (position.Y - itemLocation.Y) + mountOffset;
				if (sItem.type == 930)
				{
					itemLocation.Y -= 24f;
				}
			}
		}
		else if (sItem.holdStyle == 2 && !pulley)
		{
			if (sItem.type == 946 || sItem.type == 4707)
			{
				itemRotation = 0f;
				itemLocation.X = position.X + (float)width * 0.5f - (float)(16 * direction);
				itemLocation.Y = position.Y + 22f + mountOffset;
				fallStart = (int)(position.Y / 16f);
				if (gravDir == -1f)
				{
					itemRotation = 0f - itemRotation;
					itemLocation.Y = position.Y + (float)height + (position.Y - itemLocation.Y);
					if (velocity.Y < -2f && !controlDown)
					{
						velocity.Y = -2f;
					}
				}
				else if (velocity.Y > 2f && !controlDown)
				{
					velocity.Y = 2f;
				}
			}
			else
			{
				itemLocation.X = position.X + (float)width * 0.5f + (float)(6 * direction);
				itemLocation.Y = position.Y + 16f + mountOffset;
				itemRotation = 0.79f * (float)(-direction);
				if (gravDir == -1f)
				{
					itemRotation = 0f - itemRotation;
					itemLocation.Y = position.Y + (float)height + (position.Y - itemLocation.Y);
				}
			}
		}
		else if (sItem.holdStyle == 3 && !pulley)
		{
			if (!Main.dedServ)
			{
				itemLocation.X = position.X + (float)width * 0.5f - (float)(direction * 2);
				itemLocation.Y = MountedCenter.Y - (float)heldItemFrame.Height * 0.5f;
				itemRotation = 0f;
			}
		}
		else if (sItem.holdStyle == 4)
		{
			if (!Main.dedServ)
			{
				float num5 = Utils.ToRotation(new Vector2((float)(10 * direction), 10f)) + (float)Math.PI / 4f;
				itemRotation = num5;
				if (direction == -1)
				{
					itemRotation += (float)Math.PI / 2f;
				}
				CompositeArmStretchAmount stretch2 = CompositeArmStretchAmount.Full;
				CompositeArmStretchAmount stretch3 = CompositeArmStretchAmount.ThreeQuarters;
				float num6 = -(float)Math.PI / 10f;
				if (direction == -1)
				{
					num6 *= -1f;
				}
				float num7 = itemRotation - (float)Math.PI / 4f + (float)Math.PI;
				if (direction == 1)
				{
					num7 += (float)Math.PI / 2f;
				}
				float rotation = num7 + num6;
				float rotation2 = num7 - num6;
				Vector2 val = (num7 + (float)Math.PI / 2f).ToRotationVector2() * 2f;
				itemLocation = MountedCenter.Floor() + val;
				SetCompositeArmFront(enabled: true, stretch2, rotation);
				SetCompositeArmBack(enabled: true, stretch3, rotation2);
				FlipItemLocationAndRotationForGravity();
			}
		}
		else if (sItem.holdStyle == 5 && !pulley)
		{
			if (!Main.dedServ)
			{
				itemRotation = 0f;
				itemLocation.X = base.Center.X - (float)(8 * direction);
				itemLocation.Y = position.Y + 40f + mountOffset;
				Vector2 val2 = Main.OffsetsPlayerHeadgear[bodyFrame.Y / 56];
				itemLocation += val2;
				CompositeArmStretchAmount stretch4 = CompositeArmStretchAmount.Quarter;
				SetCompositeArmBack(enabled: true, stretch4, -(float)Math.PI / 4f * (float)direction);
				CompositeArmStretchAmount stretch5 = CompositeArmStretchAmount.Full;
				SetCompositeArmFront(enabled: true, stretch5, -0.39269912f * (float)direction);
				FlipItemLocationAndRotationForGravity();
			}
		}
		else if (sItem.holdStyle == 6 && !pulley && !Main.dedServ)
		{
			itemRotation = 0f;
			itemLocation.X = base.Center.X + (float)(8 * direction);
			itemLocation.Y = position.Y + 40f + mountOffset - 2f;
			Vector2 val3 = Main.OffsetsPlayerHeadgear[bodyFrame.Y / 56];
			itemLocation += val3;
			CompositeArmStretchAmount stretch6 = CompositeArmStretchAmount.ThreeQuarters;
			SetCompositeArmBack(enabled: true, stretch6, (float)Math.PI * -3f / 5f * (float)direction);
			FlipItemLocationAndRotationForGravity();
		}
	}

	private void ItemCheck_ApplyManaRegenDelay(Item sItem)
	{
		if (GetManaCost(sItem) > 0)
		{
			manaRegenDelay = (int)maxRegenDelay;
		}
	}

	public Vector2 GetFrontHandPosition(CompositeArmStretchAmount stretch, float rotation)
	{
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		float num = rotation + (float)Math.PI / 2f;
		Vector2 val = default(Vector2);
		((Vector2)(ref val))..ctor((float)Math.Cos(num), (float)Math.Sin(num));
		switch (stretch)
		{
		case CompositeArmStretchAmount.Full:
			val *= 10f;
			break;
		case CompositeArmStretchAmount.None:
			val *= 4f;
			break;
		case CompositeArmStretchAmount.Quarter:
			val *= 6f;
			break;
		case CompositeArmStretchAmount.ThreeQuarters:
			val *= 8f;
			break;
		}
		if (direction == -1)
		{
			val += new Vector2(4f, -2f);
			val += Utils.RotatedBy(new Vector2(0f, -3f), (double)(rotation + (float)Math.PI / 2f), default(Vector2));
		}
		else
		{
			val += new Vector2(-4f, -2f);
			val += Utils.RotatedBy(new Vector2(0f, 3f), (double)(rotation + (float)Math.PI / 2f), default(Vector2));
		}
		return MountedCenter + val;
	}

	public Vector2 GetBackHandPosition(CompositeArmStretchAmount stretch, float rotation)
	{
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		float num = rotation + (float)Math.PI / 2f;
		Vector2 val = default(Vector2);
		((Vector2)(ref val))..ctor((float)Math.Cos(num), (float)Math.Sin(num));
		switch (stretch)
		{
		case CompositeArmStretchAmount.Full:
			val *= new Vector2(10f, 12f);
			break;
		case CompositeArmStretchAmount.None:
			val *= new Vector2(4f, 6f);
			break;
		case CompositeArmStretchAmount.Quarter:
			val *= new Vector2(6f, 8f);
			break;
		case CompositeArmStretchAmount.ThreeQuarters:
			val *= new Vector2(8f, 10f);
			break;
		}
		val = ((direction != -1) ? (val + new Vector2(6f, -2f)) : (val + new Vector2(-6f, -2f)));
		return MountedCenter + val;
	}

	public void ItemCheck_ApplyUseStyle(float mountOffset, Item sItem, Rectangle heldItemFrame)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		ItemCheck_ApplyUseStyle_Inner(mountOffset, sItem, heldItemFrame);
		ItemLoader.UseStyle(sItem, this, heldItemFrame);
	}

	private void ItemCheck_ApplyUseStyle_Inner(float mountOffset, Item sItem, Rectangle heldItemFrame)
	{
		//IL_01cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_090d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0931: Unknown result type (might be due to invalid IL or missing references)
		//IL_0936: Unknown result type (might be due to invalid IL or missing references)
		//IL_093b: Unknown result type (might be due to invalid IL or missing references)
		//IL_097c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0990: Unknown result type (might be due to invalid IL or missing references)
		//IL_0995: Unknown result type (might be due to invalid IL or missing references)
		//IL_099c: Unknown result type (might be due to invalid IL or missing references)
		//IL_09a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_09b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_09b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_09be: Unknown result type (might be due to invalid IL or missing references)
		//IL_09c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_09c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_09c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_07ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_0761: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_09f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_09fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a05: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a0b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a10: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a15: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a1c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a32: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a37: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a3e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a44: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a49: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a4e: Unknown result type (might be due to invalid IL or missing references)
		//IL_049b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0318: Unknown result type (might be due to invalid IL or missing references)
		//IL_0208: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0cbd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0cd1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0ced: Unknown result type (might be due to invalid IL or missing references)
		//IL_0cf3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0cf5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0cfa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0cff: Unknown result type (might be due to invalid IL or missing references)
		//IL_04ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_0329: Unknown result type (might be due to invalid IL or missing references)
		//IL_0219: Unknown result type (might be due to invalid IL or missing references)
		//IL_0153: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_0bf3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b66: Unknown result type (might be due to invalid IL or missing references)
		//IL_04bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_033a: Unknown result type (might be due to invalid IL or missing references)
		//IL_022a: Unknown result type (might be due to invalid IL or missing references)
		//IL_04ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_034b: Unknown result type (might be due to invalid IL or missing references)
		//IL_1054: Unknown result type (might be due to invalid IL or missing references)
		//IL_10a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_04df: Unknown result type (might be due to invalid IL or missing references)
		//IL_1315: Unknown result type (might be due to invalid IL or missing references)
		//IL_1335: Unknown result type (might be due to invalid IL or missing references)
		//IL_0db9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0dc3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0dd4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0ddf: Unknown result type (might be due to invalid IL or missing references)
		//IL_0de4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0de9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_1371: Unknown result type (might be due to invalid IL or missing references)
		//IL_1392: Unknown result type (might be due to invalid IL or missing references)
		//IL_1221: Unknown result type (might be due to invalid IL or missing references)
		//IL_1272: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_1c2c: Unknown result type (might be due to invalid IL or missing references)
		//IL_1c76: Unknown result type (might be due to invalid IL or missing references)
		//IL_1c7b: Unknown result type (might be due to invalid IL or missing references)
		//IL_1c7f: Unknown result type (might be due to invalid IL or missing references)
		//IL_1c84: Unknown result type (might be due to invalid IL or missing references)
		//IL_1c86: Unknown result type (might be due to invalid IL or missing references)
		//IL_1c8b: Unknown result type (might be due to invalid IL or missing references)
		//IL_155b: Unknown result type (might be due to invalid IL or missing references)
		//IL_1565: Unknown result type (might be due to invalid IL or missing references)
		//IL_13d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_158e: Unknown result type (might be due to invalid IL or missing references)
		//IL_1599: Unknown result type (might be due to invalid IL or missing references)
		//IL_15a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_15af: Unknown result type (might be due to invalid IL or missing references)
		//IL_15b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_15b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_15c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_15cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_15d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_15dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0557: Unknown result type (might be due to invalid IL or missing references)
		//IL_057c: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_18aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_18b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_14e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_14eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_14f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_14fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_1504: Unknown result type (might be due to invalid IL or missing references)
		//IL_1510: Unknown result type (might be due to invalid IL or missing references)
		//IL_1515: Unknown result type (might be due to invalid IL or missing references)
		//IL_151a: Unknown result type (might be due to invalid IL or missing references)
		//IL_151f: Unknown result type (might be due to invalid IL or missing references)
		//IL_15ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_1604: Unknown result type (might be due to invalid IL or missing references)
		//IL_1606: Unknown result type (might be due to invalid IL or missing references)
		//IL_161a: Unknown result type (might be due to invalid IL or missing references)
		//IL_1630: Unknown result type (might be due to invalid IL or missing references)
		//IL_1633: Unknown result type (might be due to invalid IL or missing references)
		//IL_1638: Unknown result type (might be due to invalid IL or missing references)
		//IL_164c: Unknown result type (might be due to invalid IL or missing references)
		//IL_1651: Unknown result type (might be due to invalid IL or missing references)
		//IL_1656: Unknown result type (might be due to invalid IL or missing references)
		//IL_16af: Unknown result type (might be due to invalid IL or missing references)
		//IL_16b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_16ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_16bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_058d: Unknown result type (might be due to invalid IL or missing references)
		//IL_040a: Unknown result type (might be due to invalid IL or missing references)
		//IL_063c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0641: Unknown result type (might be due to invalid IL or missing references)
		//IL_0643: Unknown result type (might be due to invalid IL or missing references)
		//IL_0648: Unknown result type (might be due to invalid IL or missing references)
		//IL_064d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0652: Unknown result type (might be due to invalid IL or missing references)
		//IL_20a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_20f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_20f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_20fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_2102: Unknown result type (might be due to invalid IL or missing references)
		//IL_2104: Unknown result type (might be due to invalid IL or missing references)
		//IL_2109: Unknown result type (might be due to invalid IL or missing references)
		//IL_17fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_14a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_14a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_172f: Unknown result type (might be due to invalid IL or missing references)
		//IL_1731: Unknown result type (might be due to invalid IL or missing references)
		//IL_1738: Unknown result type (might be due to invalid IL or missing references)
		//IL_173f: Unknown result type (might be due to invalid IL or missing references)
		//IL_1753: Unknown result type (might be due to invalid IL or missing references)
		//IL_1758: Unknown result type (might be due to invalid IL or missing references)
		//IL_175e: Unknown result type (might be due to invalid IL or missing references)
		//IL_1763: Unknown result type (might be due to invalid IL or missing references)
		//IL_1768: Unknown result type (might be due to invalid IL or missing references)
		//IL_170c: Unknown result type (might be due to invalid IL or missing references)
		//IL_1711: Unknown result type (might be due to invalid IL or missing references)
		//IL_0f49: Unknown result type (might be due to invalid IL or missing references)
		//IL_0f53: Unknown result type (might be due to invalid IL or missing references)
		//IL_0f64: Unknown result type (might be due to invalid IL or missing references)
		//IL_0f6f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0f74: Unknown result type (might be due to invalid IL or missing references)
		//IL_0f79: Unknown result type (might be due to invalid IL or missing references)
		//IL_059e: Unknown result type (might be due to invalid IL or missing references)
		//IL_1902: Unknown result type (might be due to invalid IL or missing references)
		//IL_1ab1: Unknown result type (might be due to invalid IL or missing references)
		//IL_1ab6: Unknown result type (might be due to invalid IL or missing references)
		//IL_1ab8: Unknown result type (might be due to invalid IL or missing references)
		//IL_1abd: Unknown result type (might be due to invalid IL or missing references)
		//IL_1ac2: Unknown result type (might be due to invalid IL or missing references)
		//IL_1bbe: Unknown result type (might be due to invalid IL or missing references)
		//IL_1bd1: Unknown result type (might be due to invalid IL or missing references)
		//IL_1bd6: Unknown result type (might be due to invalid IL or missing references)
		//IL_1bda: Unknown result type (might be due to invalid IL or missing references)
		//IL_1bdf: Unknown result type (might be due to invalid IL or missing references)
		//IL_1be1: Unknown result type (might be due to invalid IL or missing references)
		//IL_1be6: Unknown result type (might be due to invalid IL or missing references)
		//IL_1beb: Unknown result type (might be due to invalid IL or missing references)
		//IL_19a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_19ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_19b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_19b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_19bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_19be: Unknown result type (might be due to invalid IL or missing references)
		//IL_19c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_19c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_1db4: Unknown result type (might be due to invalid IL or missing references)
		//IL_1db9: Unknown result type (might be due to invalid IL or missing references)
		//IL_1dc0: Unknown result type (might be due to invalid IL or missing references)
		//IL_1dc8: Unknown result type (might be due to invalid IL or missing references)
		//IL_1dda: Unknown result type (might be due to invalid IL or missing references)
		//IL_1ddf: Unknown result type (might be due to invalid IL or missing references)
		//IL_1de9: Unknown result type (might be due to invalid IL or missing references)
		//IL_1dee: Unknown result type (might be due to invalid IL or missing references)
		//IL_1df3: Unknown result type (might be due to invalid IL or missing references)
		//IL_1df5: Unknown result type (might be due to invalid IL or missing references)
		//IL_1e0b: Unknown result type (might be due to invalid IL or missing references)
		//IL_1e18: Unknown result type (might be due to invalid IL or missing references)
		//IL_1e1e: Unknown result type (might be due to invalid IL or missing references)
		//IL_1e39: Unknown result type (might be due to invalid IL or missing references)
		//IL_1e43: Unknown result type (might be due to invalid IL or missing references)
		//IL_1e48: Unknown result type (might be due to invalid IL or missing references)
		//IL_1e70: Unknown result type (might be due to invalid IL or missing references)
		//IL_1e77: Unknown result type (might be due to invalid IL or missing references)
		//IL_1ea4: Unknown result type (might be due to invalid IL or missing references)
		//IL_1eaa: Unknown result type (might be due to invalid IL or missing references)
		//IL_1eac: Unknown result type (might be due to invalid IL or missing references)
		//IL_1ec7: Unknown result type (might be due to invalid IL or missing references)
		//IL_1ed6: Unknown result type (might be due to invalid IL or missing references)
		//IL_1edb: Unknown result type (might be due to invalid IL or missing references)
		//IL_1ef6: Unknown result type (might be due to invalid IL or missing references)
		//IL_1f12: Unknown result type (might be due to invalid IL or missing references)
		//IL_1f1c: Unknown result type (might be due to invalid IL or missing references)
		//IL_1f21: Unknown result type (might be due to invalid IL or missing references)
		//IL_1f31: Unknown result type (might be due to invalid IL or missing references)
		//IL_1f38: Unknown result type (might be due to invalid IL or missing references)
		//IL_1f42: Unknown result type (might be due to invalid IL or missing references)
		//IL_1f47: Unknown result type (might be due to invalid IL or missing references)
		//IL_1f4c: Unknown result type (might be due to invalid IL or missing references)
		//IL_1f83: Unknown result type (might be due to invalid IL or missing references)
		//IL_1f8a: Unknown result type (might be due to invalid IL or missing references)
		//IL_1fb7: Unknown result type (might be due to invalid IL or missing references)
		//IL_1fbd: Unknown result type (might be due to invalid IL or missing references)
		//IL_1fbf: Unknown result type (might be due to invalid IL or missing references)
		//IL_1fda: Unknown result type (might be due to invalid IL or missing references)
		//IL_1fe9: Unknown result type (might be due to invalid IL or missing references)
		//IL_1fee: Unknown result type (might be due to invalid IL or missing references)
		//IL_2009: Unknown result type (might be due to invalid IL or missing references)
		//IL_2025: Unknown result type (might be due to invalid IL or missing references)
		//IL_202f: Unknown result type (might be due to invalid IL or missing references)
		//IL_2034: Unknown result type (might be due to invalid IL or missing references)
		//IL_2044: Unknown result type (might be due to invalid IL or missing references)
		//IL_204b: Unknown result type (might be due to invalid IL or missing references)
		//IL_2055: Unknown result type (might be due to invalid IL or missing references)
		//IL_205a: Unknown result type (might be due to invalid IL or missing references)
		//IL_205f: Unknown result type (might be due to invalid IL or missing references)
		if (Main.dedServ)
		{
			return;
		}
		if (sItem.useStyle == 1)
		{
			if (sItem.type > -1 && Item.claw[sItem.type])
			{
				if ((double)itemAnimation < (double)itemAnimationMax * 0.333)
				{
					float num = 10f;
					itemLocation.X = position.X + (float)width * 0.5f + ((float)heldItemFrame.Width * 0.5f - num) * (float)direction;
					itemLocation.Y = position.Y + 26f + mountOffset;
				}
				else if ((double)itemAnimation < (double)itemAnimationMax * 0.666)
				{
					float num2 = 8f;
					itemLocation.X = position.X + (float)width * 0.5f + ((float)heldItemFrame.Width * 0.5f - num2) * (float)direction;
					num2 = 24f;
					itemLocation.Y = position.Y + num2 + mountOffset;
				}
				else
				{
					float num3 = 6f;
					itemLocation.X = position.X + (float)width * 0.5f - ((float)heldItemFrame.Width * 0.5f - num3) * (float)direction;
					num3 = 20f;
					itemLocation.Y = position.Y + num3 + mountOffset;
				}
				itemRotation = ((float)itemAnimation / (float)itemAnimationMax - 0.5f) * (float)(-direction) * 3.5f - (float)direction * 0.3f;
			}
			else
			{
				Vector2 zero = Vector2.Zero;
				if ((double)itemAnimation < (double)itemAnimationMax * 0.333)
				{
					float num4 = 10f;
					if (heldItemFrame.Width > 32)
					{
						num4 = 14f;
					}
					if (heldItemFrame.Width >= 52)
					{
						num4 = 24f;
					}
					if (heldItemFrame.Width >= 64)
					{
						num4 = 28f;
					}
					if (heldItemFrame.Width >= 92)
					{
						num4 = 38f;
					}
					if (sItem.type == 2330 || sItem.type == 2320 || sItem.type == 2341)
					{
						num4 += 8f;
					}
					if (sItem.type == 671)
					{
						num4 += 12f;
					}
					itemLocation.X = position.X + (float)width * 0.5f + ((float)heldItemFrame.Width * 0.5f - num4) * (float)direction;
					itemLocation.Y = position.Y + 24f + mountOffset;
					((Vector2)(ref zero))..ctor(-4f, 1f);
				}
				else if ((double)itemAnimation < (double)itemAnimationMax * 0.666)
				{
					float num5 = 10f;
					if (heldItemFrame.Width > 32)
					{
						num5 = 18f;
					}
					if (heldItemFrame.Width >= 52)
					{
						num5 = 24f;
					}
					if (heldItemFrame.Width >= 64)
					{
						num5 = 28f;
					}
					if (heldItemFrame.Width >= 92)
					{
						num5 = 38f;
					}
					if (sItem.type == 2330 || sItem.type == 2320 || sItem.type == 2341)
					{
						num5 += 4f;
					}
					if (sItem.type == 671)
					{
						num5 += 6f;
					}
					itemLocation.X = position.X + (float)width * 0.5f + ((float)heldItemFrame.Width * 0.5f - num5) * (float)direction;
					num5 = 10f;
					if (heldItemFrame.Height > 32)
					{
						num5 = 8f;
					}
					if (heldItemFrame.Height > 52)
					{
						num5 = 12f;
					}
					if (heldItemFrame.Height > 64)
					{
						num5 = 14f;
					}
					if (sItem.type == 2330 || sItem.type == 2320 || sItem.type == 2341)
					{
						num5 += 4f;
					}
					if (sItem.type == 671)
					{
						num5 += 10f;
					}
					itemLocation.Y = position.Y + num5 + mountOffset;
					((Vector2)(ref zero))..ctor(-6f, -4f);
				}
				else
				{
					float num6 = 6f;
					if (heldItemFrame.Width > 32)
					{
						num6 = 14f;
					}
					if (heldItemFrame.Width >= 48)
					{
						num6 = 18f;
					}
					if (heldItemFrame.Width >= 52)
					{
						num6 = 24f;
					}
					if (heldItemFrame.Width >= 64)
					{
						num6 = 28f;
					}
					if (heldItemFrame.Width >= 92)
					{
						num6 = 38f;
					}
					if (sItem.type == 2330 || sItem.type == 2320 || sItem.type == 2341)
					{
						num6 += 4f;
					}
					if (sItem.type == 671)
					{
						num6 += 8f;
					}
					itemLocation.X = position.X + (float)width * 0.5f - ((float)heldItemFrame.Width * 0.5f - num6) * (float)direction;
					num6 = 10f;
					if (heldItemFrame.Height > 32)
					{
						num6 = 10f;
					}
					if (heldItemFrame.Height > 52)
					{
						num6 = 12f;
					}
					if (heldItemFrame.Height > 64)
					{
						num6 = 14f;
					}
					if (sItem.type == 2330 || sItem.type == 2320 || sItem.type == 2341)
					{
						num6 += 4f;
					}
					if (sItem.type == 671)
					{
						num6 += 8f;
					}
					itemLocation.Y = position.Y + num6 + mountOffset;
					((Vector2)(ref zero))..ctor(4f, -2f);
				}
				if (sItem.type > -1 && ItemID.Sets.UsesBetterMeleeItemLocation[sItem.type])
				{
					itemLocation += zero * Directions;
				}
				itemRotation = ((float)itemAnimation / (float)itemAnimationMax - 0.5f) * (float)(-direction) * 3.5f - (float)direction * 0.3f;
			}
			if (gravDir == -1f)
			{
				itemRotation = 0f - itemRotation;
				itemLocation.Y = position.Y + (float)height + (position.Y - itemLocation.Y);
			}
		}
		else if (sItem.useStyle == 7)
		{
			itemRotation = (float)itemAnimation / (float)itemAnimationMax * (float)direction * 2f + -1.4f * (float)direction;
			if ((double)itemAnimation < (double)itemAnimationMax * 0.5)
			{
				itemLocation.X = position.X + (float)width * 0.5f + ((float)heldItemFrame.Width * 0.5f - 9f - itemRotation * 12f * (float)direction) * (float)direction;
				itemLocation.Y = position.Y + 38f + itemRotation * (float)direction * 4f + mountOffset;
			}
			else
			{
				itemLocation.X = position.X + (float)width * 0.5f + ((float)heldItemFrame.Width * 0.5f - 9f - itemRotation * 16f * (float)direction) * (float)direction;
				itemLocation.Y = position.Y + 38f + itemRotation * (float)direction + mountOffset;
			}
			if (gravDir == -1f)
			{
				itemRotation = 0f - itemRotation;
				itemLocation.Y = position.Y + (float)height + (position.Y - itemLocation.Y);
			}
		}
		else if (sItem.useStyle == 9)
		{
			float num7 = (float)itemAnimation / (float)itemAnimationMax;
			float t = 1f - num7;
			t = Utils.GetLerpValue(0f, 0.7f, t, clamped: true);
			itemRotation = t * (float)(-direction) * 2f + 0.7f * (float)direction;
			itemLocation = MountedCenter + new Vector2((float)(direction * 10) * ((float)itemAnimation / (float)itemAnimationMax), 0f);
			float num8 = 8f;
			float num9 = 7f;
			float num10 = (float)Math.PI * 2f / 5f;
			float num11 = (0f - num10) * 0.5f + (1f - t) * num10;
			num11 += (float)Math.PI / 10f;
			Vector2 val = base.Center + new Vector2((float)direction * num8, 0f) + num11.ToRotationVector2() * num9 * new Vector2((float)direction, 1f);
			itemLocation = val;
			float num12 = num11 - (float)Math.PI / 2f;
			if (direction == -1)
			{
				num12 = 0f - num12;
			}
			SetCompositeArmFront(enabled: true, CompositeArmStretchAmount.Full, num12);
			itemLocation = GetFrontHandPosition(CompositeArmStretchAmount.Full, num12);
			itemLocation -= MountedCenter;
			itemLocation *= MathHelper.Lerp(1.5f, 1.2f, t);
			itemLocation += MountedCenter;
			itemLocation.X += (float)direction * MathHelper.Lerp(8f, 2f, t);
			if (gravDir == -1f)
			{
				itemRotation = 0f - itemRotation;
				itemLocation.Y = position.Y + (float)height + (position.Y - itemLocation.Y);
			}
		}
		else if (sItem.useStyle == 6)
		{
			float num13 = 1f - (float)itemAnimation / (float)itemAnimationMax;
			num13 *= 6f;
			if (num13 > 1f)
			{
				num13 = 1f;
			}
			itemRotation = (1f - num13) * (float)direction * 2f - 1.4f * (float)direction;
			if (num13 >= 0.5f)
			{
				itemLocation.X = position.X + (float)width * 0.5f + ((float)heldItemFrame.Width * 0.5f - 9f - itemRotation * 12f * (float)direction) * (float)direction;
				itemLocation.Y = position.Y + 38f + itemRotation * (float)direction * 4f + mountOffset;
			}
			else
			{
				itemLocation.X = position.X + (float)width * 0.5f + ((float)heldItemFrame.Width * 0.5f - 9f - itemRotation * 16f * (float)direction) * (float)direction;
				itemLocation.Y = position.Y + 38f + itemRotation * (float)direction + mountOffset;
			}
			if (gravDir == -1f)
			{
				itemRotation = 0f - itemRotation;
				itemLocation.Y = position.Y + (float)height + (position.Y - itemLocation.Y);
			}
		}
		else if (sItem.useStyle == 2)
		{
			itemLocation = MountedCenter + Utils.RotatedBy(new Vector2((float)(10 * direction), -10f), (double)(itemRotation + (float)Math.PI / 4f * (float)direction), default(Vector2));
			float num14 = 1f - (float)itemAnimation / (float)itemAnimationMax;
			CompositeArmStretchAmount compositeArmStretchAmount = CompositeArmStretchAmount.Full;
			if (num14 > 0.25f && num14 <= 0.5f)
			{
				compositeArmStretchAmount = CompositeArmStretchAmount.ThreeQuarters;
			}
			if (num14 > 0.5f && num14 <= 0.75f)
			{
				compositeArmStretchAmount = CompositeArmStretchAmount.Quarter;
			}
			if (num14 > 0.75f && num14 <= 1f)
			{
				compositeArmStretchAmount = CompositeArmStretchAmount.None;
			}
			SetCompositeArmFront(enabled: true, compositeArmStretchAmount, -(float)Math.PI / 2f * (float)direction);
			SetCompositeArmBack(enabled: true, compositeArmStretchAmount, -(float)Math.PI / 2f * (float)direction);
			int num15 = 8;
			switch (compositeArmStretchAmount)
			{
			case CompositeArmStretchAmount.Full:
				num15 = 8;
				break;
			case CompositeArmStretchAmount.ThreeQuarters:
				num15 = 6;
				break;
			case CompositeArmStretchAmount.Quarter:
				num15 = 4;
				break;
			case CompositeArmStretchAmount.None:
				num15 = 2;
				break;
			}
			itemLocation = MountedCenter + new Vector2((float)((num15 + 10 - heldItemFrame.Width / 2) * direction), (float)(heldItemFrame.Height / 2 - 4));
			if (gravDir == -1f)
			{
				itemRotation = 0f - itemRotation;
				itemLocation.Y = position.Y + (float)height + (position.Y - itemLocation.Y);
			}
		}
		else if (sItem.useStyle == 11)
		{
			float num16 = 1f - (float)itemAnimation / (float)itemAnimationMax;
			num16 *= 2f;
			CompositeArmStretchAmount compositeArmStretchAmount2 = CompositeArmStretchAmount.Full;
			if (num16 > 0.25f && num16 <= 0.5f)
			{
				compositeArmStretchAmount2 = CompositeArmStretchAmount.ThreeQuarters;
			}
			if (num16 > 0.5f && num16 <= 0.75f)
			{
				compositeArmStretchAmount2 = CompositeArmStretchAmount.Quarter;
			}
			if (num16 > 0.75f && num16 <= 1.25f)
			{
				compositeArmStretchAmount2 = CompositeArmStretchAmount.None;
			}
			if (num16 > 1.25f && num16 <= 1.5f)
			{
				compositeArmStretchAmount2 = CompositeArmStretchAmount.Quarter;
			}
			if (num16 > 1.5f && num16 <= 1.75f)
			{
				compositeArmStretchAmount2 = CompositeArmStretchAmount.ThreeQuarters;
			}
			if (num16 > 1.75f && num16 <= 2f)
			{
				compositeArmStretchAmount2 = CompositeArmStretchAmount.Full;
			}
			SetCompositeArmFront(enabled: true, compositeArmStretchAmount2, -(float)Math.PI / 4f * (float)direction);
			SetCompositeArmBack(enabled: true, CompositeArmStretchAmount.Full, -(float)Math.PI / 16f);
			int num17 = 8;
			switch (compositeArmStretchAmount2)
			{
			case CompositeArmStretchAmount.Full:
				num17 = 8;
				break;
			case CompositeArmStretchAmount.ThreeQuarters:
				num17 = 6;
				break;
			case CompositeArmStretchAmount.Quarter:
				num17 = 4;
				break;
			case CompositeArmStretchAmount.None:
				num17 = 2;
				break;
			}
			itemLocation = MountedCenter + new Vector2((float)((num17 + 22 - heldItemFrame.Width / 2) * direction), (float)(heldItemFrame.Height / 2 - 8));
			if (gravDir == -1f)
			{
				itemRotation = 0f - itemRotation;
				itemLocation.Y = position.Y + (float)height + (position.Y - itemLocation.Y);
			}
		}
		else if (sItem.useStyle == 3)
		{
			if ((double)itemAnimation > (double)itemAnimationMax * 0.666)
			{
				itemLocation.X = -1000f;
				itemLocation.Y = -1000f;
				itemRotation = -1.3f * (float)direction;
			}
			else
			{
				itemLocation.X = position.X + (float)width * 0.5f + ((float)heldItemFrame.Width * 0.5f - 4f) * (float)direction;
				itemLocation.Y = position.Y + 24f + mountOffset;
				float num18 = (float)itemAnimation / (float)itemAnimationMax * (float)heldItemFrame.Width * (float)direction * GetAdjustedItemScale(sItem) * 1.2f - (float)(10 * direction);
				if (num18 > -4f && direction == -1)
				{
					num18 = -8f;
				}
				if (num18 < 4f && direction == 1)
				{
					num18 = 8f;
				}
				itemLocation.X -= num18;
				itemRotation = 0.8f * (float)direction;
				if (sItem.type == 946 || sItem.type == 4707)
				{
					itemLocation.X -= 6 * direction;
				}
			}
			if (gravDir == -1f)
			{
				itemRotation = 0f - itemRotation;
				itemLocation.Y = position.Y + (float)height + (position.Y - itemLocation.Y);
			}
		}
		else if (sItem.useStyle == 4)
		{
			int num19 = 0;
			int num20 = 0;
			if (sItem.type == 3601)
			{
				num19 = 10;
			}
			if (sItem.type == 5114)
			{
				num19 = 10;
				num20 = -2;
			}
			if (sItem.type == 5120)
			{
				num19 = 10;
			}
			itemRotation = 0f;
			itemLocation.X = position.X + (float)width * 0.5f + ((float)heldItemFrame.Width * 0.5f - 9f - itemRotation * 14f * (float)direction - 4f - (float)num19) * (float)direction;
			itemLocation.Y = position.Y + (float)heldItemFrame.Height * 0.5f + 4f + mountOffset + (float)num20;
			if (gravDir == -1f)
			{
				itemRotation = 0f - itemRotation;
				itemLocation.Y = position.Y + (float)height + (position.Y - itemLocation.Y);
			}
		}
		else if (sItem.useStyle == 5)
		{
			if (sItem.type == 3779)
			{
				itemRotation = 0f;
				itemLocation.X = base.Center.X + (float)(6 * direction);
				itemLocation.Y = MountedCenter.Y + 6f;
			}
			else if (sItem.type == 4262)
			{
				itemRotation = 0f;
				itemLocation.X = base.Center.X + (float)(direction * -6);
				itemLocation.Y = MountedCenter.Y - 6f;
				if (Main.rand.Next(20) == 0)
				{
					int num21 = Main.rand.Next(570, 573);
					Vector2 val2 = default(Vector2);
					((Vector2)(ref val2))..ctor(base.Center.X + (float)(direction * 30) - 6f, itemLocation.Y - 30f);
					Vector2 val3 = default(Vector2);
					((Vector2)(ref val3))..ctor(Main.WindForVisuals * 2f + (float)direction * 0.3f, -0.5f);
					val3.X *= 1f + (float)Main.rand.Next(-50, 51) * 0.01f;
					val3.Y *= 1f + (float)Main.rand.Next(-50, 51) * 0.01f;
					if (num21 == 572)
					{
						val2.X -= 8f;
					}
					if (num21 == 571)
					{
						val2.X -= 4f;
					}
					Gore.NewGore(val2, val3, num21, 0.8f);
				}
			}
			else if (Item.staff[sItem.type])
			{
				float num22 = 6f;
				if (sItem.type == 3476)
				{
					num22 = 14f;
				}
				itemLocation = MountedCenter;
				itemLocation += (itemRotation.ToRotationVector2() * num22 * (float)direction).Floor();
			}
			else
			{
				itemLocation.X = position.X + (float)width * 0.5f - (float)(direction * 2);
				itemLocation.Y = MountedCenter.Y - (float)heldItemFrame.Height * 0.5f;
			}
			if (sItem.type != 5065)
			{
				return;
			}
			_ = itemRotation;
			Vector2 val4 = itemLocation + itemRotation.ToRotationVector2() * 38f * (float)direction;
			Vector2 val5 = itemRotation.ToRotationVector2() * 5f * (float)direction;
			if (itemAnimation % 2 == 0)
			{
				Color newColor = Main.hslToRgb(0.92f, 1f, 0.5f);
				int num23 = Dust.NewDust(val4, 0, 0, 267, 0f, 0f, 0, newColor);
				Main.dust[num23].position = val4 - velocity + Main.rand.NextVector2Circular(10f, 10f);
				Main.dust[num23].noGravity = true;
				Main.dust[num23].scale = 0.3f;
				Main.dust[num23].fadeIn = Main.rand.NextFloat() * 1.2f;
				Main.dust[num23].velocity = Main.rand.NextVector2Circular(1f, 1f) + velocity;
				if (num23 != 6000)
				{
					Dust dust = Dust.CloneDust(num23);
					dust.scale /= 2f;
					dust.fadeIn *= 0.85f;
					dust.color = new Color(255, 255, 255, 255);
				}
			}
			if (itemAnimation % 4 == 0)
			{
				ParticleOrchestrator.RequestParticleSpawn(clientOnly: true, ParticleOrchestraType.PrincessWeapon, new ParticleOrchestraSettings
				{
					PositionInWorld = val4,
					MovementVector = val5 * 0.1f + Main.rand.NextVector2Circular(2f, 2f) + velocity
				}, whoAmI);
			}
		}
		else if (sItem.useStyle == 13)
		{
			int useAnimation = itemAnimationMax;
			if (itemTimeMax != 0)
			{
				useAnimation = itemTimeMax;
			}
			if (useAnimation == 0)
			{
				useAnimation = sItem.useAnimation;
			}
			float num24 = 1f - (float)(itemAnimation % useAnimation) / (float)useAnimation;
			CompositeArmStretchAmount stretch = CompositeArmStretchAmount.Quarter;
			if (num24 > 0.33f && num24 <= 0.66f)
			{
				stretch = CompositeArmStretchAmount.ThreeQuarters;
			}
			if (num24 > 0.66f && num24 <= 1f)
			{
				stretch = CompositeArmStretchAmount.Full;
			}
			float rotation = itemRotation * Directions.Y - (float)Math.PI / 2f * (float)direction;
			SetCompositeArmFront(enabled: true, stretch, rotation);
		}
		else if (sItem.useStyle == 8)
		{
			Projectile projectile = null;
			if (ownedProjectileCounts[722] > 0)
			{
				for (int i = 0; i < 1000; i++)
				{
					Projectile projectile2 = Main.projectile[i];
					if (projectile2.active && projectile2.owner == whoAmI && projectile2.type == 722)
					{
						projectile = projectile2;
						break;
					}
				}
			}
			float num25 = 1f;
			if (projectile != null)
			{
				num25 = MathHelper.Lerp(0.6f, 1f, Utils.GetLerpValue(0f, 800f, Vector2.Distance(MountedCenter, projectile.Center), clamped: true));
			}
			num25 = 1f;
			if (itemAnimation >= sItem.useAnimation - 1 && itemAnimation <= sItem.useAnimation)
			{
				float num26 = Utils.ToRotation(new Vector2((float)(10 * direction), 10f)) + (float)Math.PI / 4f;
				itemRotation = num26;
				if (direction == -1)
				{
					itemRotation += (float)Math.PI / 2f;
				}
				_ = (float)itemAnimation / (float)itemAnimationMax;
				CompositeArmStretchAmount stretch2 = CompositeArmStretchAmount.Full;
				CompositeArmStretchAmount stretch3 = CompositeArmStretchAmount.ThreeQuarters;
				float num27 = -(float)Math.PI / 10f;
				if (direction == -1)
				{
					num27 *= -1f;
				}
				float num28 = itemRotation - (float)Math.PI / 4f + (float)Math.PI;
				if (direction == 1)
				{
					num28 += (float)Math.PI / 2f;
				}
				float rotation2 = num28 + num27;
				float rotation3 = num28 - num27;
				Vector2 val6 = (num28 + (float)Math.PI / 2f).ToRotationVector2() * -2f;
				itemLocation = (MountedCenter + val6).Floor();
				SetCompositeArmFront(enabled: true, stretch2, rotation2);
				SetCompositeArmBack(enabled: true, stretch3, rotation3);
			}
			else if (itemAnimation > sItem.useAnimation)
			{
				float num29 = 0f - Utils.GetLerpValue(itemAnimationMax, itemAnimationMax * 5, itemAnimation, clamped: true);
				num29 *= num25;
				CompositeArmStretchAmount stretch4 = CompositeArmStretchAmount.Full;
				CompositeArmStretchAmount stretch5 = CompositeArmStretchAmount.ThreeQuarters;
				float num30 = -(float)Math.PI / 10f;
				num30 *= 0f - num29;
				itemRotation = (float)Math.PI / 2f * (float)(-direction) + (float)Math.PI + (float)Math.PI * num29 * (float)(-direction);
				float num31 = -(float)Math.PI / 5f * (float)direction;
				if (direction < 1)
				{
					num30 *= -1f;
				}
				float rotation4 = num31 + num30;
				float rotation5 = num31 - num30;
				Vector2 val7 = default(Vector2);
				((Vector2)(ref val7))..ctor((float)(10 * direction), num29 * -6f);
				itemLocation = (MountedCenter + val7).Floor();
				SetCompositeArmFront(enabled: true, stretch4, rotation4);
				SetCompositeArmBack(enabled: true, stretch5, rotation5);
			}
			else
			{
				float num32 = 1f - (float)itemAnimation / (float)itemAnimationMax;
				CompositeArmStretchAmount stretch6 = CompositeArmStretchAmount.Full;
				CompositeArmStretchAmount stretch7 = CompositeArmStretchAmount.ThreeQuarters;
				if (num32 > 0.6f)
				{
					stretch7 = CompositeArmStretchAmount.Quarter;
				}
				float num33 = -(float)Math.PI / 10f;
				if (direction == -1)
				{
					num33 *= -1f;
				}
				num33 *= 1f - num32 * 2.2f;
				itemRotation = (num32 * (float)Math.PI * 1.6f + -(float)Math.PI / 2f) * num25 * (float)(-direction) + (float)Math.PI;
				float num34 = (num32 * (float)Math.PI * 0.6f + (float)Math.PI * 2f / 5f) * (float)(-direction) + (float)Math.PI - (float)Math.PI / 4f + (float)Math.PI;
				if (direction == 1)
				{
					num34 += (float)Math.PI / 2f;
				}
				float rotation6 = num34 + num33;
				float rotation7 = num34 - num33;
				Vector2 val8 = (num34 + (float)Math.PI / 2f).ToRotationVector2() * (-5f * (1f - num32));
				itemLocation = (MountedCenter + val8).Floor();
				SetCompositeArmFront(enabled: true, stretch6, rotation6);
				SetCompositeArmBack(enabled: true, stretch7, rotation7);
			}
			FlipItemLocationAndRotationForGravity();
		}
		else if (sItem.useStyle == 12)
		{
			itemRotation = 0f;
			itemLocation.X = MountedCenter.X - (float)(8 * direction);
			itemLocation.Y = position.Y + 40f + mountOffset;
			Vector2 val9 = Main.OffsetsPlayerHeadgear[bodyFrame.Y / 56];
			itemLocation += val9;
			float num35 = itemAnimationMax;
			if (num35 == 0f)
			{
				num35 = sItem.useAnimation;
			}
			float num36 = 1f - (float)itemAnimation / num35;
			num36 *= 2f;
			float num37 = (float)Math.Cos(num36 * (float)Math.PI) * 0.2f;
			CompositeArmStretchAmount compositeArmStretchAmount3 = CompositeArmStretchAmount.Full;
			if (num36 > 0.25f && num36 <= 0.5f)
			{
				compositeArmStretchAmount3 = CompositeArmStretchAmount.ThreeQuarters;
			}
			if (num36 > 0.5f && num36 <= 0.75f)
			{
				compositeArmStretchAmount3 = CompositeArmStretchAmount.Quarter;
			}
			if (num36 > 0.75f && num36 <= 1.25f)
			{
				compositeArmStretchAmount3 = CompositeArmStretchAmount.None;
			}
			if (num36 > 1.25f && num36 <= 1.5f)
			{
				compositeArmStretchAmount3 = CompositeArmStretchAmount.Quarter;
			}
			if (num36 > 1.5f && num36 <= 1.75f)
			{
				compositeArmStretchAmount3 = CompositeArmStretchAmount.ThreeQuarters;
			}
			if (num36 > 1.75f && num36 <= 2f)
			{
				compositeArmStretchAmount3 = CompositeArmStretchAmount.Full;
			}
			SetCompositeArmFront(enabled: true, compositeArmStretchAmount3, (-(float)Math.PI / 4f + num37) * (float)direction);
			CompositeArmStretchAmount stretch8 = CompositeArmStretchAmount.Quarter;
			SetCompositeArmBack(enabled: true, stretch8, (-(float)Math.PI / 4f - num37 * 0.5f) * (float)direction);
			FlipItemLocationAndRotationForGravity();
			if (sItem.type != 4715 || compositeArmStretchAmount3 != CompositeArmStretchAmount.ThreeQuarters)
			{
				return;
			}
			Vector2 val10 = itemLocation + new Vector2((float)heldItemFrame.Width, (float)(-heldItemFrame.Height)) * new Vector2((float)direction, gravDir) * 0.3f;
			Dust dust2 = Dust.NewDustPerfect(val10, 228, Main.rand.NextVector2CircularEdge(1f, 1f));
			dust2.noGravity = true;
			dust2.noLight = true;
			dust2.velocity *= 2f;
			float num38 = 0.5f;
			for (float num39 = 0f; num39 < 1f; num39 += 0.5f)
			{
				if (Main.rand.Next(3) == 0)
				{
					Dust dust3 = Dust.NewDustPerfect(val10, 278, Vector2.UnitY.RotatedBy(num39 * ((float)Math.PI * 2f) + Main.rand.NextFloat() * num38 - num38 * 0.5f + (float)Math.PI / 2f) * (2f + Main.rand.NextFloat() * 1f), 150, Color.Lerp(Color.White, Color.HotPink, Main.rand.NextFloat() * 0.5f + 0.5f), 0.45f);
					dust3.noGravity = true;
					dust3.velocity *= 0.5f;
					dust3.customData = this;
					dust3.position += dust3.velocity * 6f;
				}
			}
			for (float num40 = 0f; num40 < 1f; num40 += 0.5f)
			{
				if (Main.rand.Next(3) == 0)
				{
					Dust dust4 = Dust.NewDustPerfect(val10, 278, Vector2.UnitY.RotatedBy(num40 * ((float)Math.PI * 2f) + Main.rand.NextFloat() * num38 - num38 * 0.5f + (float)Math.PI / 2f) * (0.5f + Main.rand.NextFloat() * 1f), 150, Color.Lerp(Color.White, Color.Gold, Main.rand.NextFloat() * 0.5f + 0.5f), 0.45f);
					dust4.noGravity = true;
					dust4.velocity *= 0.5f;
					dust4.customData = this;
					dust4.position += dust4.velocity * 6f;
				}
			}
		}
		else if (sItem.useStyle == 14 && !Main.dedServ)
		{
			itemRotation = 0f;
			itemLocation.X = base.Center.X + (float)(6 * direction);
			itemLocation.Y = position.Y + 40f + mountOffset - 8f;
			Vector2 val11 = Main.OffsetsPlayerHeadgear[bodyFrame.Y / 56];
			itemLocation += val11;
			CompositeArmStretchAmount stretch9 = CompositeArmStretchAmount.Full;
			SetCompositeArmBack(enabled: true, stretch9, (float)Math.PI * -3f / 4f * (float)direction);
			FlipItemLocationAndRotationForGravity();
		}
	}

	public void FlipItemLocationAndRotationForGravity()
	{
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		if (gravDir == -1f)
		{
			itemRotation = 0f - itemRotation;
			float num = position.Y - itemLocation.Y;
			itemLocation.Y = base.Bottom.Y + num;
		}
	}

	private void ItemCheck_StartActualUse(Item sItem)
	{
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		bool flag = sItem.type == 4711;
		if (sItem.pick > 0 || sItem.axe > 0 || sItem.hammer > 0 || flag)
		{
			toolTime = 1;
		}
		if (grappling[0] > -1 || sItem.useTurnOnAnimationStart)
		{
			pulley = false;
			pulleyDir = 1;
			if (controlRight)
			{
				direction = 1;
			}
			else if (controlLeft)
			{
				direction = -1;
			}
		}
		StartChanneling(sItem);
		attackCD = 0;
		ResetMeleeHitCooldowns();
		ApplyItemAnimation(sItem);
		bool flag2 = ItemID.Sets.SkipsInitialUseSound[sItem.type];
		if (sItem.UseSound.HasValue && !flag2)
		{
			SoundEngine.PlaySound(sItem.UseSound, base.Center);
		}
	}

	private void FreeUpPetsAndMinions(Item sItem)
	{
		if (ProjectileID.Sets.MinionSacrificable[sItem.shoot])
		{
			List<int> list = new List<int>();
			float num = 0f;
			for (int i = 0; i < 1000; i++)
			{
				if (!Main.projectile[i].active || Main.projectile[i].owner != whoAmI || !Main.projectile[i].minion)
				{
					continue;
				}
				int j;
				for (j = 0; j < list.Count; j++)
				{
					if (Main.projectile[list[j]].minionSlots > Main.projectile[i].minionSlots)
					{
						list.Insert(j, i);
						break;
					}
				}
				if (j == list.Count)
				{
					list.Add(i);
				}
				num += Main.projectile[i].minionSlots;
			}
			float num2 = ItemID.Sets.StaffMinionSlotsRequired[sItem.type];
			float num3 = 0f;
			int num4 = 388;
			int num5 = -1;
			for (int k = 0; k < list.Count; k++)
			{
				int type = Main.projectile[list[k]].type;
				if (type == 626)
				{
					list.RemoveAt(k);
					k--;
				}
				if (type == 627)
				{
					if (Main.projectile[(int)Main.projectile[list[k]].localAI[1]].type == 628)
					{
						num5 = list[k];
					}
					list.RemoveAt(k);
					k--;
				}
			}
			if (num5 != -1)
			{
				list.Add(num5);
				list.Add(Projectile.GetByUUID(Main.projectile[num5].owner, Main.projectile[num5].ai[0]));
			}
			for (int l = 0; l < list.Count; l++)
			{
				if (!(num - num3 > (float)maxMinions - num2 + 1E-05f))
				{
					break;
				}
				int type2 = Main.projectile[list[l]].type;
				if (type2 == num4 || type2 == 625 || type2 == 628 || type2 == 623)
				{
					continue;
				}
				if (type2 == 388 && num4 == 387)
				{
					num4 = 388;
				}
				if (type2 == 387 && num4 == 388)
				{
					num4 = 387;
				}
				num3 += Main.projectile[list[l]].minionSlots;
				if (type2 == 626 || type2 == 627)
				{
					Projectile projectile = Main.projectile[list[l]];
					int byUUID = Projectile.GetByUUID(projectile.owner, projectile.ai[0]);
					if (Main.projectile.IndexInRange(byUUID))
					{
						Projectile projectile2 = Main.projectile[byUUID];
						if (projectile2.type != 625)
						{
							projectile2.localAI[1] = projectile.localAI[1];
						}
						projectile2 = Main.projectile[(int)projectile.localAI[1]];
						projectile2.ai[0] = projectile.ai[0];
						projectile2.ai[1] = 1f;
						projectile2.netUpdate = true;
					}
				}
				Main.projectile[list[l]].Kill();
			}
			list.Clear();
			if (num + num2 >= 9f)
			{
				AchievementsHelper.HandleSpecialEvent(this, 6);
			}
			return;
		}
		for (int m = 0; m < 1000; m++)
		{
			Projectile projectile3 = Main.projectile[m];
			if (projectile3.active && projectile3.owner == whoAmI)
			{
				if (projectile3.type == sItem.shoot)
				{
					projectile3.Kill();
				}
				if (sItem.shoot == 72 && (projectile3.type == 86 || projectile3.type == 87))
				{
					projectile3.Kill();
				}
				if (sItem.type == 5131 && (projectile3.type == 881 || projectile3.type == 934))
				{
					projectile3.Kill();
				}
			}
		}
	}

	private void ApplyPotionDelay(Item sItem)
	{
		int baseDelay = sItem.type switch
		{
			3001 => Main.rand.Next(2400, 4201), 
			227 => restorationDelayTime, 
			5 => mushroomDelayTime, 
			_ => potionDelayTime, 
		};
		ItemLoader.ModifyPotionDelay(sItem, this, ref baseDelay);
		int num = (int)PotionDelayModifier.ApplyTo(baseDelay);
		if (CombinedHooks.ApplyPotionDelay(sItem, this, num) && num > 0)
		{
			potionDelay = num;
			AddBuff(21, potionDelay);
			if (sItem.type == 5)
			{
				TryToResetHungerToNeutral();
			}
		}
	}

	private void ApplyLifeAndOrMana(Item item)
	{
		int num = ((item.healLife > 0) ? GetHealLife(item, quickHeal: true) : 0);
		int num2 = ((item.healMana > 0) ? GetHealMana(item, quickHeal: true) : 0);
		if (item.type == 3001)
		{
			int healLife = item.healLife;
			int num3 = 120;
			num = Main.rand.Next(healLife, num3 + 1);
			if (Main.myPlayer == whoAmI)
			{
				float num4 = Main.rand.NextFloat();
				int num5 = 0;
				if (num4 <= 0.1f)
				{
					num5 = 240;
				}
				else if (num4 <= 0.3f)
				{
					num5 = 120;
				}
				else if (num4 <= 0.6f)
				{
					num5 = 60;
				}
				if (num5 > 0)
				{
					SetImmuneTimeForAllTypes(num5);
				}
			}
		}
		statLife += num;
		statMana += num2;
		if (statLife > statLifeMax2)
		{
			statLife = statLifeMax2;
		}
		if (statMana > statManaMax2)
		{
			statMana = statManaMax2;
		}
		if (num > 0 && Main.myPlayer == whoAmI)
		{
			HealEffect(num);
		}
		if (num2 > 0)
		{
			AddBuff(94, manaSickTime);
			if (Main.myPlayer == whoAmI)
			{
				ManaEffect(num2);
			}
		}
	}

	private bool ItemCheck_CheckCanUse(Item sItem)
	{
		if (sItem.IsAir || !CombinedHooks.CanUseItem(this, sItem))
		{
			return false;
		}
		int num = whoAmI;
		bool flag = true;
		int num2 = (int)((float)Main.mouseX + Main.screenPosition.X) / 16;
		int num3 = (int)((float)Main.mouseY + Main.screenPosition.Y) / 16;
		if (gravDir == -1f)
		{
			num3 = (int)(Main.screenPosition.Y + (float)Main.screenHeight - (float)Main.mouseY) / 16;
		}
		if (sItem.type == 3335 && (extraAccessory || !Main.expertMode))
		{
			flag = false;
		}
		if (pulley && sItem.fishingPole > 0)
		{
			flag = false;
		}
		if (pulley && ItemID.Sets.IsAKite[sItem.type])
		{
			flag = false;
		}
		if (sItem.type == 3611 && (WiresUI.Settings.ToolMode & (WiresUI.Settings.MultiToolMode.Red | WiresUI.Settings.MultiToolMode.Green | WiresUI.Settings.MultiToolMode.Blue | WiresUI.Settings.MultiToolMode.Yellow | WiresUI.Settings.MultiToolMode.Actuator)) == 0)
		{
			flag = false;
		}
		if (sItem.type == 5451 && ownedProjectileCounts[1020] > 0)
		{
			flag = false;
		}
		if ((sItem.type == 3611 || sItem.type == 3625) && wireOperationsCooldown > 0)
		{
			flag = false;
		}
		if (!CheckDD2CrystalPaymentLock(sItem))
		{
			flag = false;
		}
		if (sItem.shoot > -1 && ProjectileID.Sets.IsADD2Turret[sItem.shoot] && !downedDD2EventAnyDifficulty && !DD2Event.Ongoing)
		{
			flag = false;
		}
		int pushYUp;
		if (sItem.shoot > -1 && ProjectileID.Sets.IsADD2Turret[sItem.shoot] && DD2Event.Ongoing && num == Main.myPlayer)
		{
			FindSentryRestingSpot(sItem.shoot, out var worldX, out var worldY, out pushYUp);
			if (WouldSpotOverlapWithSentry(worldX, worldY, sItem.shoot == 688 || sItem.shoot == 689 || sItem.shoot == 690))
			{
				flag = false;
			}
		}
		if (sItem.shoot > -1 && ProjectileID.Sets.IsADD2Turret[sItem.shoot] && num == Main.myPlayer)
		{
			FindSentryRestingSpot(sItem.shoot, out var worldX2, out var worldY2, out pushYUp);
			worldX2 /= 16;
			worldY2 /= 16;
			worldY2--;
			if (sItem.shoot == 688 || sItem.shoot == 689 || sItem.shoot == 690)
			{
				if (Collision.SolidTiles(worldX2, worldX2, worldY2 - 2, worldY2))
				{
					flag = false;
				}
			}
			else if (WorldGen.SolidTile(worldX2, worldY2))
			{
				flag = false;
			}
		}
		if (wet && (sItem.shoot == 85 || sItem.shoot == 15 || sItem.shoot == 34))
		{
			flag = false;
		}
		if (sItem.makeNPC > 0 && !NPC.CanReleaseNPCs(whoAmI))
		{
			flag = false;
		}
		if (whoAmI == Main.myPlayer && sItem.type == 603 && !Main.runningCollectorsEdition)
		{
			flag = false;
		}
		if (sItem.type == 1071 || sItem.type == 1072)
		{
			bool flag2 = false;
			for (int i = 0; i < 58; i++)
			{
				if (inventory[i].PaintOrCoating)
				{
					flag2 = true;
					break;
				}
			}
			if (!flag2)
			{
				flag = false;
			}
		}
		if (noItems)
		{
			flag = false;
		}
		if (sItem.tileWand > 0)
		{
			int tileWand = sItem.tileWand;
			flag = false;
			for (int j = 0; j < 58; j++)
			{
				if (tileWand == inventory[j].type && inventory[j].stack > 0)
				{
					flag = true;
					break;
				}
			}
		}
		if (sItem.shoot == 6 || sItem.shoot == 19 || sItem.shoot == 33 || sItem.shoot == 52 || sItem.shoot == 113 || sItem.shoot == 320 || sItem.shoot == 333 || sItem.shoot == 383 || sItem.shoot == 491 || sItem.shoot == 867 || sItem.shoot == 902 || sItem.shoot == 866)
		{
			for (int k = 0; k < 1000; k++)
			{
				if (Main.projectile[k].active && Main.projectile[k].owner == Main.myPlayer && Main.projectile[k].type == sItem.shoot)
				{
					flag = false;
				}
			}
		}
		if (sItem.shoot == 106)
		{
			int num4 = 0;
			for (int l = 0; l < 1000; l++)
			{
				if (Main.projectile[l].active && Main.projectile[l].owner == Main.myPlayer && Main.projectile[l].type == sItem.shoot)
				{
					num4++;
				}
			}
			if (num4 >= 6)
			{
				flag = false;
			}
		}
		if (sItem.shoot == 272)
		{
			int num5 = 0;
			for (int m = 0; m < 1000; m++)
			{
				if (Main.projectile[m].active && Main.projectile[m].owner == Main.myPlayer && Main.projectile[m].type == sItem.shoot)
				{
					num5++;
				}
			}
			if (num5 >= 10)
			{
				flag = false;
			}
		}
		if (sItem.shoot == 1000)
		{
			int num6 = 0;
			for (int n = 0; n < 1000; n++)
			{
				if (Main.projectile[n].active && Main.projectile[n].owner == Main.myPlayer && Main.projectile[n].type == sItem.shoot)
				{
					num6++;
				}
			}
			if (num6 >= 3)
			{
				flag = false;
			}
		}
		if (sItem.shoot == 13 || sItem.shoot == 32 || (sItem.shoot >= 230 && sItem.shoot <= 235) || sItem.shoot == 315 || sItem.shoot == 331 || sItem.shoot == 372)
		{
			for (int num7 = 0; num7 < 1000; num7++)
			{
				if (Main.projectile[num7].active && Main.projectile[num7].owner == Main.myPlayer && Main.projectile[num7].type == sItem.shoot && Main.projectile[num7].ai[0] != 2f)
				{
					flag = false;
				}
			}
		}
		if (sItem.shoot == 332)
		{
			int num8 = 0;
			for (int num9 = 0; num9 < 1000; num9++)
			{
				if (Main.projectile[num9].active && Main.projectile[num9].owner == Main.myPlayer && Main.projectile[num9].type == sItem.shoot && Main.projectile[num9].ai[0] != 2f)
				{
					num8++;
				}
			}
			if (num8 >= 3)
			{
				flag = false;
			}
		}
		if (sItem.potion && potionDelay > 0)
		{
			flag = false;
		}
		if (sItem.mana > 0 && silence)
		{
			flag = false;
		}
		if (sItem.mana > 0 && flag)
		{
			flag = ItemCheck_PayMana(sItem, flag);
		}
		if (sItem.type == 43 && Main.IsItDay())
		{
			flag = false;
		}
		if (sItem.type == 544 && Main.IsItDay())
		{
			flag = false;
		}
		if (sItem.type == 556 && Main.IsItDay())
		{
			flag = false;
		}
		if (sItem.type == 557 && Main.IsItDay())
		{
			flag = false;
		}
		if (sItem.type == 70 && !ZoneCorrupt)
		{
			flag = false;
		}
		if (sItem.type == 1133 && !ZoneJungle)
		{
			flag = false;
		}
		if (sItem.type == 5120 && !ZoneSnow)
		{
			flag = false;
		}
		if (sItem.type == 1844 && (Main.dayTime || Main.pumpkinMoon || Main.snowMoon || DD2Event.Ongoing))
		{
			flag = false;
		}
		if (sItem.type == 1958 && (Main.dayTime || Main.pumpkinMoon || Main.snowMoon || DD2Event.Ongoing))
		{
			flag = false;
		}
		if (sItem.type == 2767 && (!Main.dayTime || Main.eclipse || !Main.hardMode))
		{
			flag = false;
		}
		if (sItem.type == 4271 && (Main.dayTime || Main.bloodMoon))
		{
			flag = false;
		}
		if (sItem.type == 3601 && (!NPC.downedGolemBoss || !Main.hardMode || NPC.AnyDanger() || NPC.AnyoneNearCultists()))
		{
			flag = false;
		}
		if (!SummonItemCheck(sItem))
		{
			flag = false;
		}
		if (sItem.shoot == 17 && flag && num == Main.myPlayer && !ItemCheck_IsValidDirtRodTarget(Main.tile[num2, num3]))
		{
			flag = false;
		}
		if (sItem.chlorophyteExtractinatorConsumable && flag && num == Main.myPlayer)
		{
			Tile tile = Main.tile[num2, num3];
			if (!tile.active() || (tile.type != 642 && tile.type != 219))
			{
				flag = false;
			}
		}
		if (sItem.fishingPole > 0)
		{
			flag = ItemCheck_CheckFishingBobbers(flag);
		}
		if (ItemID.Sets.HasAProjectileThatHasAUsabilityCheck[sItem.type])
		{
			flag = ItemCheck_CheckUsabilityOfProjectiles(flag);
		}
		if (sItem.shoot == 17 && flag && num == Main.myPlayer)
		{
			if (ItemCheck_IsValidDirtRodTarget(Main.tile[num2, num3]))
			{
				WorldGen.KillTile(num2, num3, fail: false, effectOnly: false, noItem: true);
				if (!Main.tile[num2, num3].active())
				{
					if (Main.netMode == 1)
					{
						NetMessage.SendData(17, -1, -1, null, 4, num2, num3);
					}
				}
				else
				{
					flag = false;
				}
			}
			else
			{
				flag = false;
			}
		}
		if (flag)
		{
			flag = HasAmmo(sItem, flag);
		}
		return flag;
	}

	private bool ItemCheck_CheckUsabilityOfProjectiles(bool canUse)
	{
		for (int i = 0; i < 1000; i++)
		{
			Projectile projectile = Main.projectile[i];
			if (projectile.active && projectile.owner == whoAmI)
			{
				projectile.CheckUsability(this, ref canUse);
			}
		}
		return canUse;
	}

	private bool ItemCheck_CheckFishingBobbers(bool canUse)
	{
		for (int i = 0; i < 1000; i++)
		{
			Projectile projectile = Main.projectile[i];
			if (!projectile.active || projectile.owner != whoAmI || !projectile.bobber)
			{
				continue;
			}
			canUse = false;
			if (whoAmI != Main.myPlayer || projectile.ai[0] != 0f)
			{
				continue;
			}
			projectile.ai[0] = 1f;
			float num = -10f;
			if (projectile.wet && projectile.velocity.Y > num)
			{
				projectile.velocity.Y = num;
			}
			projectile.netUpdate2 = true;
			if (projectile.ai[1] < 0f && projectile.localAI[1] != 0f)
			{
				ItemCheck_CheckFishingBobber_PickAndConsumeBait(projectile, out var pullTheBobber, out var baitTypeUsed);
				if (pullTheBobber)
				{
					ItemCheck_CheckFishingBobber_PullBobber(projectile, baitTypeUsed);
				}
			}
		}
		return canUse;
	}

	private void ItemCheck_CheckFishingBobber_PullBobber(Projectile bobber, int baitTypeUsed)
	{
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		if (baitTypeUsed == 2673)
		{
			if (Main.netMode != 1)
			{
				NPC.SpawnOnPlayer(whoAmI, 370);
			}
			else
			{
				NetMessage.SendData(61, -1, -1, null, whoAmI, 370f);
			}
			bobber.ai[0] = 2f;
		}
		else if (bobber.localAI[1] < 0f)
		{
			Point val = default(Point);
			((Point)(ref val))..ctor((int)bobber.position.X, (int)bobber.position.Y);
			int num = (int)(0f - bobber.localAI[1]);
			if (num == 618)
			{
				val.Y += 64;
			}
			if (Main.netMode == 1)
			{
				NetMessage.SendData(130, -1, -1, null, val.X / 16, val.Y / 16, num);
			}
			else
			{
				if (num == 682)
				{
					NPC.unlockedSlimeRedSpawn = true;
				}
				NPC.NewNPC(new EntitySource_FishedOut(this), val.X, val.Y, num);
				bobber.ai[0] = 2f;
				WorldGen.CheckAchievement_RealEstateAndTownSlimes();
			}
		}
		else if (Main.rand.Next(7) == 0 && !accFishingLine)
		{
			bobber.ai[0] = 2f;
		}
		else
		{
			bobber.ai[1] = bobber.localAI[1];
		}
		bobber.netUpdate = true;
	}

	private void ItemCheck_CheckFishingBobber_PickAndConsumeBait(Projectile bobber, out bool pullTheBobber, out int baitTypeUsed)
	{
		//IL_016c: Unknown result type (might be due to invalid IL or missing references)
		pullTheBobber = false;
		baitTypeUsed = 0;
		int num = -1;
		for (int i = 54; i < 58; i++)
		{
			if (inventory[i].stack > 0 && inventory[i].bait > 0)
			{
				num = i;
				break;
			}
		}
		if (num == -1)
		{
			for (int j = 0; j < 50; j++)
			{
				if (inventory[j].stack > 0 && inventory[j].bait > 0)
				{
					num = j;
					break;
				}
			}
		}
		if (num <= -1)
		{
			return;
		}
		Item item = inventory[num];
		bool flag = false;
		float num2 = 1f + (float)item.bait / 6f;
		if (num2 < 1f)
		{
			num2 = 1f;
		}
		if (accTackleBox)
		{
			num2 += 1f;
		}
		if (Main.rand.NextFloat() * num2 < 1f)
		{
			flag = true;
		}
		if (bobber.localAI[1] == -1f)
		{
			flag = true;
		}
		if (bobber.localAI[1] > 0f)
		{
			Item item2 = new Item();
			item2.SetDefaults((int)bobber.localAI[1]);
			if (item2.rare < 0)
			{
				flag = false;
			}
		}
		baitTypeUsed = item.type;
		if (baitTypeUsed == 2895)
		{
			flag = Main.rand.Next(20) == 0;
		}
		if (baitTypeUsed == 2673)
		{
			flag = true;
		}
		if (CombinedHooks.CanConsumeBait(this, item) ?? flag)
		{
			if (item.type == 4361 || item.type == 4362)
			{
				NPC.LadyBugKilled(base.Center, item.type == 4362);
			}
			item.stack--;
			if (item.stack <= 0)
			{
				item.SetDefaults();
			}
		}
		pullTheBobber = true;
	}

	private static bool ItemCheck_IsValidDirtRodTarget(Tile t)
	{
		if (t.active())
		{
			if (t.type != 0 && t.type != 2 && t.type != 23 && t.type != 109 && t.type != 199 && t.type != 477)
			{
				return t.type == 492;
			}
			return true;
		}
		return false;
	}

	private bool ItemCheck_PayMana(Item sItem, bool canUse)
	{
		bool flag = altFunctionUse == 2;
		bool flag2 = false;
		int num = (int)((float)sItem.mana * manaCost);
		if (sItem.type == 2795)
		{
			flag2 = true;
		}
		if (sItem.type == 3852 && flag)
		{
			num = (int)((float)(sItem.mana * 2) * manaCost);
		}
		if (sItem.shoot > 0 && ProjectileID.Sets.TurretFeature[sItem.shoot] && flag)
		{
			flag2 = true;
		}
		if (sItem.shoot > 0 && ProjectileID.Sets.MinionTargettingFeature[sItem.shoot] && flag)
		{
			flag2 = true;
		}
		if (sItem.type == 3006)
		{
			flag2 = true;
		}
		if (sItem.type != 3269 && !CheckMana(sItem, -1, !flag2))
		{
			canUse = false;
		}
		return canUse;
	}

	private void ItemCheck_TryPlacingWearablesOnMannequins(Item sItem)
	{
		if (!controlUseItem || !releaseUseItem || (sItem.headSlot <= 0 && sItem.bodySlot <= 0 && sItem.legSlot <= 0))
		{
			return;
		}
		if (sItem.useStyle == 0)
		{
			releaseUseItem = false;
		}
		if (!(position.X / 16f - (float)tileRangeX - (float)sItem.tileBoost <= (float)tileTargetX) || !((position.X + (float)width) / 16f + (float)tileRangeX + (float)sItem.tileBoost - 1f >= (float)tileTargetX) || !(position.Y / 16f - (float)tileRangeY - (float)sItem.tileBoost <= (float)tileTargetY) || !((position.Y + (float)height) / 16f + (float)tileRangeY + (float)sItem.tileBoost - 2f >= (float)tileTargetY))
		{
			return;
		}
		int num = tileTargetX;
		int num2 = tileTargetY;
		if (!Main.tile[num, num2].active() || (Main.tile[num, num2].type != 128 && Main.tile[num, num2].type != 269))
		{
			return;
		}
		int frameY = Main.tile[num, num2].frameY;
		int num3 = 0;
		if (sItem.bodySlot >= 0)
		{
			num3 = 1;
		}
		if (sItem.legSlot >= 0)
		{
			num3 = 2;
		}
		frameY /= 18;
		while (num3 > frameY)
		{
			num2++;
			frameY = Main.tile[num, num2].frameY;
			frameY /= 18;
		}
		while (num3 < frameY)
		{
			num2--;
			frameY = Main.tile[num, num2].frameY;
			frameY /= 18;
		}
		int num4;
		for (num4 = Main.tile[num, num2].frameX; num4 >= 100; num4 -= 100)
		{
		}
		if (num4 >= 36)
		{
			num4 -= 36;
		}
		num -= num4 / 18;
		int num5 = Main.tile[num, num2].frameX;
		WorldGen.KillTile(num, num2, fail: true);
		if (Main.netMode == 1)
		{
			NetMessage.SendData(17, -1, -1, null, 0, num, num2, 1f);
		}
		while (num5 >= 100)
		{
			num5 -= 100;
		}
		if (frameY == 0 && sItem.headSlot >= 0)
		{
			Main.blockMouse = true;
			Main.tile[num, num2].frameX = (short)(num5 + sItem.headSlot * 100);
			if (Main.netMode == 1)
			{
				NetMessage.SendTileSquare(-1, num, num2);
			}
			sItem.stack--;
			if (sItem.stack <= 0)
			{
				sItem.SetDefaults();
				Main.mouseItem.SetDefaults();
			}
			if (selectedItem == 58)
			{
				Main.mouseItem = sItem.Clone();
			}
			releaseUseItem = false;
			mouseInterface = true;
		}
		else if (frameY == 1 && sItem.bodySlot >= 0)
		{
			Main.blockMouse = true;
			Main.tile[num, num2].frameX = (short)(num5 + sItem.bodySlot * 100);
			if (Main.netMode == 1)
			{
				NetMessage.SendTileSquare(-1, num, num2);
			}
			sItem.stack--;
			if (sItem.stack <= 0)
			{
				sItem.SetDefaults();
				Main.mouseItem.SetDefaults();
			}
			if (selectedItem == 58)
			{
				Main.mouseItem = sItem.Clone();
			}
			releaseUseItem = false;
			mouseInterface = true;
		}
		else if (frameY == 2 && sItem.legSlot >= 0 && !ArmorIDs.Legs.Sets.MannequinIncompatible.Contains(sItem.legSlot))
		{
			Main.blockMouse = true;
			Main.tile[num, num2].frameX = (short)(num5 + sItem.legSlot * 100);
			if (Main.netMode == 1)
			{
				NetMessage.SendTileSquare(-1, num, num2);
			}
			sItem.stack--;
			if (sItem.stack <= 0)
			{
				sItem.SetDefaults();
				Main.mouseItem.SetDefaults();
			}
			if (selectedItem == 58)
			{
				Main.mouseItem = sItem.Clone();
			}
			releaseUseItem = false;
			mouseInterface = true;
		}
	}

	private void ApplyReuseDelay()
	{
		itemAnimation = reuseDelay;
		itemTime = reuseDelay;
		reuseDelay = 0;
	}

	private void ItemCheck_HackHoldStyles(Item sItem)
	{
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		if (sItem.fishingPole > 0)
		{
			sItem.holdStyle = 0;
			if (ItemTimeIsZero && itemAnimation == 0)
			{
				for (int i = 0; i < 1000; i++)
				{
					if (Main.projectile[i].active && Main.projectile[i].owner == whoAmI && Main.projectile[i].bobber)
					{
						sItem.holdStyle = 1;
					}
				}
			}
		}
		if (!ItemID.Sets.IsAKite[sItem.type])
		{
			return;
		}
		sItem.holdStyle = 0;
		if (!ItemTimeIsZero || itemAnimation != 0)
		{
			return;
		}
		for (int j = 0; j < 1000; j++)
		{
			if (Main.projectile[j].active && Main.projectile[j].owner == whoAmI && Main.projectile[j].type == sItem.shoot)
			{
				sItem.holdStyle = 1;
				ChangeDir((!(Main.projectile[j].Center.X - base.Center.X < 0f)) ? 1 : (-1));
			}
		}
	}

	private void ItemCheck_HandleMPItemAnimation(Item sItem)
	{
		TryAllowingItemReuse(sItem);
	}

	private void TryAllowingItemReuse(Item sItem)
	{
		if (CanAutoReuseItem(sItem))
		{
			releaseUseItem = true;
		}
	}

	public bool CanAutoReuseItem(Item sItem)
	{
		bool? flag = CombinedHooks.CanAutoReuseItem(this, sItem);
		if (flag.HasValue)
		{
			return flag == true;
		}
		bool flag2 = sItem.autoReuse;
		if (autoReuseGlove)
		{
			flag2 |= sItem.CountsAsClass(DamageClass.Melee) || sItem.CountsAsClass(DamageClass.SummonMeleeSpeed);
		}
		if (autoReuseAllWeapons && sItem.damage > 0 && (!sItem.channel || !channel))
		{
			flag2 = true;
		}
		return flag2;
	}

	private void ItemCheck_HandleMount()
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		if (!mount.Active)
		{
			return;
		}
		MountLoader.UseAbility(this, Vector2.Zero, toggleOn: false);
		if (whoAmI == Main.myPlayer && gravDir == -1f)
		{
			mount.Dismount(this);
		}
		else
		{
			if (mount.Type != 8)
			{
				return;
			}
			noItems = true;
			if (controlUseItem || controlUseTile)
			{
				StartChanneling();
				if (releaseUseItem && releaseUseTile)
				{
					mount.UseAbility(this, Vector2.Zero, toggleOn: true);
				}
				releaseUseItem = false;
				releaseUseTile = false;
			}
		}
	}

	public void StartChanneling()
	{
		channel = true;
		_channelShotCache = default(ChannelCancelKey);
	}

	public void StartChanneling(Item item)
	{
		if (item.channel)
		{
			channel = true;
			_channelShotCache = new ChannelCancelKey
			{
				ProjectileTypeExpected = item.shoot
			};
		}
	}

	public void TryUpdateChannel(Projectile projectile)
	{
		_channelShotCache.TryTracking(projectile);
	}

	public void TryCancelChannel(Projectile projectile)
	{
		if (_channelShotCache.Matches(projectile))
		{
			channel = false;
		}
	}

	public static bool WouldSpotOverlapWithSentry(int worldX, int worldY, bool lightningAura)
	{
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		Point val = default(Point);
		((Point)(ref val))..ctor(worldX, worldY - 8);
		Point val2 = default(Point);
		((Point)(ref val2))..ctor(worldX + 16, worldY - 8);
		Point val3 = default(Point);
		((Point)(ref val3))..ctor(worldX - 16, worldY - 8);
		bool result = false;
		for (int i = 0; i < 1000; i++)
		{
			Projectile projectile = Main.projectile[i];
			if (projectile.active && projectile.sentry)
			{
				Rectangle hitbox = projectile.Hitbox;
				if (!lightningAura && hitbox.X > 30)
				{
					hitbox.X += hitbox.Width / 2;
					hitbox.Width = 30;
					hitbox.X -= hitbox.Width / 2;
				}
				if (((Rectangle)(ref hitbox)).Contains(val) || ((Rectangle)(ref hitbox)).Contains(val2) || ((Rectangle)(ref hitbox)).Contains(val3))
				{
					result = true;
					break;
				}
			}
		}
		return result;
	}

	/// <summary>
	/// Determines a suitable spawn location for a "grounded" sentry (<paramref name="checkProj" />). The spawn location will be centered on a tile location at the first 3 tile wide area with at least 1 solid tile, searching down from the mouse position. It will also utilize <see cref="M:Terraria.Player.LimitPointToPlayerReachableArea(Microsoft.Xna.Framework.Vector2@)" /> to limit the mouse position to the normal gameplay range.
	/// <br /><br /> The final spawn position after using this method will be <c>new Vector2(worldX, worldY - offset);</c>, where <c>offset</c> should most likely be half of the projectile height. <paramref name="pushYUp" /> should be ignored for modded projectiles.
	/// </summary>
	public void FindSentryRestingSpot(int checkProj, out int worldX, out int worldY, out int pushYUp)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		bool flag = false;
		Vector2 pointPoisition = Main.MouseWorld;
		LimitPointToPlayerReachableArea(ref pointPoisition);
		int num = (int)pointPoisition.X / 16;
		int i = (int)pointPoisition.Y / 16;
		worldX = num * 16 + 8;
		pushYUp = 41;
		switch (checkProj)
		{
		case 663:
			worldX += direction;
			break;
		case 665:
			pushYUp += 2;
			break;
		case 667:
			pushYUp += 3;
			break;
		case 677:
			worldX += direction;
			break;
		case 678:
			worldX += direction;
			break;
		case 691:
		case 692:
		case 693:
			pushYUp = 20;
			worldX += direction;
			pushYUp += 2;
			break;
		}
		if (!flag)
		{
			for (; i < Main.maxTilesY - 10 && Main.tile[num, i] != null && !WorldGen.SolidTile2(num, i) && Main.tile[num - 1, i] != null && !WorldGen.SolidTile2(num - 1, i) && Main.tile[num + 1, i] != null && !WorldGen.SolidTile2(num + 1, i); i++)
			{
			}
			i++;
		}
		i--;
		pushYUp -= 14;
		worldY = i * 16;
	}

	/// <summary>
	/// Kills <see cref="F:Terraria.Projectile.sentry" /> projectiles exceeding the players current <see cref="F:Terraria.Player.maxTurrets" />. The oldest projectiles, determined by <see cref="F:Terraria.Projectile.timeLeft" />, are killed. <br />
	/// Call this method immediately after spawning a <see cref="F:Terraria.Projectile.sentry" /> projectile.<br />
	/// </summary>
	public void UpdateMaxTurrets()
	{
		if (Main.myPlayer != whoAmI)
		{
			return;
		}
		List<Projectile> list = new List<Projectile>();
		for (int i = 0; i < 1000; i++)
		{
			if (Main.projectile[i].WipableTurret)
			{
				list.Add(Main.projectile[i]);
			}
		}
		int num = 0;
		while (list.Count > maxTurrets && ++num < 1000)
		{
			Projectile projectile = list[0];
			for (int j = 1; j < list.Count; j++)
			{
				if (list[j].timeLeft < projectile.timeLeft)
				{
					projectile = list[j];
				}
			}
			projectile.Kill();
			list.Remove(projectile);
		}
	}

	private void ItemCheck_ApplyPetBuffs(Item sItem)
	{
		if (whoAmI == Main.myPlayer && sItem.type == 603 && Main.runningCollectorsEdition)
		{
			AddBuff(sItem.buffType, 3600);
		}
		if (whoAmI == Main.myPlayer && sItem.type == 669)
		{
			AddBuff(sItem.buffType, 3600);
		}
		if (whoAmI == Main.myPlayer && sItem.type == 115)
		{
			AddBuff(sItem.buffType, 3600);
		}
		if (whoAmI == Main.myPlayer && sItem.type == 3060)
		{
			AddBuff(sItem.buffType, 3600);
		}
		if (whoAmI == Main.myPlayer && sItem.type == 3628)
		{
			AddBuff(sItem.buffType, 3600);
		}
		if (whoAmI == Main.myPlayer && sItem.type == 3062)
		{
			AddBuff(sItem.buffType, 3600);
		}
		if (whoAmI == Main.myPlayer && sItem.type == 3577)
		{
			AddBuff(sItem.buffType, 3600);
		}
		if (whoAmI == Main.myPlayer && sItem.type == 425)
		{
			int num = Main.rand.Next(3);
			if (num == 0)
			{
				num = 27;
			}
			if (num == 1)
			{
				num = 101;
			}
			if (num == 2)
			{
				num = 102;
			}
			for (int i = 0; i < maxBuffs; i++)
			{
				if (buffType[i] == 27 || buffType[i] == 101 || buffType[i] == 102)
				{
					DelBuff(i);
					i--;
				}
			}
			AddBuff(num, 3600);
		}
		if (whoAmI == Main.myPlayer && sItem.type == 753)
		{
			AddBuff(sItem.buffType, 3600);
		}
		if (whoAmI == Main.myPlayer && sItem.type == 994)
		{
			AddBuff(sItem.buffType, 3600);
		}
		if (whoAmI == Main.myPlayer && sItem.type == 1169)
		{
			AddBuff(sItem.buffType, 3600);
		}
		if (whoAmI == Main.myPlayer && sItem.type == 1170)
		{
			AddBuff(sItem.buffType, 3600);
		}
		if (whoAmI == Main.myPlayer && sItem.type == 1171)
		{
			AddBuff(sItem.buffType, 3600);
		}
		if (whoAmI == Main.myPlayer && sItem.type == 1172)
		{
			AddBuff(sItem.buffType, 3600);
		}
		if (whoAmI == Main.myPlayer && sItem.type == 1180)
		{
			AddBuff(sItem.buffType, 3600);
		}
		if (whoAmI == Main.myPlayer && sItem.type == 1181)
		{
			AddBuff(sItem.buffType, 3600);
		}
		if (whoAmI == Main.myPlayer && sItem.type == 1182)
		{
			AddBuff(sItem.buffType, 3600);
		}
		if (whoAmI == Main.myPlayer && sItem.type == 1183)
		{
			AddBuff(sItem.buffType, 3600);
		}
		if (whoAmI == Main.myPlayer && sItem.type == 1242)
		{
			AddBuff(sItem.buffType, 3600);
		}
		if (whoAmI == Main.myPlayer && sItem.type == 1157)
		{
			AddBuff(sItem.buffType, 3600);
		}
		if (whoAmI == Main.myPlayer && sItem.type == 1309)
		{
			AddBuff(sItem.buffType, 3600);
		}
		if (whoAmI == Main.myPlayer && sItem.type == 1311)
		{
			AddBuff(sItem.buffType, 3600);
		}
		if (whoAmI == Main.myPlayer && sItem.type == 1837)
		{
			AddBuff(sItem.buffType, 3600);
		}
		if (whoAmI == Main.myPlayer && sItem.type == 1312)
		{
			AddBuff(sItem.buffType, 3600);
		}
		if (whoAmI == Main.myPlayer && sItem.type == 1798)
		{
			AddBuff(sItem.buffType, 3600);
		}
		if (whoAmI == Main.myPlayer && sItem.type == 1799)
		{
			AddBuff(sItem.buffType, 3600);
		}
		if (whoAmI == Main.myPlayer && sItem.type == 1802)
		{
			AddBuff(sItem.buffType, 3600);
		}
		if (whoAmI == Main.myPlayer && sItem.type == 1810)
		{
			AddBuff(sItem.buffType, 3600);
		}
		if (whoAmI == Main.myPlayer && sItem.type == 1927)
		{
			AddBuff(sItem.buffType, 3600);
		}
		if (whoAmI == Main.myPlayer && sItem.type == 1959)
		{
			AddBuff(sItem.buffType, 3600);
		}
		if (whoAmI == Main.myPlayer && sItem.type == 2364)
		{
			AddBuff(sItem.buffType, 3600);
		}
		if (whoAmI == Main.myPlayer && sItem.type == 2365)
		{
			AddBuff(sItem.buffType, 3600);
		}
		if (whoAmI == Main.myPlayer && sItem.type == 3043)
		{
			AddBuff(sItem.buffType, 3600);
		}
		if (whoAmI == Main.myPlayer && sItem.type == 2420)
		{
			AddBuff(sItem.buffType, 3600);
		}
		if (whoAmI == Main.myPlayer)
		{
			switch (sItem.type)
			{
			case 2535:
			case 2551:
			case 2584:
			case 2587:
			case 2621:
			case 2749:
			case 3249:
			case 3474:
			case 3531:
			case 4269:
			case 4273:
			case 4281:
			case 4607:
			case 4758:
			case 5005:
			case 5069:
			case 5114:
				AddBuff(sItem.buffType, 3600);
				break;
			}
		}
		if (whoAmI == Main.myPlayer)
		{
			switch (sItem.type)
			{
			case 3855:
			case 3856:
			case 3857:
			case 4365:
			case 4366:
			case 4425:
			case 4550:
			case 4551:
			case 4603:
			case 4604:
			case 4605:
			case 4701:
			case 4735:
			case 4736:
			case 4737:
			case 4777:
			case 4797:
			case 4798:
			case 4799:
			case 4800:
			case 4801:
			case 4802:
			case 4803:
			case 4804:
			case 4805:
			case 4806:
			case 4807:
			case 4808:
			case 4809:
			case 4810:
			case 4811:
			case 4812:
			case 4813:
			case 4814:
			case 4815:
			case 4816:
			case 4817:
			case 4960:
			case 5088:
			case 5089:
			case 5090:
			case 5091:
			case 5098:
			case 5131:
			case 5276:
			case 5297:
			case 5332:
			case 5333:
			case 5400:
				AddBuff(sItem.buffType, 3600);
				break;
			}
		}
	}

	public float GetWeaponKnockback(Item sItem)
	{
		return GetWeaponKnockback(sItem, sItem.knockBack);
	}

	public float GetWeaponKnockback(Item sItem, float baseKnockback)
	{
		StatModifier knockback = GetTotalKnockback(sItem.DamageType);
		CombinedHooks.ModifyWeaponKnockback(this, sItem, ref knockback);
		return Math.Max(0f, knockback.ApplyTo(baseKnockback));
	}

	public int GetWeaponCrit(Item sItem)
	{
		float crit = (float)sItem.crit + GetTotalCritChance(sItem.DamageType);
		CombinedHooks.ModifyWeaponCrit(this, sItem, ref crit);
		return (int)(crit + 5E-06f);
	}

	public int GetWeaponDamage(Item sItem, bool forTooltip = false)
	{
		StatModifier damage = GetTotalDamage(sItem.DamageType);
		if (AmmoID.Sets.IsArrow[sItem.useAmmo])
		{
			damage = damage.CombineWith(arrowDamage);
		}
		if (AmmoID.Sets.IsBullet[sItem.useAmmo])
		{
			damage = damage.CombineWith(bulletDamage);
		}
		if (AmmoID.Sets.IsSpecialist[sItem.useAmmo] || ItemID.Sets.IsRangedSpecialistWeapon[sItem.type])
		{
			damage = damage.CombineWith(specialistDamage);
		}
		CombinedHooks.ModifyWeaponDamage(this, sItem, ref damage);
		float num = sItem.damage;
		if (forTooltip)
		{
			num *= ItemID.Sets.ToolTipDamageMultiplier[sItem.type];
		}
		return Math.Max(0, (int)(damage.ApplyTo(num) + 5E-06f));
	}

	/// <summary>
	/// Whether or not the player has ammunition available for the given weapon.
	/// </summary>
	/// <param name="sItem">The weapon for which to try to find ammunition.</param>
	/// <returns>True if the player has ammo available; false otherwise.</returns>
	public bool HasAmmo(Item sItem)
	{
		return HasAmmo(sItem, canUse: true);
	}

	internal bool HasAmmo(Item sItem, bool canUse)
	{
		if (!canUse)
		{
			return false;
		}
		if (sItem.useAmmo != 0 && ChooseAmmo(sItem) == null)
		{
			return !ItemLoader.NeedsAmmo(sItem, this);
		}
		return true;
	}

	private bool PickAmmo_TryFindingSpecificMatches(int launcher, int ammo, out int pickedProjectileId)
	{
		pickedProjectileId = 0;
		if (AmmoID.Sets.SpecificLauncherAmmoProjectileMatches.TryGetValue(launcher, out var value) && value.TryGetValue(ammo, out pickedProjectileId))
		{
			return true;
		}
		launcher = AmmoID.Sets.SpecificLauncherAmmoProjectileFallback[launcher];
		if (launcher != -1 && AmmoID.Sets.SpecificLauncherAmmoProjectileMatches.TryGetValue(launcher, out var value2) && value2.TryGetValue(ammo, out pickedProjectileId))
		{
			return true;
		}
		return false;
	}

	/// <summary>
	/// A more-convenient-to-call variant of the vanilla PickAmmo method, which handles most vanilla ammunition logic to decide various common stats related to ammunition-consuming weapons.<br></br>
	/// The stats output by this method take into account any extra stats which the ammunition it finds may provide (read: it accounts for ammo damage and knockback).<br></br>
	/// </summary>
	/// <param name="weapon">The weapon for which to handle ammunition logic.</param>
	/// <param name="projToShoot">The projectile that should be shot based on the given weapon and the located ammunition.</param>
	/// <param name="speed">The speed at which the projectile that would be made by the given weapon and located ammunition should move.</param>
	/// <param name="damage">The damage value that the projectile shot should have, based on the given weapon and the located ammunition.</param>
	/// <param name="knockBack">The knockback value that the projectile shot should have, based on the given weapon and the located ammunition.</param>
	/// <param name="usedAmmoItemId">The numerical ID of the located ammunition.</param>
	/// <param name="dontConsume">
	/// Whether or not ammo consumption logic should be called upon.<br></br>
	/// This defaults to false, and if it is true for any reason, ammo will not be consumed at the end of the method.<br></br>
	/// This is useful for gathering the data needed based on PickAmmo's calculations without incidentally consuming any ammunition in the process.
	/// </param>
	/// <returns>True if ammo was found/chosen, and false otherwise.</returns>
	public bool PickAmmo(Item weapon, out int projToShoot, out float speed, out int damage, out float knockBack, out int usedAmmoItemId, bool dontConsume = false)
	{
		projToShoot = weapon.shoot;
		speed = weapon.shootSpeed;
		damage = GetWeaponDamage(weapon);
		knockBack = GetWeaponKnockback(weapon);
		bool canShoot = false;
		PickAmmo(weapon, ref projToShoot, ref speed, ref canShoot, ref damage, ref knockBack, out usedAmmoItemId, dontConsume);
		if (!canShoot)
		{
			projToShoot = 0;
			return false;
		}
		return true;
	}

	/// <summary>
	/// Attempts to select an ammo item stack from this player's inventory to shoot with the given weapon.
	/// </summary>
	/// <param name="weapon">The weapon for which this call should try to find ammo.</param>
	/// <returns>Null if no suitable ammo is found; otherwise, returns the first ammo item found.</returns>
	public Item ChooseAmmo(Item weapon)
	{
		Item result = null;
		bool flag = false;
		if (weapon.useAmmo == AmmoID.Coin)
		{
			for (int i = 0; i < 4; i++)
			{
				int num = 50 + i;
				if (inventory[num].stack > 0 && ItemLoader.CanChooseAmmo(weapon, inventory[i], this))
				{
					result = inventory[num];
					flag = true;
					break;
				}
			}
		}
		for (int j = 54; j < 58; j++)
		{
			if (inventory[j].stack > 0 && ItemLoader.CanChooseAmmo(weapon, inventory[j], this))
			{
				result = inventory[j];
				flag = true;
				break;
			}
		}
		if (!flag)
		{
			for (int k = 0; k < 54; k++)
			{
				if (inventory[k].stack > 0 && ItemLoader.CanChooseAmmo(weapon, inventory[k], this))
				{
					result = inventory[k];
					break;
				}
			}
		}
		return result;
	}

	internal void PickAmmo(Item sItem, ref int projToShoot, ref float speed, ref bool canShoot, ref int totalDamage, ref float KnockBack, out int usedAmmoItemId, bool dontConsume = false)
	{
		usedAmmoItemId = 0;
		Item item = ChooseAmmo(sItem);
		canShoot = item != null;
		bool flag = false;
		if (!canShoot && !ItemLoader.NeedsAmmo(sItem, this))
		{
			item = ContentSamples.ItemsByType[sItem.useAmmo];
			if (item.ammo == sItem.useAmmo)
			{
				flag = (canShoot = true);
			}
		}
		if (!canShoot)
		{
			return;
		}
		usedAmmoItemId = item.type;
		StatModifier damage = GetTotalDamage(item.DamageType);
		if (AmmoID.Sets.IsArrow[item.ammo])
		{
			damage = damage.CombineWith(arrowDamage);
		}
		if (AmmoID.Sets.IsBullet[item.ammo])
		{
			damage = damage.CombineWith(bulletDamage);
		}
		if (AmmoID.Sets.IsSpecialist[item.ammo])
		{
			damage = damage.CombineWith(specialistDamage);
		}
		damage.Base = 0f;
		damage.Flat = totalDamage;
		ref float flat = ref damage.Flat;
		int pickedProjectileId = -1;
		if (PickAmmo_TryFindingSpecificMatches(sItem.type, item.type, out pickedProjectileId))
		{
			projToShoot = pickedProjectileId;
		}
		else if (sItem.useAmmo == AmmoID.Rocket)
		{
			projToShoot += item.shoot;
		}
		else if (sItem.useAmmo == AmmoID.Solution)
		{
			projToShoot += item.shoot;
		}
		else if (item.shoot > 0)
		{
			projToShoot = item.shoot;
		}
		if (sItem.type == 3019 && projToShoot == 1)
		{
			projToShoot = 485;
		}
		if (sItem.type == 3052)
		{
			projToShoot = 495;
		}
		if (sItem.type == 4953 && projToShoot == 1)
		{
			projToShoot = 932;
		}
		if (sItem.type == 4381)
		{
			projToShoot = 819;
		}
		if (sItem.type == 4058 && projToShoot == 474)
		{
			projToShoot = 117;
		}
		if (projToShoot == 42)
		{
			ItemID.Sets.SandgunAmmoInfo sandgunAmmoInfo = ItemID.Sets.SandgunAmmoProjectileData[item.type];
			if (sandgunAmmoInfo != null)
			{
				projToShoot = sandgunAmmoInfo.ProjectileType;
				flat += sandgunAmmoInfo.BonusDamage;
			}
		}
		if (inventory[selectedItem].type == 2888 && projToShoot == 1)
		{
			projToShoot = 469;
		}
		if (hasMoltenQuiver && projToShoot == 1)
		{
			projToShoot = 2;
			flat += 2f;
		}
		speed += item.shootSpeed;
		if (magicQuiver && (sItem.useAmmo == AmmoID.Arrow || sItem.useAmmo == AmmoID.Stake))
		{
			KnockBack *= 1.1f;
			speed *= 1.1f;
		}
		if ((sItem.useAmmo == AmmoID.Arrow || sItem.useAmmo == AmmoID.Stake) && archery && speed < 20f)
		{
			speed *= 1.2f;
			if (speed > 20f)
			{
				speed = 20f;
			}
		}
		KnockBack += item.knockBack;
		ItemLoader.PickAmmo(sItem, item, this, ref projToShoot, ref speed, ref damage, ref KnockBack);
		totalDamage = (int)(damage.ApplyTo(item.damage) + 5E-06f);
		if (!dontConsume && !flag && item.consumable && !IsAmmoFreeThisShot(sItem, item, projToShoot))
		{
			CombinedHooks.OnConsumeAmmo(this, sItem, item);
			item.stack--;
			if (item.stack <= 0)
			{
				item.active = false;
				item.TurnToAir();
			}
		}
	}

	/// <summary>
	/// Determines whether or not the given ammunition should be conserved, based on the given weapon as wielded by this player.
	/// </summary>
	/// <param name="weapon">The weapon attempting to consume the ammo.</param>
	/// <param name="ammo">The ammo attempting to be conserved (i.e. not consumed).</param>
	/// <param name="projToShoot">The projectile that should be shot by the given weapon/ammo combination.</param>
	/// <returns>True if the ammo should be conserved on the given shot; false otherwise.</returns>
	public bool IsAmmoFreeThisShot(Item weapon, Item ammo, int projToShoot)
	{
		if (!CombinedHooks.CanConsumeAmmo(this, weapon, ammo))
		{
			return true;
		}
		if (weapon.consumeAmmoOnFirstShotOnly && !ItemAnimationJustStarted)
		{
			return true;
		}
		if (weapon.consumeAmmoOnLastShotOnly)
		{
			int num = CombinedHooks.TotalUseTime(weapon.useTime, this, weapon);
			if (itemAnimation > num && (!weapon.useLimitPerAnimation.HasValue || ItemUsesThisAnimation != weapon.useLimitPerAnimation - 1))
			{
				return true;
			}
		}
		bool result = false;
		if (weapon.type == 3475 && Main.rand.Next(3) != 0)
		{
			result = true;
		}
		if (weapon.type == 3930 && Main.rand.Next(2) == 0)
		{
			result = true;
		}
		if (weapon.type == 3540 && Main.rand.Next(3) != 0)
		{
			result = true;
		}
		if (weapon.type == 5134 && Main.rand.Next(3) == 0)
		{
			result = true;
		}
		if (magicQuiver && AmmoID.Sets.IsArrow[weapon.useAmmo] && Main.rand.Next(5) == 0)
		{
			result = true;
		}
		if (ammoBox && Main.rand.Next(5) == 0)
		{
			result = true;
		}
		if (ammoPotion && Main.rand.Next(5) == 0)
		{
			result = true;
		}
		if (weapon.type == 1782 && Main.rand.Next(3) == 0)
		{
			result = true;
		}
		if (weapon.type == 98 && Main.rand.Next(3) == 0)
		{
			result = true;
		}
		if (weapon.type == 2270 && Main.rand.Next(2) == 0)
		{
			result = true;
		}
		if (weapon.type == 533 && Main.rand.Next(2) == 0)
		{
			result = true;
		}
		if (weapon.type == 1929 && Main.rand.Next(2) == 0)
		{
			result = true;
		}
		if (weapon.type == 1553 && Main.rand.Next(3) != 0)
		{
			result = true;
		}
		if (huntressAmmoCost90 && Main.rand.Next(10) == 0)
		{
			result = true;
		}
		if (chloroAmmoCost80 && Main.rand.Next(5) == 0)
		{
			result = true;
		}
		if (ammoCost80 && Main.rand.Next(5) == 0)
		{
			result = true;
		}
		if (ammoCost75 && Main.rand.Next(4) == 0)
		{
			result = true;
		}
		if (ammo.CountsAsClass(DamageClass.Throwing))
		{
			if (ThrownCost50 && Main.rand.Next(100) < 50)
			{
				result = true;
			}
			if (ThrownCost33 && Main.rand.Next(100) < 33)
			{
				result = true;
			}
		}
		if (Main.remixWorld && weapon.type == 1319 && Main.rand.Next(2) == 0)
		{
			result = true;
		}
		return result;
	}

	public void GetOtherPlayersPickTile(int x, int y, int pickDamage)
	{
		int tileId = hitTile.HitObject(x, y, 1);
		hitTile.AddDamage(tileId, pickDamage);
	}

	public void PickTile(int x, int y, int pickPower)
	{
		int num = hitTile.HitObject(x, y, 1);
		Tile tileTarget = Main.tile[x, y];
		if (tileTarget.type == 504)
		{
			return;
		}
		int num2 = GetPickaxeDamage(x, y, pickPower, num, tileTarget);
		if (!WorldGen.CanKillTile(x, y))
		{
			num2 = 0;
		}
		if (Main.getGoodWorld)
		{
			num2 *= 2;
		}
		if (DoesPickTargetTransformOnKill(hitTile, num2, x, y, pickPower, num, tileTarget))
		{
			num2 = 0;
		}
		if (hitTile.AddDamage(num, num2) >= 100)
		{
			AchievementsHelper.CurrentlyMining = true;
			ClearMiningCacheAt(x, y, 1);
			if (Main.netMode == 1 && Main.tileContainer[Main.tile[x, y].type])
			{
				if (Main.tile[x, y].type == 470 || Main.tile[x, y].type == 475)
				{
					NetMessage.SendData(17, -1, -1, null, 20, x, y);
				}
				else
				{
					WorldGen.KillTile(x, y, fail: true);
					NetMessage.SendData(17, -1, -1, null, 0, x, y, 1f);
				}
				if (Main.tile[x, y].type == 21 || (Main.tile[x, y].type < TileID.Count && TileID.Sets.BasicChest[Main.tile[x, y].type]))
				{
					NetMessage.SendData(34, -1, -1, null, 1, x, y);
				}
				if (Main.tile[x, y].type == 467)
				{
					NetMessage.SendData(34, -1, -1, null, 5, x, y);
				}
				if (Main.tile[x, y].type == 88)
				{
					NetMessage.SendData(34, -1, -1, null, 3, x, y);
				}
				if (Main.tile[x, y].type >= TileID.Count)
				{
					if (TileID.Sets.BasicChest[Main.tile[x, y].type])
					{
						NetMessage.SendData(34, -1, -1, null, 101, x, y, 0f, 0, Main.tile[x, y].type);
					}
					if (TileID.Sets.BasicDresser[Main.tile[x, y].type])
					{
						NetMessage.SendData(34, -1, -1, null, 103, x, y, 0f, 0, Main.tile[x, y].type);
					}
				}
			}
			else
			{
				bool flag = Main.tile[x, y].active();
				WorldGen.KillTile(x, y);
				if (!Main.dedServ && flag && !Main.tile[x, y].active())
				{
					AchievementsHelper.HandleMining();
				}
				if (Main.netMode == 1)
				{
					NetMessage.SendData(17, -1, -1, null, 0, x, y);
				}
			}
			AchievementsHelper.CurrentlyMining = false;
		}
		else
		{
			WorldGen.KillTile(x, y, fail: true);
			if (Main.netMode == 1)
			{
				NetMessage.SendData(17, -1, -1, null, 0, x, y, 1f);
				NetMessage.SendData(125, -1, -1, null, Main.myPlayer, x, y, num2);
			}
		}
		if (num2 != 0)
		{
			hitTile.Prune();
		}
	}

	private void ClearMiningCacheAt(int x, int y, int hitTileCacheType)
	{
		hitReplace.TryClearingAndPruning(x, y, 1);
		hitTile.TryClearingAndPruning(x, y, 1);
	}

	public bool isNearFairy()
	{
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		if (NPC.npcsFoundForCheckActive[583] || NPC.npcsFoundForCheckActive[584] || NPC.npcsFoundForCheckActive[585])
		{
			for (int i = 0; i < 200; i++)
			{
				if (Main.npc[i].active && (Main.npc[i].type == 583 || Main.npc[i].type == 584 || Main.npc[i].type == 585) && Vector2.Distance(Main.npc[i].Center, base.Center) < (float)NPC.sWidth)
				{
					return true;
				}
			}
		}
		return false;
	}

	public bool isNearNPC(int type, float range = -1f)
	{
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		if (range == -1f)
		{
			range = NPC.sWidth;
		}
		if (NPC.npcsFoundForCheckActive[type])
		{
			for (int i = 0; i < 200; i++)
			{
				if (Main.npc[i].active && Main.npc[i].type == type && Vector2.Distance(Main.npc[i].Center, base.Center) < range)
				{
					return true;
				}
			}
		}
		return false;
	}

	public bool HasEnoughPickPowerToHurtTile(int x, int y)
	{
		Item bestPickaxe = GetBestPickaxe();
		if (bestPickaxe == null)
		{
			return false;
		}
		Tile tileTarget = Main.tile[x, y];
		_ = ref tileTarget.type;
		int hitBufferIndex = hitTile.HitObject(x, y, 1);
		if (GetPickaxeDamage(x, y, bestPickaxe.pick, hitBufferIndex, tileTarget) == 0)
		{
			return false;
		}
		return true;
	}

	private int GetPickaxeDamage(int x, int y, int pickPower, int hitBufferIndex, Tile tileTarget)
	{
		int num = 0;
		if (Main.tileNoFail[tileTarget.type])
		{
			num = 100;
		}
		ModTile tile = TileLoader.GetTile(tileTarget.type);
		num = ((tile == null) ? ((Main.tileDungeon[tileTarget.type] || tileTarget.type == 25 || tileTarget.type == 58 || tileTarget.type == 117 || tileTarget.type == 203) ? (num + pickPower / 2) : ((tileTarget.type != 85) ? ((tileTarget.type != 48 && tileTarget.type != 232) ? ((tileTarget.type == 226) ? (num + pickPower / 4) : ((tileTarget.type != 107 && tileTarget.type != 221) ? ((tileTarget.type != 108 && tileTarget.type != 222) ? ((tileTarget.type == 111 || tileTarget.type == 223) ? (num + pickPower / 4) : ((tileTarget.type != 211) ? (num + pickPower) : (num + pickPower / 5))) : (num + pickPower / 3)) : (num + pickPower / 2))) : (num + pickPower * 2)) : ((!Main.getGoodWorld) ? (num + pickPower / 3) : (num + pickPower / 4)))) : (num + (int)((float)pickPower / tile.MineResist)));
		if (tileTarget.type == 211 && pickPower < 200)
		{
			num = 0;
		}
		if ((tileTarget.type == 25 || tileTarget.type == 203) && pickPower < 65)
		{
			num = 0;
		}
		else if (tileTarget.type == 117 && pickPower < 65)
		{
			num = 0;
		}
		else if (tileTarget.type == 37 && pickPower < 50)
		{
			num = 0;
		}
		else if ((tileTarget.type == 22 || tileTarget.type == 204) && (double)y > Main.worldSurface && pickPower < 55)
		{
			num = 0;
		}
		else if (tileTarget.type == 56 && pickPower < 55)
		{
			num = 0;
		}
		else if (tileTarget.type == 77 && pickPower < 65 && y >= Main.UnderworldLayer)
		{
			num = 0;
		}
		else if (tileTarget.type == 58 && pickPower < 65)
		{
			num = 0;
		}
		else if ((tileTarget.type == 226 || tileTarget.type == 237) && pickPower < 210)
		{
			num = 0;
		}
		else if (tileTarget.type == 137 && pickPower < 210)
		{
			if ((uint)(tileTarget.frameY / 18 - 1) <= 3u)
			{
				num = 0;
			}
		}
		else if (Main.tileDungeon[tileTarget.type] && pickPower < 100 && (double)y > Main.worldSurface)
		{
			if ((double)x < (double)Main.maxTilesX * 0.35 || (double)x > (double)Main.maxTilesX * 0.65)
			{
				num = 0;
			}
		}
		else if (tileTarget.type == 107 && pickPower < 100)
		{
			num = 0;
		}
		else if (tileTarget.type == 108 && pickPower < 110)
		{
			num = 0;
		}
		else if (tileTarget.type == 111 && pickPower < 150)
		{
			num = 0;
		}
		else if (tileTarget.type == 221 && pickPower < 100)
		{
			num = 0;
		}
		else if (tileTarget.type == 222 && pickPower < 110)
		{
			num = 0;
		}
		else if (tileTarget.type == 223 && pickPower < 150)
		{
			num = 0;
		}
		else
		{
			TileLoader.PickPowerCheck(tileTarget, pickPower, ref num);
		}
		if (tileTarget.type == 147 || tileTarget.type == 0 || tileTarget.type == 40 || tileTarget.type == 53 || tileTarget.type == 57 || tileTarget.type == 59 || tileTarget.type == 123 || tileTarget.type == 224 || tileTarget.type == 397)
		{
			num += pickPower;
		}
		if (tileTarget.type == 404)
		{
			num += 5;
		}
		if (tileTarget.type == 165 || Main.tileRope[tileTarget.type] || tileTarget.type == 199)
		{
			num = 100;
		}
		if (tileTarget.type == 128 || tileTarget.type == 269)
		{
			if (tileTarget.frameX == 18 || tileTarget.frameX == 54)
			{
				x--;
				tileTarget = Main.tile[x, y];
				hitTile.UpdatePosition(hitBufferIndex, x, y);
			}
			if (tileTarget.frameX >= 100)
			{
				num = 0;
				Main.blockMouse = true;
			}
		}
		if (tileTarget.type == 334)
		{
			if (tileTarget.frameY == 0)
			{
				y++;
				tileTarget = Main.tile[x, y];
				hitTile.UpdatePosition(hitBufferIndex, x, y);
			}
			if (tileTarget.frameY == 36)
			{
				y--;
				tileTarget = Main.tile[x, y];
				hitTile.UpdatePosition(hitBufferIndex, x, y);
			}
			int frameX = tileTarget.frameX;
			bool flag = frameX >= 5000;
			bool flag2 = false;
			if (!flag)
			{
				int num2 = frameX / 18;
				num2 %= 3;
				x -= num2;
				tileTarget = Main.tile[x, y];
				if (tileTarget.frameX >= 5000)
				{
					flag = true;
				}
			}
			if (flag)
			{
				frameX = tileTarget.frameX;
				int num3 = 0;
				while (frameX >= 5000)
				{
					frameX -= 5000;
					num3++;
				}
				if (num3 != 0)
				{
					flag2 = true;
				}
			}
			if (flag2)
			{
				num = 0;
				Main.blockMouse = true;
			}
		}
		return num;
	}

	private bool DoesPickTargetTransformOnKill(HitTile hitCounter, int damage, int x, int y, int pickPower, int bufferIndex, Tile tileTarget)
	{
		if (hitCounter.AddDamage(bufferIndex, damage, updateAmount: false) >= 100 && (tileTarget.type == 2 || tileTarget.type == 477 || tileTarget.type == 492 || tileTarget.type == 23 || tileTarget.type == 60 || tileTarget.type == 70 || tileTarget.type == 109 || tileTarget.type == 199 || Main.tileMoss[tileTarget.type] || tileTarget.type == 662 || tileTarget.type == 661 || TileID.Sets.tileMossBrick[tileTarget.type] || tileTarget.type == 633))
		{
			return true;
		}
		return false;
	}

	public bool ItemFitsWeaponRack(Item i)
	{
		bool flag = false;
		if (i.fishingPole > 0)
		{
			flag = true;
		}
		int netID = i.netID;
		if (netID == 905 || netID == 1326 || netID == 5335)
		{
			flag = true;
		}
		if ((i.damage > 0 || flag) && i.useStyle != 0)
		{
			return i.stack > 0;
		}
		return false;
	}

	public void PlaceWeapon(int x, int y)
	{
		if (Main.tile[x, y].active() && Main.tile[x, y].type == 334)
		{
			int frameY = Main.tile[x, y].frameY;
			int num = 1;
			frameY /= 18;
			while (num > frameY)
			{
				y++;
				frameY = Main.tile[x, y].frameY;
				frameY /= 18;
			}
			while (num < frameY)
			{
				y--;
				frameY = Main.tile[x, y].frameY;
				frameY /= 18;
			}
			int num2 = Main.tile[x, y].frameX;
			int num3 = 0;
			while (num2 >= 5000)
			{
				num2 -= 5000;
				num3++;
			}
			if (num3 != 0)
			{
				num2 = (num3 - 1) * 18;
			}
			bool flag = false;
			if (num2 >= 54)
			{
				num2 -= 54;
				flag = true;
			}
			x -= num2 / 18;
			int num4 = Main.tile[x, y].frameX;
			WorldGen.KillTile(x, y, fail: true);
			if (Main.netMode == 1)
			{
				NetMessage.SendData(17, -1, -1, null, 0, x, y, 1f);
			}
			if (Main.netMode == 1)
			{
				NetMessage.SendData(17, -1, -1, null, 0, x + 1, y, 1f);
			}
			while (num4 >= 5000)
			{
				num4 -= 5000;
			}
			Main.blockMouse = true;
			int num5 = 5000;
			int num6 = 10000;
			if (flag)
			{
				num5 = 20000;
				num6 = 25000;
			}
			Main.tile[x, y].frameX = (short)(inventory[selectedItem].netID + num5 + 100);
			Main.tile[x + 1, y].frameX = (short)(inventory[selectedItem].prefix + num6);
			if (Main.netMode == 1)
			{
				NetMessage.SendTileSquare(-1, x, y);
			}
			if (Main.netMode == 1)
			{
				NetMessage.SendTileSquare(-1, x + 1, y);
			}
			inventory[selectedItem].stack--;
			if (inventory[selectedItem].stack <= 0)
			{
				inventory[selectedItem].SetDefaults();
				Main.mouseItem.SetDefaults();
			}
			if (selectedItem == 58)
			{
				Main.mouseItem = inventory[selectedItem].Clone();
			}
			releaseUseItem = false;
			mouseInterface = true;
		}
	}

	public bool ItemFitsItemFrame(Item i)
	{
		return i.stack > 0;
	}

	public Color GetImmuneAlpha(Color newColor, float alphaReduction)
	{
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		float num = (float)(255 - immuneAlpha) / 255f;
		if (alphaReduction > 0f)
		{
			num *= 1f - alphaReduction;
		}
		if (shimmerTransparency > 0f)
		{
			if ((double)shimmerTransparency >= 0.8)
			{
				return Color.Transparent;
			}
			num *= 1f - shimmerTransparency;
			num *= 1f - shimmerTransparency;
			num *= 1f - shimmerTransparency;
		}
		if (immuneAlpha > 125)
		{
			return Color.Transparent;
		}
		return Color.Multiply(newColor, num);
	}

	public Color GetImmuneAlphaPure(Color newColor, float alphaReduction)
	{
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		float num = (float)(255 - immuneAlpha) / 255f;
		if (alphaReduction > 0f)
		{
			num *= 1f - alphaReduction;
		}
		if (shimmerTransparency > 0f)
		{
			num *= 1f - shimmerTransparency;
		}
		return Color.Multiply(newColor, num);
	}

	public Color GetDeathAlpha(Color newColor)
	{
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		int num = ((Color)(ref newColor)).R + (int)((double)immuneAlpha * 0.9);
		int num2 = ((Color)(ref newColor)).G + (int)((double)immuneAlpha * 0.5);
		int num3 = ((Color)(ref newColor)).B + (int)((double)immuneAlpha * 0.5);
		int num4 = ((Color)(ref newColor)).A + (int)((double)immuneAlpha * 0.4);
		if (num4 < 0)
		{
			num4 = 0;
		}
		if (num4 > 255)
		{
			num4 = 255;
		}
		return new Color(num, num2, num3, num4);
	}

	public void addDPS(int dmg)
	{
		if (dpsStarted)
		{
			dpsLastHit = DateTime.Now;
			dpsDamage += dmg;
			dpsEnd = DateTime.Now;
		}
		else
		{
			dpsStarted = true;
			dpsStart = DateTime.Now;
			dpsEnd = DateTime.Now;
			dpsLastHit = DateTime.Now;
			dpsDamage = dmg;
		}
	}

	public void checkDPSTime()
	{
		int num = 3;
		if (dpsStarted && (DateTime.Now - dpsLastHit).Seconds >= num)
		{
			dpsStarted = false;
		}
	}

	public int getDPS()
	{
		TimeSpan timeSpan = dpsEnd - dpsStart;
		float num = (float)timeSpan.Milliseconds / 1000f;
		num += (float)timeSpan.Seconds;
		num += (float)timeSpan.Minutes / 60f;
		if (num >= 3f)
		{
			dpsStart = DateTime.Now;
			dpsStart = dpsStart.AddSeconds(-1.0);
			dpsDamage = (int)((float)dpsDamage / num);
			timeSpan = dpsEnd - dpsStart;
			num = (float)timeSpan.Milliseconds / 1000f;
			num += (float)timeSpan.Seconds;
			num += (float)timeSpan.Minutes / 60f;
		}
		if (num < 1f)
		{
			num = 1f;
		}
		return (int)((float)dpsDamage / num);
	}

	public long DropCoins()
	{
		IEntitySource itemSource_Death = GetItemSource_Death();
		long num = 0L;
		for (int i = 0; i < 59; i++)
		{
			if (inventory[i].IsACoin)
			{
				int num2 = Item.NewItem(itemSource_Death, (int)position.X, (int)position.Y, width, height, inventory[i].type);
				int num3 = inventory[i].stack / 2;
				if (Main.expertMode)
				{
					num3 = (int)((double)inventory[i].stack * 0.25);
				}
				if (Main.masterMode)
				{
					num3 = 0;
				}
				num3 = inventory[i].stack - num3;
				inventory[i].stack -= num3;
				if (inventory[i].type == 71)
				{
					num += num3;
				}
				if (inventory[i].type == 72)
				{
					num += (long)num3 * 100L;
				}
				if (inventory[i].type == 73)
				{
					num += (long)num3 * 10000L;
				}
				if (inventory[i].type == 74)
				{
					num += (long)num3 * 1000000L;
				}
				if (inventory[i].stack <= 0)
				{
					inventory[i] = new Item();
				}
				Main.item[num2].stack = num3;
				Main.item[num2].velocity.Y = (float)Main.rand.Next(-20, 1) * 0.2f;
				Main.item[num2].velocity.X = (float)Main.rand.Next(-20, 21) * 0.2f;
				Main.item[num2].noGrabDelay = 100;
				if (Main.netMode == 1)
				{
					NetMessage.SendData(21, -1, -1, null, num2);
				}
				if (i == 58)
				{
					Main.mouseItem = inventory[i].Clone();
				}
			}
		}
		lostCoins = num;
		lostCoinString = Main.ValueToCoins(lostCoins);
		return num;
	}

	public void DropItems()
	{
		IEntitySource itemSource_Death = GetItemSource_Death();
		List<Item> startingItems = PlayerLoader.GetStartingItems(this, from item2 in DropItems_GetDefaults()
			where !item2.IsAir
			select item2, mediumCoreDeath: true);
		Dictionary<int, int> dictionary = new Dictionary<int, int>();
		foreach (Item item2 in startingItems)
		{
			if (!dictionary.ContainsKey(item2.netID))
			{
				dictionary[item2.netID] = 0;
			}
			dictionary[item2.netID] += item2.stack;
		}
		dictionary[ModContent.ItemType<StartBag>()] = 1;
		AccessorySlotLoader.ModSlotPlayer(this).DropItems(itemSource_Death);
		for (int num = 0; num < 59; num++)
		{
			if (inventory[num].stack > 0)
			{
				int type = inventory[num].type;
				Item item = inventory[num];
				if (dictionary.TryGetValue(type, out var value))
				{
					int num2 = Math.Min(item.stack, value);
					item.stack -= num2;
					dictionary[type] -= num2;
				}
				if (item.stack > 0)
				{
					TryDroppingSingleItem(itemSource_Death, item);
				}
			}
			inventory[num].TurnToAir();
			if (num < armor.Length)
			{
				TryDroppingSingleItem(itemSource_Death, armor[num]);
			}
			if (num < dye.Length)
			{
				TryDroppingSingleItem(itemSource_Death, dye[num]);
			}
			if (num < miscEquips.Length)
			{
				TryDroppingSingleItem(itemSource_Death, miscEquips[num]);
			}
			if (num < miscDyes.Length)
			{
				TryDroppingSingleItem(itemSource_Death, miscDyes[num]);
			}
		}
		EquipmentLoadout[] loadouts = Loadouts;
		for (int num3 = 0; num3 < loadouts.Length; num3++)
		{
			loadouts[num3].TryDroppingItems(this, itemSource_Death);
		}
		DropItems_End(startingItems);
	}

	private IEnumerable<Item> DropItems_GetDefaults()
	{
		Item[] array = new Item[inventory.Length];
		for (int i = 0; i < array.Length; i++)
		{
			array[i] = new Item();
		}
		array[0].SetDefaults(3507);
		array[0].Prefix(-1);
		array[1].SetDefaults(3509);
		array[1].Prefix(-1);
		array[2].SetDefaults(3506);
		array[2].Prefix(-1);
		return array;
	}

	private void DropItems_End(IList<Item> startInventory)
	{
		PlayerLoader.SetStartInventory(this, startInventory);
		Main.mouseItem.TurnToAir();
	}

	public void TryDroppingSingleItem(IEntitySource source, Item theItem)
	{
		if (theItem.stack > 0)
		{
			int num = Item.NewItem(source, (int)position.X, (int)position.Y, width, height, theItem);
			Item obj = Main.item[num];
			obj.velocity.Y = (float)Main.rand.Next(-20, 1) * 0.2f;
			obj.velocity.X = (float)Main.rand.Next(-20, 21) * 0.2f;
			obj.noGrabDelay = 100;
			obj.newAndShiny = false;
			if (Main.netMode == 1)
			{
				NetMessage.SendData(21, -1, -1, null, num);
			}
		}
		theItem.TurnToAir(fullReset: true);
	}

	public object Clone()
	{
		return MemberwiseClone();
	}

	public void CopyVisuals(Player other)
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		skinVariant = other.skinVariant;
		direction = other.direction;
		selectedItem = other.selectedItem;
		extraAccessory = other.extraAccessory;
		skinColor = other.skinColor;
		eyeColor = other.eyeColor;
		hair = other.hair;
		hairColor = other.hairColor;
		shirtColor = other.shirtColor;
		underShirtColor = other.underShirtColor;
		pantsColor = other.pantsColor;
		shoeColor = other.shoeColor;
		position = other.position;
		velocity = other.velocity;
		statLife = other.statLife;
		statLifeMax = other.statLifeMax;
		statLifeMax2 = other.statLifeMax2;
		statMana = other.statMana;
		statManaMax = other.statManaMax;
		statManaMax2 = other.statManaMax2;
		hideMisc = other.hideMisc;
		for (int i = 0; i < 59; i++)
		{
			inventory[i] = other.inventory[i].Clone();
			if (i < armor.Length)
			{
				armor[i] = other.armor[i].Clone();
			}
			if (i < dye.Length)
			{
				dye[i] = other.dye[i].Clone();
			}
			if (i < miscEquips.Length)
			{
				miscEquips[i] = other.miscEquips[i].Clone();
			}
			if (i < miscDyes.Length)
			{
				miscDyes[i] = other.miscDyes[i].Clone();
			}
			if (i < hideVisibleAccessory.Length)
			{
				hideVisibleAccessory[i] = other.hideVisibleAccessory[i];
			}
		}
	}

	public Player clientClone()
	{
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		using (new Item.DisableCloneMethod("Item.Clone is bad for performance, and should not be called during Player.clientClone or ModPlayer.CopyClientStateTo. Use Item.CopyNetStateTo instead"))
		{
			Player player = _clientClone ?? (_clientClone = new Player());
			player.zone1 = zone1;
			player.zone2 = zone2;
			player.zone3 = zone3;
			player.zone4 = zone4;
			player.zone5 = zone5;
			player.voidVaultInfo = voidVaultInfo;
			player.luck = luck;
			BiomeLoader.CopyCustomBiomesTo(this, player);
			player.extraAccessory = extraAccessory;
			player.MinionRestTargetPoint = MinionRestTargetPoint;
			player.MinionAttackTargetNPC = MinionAttackTargetNPC;
			player.direction = direction;
			player.selectedItem = selectedItem;
			player.controlUp = controlUp;
			player.controlDown = controlDown;
			player.controlLeft = controlLeft;
			player.controlRight = controlRight;
			player.controlJump = controlJump;
			player.controlUseItem = controlUseItem;
			player.controlDownHold = controlDownHold;
			player.isOperatingAnotherEntity = isOperatingAnotherEntity;
			player.autoReuseAllWeapons = autoReuseAllWeapons;
			player.statLife = statLife;
			player.statLifeMax = statLifeMax;
			player.statMana = statMana;
			player.statManaMax = statManaMax;
			player.position.X = position.X;
			player.tileEntityAnchor = tileEntityAnchor;
			player.chest = chest;
			player.talkNPC = talkNPC;
			player.piggyBankProjTracker = piggyBankProjTracker;
			player.voidLensChest = voidLensChest;
			player.hideVisibleAccessory = hideVisibleAccessory;
			player.hideMisc = hideMisc;
			player.shieldRaised = shieldRaised;
			for (int i = 0; i < 59; i++)
			{
				inventory[i].CopyNetStateTo(player.inventory[i]);
				if (i < armor.Length)
				{
					armor[i].CopyNetStateTo(player.armor[i]);
				}
				if (i < dye.Length)
				{
					dye[i].CopyNetStateTo(player.dye[i]);
				}
				if (i < miscEquips.Length)
				{
					miscEquips[i].CopyNetStateTo(player.miscEquips[i]);
				}
				if (i < miscDyes.Length)
				{
					miscDyes[i].CopyNetStateTo(player.miscDyes[i]);
				}
				if (i < bank.item.Length)
				{
					bank.item[i].CopyNetStateTo(player.bank.item[i]);
				}
				if (i < bank2.item.Length)
				{
					bank2.item[i].CopyNetStateTo(player.bank2.item[i]);
				}
				if (i < bank3.item.Length)
				{
					bank3.item[i].CopyNetStateTo(player.bank3.item[i]);
				}
				if (i < bank4.item.Length)
				{
					bank4.item[i].CopyNetStateTo(player.bank4.item[i]);
				}
			}
			CloneLoadouts(player);
			trashItem.CopyNetStateTo(player.trashItem);
			for (int j = 0; j < maxBuffs; j++)
			{
				player.buffType[j] = buffType[j];
				player.buffTime[j] = buffTime[j];
			}
			DpadRadial.CopyTo(player.DpadRadial);
			CircularRadial.CopyTo(player.CircularRadial);
			PlayerLoader.CopyClientState(this, player);
			return player;
		}
	}

	private void CloneLoadouts(Player clonePlayer)
	{
		Item[] array = armor;
		Item[] array2 = clonePlayer.armor;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].CopyNetStateTo(array2[i]);
		}
		array = dye;
		array2 = clonePlayer.dye;
		for (int j = 0; j < array.Length; j++)
		{
			array[j].CopyNetStateTo(array2[j]);
		}
		for (int k = 0; k < Loadouts.Length; k++)
		{
			array = Loadouts[k].Armor;
			array2 = clonePlayer.Loadouts[k].Armor;
			for (int l = 0; l < array.Length; l++)
			{
				array[l].CopyNetStateTo(array2[l]);
			}
			array = Loadouts[k].Dye;
			array2 = clonePlayer.Loadouts[k].Dye;
			for (int m = 0; m < array.Length; m++)
			{
				array[m].CopyNetStateTo(array2[m]);
			}
		}
	}

	public static bool CheckSpawn(int x, int y)
	{
		bool flag = Main.tileSolid[379];
		Main.tileSolid[379] = true;
		bool result = CheckSpawn_Internal(x, y);
		Main.tileSolid[379] = flag;
		return result;
	}

	private static bool CheckSpawn_Internal(int x, int y)
	{
		if (x < 10 || x > Main.maxTilesX - 10 || y < 10 || y > Main.maxTilesX - 10)
		{
			return false;
		}
		if (Main.tile[x, y - 1] == null)
		{
			return false;
		}
		if (!Main.tile[x, y - 1].active() || !TileID.Sets.IsValidSpawnPoint[Main.tile[x, y - 1].type])
		{
			return false;
		}
		for (int i = x - 1; i <= x + 1; i++)
		{
			for (int j = y - 3; j < y; j++)
			{
				if (Main.tile[i, j] == null)
				{
					return false;
				}
				if (Main.tile[i, j].nactive() && Main.tileSolid[Main.tile[i, j].type] && !Main.tileSolidTop[Main.tile[i, j].type])
				{
					Main.NewText(Language.GetTextValue("Game.BedObstructed"), byte.MaxValue, 240, 20);
					return false;
				}
			}
		}
		if (!WorldGen.StartRoomCheck(x, y - 1))
		{
			return false;
		}
		return true;
	}

	public void FindSpawn()
	{
		for (int i = 0; i < 200; i++)
		{
			if (spN[i] == null)
			{
				SpawnX = -1;
				SpawnY = -1;
				break;
			}
			if (spN[i] == Main.worldName && spI[i] == Main.worldID)
			{
				SpawnX = spX[i];
				SpawnY = spY[i];
				break;
			}
		}
	}

	public void RemoveSpawn()
	{
		SpawnX = -1;
		SpawnY = -1;
		for (int i = 0; i < 200 && spN[i] != null; i++)
		{
			if (spN[i] == Main.worldName && spI[i] == Main.worldID)
			{
				for (int j = i; j < 199; j++)
				{
					spN[j] = spN[j + 1];
					spI[j] = spI[j + 1];
					spX[j] = spX[j + 1];
					spY[j] = spY[j + 1];
				}
				spN[199] = null;
				spI[199] = 0;
				spX[199] = 0;
				spY[199] = 0;
				break;
			}
		}
	}

	public void ChangeSpawn(int x, int y)
	{
		for (int i = 0; i < 200 && spN[i] != null; i++)
		{
			if (spN[i] == Main.worldName && spI[i] == Main.worldID)
			{
				for (int num = i; num > 0; num--)
				{
					spN[num] = spN[num - 1];
					spI[num] = spI[num - 1];
					spX[num] = spX[num - 1];
					spY[num] = spY[num - 1];
				}
				spN[0] = Main.worldName;
				spI[0] = Main.worldID;
				spX[0] = x;
				spY[0] = y;
				FindSpawn();
				return;
			}
		}
		for (int num2 = 199; num2 > 0; num2--)
		{
			if (spN[num2 - 1] != null)
			{
				spN[num2] = spN[num2 - 1];
				spI[num2] = spI[num2 - 1];
				spX[num2] = spX[num2 - 1];
				spY[num2] = spY[num2 - 1];
			}
		}
		spN[0] = Main.worldName;
		spI[0] = Main.worldID;
		spX[0] = x;
		spY[0] = y;
		FindSpawn();
	}

	public static void SavePlayer(PlayerFileData playerFile, bool skipMapSave = false)
	{
		try
		{
			Main.Achievements.Save();
			InternalSaveMap(playerFile.IsCloudSave);
			if (!Main.ServerSideCharacter)
			{
				FileUtilities.ProtectedInvoke(delegate
				{
					InternalSavePlayerFile(playerFile);
				});
			}
		}
		catch (Exception ex)
		{
			FancyErrorPrinter.ShowFileSavingFailError(ex, playerFile.Path);
			if (!Main.gameMenu)
			{
				WorldGen.SaveAndQuit();
			}
			Utils.ShowFancyErrorMessage($"{Language.GetTextValue("tModLoader.PlayerSaveFail")}\n\n{ex}", Main.menuMode);
			throw;
		}
	}

	private static void InternalSavePlayerFile(PlayerFileData playerFile)
	{
		if (!playerFile.ServerSideCharacter)
		{
			string path = playerFile.Path;
			Player player = playerFile.Player;
			_ = playerFile.IsCloudSave;
			if (!string.IsNullOrEmpty(path))
			{
				PlayerLoader.PreSavePlayer(player);
				byte[] plrData = SavePlayerFile_Vanilla(playerFile);
				PlayerLoader.PostSavePlayer(player);
				player.ModSaveErrors.Clear();
				TagCompound tplrData = PlayerIO.SaveData(player);
				SavePlayerFile_Write(playerFile, plrData, tplrData);
			}
		}
	}

	public static byte[] SavePlayerFile_Vanilla(PlayerFileData playerFile)
	{
		Player player = playerFile.Player;
		RijndaelManaged rijndaelManaged = new RijndaelManaged();
		using Stream stream = new MemoryStream(2000);
		using CryptoStream cryptoStream = new CryptoStream(stream, rijndaelManaged.CreateEncryptor(ENCRYPTION_KEY, ENCRYPTION_KEY), CryptoStreamMode.Write);
		using BinaryWriter binaryWriter = new BinaryWriter(cryptoStream);
		binaryWriter.Write(279);
		playerFile.Metadata.Write(binaryWriter);
		Serialize(playerFile, player, binaryWriter);
		binaryWriter.Flush();
		cryptoStream.FlushFinalBlock();
		stream.Flush();
		return ((MemoryStream)stream).ToArray();
	}

	private static void SavePlayerFile_Write(PlayerFileData playerFile, byte[] plrData, TagCompound tplrData)
	{
		string path = playerFile.Path;
		bool isCloudSave = playerFile.IsCloudSave;
		if (!string.IsNullOrEmpty(path))
		{
			Main.statusText = Language.GetTextValue("tModLoader.BackingUpPlayerFile");
			BackupIO.Player.ArchivePlayer(path, isCloudSave);
			if (FileUtilities.Exists(path, isCloudSave))
			{
				FileUtilities.Copy(path, path + ".bak", isCloudSave);
			}
			FileUtilities.WriteAllBytes(path, plrData, isCloudSave);
			PlayerIO.Save(tplrData, path, isCloudSave);
		}
	}

	private static void Serialize(PlayerFileData playerFile, Player newPlayer, BinaryWriter fileIO)
	{
		fileIO.Write(newPlayer.name);
		fileIO.Write(newPlayer.difficulty);
		fileIO.Write(playerFile.GetPlayTime().Ticks);
		PlayerIO.WriteVanillaHair(newPlayer.hair, fileIO);
		PlayerIO.WriteByteVanillaHairDye(newPlayer.hairDye, fileIO);
		BitsByte bitsByte = (byte)0;
		for (int i = 0; i < 8; i++)
		{
			bitsByte[i] = newPlayer.hideVisibleAccessory[i];
		}
		fileIO.Write(bitsByte);
		bitsByte = (byte)0;
		for (int j = 0; j < 2; j++)
		{
			bitsByte[j] = newPlayer.hideVisibleAccessory[j + 8];
		}
		fileIO.Write(bitsByte);
		fileIO.Write(newPlayer.hideMisc);
		fileIO.Write((byte)newPlayer.skinVariant);
		fileIO.Write(newPlayer.statLife);
		fileIO.Write(100 + newPlayer.ConsumedLifeCrystals * 20 + newPlayer.ConsumedLifeFruit * 5);
		fileIO.Write(newPlayer.statMana);
		fileIO.Write(20 + newPlayer.ConsumedManaCrystals * 20);
		fileIO.Write(newPlayer.extraAccessory);
		fileIO.Write(newPlayer.unlockedBiomeTorches);
		fileIO.Write(newPlayer.UsingBiomeTorches);
		fileIO.Write(newPlayer.ateArtisanBread);
		fileIO.Write(newPlayer.usedAegisCrystal);
		fileIO.Write(newPlayer.usedAegisFruit);
		fileIO.Write(newPlayer.usedArcaneCrystal);
		fileIO.Write(newPlayer.usedGalaxyPearl);
		fileIO.Write(newPlayer.usedGummyWorm);
		fileIO.Write(newPlayer.usedAmbrosia);
		fileIO.Write(newPlayer.downedDD2EventAnyDifficulty);
		fileIO.Write(newPlayer.taxMoney);
		fileIO.Write(newPlayer.numberOfDeathsPVE);
		fileIO.Write(newPlayer.numberOfDeathsPVP);
		fileIO.Write(((Color)(ref newPlayer.hairColor)).R);
		fileIO.Write(((Color)(ref newPlayer.hairColor)).G);
		fileIO.Write(((Color)(ref newPlayer.hairColor)).B);
		fileIO.Write(((Color)(ref newPlayer.skinColor)).R);
		fileIO.Write(((Color)(ref newPlayer.skinColor)).G);
		fileIO.Write(((Color)(ref newPlayer.skinColor)).B);
		fileIO.Write(((Color)(ref newPlayer.eyeColor)).R);
		fileIO.Write(((Color)(ref newPlayer.eyeColor)).G);
		fileIO.Write(((Color)(ref newPlayer.eyeColor)).B);
		fileIO.Write(((Color)(ref newPlayer.shirtColor)).R);
		fileIO.Write(((Color)(ref newPlayer.shirtColor)).G);
		fileIO.Write(((Color)(ref newPlayer.shirtColor)).B);
		fileIO.Write(((Color)(ref newPlayer.underShirtColor)).R);
		fileIO.Write(((Color)(ref newPlayer.underShirtColor)).G);
		fileIO.Write(((Color)(ref newPlayer.underShirtColor)).B);
		fileIO.Write(((Color)(ref newPlayer.pantsColor)).R);
		fileIO.Write(((Color)(ref newPlayer.pantsColor)).G);
		fileIO.Write(((Color)(ref newPlayer.pantsColor)).B);
		fileIO.Write(((Color)(ref newPlayer.shoeColor)).R);
		fileIO.Write(((Color)(ref newPlayer.shoeColor)).G);
		fileIO.Write(((Color)(ref newPlayer.shoeColor)).B);
		for (int k = 0; k < newPlayer.armor.Length; k++)
		{
			ItemIO.WriteVanillaID(newPlayer.armor[k], fileIO);
			ItemIO.WriteByteVanillaPrefix(newPlayer.armor[k], fileIO);
		}
		for (int l = 0; l < newPlayer.dye.Length; l++)
		{
			ItemIO.WriteVanillaID(newPlayer.dye[l], fileIO);
			ItemIO.WriteByteVanillaPrefix(newPlayer.dye[l], fileIO);
		}
		for (int m = 0; m < 58; m++)
		{
			ItemIO.WriteVanillaID(newPlayer.inventory[m], fileIO);
			fileIO.Write(newPlayer.inventory[m].stack);
			ItemIO.WriteByteVanillaPrefix(newPlayer.inventory[m], fileIO);
			fileIO.Write(newPlayer.inventory[m].favorited);
		}
		for (int n = 0; n < newPlayer.miscEquips.Length; n++)
		{
			ItemIO.WriteVanillaID(newPlayer.miscEquips[n], fileIO);
			ItemIO.WriteByteVanillaPrefix(newPlayer.miscEquips[n], fileIO);
			ItemIO.WriteVanillaID(newPlayer.miscDyes[n], fileIO);
			ItemIO.WriteByteVanillaPrefix(newPlayer.miscDyes[n], fileIO);
		}
		for (int num = 0; num < 40; num++)
		{
			ItemIO.WriteVanillaID(newPlayer.bank.item[num], fileIO);
			fileIO.Write(newPlayer.bank.item[num].stack);
			ItemIO.WriteByteVanillaPrefix(newPlayer.bank.item[num], fileIO);
		}
		for (int num2 = 0; num2 < 40; num2++)
		{
			ItemIO.WriteVanillaID(newPlayer.bank2.item[num2], fileIO);
			fileIO.Write(newPlayer.bank2.item[num2].stack);
			ItemIO.WriteByteVanillaPrefix(newPlayer.bank2.item[num2], fileIO);
		}
		for (int num3 = 0; num3 < 40; num3++)
		{
			ItemIO.WriteVanillaID(newPlayer.bank3.item[num3], fileIO);
			fileIO.Write(newPlayer.bank3.item[num3].stack);
			ItemIO.WriteByteVanillaPrefix(newPlayer.bank3.item[num3], fileIO);
		}
		for (int num4 = 0; num4 < 40; num4++)
		{
			ItemIO.WriteVanillaID(newPlayer.bank4.item[num4], fileIO);
			fileIO.Write(newPlayer.bank4.item[num4].stack);
			ItemIO.WriteByteVanillaPrefix(newPlayer.bank4.item[num4], fileIO);
			fileIO.Write(newPlayer.bank4.item[num4].favorited);
		}
		fileIO.Write(newPlayer.voidVaultInfo);
		for (int num5 = 0; num5 < 44; num5++)
		{
			fileIO.Write(0);
			fileIO.Write(0);
		}
		for (int num6 = 0; num6 < 200; num6++)
		{
			if (newPlayer.spN[num6] == null)
			{
				fileIO.Write(-1);
				break;
			}
			fileIO.Write(newPlayer.spX[num6]);
			fileIO.Write(newPlayer.spY[num6]);
			fileIO.Write(newPlayer.spI[num6]);
			fileIO.Write(newPlayer.spN[num6]);
		}
		fileIO.Write(newPlayer.hbLocked);
		for (int num7 = 0; num7 < InfoDisplayLoader.DefaultDisplayCount; num7++)
		{
			fileIO.Write(newPlayer.hideInfo[num7]);
		}
		fileIO.Write(newPlayer.anglerQuestsFinished);
		for (int num8 = 0; num8 < newPlayer.DpadRadial.Bindings.Length; num8++)
		{
			fileIO.Write(newPlayer.DpadRadial.Bindings[num8]);
		}
		for (int num9 = 0; num9 < BuilderToggleLoader.DefaultDisplayCount; num9++)
		{
			fileIO.Write(newPlayer.builderAccStatus[num9]);
		}
		fileIO.Write(newPlayer.bartenderQuestLog);
		fileIO.Write(newPlayer.dead);
		if (newPlayer.dead)
		{
			fileIO.Write(newPlayer.respawnTimer);
		}
		long value = DateTime.UtcNow.ToBinary();
		fileIO.Write(value);
		fileIO.Write(newPlayer.golferScoreAccumulated);
		newPlayer.creativeTracker.Save(fileIO);
		newPlayer.SaveTemporaryItemSlotContents(fileIO);
		CreativePowerManager.Instance.SaveToPlayer(newPlayer, fileIO);
		fileIO.Write(new BitsByte
		{
			[0] = newPlayer.unlockedSuperCart,
			[1] = newPlayer.enabledSuperCart
		});
		fileIO.Write(newPlayer.CurrentLoadoutIndex);
		for (int num10 = 0; num10 < newPlayer.Loadouts.Length; num10++)
		{
			newPlayer.Loadouts[num10].Serialize(fileIO);
		}
	}

	private void SaveTemporaryItemSlotContents(BinaryWriter writer)
	{
		Item itemByIndex = Main.CreativeMenu.GetItemByIndex(0);
		BitsByte bitsByte = (byte)0;
		bitsByte[0] = !Main.mouseItem.IsAir;
		bitsByte[1] = !itemByIndex.IsAir;
		bitsByte[2] = !Main.guideItem.IsAir;
		bitsByte[3] = !Main.reforgeItem.IsAir;
		ItemSerializationContext context = ItemSerializationContext.SavingAndLoading;
		writer.Write(bitsByte);
		if (bitsByte[0])
		{
			Main.mouseItem.Serialize(writer, context);
		}
		if (bitsByte[1])
		{
			itemByIndex.Serialize(writer, context);
		}
		if (bitsByte[2])
		{
			Main.guideItem.Serialize(writer, context);
		}
		if (bitsByte[3])
		{
			Main.reforgeItem.Serialize(writer, context);
		}
	}

	private void LoadTemporaryItemSlotContents(BinaryReader reader)
	{
		BitsByte bitsByte = reader.ReadByte();
		ItemSerializationContext context = ItemSerializationContext.SavingAndLoading;
		if (bitsByte[0])
		{
			_temporaryItemSlots[0] = new Item();
			_temporaryItemSlots[0].DeserializeFrom(reader, context);
		}
		if (bitsByte[1])
		{
			_temporaryItemSlots[1] = new Item();
			_temporaryItemSlots[1].DeserializeFrom(reader, context);
		}
		if (bitsByte[2])
		{
			_temporaryItemSlots[2] = new Item();
			_temporaryItemSlots[2].DeserializeFrom(reader, context);
		}
		if (bitsByte[3])
		{
			_temporaryItemSlots[3] = new Item();
			_temporaryItemSlots[3].DeserializeFrom(reader, context);
		}
	}

	public void SetPlayerDataToOutOfClassFields()
	{
		Item mouseItem = new Item();
		if (_temporaryItemSlots[0] != null)
		{
			mouseItem = _temporaryItemSlots[0].Clone();
		}
		Main.mouseItem = mouseItem;
		mouseItem = new Item();
		if (_temporaryItemSlots[1] != null)
		{
			mouseItem = _temporaryItemSlots[1].Clone();
		}
		Main.CreativeMenu.SetItembyIndex(mouseItem, 0);
		mouseItem = new Item();
		if (_temporaryItemSlots[2] != null)
		{
			mouseItem = _temporaryItemSlots[2].Clone();
		}
		Main.guideItem = mouseItem;
		mouseItem = new Item();
		if (_temporaryItemSlots[3] != null)
		{
			mouseItem = _temporaryItemSlots[3].Clone();
		}
		Main.reforgeItem = mouseItem;
		CreativePowerManager.Instance.ApplyLoadedDataToPlayer(this);
	}

	public static void ClearPlayerTempInfo()
	{
		Main.mouseItem.TurnToAir();
		Main.guideItem.TurnToAir();
		Main.reforgeItem.TurnToAir();
		Main.CreativeMenu.GetItemByIndex(0).TurnToAir();
	}

	public static void InternalSaveMap(bool isCloudSave)
	{
		if (string.IsNullOrEmpty(Main.playerPathName))
		{
			return;
		}
		try
		{
			if (Main.mapEnabled)
			{
				Main.Map.Save();
			}
		}
		catch
		{
		}
		if (!isCloudSave)
		{
			Utils.TryCreatingDirectory(Main.PlayerPath);
		}
	}

	public static PlayerFileData LoadPlayer(string playerPath, bool cloudSave)
	{
		PlayerFileData playerFileData = new PlayerFileData(playerPath, cloudSave);
		if (cloudSave && SocialAPI.Cloud == null)
		{
			return playerFileData;
		}
		if (Main.rand == null)
		{
			Main.rand = new UnifiedRandom((int)DateTime.Now.Ticks);
		}
		byte[] plrData = FileUtilities.ReadAllBytes(playerPath, cloudSave);
		byte[] tplrData = PlayerIO.ReadDataBytes(playerPath, cloudSave);
		return LoadPlayerFromStream(playerFileData, plrData, tplrData);
	}

	public static PlayerFileData LoadPlayerFromStream(PlayerFileData playerFileData, byte[] plrData, byte[] tplrData)
	{
		string path = playerFileData.Path;
		Player player = new Player();
		bool gotToReadName = false;
		using (new Main.CurrentPlayerOverride(player))
		{
			try
			{
				RijndaelManaged rijndaelManaged = new RijndaelManaged();
				rijndaelManaged.Padding = PaddingMode.None;
				using (MemoryStream stream = new MemoryStream(plrData))
				{
					using CryptoStream input = new CryptoStream(stream, rijndaelManaged.CreateDecryptor(ENCRYPTION_KEY, ENCRYPTION_KEY), CryptoStreamMode.Read);
					using BinaryReader binaryReader = new BinaryReader(input);
					int num = binaryReader.ReadInt32();
					if (num >= 135)
					{
						playerFileData.Metadata = FileMetadata.Read(binaryReader, FileType.Player);
					}
					else
					{
						playerFileData.Metadata = FileMetadata.FromCurrentSettings(FileType.Player);
					}
					if (num > 279)
					{
						player.loadStatus = 1;
						player.name = binaryReader.ReadString();
						playerFileData.Player = player;
						return playerFileData;
					}
					Deserialize(playerFileData, player, binaryReader, tplrData, num, out gotToReadName);
				}
				player.PlayerFrame();
				player.loadStatus = 0;
				playerFileData.Player = player;
				return playerFileData;
			}
			catch (CustomModDataException customDataFail)
			{
				playerFileData.customDataFail = customDataFail;
			}
			catch
			{
			}
			Player player2 = new Player();
			player2.loadStatus = 2;
			if (gotToReadName && player.name.Length <= nameLen)
			{
				player2.name = player.name;
			}
			else
			{
				player2.name = path.Replace('/', Path.DirectorySeparatorChar).Split(Path.DirectorySeparatorChar)[^1].Split('.')[0];
			}
			playerFileData.Player = player2;
			return playerFileData;
		}
	}

	public Player SerializedClone()
	{
		Player player = new Player();
		_visualCloneStream.Seek(0L, SeekOrigin.Begin);
		Serialize(_visualCloneDummyData, this, _visualCloneWriter);
		_visualCloneStream.Seek(0L, SeekOrigin.Begin);
		try
		{
			Deserialize(_visualCloneDummyData, player, _visualCloneReader, PlayerIO.SaveData(this), 279, out var _);
		}
		catch (CustomModDataException)
		{
		}
		return player;
	}

	private static void Deserialize(PlayerFileData data, Player newPlayer, BinaryReader fileIO, TagCompound tplrData, int release, out bool gotToReadName)
	{
		Deserialize(data, newPlayer, fileIO, release, out gotToReadName);
		if (tplrData != null)
		{
			PlayerIO.Load(newPlayer, tplrData);
		}
		LoadPlayer_LastMinuteFixes(newPlayer);
	}

	private static void Deserialize(PlayerFileData data, Player newPlayer, BinaryReader fileIO, byte[] tplrData, int release, out bool gotToReadName)
	{
		Deserialize(data, newPlayer, fileIO, release, out gotToReadName);
		if (tplrData != null)
		{
			PlayerIO.Load(newPlayer, TagIO.FromStream(tplrData.ToMemoryStream()));
		}
		LoadPlayer_LastMinuteFixes(newPlayer);
	}

	private static void Deserialize(PlayerFileData data, Player newPlayer, BinaryReader fileIO, int release, out bool gotToReadName)
	{
		//IL_0314: Unknown result type (might be due to invalid IL or missing references)
		//IL_0319: Unknown result type (might be due to invalid IL or missing references)
		//IL_0320: Unknown result type (might be due to invalid IL or missing references)
		//IL_0325: Unknown result type (might be due to invalid IL or missing references)
		//IL_032c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0331: Unknown result type (might be due to invalid IL or missing references)
		//IL_0338: Unknown result type (might be due to invalid IL or missing references)
		//IL_033d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0344: Unknown result type (might be due to invalid IL or missing references)
		//IL_0349: Unknown result type (might be due to invalid IL or missing references)
		//IL_0350: Unknown result type (might be due to invalid IL or missing references)
		//IL_0355: Unknown result type (might be due to invalid IL or missing references)
		//IL_035c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0361: Unknown result type (might be due to invalid IL or missing references)
		//IL_0372: Unknown result type (might be due to invalid IL or missing references)
		//IL_0377: Unknown result type (might be due to invalid IL or missing references)
		//IL_0388: Unknown result type (might be due to invalid IL or missing references)
		//IL_038d: Unknown result type (might be due to invalid IL or missing references)
		//IL_039e: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_03cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_03fb: Unknown result type (might be due to invalid IL or missing references)
		gotToReadName = false;
		newPlayer.name = fileIO.ReadString();
		gotToReadName = true;
		if (release >= 10)
		{
			if (release >= 17)
			{
				newPlayer.difficulty = fileIO.ReadByte();
			}
			else if (fileIO.ReadBoolean())
			{
				newPlayer.difficulty = 2;
			}
		}
		if (release >= 138)
		{
			data.SetPlayTime(new TimeSpan(fileIO.ReadInt64()));
		}
		else
		{
			data.SetPlayTime(TimeSpan.Zero);
		}
		newPlayer.hair = fileIO.ReadInt32();
		if (release >= 82)
		{
			newPlayer.hairDye = fileIO.ReadByte();
		}
		if (release >= 124)
		{
			BitsByte bitsByte = fileIO.ReadByte();
			for (int i = 0; i < 8; i++)
			{
				newPlayer.hideVisibleAccessory[i] = bitsByte[i];
			}
			bitsByte = fileIO.ReadByte();
			for (int j = 0; j < 2; j++)
			{
				newPlayer.hideVisibleAccessory[j + 8] = bitsByte[j];
			}
		}
		else if (release >= 83)
		{
			BitsByte bitsByte2 = fileIO.ReadByte();
			for (int k = 0; k < 8; k++)
			{
				newPlayer.hideVisibleAccessory[k] = bitsByte2[k];
			}
		}
		if (release >= 119)
		{
			newPlayer.hideMisc = fileIO.ReadByte();
		}
		if (release <= 17)
		{
			if (newPlayer.hair == 5 || newPlayer.hair == 6 || newPlayer.hair == 9 || newPlayer.hair == 11)
			{
				newPlayer.Male = false;
			}
			else
			{
				newPlayer.Male = true;
			}
		}
		else if (release < 107)
		{
			newPlayer.Male = fileIO.ReadBoolean();
		}
		else
		{
			newPlayer.skinVariant = fileIO.ReadByte();
		}
		if (release < 161 && newPlayer.skinVariant == 7)
		{
			newPlayer.skinVariant = 9;
		}
		newPlayer.statLife = fileIO.ReadInt32();
		newPlayer.statLifeMax = fileIO.ReadInt32();
		if (newPlayer.statLifeMax > 500)
		{
			newPlayer.statLifeMax = 500;
		}
		newPlayer.statMana = fileIO.ReadInt32();
		newPlayer.statManaMax = fileIO.ReadInt32();
		if (newPlayer.statManaMax > 200)
		{
			newPlayer.statManaMax = 200;
		}
		newPlayer.ConsumedLifeCrystals = (newPlayer.statLifeMax - 100) / 20;
		newPlayer.ConsumedLifeFruit = (newPlayer.statLifeMax - 400) / 5;
		newPlayer.ConsumedManaCrystals = (newPlayer.statManaMax - 20) / 20;
		if (release >= 125)
		{
			newPlayer.extraAccessory = fileIO.ReadBoolean();
		}
		if (release >= 229)
		{
			newPlayer.unlockedBiomeTorches = fileIO.ReadBoolean();
			newPlayer.UsingBiomeTorches = fileIO.ReadBoolean();
			if (release >= 256)
			{
				newPlayer.ateArtisanBread = fileIO.ReadBoolean();
			}
			if (release >= 260)
			{
				newPlayer.usedAegisCrystal = fileIO.ReadBoolean();
				newPlayer.usedAegisFruit = fileIO.ReadBoolean();
				newPlayer.usedArcaneCrystal = fileIO.ReadBoolean();
				newPlayer.usedGalaxyPearl = fileIO.ReadBoolean();
				newPlayer.usedGummyWorm = fileIO.ReadBoolean();
				newPlayer.usedAmbrosia = fileIO.ReadBoolean();
			}
		}
		if (release >= 182)
		{
			newPlayer.downedDD2EventAnyDifficulty = fileIO.ReadBoolean();
		}
		if (release >= 128)
		{
			newPlayer.taxMoney = fileIO.ReadInt32();
		}
		if (release >= 254)
		{
			newPlayer.numberOfDeathsPVE = fileIO.ReadInt32();
		}
		if (release >= 254)
		{
			newPlayer.numberOfDeathsPVP = fileIO.ReadInt32();
		}
		newPlayer.hairColor = fileIO.ReadRGB();
		newPlayer.skinColor = fileIO.ReadRGB();
		newPlayer.eyeColor = fileIO.ReadRGB();
		newPlayer.shirtColor = fileIO.ReadRGB();
		newPlayer.underShirtColor = fileIO.ReadRGB();
		newPlayer.pantsColor = fileIO.ReadRGB();
		newPlayer.shoeColor = fileIO.ReadRGB();
		Main.player[Main.myPlayer].hairColor = newPlayer.hairColor;
		Main.player[Main.myPlayer].skinColor = newPlayer.skinColor;
		Main.player[Main.myPlayer].eyeColor = newPlayer.eyeColor;
		Main.player[Main.myPlayer].shirtColor = newPlayer.shirtColor;
		Main.player[Main.myPlayer].underShirtColor = newPlayer.underShirtColor;
		Main.player[Main.myPlayer].pantsColor = newPlayer.pantsColor;
		Main.player[Main.myPlayer].shoeColor = newPlayer.shoeColor;
		if (release >= 38)
		{
			if (release < 124)
			{
				int num = 11;
				if (release >= 81)
				{
					num = 16;
				}
				for (int l = 0; l < num; l++)
				{
					int num2 = l;
					if (num2 >= 8)
					{
						num2 += 2;
					}
					newPlayer.armor[num2].netDefaults(fileIO.ReadInt32());
					newPlayer.armor[num2].Prefix(fileIO.ReadByte());
				}
			}
			else
			{
				int num3 = 20;
				for (int m = 0; m < num3; m++)
				{
					newPlayer.armor[m].netDefaults(fileIO.ReadInt32());
					newPlayer.armor[m].Prefix(fileIO.ReadByte());
				}
			}
			if (release >= 47)
			{
				int num4 = 3;
				if (release >= 81)
				{
					num4 = 8;
				}
				if (release >= 124)
				{
					num4 = 10;
				}
				for (int n = 0; n < num4; n++)
				{
					int num5 = n;
					newPlayer.dye[num5].netDefaults(fileIO.ReadInt32());
					newPlayer.dye[num5].Prefix(fileIO.ReadByte());
				}
			}
			if (release >= 58)
			{
				for (int num6 = 0; num6 < 58; num6++)
				{
					int num7 = fileIO.ReadInt32();
					if (num7 >= ItemID.Count)
					{
						newPlayer.inventory[num6].netDefaults(0);
						fileIO.ReadInt32();
						fileIO.ReadByte();
						if (release >= 114)
						{
							fileIO.ReadBoolean();
						}
					}
					else
					{
						newPlayer.inventory[num6].netDefaults(num7);
						newPlayer.inventory[num6].stack = fileIO.ReadInt32();
						newPlayer.inventory[num6].Prefix(fileIO.ReadByte());
						if (release >= 114)
						{
							newPlayer.inventory[num6].favorited = fileIO.ReadBoolean();
						}
					}
				}
			}
			else
			{
				for (int num8 = 0; num8 < 48; num8++)
				{
					int num9 = fileIO.ReadInt32();
					if (num9 >= ItemID.Count)
					{
						newPlayer.inventory[num8].netDefaults(0);
						fileIO.ReadInt32();
						fileIO.ReadByte();
					}
					else
					{
						newPlayer.inventory[num8].netDefaults(num9);
						newPlayer.inventory[num8].stack = fileIO.ReadInt32();
						newPlayer.inventory[num8].Prefix(fileIO.ReadByte());
					}
				}
			}
			if (release >= 117)
			{
				if (release < 136)
				{
					for (int num10 = 0; num10 < 5; num10++)
					{
						if (num10 != 1)
						{
							int num11 = fileIO.ReadInt32();
							if (num11 >= ItemID.Count)
							{
								newPlayer.miscEquips[num10].netDefaults(0);
								fileIO.ReadByte();
							}
							else
							{
								newPlayer.miscEquips[num10].netDefaults(num11);
								newPlayer.miscEquips[num10].Prefix(fileIO.ReadByte());
							}
							num11 = fileIO.ReadInt32();
							if (num11 >= ItemID.Count)
							{
								newPlayer.miscDyes[num10].netDefaults(0);
								fileIO.ReadByte();
							}
							else
							{
								newPlayer.miscDyes[num10].netDefaults(num11);
								newPlayer.miscDyes[num10].Prefix(fileIO.ReadByte());
							}
						}
					}
				}
				else
				{
					for (int num12 = 0; num12 < 5; num12++)
					{
						int num13 = fileIO.ReadInt32();
						if (num13 >= ItemID.Count)
						{
							newPlayer.miscEquips[num12].netDefaults(0);
							fileIO.ReadByte();
						}
						else
						{
							newPlayer.miscEquips[num12].netDefaults(num13);
							newPlayer.miscEquips[num12].Prefix(fileIO.ReadByte());
						}
						num13 = fileIO.ReadInt32();
						if (num13 >= ItemID.Count)
						{
							newPlayer.miscDyes[num12].netDefaults(0);
							fileIO.ReadByte();
						}
						else
						{
							newPlayer.miscDyes[num12].netDefaults(num13);
							newPlayer.miscDyes[num12].Prefix(fileIO.ReadByte());
						}
					}
				}
			}
			if (release >= 58)
			{
				for (int num14 = 0; num14 < 40; num14++)
				{
					newPlayer.bank.item[num14].netDefaults(fileIO.ReadInt32());
					newPlayer.bank.item[num14].stack = fileIO.ReadInt32();
					newPlayer.bank.item[num14].Prefix(fileIO.ReadByte());
				}
				for (int num15 = 0; num15 < 40; num15++)
				{
					newPlayer.bank2.item[num15].netDefaults(fileIO.ReadInt32());
					newPlayer.bank2.item[num15].stack = fileIO.ReadInt32();
					newPlayer.bank2.item[num15].Prefix(fileIO.ReadByte());
				}
			}
			else
			{
				for (int num16 = 0; num16 < 20; num16++)
				{
					newPlayer.bank.item[num16].netDefaults(fileIO.ReadInt32());
					newPlayer.bank.item[num16].stack = fileIO.ReadInt32();
					newPlayer.bank.item[num16].Prefix(fileIO.ReadByte());
				}
				for (int num17 = 0; num17 < 20; num17++)
				{
					newPlayer.bank2.item[num17].netDefaults(fileIO.ReadInt32());
					newPlayer.bank2.item[num17].stack = fileIO.ReadInt32();
					newPlayer.bank2.item[num17].Prefix(fileIO.ReadByte());
				}
			}
			if (release >= 182)
			{
				for (int num18 = 0; num18 < 40; num18++)
				{
					newPlayer.bank3.item[num18].netDefaults(fileIO.ReadInt32());
					newPlayer.bank3.item[num18].stack = fileIO.ReadInt32();
					newPlayer.bank3.item[num18].Prefix(fileIO.ReadByte());
				}
			}
			if (release >= 198)
			{
				for (int num19 = 0; num19 < 40; num19++)
				{
					newPlayer.bank4.item[num19].netDefaults(fileIO.ReadInt32());
					newPlayer.bank4.item[num19].stack = fileIO.ReadInt32();
					newPlayer.bank4.item[num19].Prefix(fileIO.ReadByte());
					if (release >= 255)
					{
						newPlayer.bank4.item[num19].favorited = fileIO.ReadBoolean();
					}
				}
			}
			if (release >= 199)
			{
				newPlayer.voidVaultInfo = fileIO.ReadByte();
			}
		}
		else
		{
			for (int num20 = 0; num20 < 8; num20++)
			{
				newPlayer.armor[num20].SetDefaults(ItemID.FromLegacyName(fileIO.ReadString(), release));
				if (release >= 36)
				{
					newPlayer.armor[num20].Prefix(fileIO.ReadByte());
				}
			}
			if (release >= 6)
			{
				for (int num21 = 8; num21 < 11; num21++)
				{
					newPlayer.armor[num21].SetDefaults(ItemID.FromLegacyName(fileIO.ReadString(), release));
					if (release >= 36)
					{
						newPlayer.armor[num21].Prefix(fileIO.ReadByte());
					}
				}
			}
			for (int num22 = 0; num22 < 44; num22++)
			{
				newPlayer.inventory[num22].SetDefaults(ItemID.FromLegacyName(fileIO.ReadString(), release));
				newPlayer.inventory[num22].stack = fileIO.ReadInt32();
				if (release >= 36)
				{
					newPlayer.inventory[num22].Prefix(fileIO.ReadByte());
				}
			}
			if (release >= 15)
			{
				for (int num23 = 44; num23 < 48; num23++)
				{
					newPlayer.inventory[num23].SetDefaults(ItemID.FromLegacyName(fileIO.ReadString(), release));
					newPlayer.inventory[num23].stack = fileIO.ReadInt32();
					if (release >= 36)
					{
						newPlayer.inventory[num23].Prefix(fileIO.ReadByte());
					}
				}
			}
			for (int num24 = 0; num24 < 20; num24++)
			{
				newPlayer.bank.item[num24].SetDefaults(ItemID.FromLegacyName(fileIO.ReadString(), release));
				newPlayer.bank.item[num24].stack = fileIO.ReadInt32();
				if (release >= 36)
				{
					newPlayer.bank.item[num24].Prefix(fileIO.ReadByte());
				}
			}
			if (release >= 20)
			{
				for (int num25 = 0; num25 < 20; num25++)
				{
					newPlayer.bank2.item[num25].SetDefaults(ItemID.FromLegacyName(fileIO.ReadString(), release));
					newPlayer.bank2.item[num25].stack = fileIO.ReadInt32();
					if (release >= 36)
					{
						newPlayer.bank2.item[num25].Prefix(fileIO.ReadByte());
					}
				}
			}
		}
		if (release < 58)
		{
			for (int num26 = 40; num26 < 48; num26++)
			{
				newPlayer.inventory[num26 + 10] = newPlayer.inventory[num26].Clone();
				newPlayer.inventory[num26].SetDefaults();
			}
		}
		if (release >= 11)
		{
			int num27 = 22;
			if (release < 74)
			{
				num27 = 10;
			}
			if (release >= 252)
			{
				num27 = 44;
			}
			for (int num28 = 0; num28 < num27; num28++)
			{
				newPlayer.buffType[num28] = fileIO.ReadInt32();
				newPlayer.buffTime[num28] = fileIO.ReadInt32();
				if (newPlayer.buffType[num28] == 0)
				{
					num28--;
					num27--;
				}
			}
		}
		for (int num29 = 0; num29 < 200; num29++)
		{
			int num30 = fileIO.ReadInt32();
			if (num30 == -1)
			{
				break;
			}
			newPlayer.spX[num29] = num30;
			newPlayer.spY[num29] = fileIO.ReadInt32();
			newPlayer.spI[num29] = fileIO.ReadInt32();
			newPlayer.spN[num29] = fileIO.ReadString();
		}
		if (release >= 16)
		{
			newPlayer.hbLocked = fileIO.ReadBoolean();
		}
		if (release >= 115)
		{
			int num31 = 13;
			for (int num32 = 0; num32 < num31; num32++)
			{
				newPlayer.hideInfo[num32] = fileIO.ReadBoolean();
			}
		}
		if (release >= 98)
		{
			newPlayer.anglerQuestsFinished = fileIO.ReadInt32();
		}
		if (release >= 162)
		{
			for (int num33 = 0; num33 < 4; num33++)
			{
				newPlayer.DpadRadial.Bindings[num33] = fileIO.ReadInt32();
			}
		}
		if (release >= 164)
		{
			int num34 = 8;
			if (release >= 167)
			{
				num34 = 10;
			}
			if (release >= 197)
			{
				num34 = 11;
			}
			if (release >= 230)
			{
				num34 = 12;
			}
			for (int num35 = 0; num35 < num34; num35++)
			{
				newPlayer.builderAccStatus[num35] = fileIO.ReadInt32();
			}
			if (release < 210)
			{
				newPlayer.builderAccStatus[0] = 1;
			}
			if (release < 249)
			{
				bool flag = false;
				for (int num36 = 0; num36 < 58; num36++)
				{
					if (newPlayer.inventory[num36].type == 3611)
					{
						flag = true;
						break;
					}
				}
				if (flag)
				{
					newPlayer.builderAccStatus[1] = 1;
				}
			}
		}
		if (release >= 181)
		{
			newPlayer.bartenderQuestLog = fileIO.ReadInt32();
		}
		if (release >= 200)
		{
			newPlayer.dead = fileIO.ReadBoolean();
			if (newPlayer.dead)
			{
				newPlayer.respawnTimer = Utils.Clamp(fileIO.ReadInt32(), 0, 60000);
			}
		}
		newPlayer.lastTimePlayerWasSaved = 0L;
		if (release >= 202)
		{
			newPlayer.lastTimePlayerWasSaved = fileIO.ReadInt64();
		}
		else
		{
			newPlayer.lastTimePlayerWasSaved = DateTime.UtcNow.ToBinary();
		}
		if (release >= 206)
		{
			newPlayer.golferScoreAccumulated = fileIO.ReadInt32();
		}
		if (release >= 218)
		{
			newPlayer.creativeTracker.Load(fileIO, release);
		}
		if (release >= 214)
		{
			newPlayer.LoadTemporaryItemSlotContents(fileIO);
		}
		newPlayer.savedPerPlayerFieldsThatArentInThePlayerClass = new SavedPlayerDataWithAnnoyingRules();
		CreativePowerManager.Instance.ResetDataForNewPlayer(newPlayer);
		if (release >= 220)
		{
			CreativePowerManager.Instance.LoadToPlayer(newPlayer, fileIO, release);
		}
		if (release >= 253)
		{
			BitsByte bitsByte3 = fileIO.ReadByte();
			newPlayer.unlockedSuperCart = bitsByte3[0];
			newPlayer.enabledSuperCart = bitsByte3[1];
		}
		else
		{
			newPlayer.unlockedSuperCart = newPlayer.HasItemInAnyInventory(3353);
		}
		if (release >= 262)
		{
			int value = fileIO.ReadInt32();
			newPlayer.CurrentLoadoutIndex = Utils.Clamp(value, 0, newPlayer.Loadouts.Length - 1);
			for (int num37 = 0; num37 < newPlayer.Loadouts.Length; num37++)
			{
				newPlayer.Loadouts[num37].Deserialize(fileIO, release);
			}
		}
	}

	private static void AdjustRespawnTimerForWorldJoining(Player newPlayer)
	{
		if (Main.myPlayer != newPlayer.whoAmI || !newPlayer.dead)
		{
			return;
		}
		long num = DateTime.UtcNow.ToBinary() - newPlayer.lastTimePlayerWasSaved;
		if (num > 0)
		{
			int num2 = Utils.Clamp((int)(Utils.Clamp(new TimeSpan(num).TotalSeconds, 0.0, 1000.0) * 60.0), 0, newPlayer.respawnTimer);
			newPlayer.respawnTimer -= num2;
			if (newPlayer.respawnTimer == 0)
			{
				newPlayer.dead = false;
			}
		}
	}

	public void FixLoadedData()
	{
		FixLoadedData_Items(armor);
		FixLoadedData_Items(dye);
		FixLoadedData_Items(inventory);
		FixLoadedData_Items(miscEquips);
		FixLoadedData_Items(miscDyes);
		FixLoadedData_Items(bank.item);
		FixLoadedData_Items(bank2.item);
		FixLoadedData_Items(bank3.item);
		FixLoadedData_Items(bank4.item);
		FixLoadedData_Items(_temporaryItemSlots);
		FixLoadedData_EliminiateDuplicateAccessories(armor);
		for (int i = 0; i < Loadouts.Length; i++)
		{
			Loadouts[i].FixLoadedData();
		}
	}

	public static void FixLoadedData_EliminiateDuplicateAccessories(Item[] armorArray)
	{
		for (int i = 3; i < 10; i++)
		{
			Item item = armorArray[i];
			if (item.IsAir || item._globals.Length != 0)
			{
				continue;
			}
			for (int j = i + 1; j < 10; j++)
			{
				Item item2 = armorArray[j];
				if (item2.type == item.type)
				{
					item2.TurnToAir();
				}
			}
		}
	}

	private void FixLoadedData_Items(Item[] items)
	{
		for (int i = 0; i < items.Length; i++)
		{
			if (items[i] != null)
			{
				items[i].FixAgainstExploit();
			}
		}
	}

	private static void LoadPlayer_LastMinuteFixes(Player newPlayer)
	{
		newPlayer.skinVariant = (int)MathHelper.Clamp((float)newPlayer.skinVariant, 0f, (float)(PlayerVariantID.Count - 1));
		for (int i = 3; i < 10; i++)
		{
			LoadPlayer_LastMinuteFixes(newPlayer, newPlayer.armor[i]);
		}
		ModAccessorySlotPlayer modAccessorySlotPlayer = AccessorySlotLoader.ModSlotPlayer(newPlayer);
		for (int j = 0; j < modAccessorySlotPlayer.SlotCount; j++)
		{
			LoadPlayer_LastMinuteFixes(newPlayer, modAccessorySlotPlayer.exAccessorySlot[j]);
		}
		LoadPlayer_Finish(newPlayer);
	}

	private static void LoadPlayer_LastMinuteFixes(Player newPlayer, Item item)
	{
		Item[] array = newPlayer.armor;
		newPlayer.armor = new Item[1] { item };
		int num = 0;
		int type = newPlayer.armor[num].type;
		if (type == 908 || type == 5000)
		{
			newPlayer.lavaMax += 420;
		}
		if (type == 906 || type == 4038 || type == 3999 || type == 4003)
		{
			newPlayer.lavaMax += 420;
		}
		if (newPlayer.wingsLogic == 0 && newPlayer.armor[num].wingSlot >= 0)
		{
			newPlayer.wingsLogic = newPlayer.armor[num].wingSlot;
			newPlayer.equippedWings = newPlayer.armor[num];
		}
		if (type == 158 || type == 396 || type == 1250 || type == 1251 || type == 1252)
		{
			newPlayer.noFallDmg = true;
		}
		if (type == 860 || type == 535)
		{
			newPlayer.pStone = true;
		}
		newPlayer.lavaTime = newPlayer.lavaMax;
		newPlayer.armor = array;
	}

	private static void LoadPlayer_Finish(Player newPlayer)
	{
		newPlayer.FixLoadedData();
		newPlayer.ResetEffects();
	}

	public static PlayerFileData GetFileData(string file, bool cloudSave)
	{
		if (file == null || (cloudSave && SocialAPI.Cloud == null))
		{
			return null;
		}
		PlayerFileData playerFileData = LoadPlayer(file, cloudSave);
		if (playerFileData.Player != null)
		{
			if (playerFileData.Player.loadStatus != 0 && playerFileData.Player.loadStatus != 1)
			{
				CustomModDataException customDataFail = playerFileData.customDataFail;
				if (FileUtilities.Exists(file + ".bak", cloudSave))
				{
					FileUtilities.Move(file + ".bak", file, cloudSave);
					PlayerIO.LoadBackup(file, cloudSave);
				}
				playerFileData = LoadPlayer(file, cloudSave);
				if (playerFileData.Player == null)
				{
					return null;
				}
				playerFileData.customDataFail = customDataFail;
			}
			return playerFileData;
		}
		return null;
	}

	public Color GetHairColor(bool useLighting = true)
	{
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		Color color = Lighting.GetColor((int)((double)position.X + (double)width * 0.5) / 16, (int)(((double)position.Y + (double)height * 0.25) / 16.0));
		return GameShaders.Hair.GetColor(hairDye, this, useLighting ? color : Color.White);
	}

	/// <summary>
	/// Checks if the player has the specified item in their <see cref="F:Terraria.Player.inventory" />. <br />
	/// Does not check Void Bag. <br />
	/// Use <see cref="M:Terraria.Player.CountItem(System.Int32,System.Int32)" /> instead to count the total amount if needed. <br />
	/// </summary>
	/// <param name="type">The item type to count</param>
	/// <returns>True if the player has the item</returns>
	public bool HasItem(int type)
	{
		for (int i = 0; i < 58; i++)
		{
			if (type == inventory[i].type && inventory[i].stack > 0)
			{
				return true;
			}
		}
		return false;
	}

	/// <summary>
	/// Similar to <see cref="M:Terraria.Player.HasItem(System.Int32)" />, but checks the provided Item[] <paramref name="collection" /> for items instead. Useful for checking other Item arrays, such as <see cref="F:Terraria.Player.armor" /> or <see cref="F:Terraria.Player.bank" />.
	/// </summary>
	public bool HasItem(int type, Item[] collection)
	{
		for (int i = 0; i < collection.Length; i++)
		{
			if (type == collection[i].type && collection[i].stack > 0)
			{
				return true;
			}
		}
		return false;
	}

	/// <summary>
	/// Similar to <see cref="M:Terraria.Player.HasItem(System.Int32)" />, but also checks the Void Bag.
	/// </summary>
	public bool HasItemInInventoryOrOpenVoidBag(int type)
	{
		if (!HasItem(type))
		{
			if (useVoidBag())
			{
				return HasItem(type, bank4.item);
			}
			return false;
		}
		return true;
	}

	public bool HasItemInAnyInventory(int type)
	{
		if (HasItem(type, inventory))
		{
			return true;
		}
		if (HasItem(type, armor))
		{
			return true;
		}
		if (HasItem(type, dye))
		{
			return true;
		}
		if (HasItem(type, miscEquips))
		{
			return true;
		}
		if (HasItem(type, miscDyes))
		{
			return true;
		}
		if (HasItem(type, bank.item))
		{
			return true;
		}
		if (HasItem(type, bank2.item))
		{
			return true;
		}
		if (HasItem(type, bank3.item))
		{
			return true;
		}
		if (HasItem(type, bank4.item))
		{
			return true;
		}
		return false;
	}

	public int FindItem(int netid)
	{
		for (int i = 0; i < 58; i++)
		{
			if (netid == inventory[i].netID && inventory[i].stack > 0)
			{
				return i;
			}
		}
		return -1;
	}

	public int FindItem(List<int> netids)
	{
		for (int i = 0; i < 58; i++)
		{
			if (inventory[i].stack > 0 && netids.Contains(inventory[i].netID))
			{
				return i;
			}
		}
		return -1;
	}

	public int FindItem(bool[] validtypes)
	{
		for (int i = 0; i < 58; i++)
		{
			if (inventory[i].stack > 0 && validtypes[inventory[i].type])
			{
				return i;
			}
		}
		return -1;
	}

	public int FindItem(int type, Item[] collection)
	{
		for (int i = 0; i < collection.Length; i++)
		{
			if (inventory[i].stack > 0 && type == collection[i].type)
			{
				return i;
			}
		}
		return -1;
	}

	public int FindItemInInventoryOrOpenVoidBag(int type, out bool inVoidBag)
	{
		inVoidBag = false;
		int num = FindItem(type);
		if (num == -1 && useVoidBag())
		{
			num = FindItem(type, bank4.item);
			if (num == -1)
			{
				return -1;
			}
			inVoidBag = true;
		}
		return num;
	}

	public Player()
	{
		//IL_0234: Unknown result type (might be due to invalid IL or missing references)
		//IL_0239: Unknown result type (might be due to invalid IL or missing references)
		//IL_0385: Unknown result type (might be due to invalid IL or missing references)
		//IL_038a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0482: Unknown result type (might be due to invalid IL or missing references)
		//IL_0487: Unknown result type (might be due to invalid IL or missing references)
		//IL_0496: Unknown result type (might be due to invalid IL or missing references)
		//IL_049b: Unknown result type (might be due to invalid IL or missing references)
		//IL_04aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_04af: Unknown result type (might be due to invalid IL or missing references)
		//IL_04bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_04c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_04d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_04da: Unknown result type (might be due to invalid IL or missing references)
		//IL_04ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_04f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0509: Unknown result type (might be due to invalid IL or missing references)
		//IL_050e: Unknown result type (might be due to invalid IL or missing references)
		//IL_051d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0522: Unknown result type (might be due to invalid IL or missing references)
		//IL_05ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_05bf: Unknown result type (might be due to invalid IL or missing references)
		ResetDamageClassData();
		buffType = new int[maxBuffs];
		buffTime = new int[maxBuffs];
		buffImmune = new bool[BuffLoader.BuffCount];
		ownedProjectileCounts = new int[ProjectileLoader.ProjectileCount];
		npcTypeNoAggro = new bool[NPCLoader.NPCCount];
		PlayerLoader.SetupPlayer(this);
		LoaderManager.Get<BiomeLoader>().SetupPlayer(this);
		width = 20;
		height = 42;
		name = string.Empty;
		bodyFrame.Width = 40;
		bodyFrame.Height = 56;
		legFrame.Width = 40;
		legFrame.Height = 56;
		tileEntityAnchor.Clear();
		doorHelper = new DoorOpeningHelper();
		for (int i = 0; i < 59; i++)
		{
			if (i < armor.Length)
			{
				armor[i] = new Item();
			}
			inventory[i] = new Item();
		}
		for (int j = 0; j < 40; j++)
		{
			bank.item[j] = new Item();
			bank2.item[j] = new Item();
			bank3.item[j] = new Item();
			bank4.item[j] = new Item();
		}
		for (int k = 0; k < dye.Length; k++)
		{
			dye[k] = new Item();
		}
		for (int l = 0; l < miscEquips.Length; l++)
		{
			miscEquips[l] = new Item();
		}
		for (int m = 0; m < miscDyes.Length; m++)
		{
			miscDyes[m] = new Item();
		}
		trashItem = new Item();
		lastVisualizedSelectedItem = new Item();
		grappling[0] = -1;
		statManaMax = 20;
		extraAccessory = false;
		ateArtisanBread = false;
		usedAegisCrystal = false;
		usedAegisFruit = false;
		usedArcaneCrystal = false;
		usedGalaxyPearl = false;
		usedGummyWorm = false;
		usedAmbrosia = false;
		PlayerLoader.ModifyMaxStats(this);
		for (int n = 0; n < adjTile.Length; n++)
		{
			adjTile[n] = false;
			oldAdjTile[n] = false;
		}
		hitTile = new HitTile();
		hitReplace = new HitTile();
		mount = new Mount();
		talkNPC = -1;
		piggyBankProjTracker.Clear();
		voidLensChest.Clear();
		creativeTracker = new CreativeUnlocksTracker();
		builderAccStatus[0] = 1;
	}

	public void MagicConch()
	{
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_010e: Unknown result type (might be due to invalid IL or missing references)
		//IL_016e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0173: Unknown result type (might be due to invalid IL or missing references)
		//IL_0176: Unknown result type (might be due to invalid IL or missing references)
		//IL_0180: Unknown result type (might be due to invalid IL or missing references)
		//IL_0185: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_0199: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0156: Unknown result type (might be due to invalid IL or missing references)
		//IL_015d: Unknown result type (might be due to invalid IL or missing references)
		bool flag = position.X / 16f < (float)(Main.maxTilesX / 2);
		bool flag2 = false;
		int num = 50;
		int num2 = 50;
		int num3 = WorldGen.beachDistance - num - num2;
		if (flag)
		{
			num3 = Main.maxTilesX - num3 - 1 - num2;
		}
		else
		{
			num3 -= num2 / 2;
		}
		_ = (float)Main.maxTilesY / 1200f;
		_ = (float)Main.maxTilesY / 1200f;
		new RandomTeleportationAttemptSettings
		{
			avoidAnyLiquid = true,
			avoidHurtTiles = true,
			attemptsBeforeGivingUp = 1000,
			maximumFallDistanceFromOrignalPoint = 300
		};
		Vector2 val = Vector2.Zero;
		int num4 = flag.ToDirectionInt();
		int startX = (flag ? (Main.maxTilesX - 50) : 50);
		flag2 = true;
		if (!TeleportHelpers.RequestMagicConchTeleportPosition(this, -num4, startX, out var landingPoint))
		{
			flag2 = false;
			startX = ((!flag) ? (Main.maxTilesX - 50) : 50);
			if (TeleportHelpers.RequestMagicConchTeleportPosition(this, num4, startX, out landingPoint))
			{
				flag2 = true;
			}
		}
		if (flag2)
		{
			val = landingPoint.ToWorldCoordinates(8f, 16f) - new Vector2((float)(width / 2), (float)height);
		}
		if (flag2)
		{
			Vector2 val2 = val;
			Teleport(val2, 5);
			velocity = Vector2.Zero;
			if (Main.netMode == 2)
			{
				RemoteClient.CheckSection(whoAmI, position);
				NetMessage.SendData(65, -1, -1, null, 0, whoAmI, val2.X, val2.Y, 5);
			}
		}
		else
		{
			Vector2 val3 = position;
			Teleport(val3, 5);
			velocity = Vector2.Zero;
			if (Main.netMode == 2)
			{
				RemoteClient.CheckSection(whoAmI, position);
				NetMessage.SendData(65, -1, -1, null, 0, whoAmI, val3.X, val3.Y, 5, 1);
			}
		}
	}

	public void Shellphone_Spawn()
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		int floorX = Main.spawnTileX;
		int floorY = Main.spawnTileY;
		Spawn_GetPositionAtWorldSpawn(ref floorX, ref floorY);
		if (Main.netMode != 1 && !Spawn_IsAreaAValidWorldSpawn(floorX, floorY))
		{
			Spawn_ForceClearArea(floorX, floorY);
		}
		Vector2 val = Utils.ToWorldCoordinates(new Point(floorX, floorY), 8f, 0f) - new Vector2((float)(width / 2), (float)height);
		Teleport(val, 11);
		velocity = Vector2.Zero;
		if (Main.netMode == 2)
		{
			RemoteClient.CheckSection(whoAmI, position);
			NetMessage.SendData(65, -1, -1, null, 0, whoAmI, val.X, val.Y, 11);
		}
	}

	public void DemonConch()
	{
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_010e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_013f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0146: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		bool canSpawn = false;
		int num = Main.maxTilesX / 2;
		int num2 = 100;
		int num3 = num2 / 2;
		int teleportStartY = Main.UnderworldLayer + 20;
		int teleportRangeY = 80;
		RandomTeleportationAttemptSettings settings = new RandomTeleportationAttemptSettings
		{
			mostlySolidFloor = true,
			avoidAnyLiquid = true,
			avoidLava = true,
			avoidHurtTiles = true,
			avoidWalls = true,
			attemptsBeforeGivingUp = 1000,
			maximumFallDistanceFromOrignalPoint = 30
		};
		Vector2 val = CheckForGoodTeleportationSpot(ref canSpawn, num - num3, num2, teleportStartY, teleportRangeY, settings);
		if (!canSpawn)
		{
			val = CheckForGoodTeleportationSpot(ref canSpawn, num - num2, num3, teleportStartY, teleportRangeY, settings);
		}
		if (!canSpawn)
		{
			val = CheckForGoodTeleportationSpot(ref canSpawn, num + num3, num3, teleportStartY, teleportRangeY, settings);
		}
		if (canSpawn)
		{
			Vector2 val2 = val;
			Teleport(val2, 7);
			velocity = Vector2.Zero;
			if (Main.netMode == 2)
			{
				RemoteClient.CheckSection(whoAmI, position);
				NetMessage.SendData(65, -1, -1, null, 0, whoAmI, val2.X, val2.Y, 7);
			}
		}
		else
		{
			Vector2 val3 = position;
			Teleport(val3, 7);
			velocity = Vector2.Zero;
			if (Main.netMode == 2)
			{
				RemoteClient.CheckSection(whoAmI, position);
				NetMessage.SendData(65, -1, -1, null, 0, whoAmI, val3.X, val3.Y, 7, 1);
			}
		}
	}

	public void TeleportationPotion()
	{
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		bool canSpawn = false;
		int teleportStartX = 100;
		int teleportRangeX = Main.maxTilesX - 200;
		int teleportStartY = 100;
		int underworldLayer = Main.UnderworldLayer;
		Vector2 val = CheckForGoodTeleportationSpot(ref canSpawn, teleportStartX, teleportRangeX, teleportStartY, underworldLayer, new RandomTeleportationAttemptSettings
		{
			avoidLava = true,
			avoidHurtTiles = true,
			maximumFallDistanceFromOrignalPoint = 100,
			attemptsBeforeGivingUp = 1000
		});
		if (canSpawn)
		{
			Vector2 val2 = val;
			Teleport(val2, 2);
			velocity = Vector2.Zero;
			if (Main.netMode == 2)
			{
				RemoteClient.CheckSection(whoAmI, position);
				NetMessage.SendData(65, -1, -1, null, 0, whoAmI, val2.X, val2.Y, 2);
			}
		}
		else
		{
			Vector2 val3 = position;
			Teleport(val3, 2);
			velocity = Vector2.Zero;
			if (Main.netMode == 2)
			{
				RemoteClient.CheckSection(whoAmI, position);
				NetMessage.SendData(65, -1, -1, null, 0, whoAmI, val3.X, val3.Y, 2, 1);
			}
		}
	}

	public Vector2 CheckForGoodTeleportationSpot(ref bool canSpawn, int teleportStartX, int teleportRangeX, int teleportStartY, int teleportRangeY, RandomTeleportationAttemptSettings settings)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0550: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0271: Unknown result type (might be due to invalid IL or missing references)
		//IL_027e: Unknown result type (might be due to invalid IL or missing references)
		//IL_028b: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_020d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0213: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_03dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0414: Unknown result type (might be due to invalid IL or missing references)
		//IL_0429: Unknown result type (might be due to invalid IL or missing references)
		//IL_0433: Unknown result type (might be due to invalid IL or missing references)
		//IL_0438: Unknown result type (might be due to invalid IL or missing references)
		//IL_043a: Unknown result type (might be due to invalid IL or missing references)
		//IL_043c: Unknown result type (might be due to invalid IL or missing references)
		//IL_043e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0443: Unknown result type (might be due to invalid IL or missing references)
		//IL_045a: Unknown result type (might be due to invalid IL or missing references)
		//IL_045f: Unknown result type (might be due to invalid IL or missing references)
		//IL_046b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0470: Unknown result type (might be due to invalid IL or missing references)
		//IL_047a: Unknown result type (might be due to invalid IL or missing references)
		//IL_047f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0481: Unknown result type (might be due to invalid IL or missing references)
		//IL_0483: Unknown result type (might be due to invalid IL or missing references)
		//IL_0485: Unknown result type (might be due to invalid IL or missing references)
		//IL_048a: Unknown result type (might be due to invalid IL or missing references)
		//IL_04a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_04a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_04b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_04bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_04c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_04c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_04c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_04c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_04cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_04e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_04e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_04f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_04f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0500: Unknown result type (might be due to invalid IL or missing references)
		//IL_0505: Unknown result type (might be due to invalid IL or missing references)
		//IL_0507: Unknown result type (might be due to invalid IL or missing references)
		//IL_0509: Unknown result type (might be due to invalid IL or missing references)
		//IL_050b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0510: Unknown result type (might be due to invalid IL or missing references)
		//IL_0527: Unknown result type (might be due to invalid IL or missing references)
		//IL_052c: Unknown result type (might be due to invalid IL or missing references)
		int num = 0;
		int num2 = 0;
		int num3 = 0;
		int num4 = width;
		Vector2 val = new Vector2((float)num2, (float)num3) * 16f + new Vector2((float)(-num4 / 2 + 8), (float)(-height));
		while (!canSpawn && num < settings.attemptsBeforeGivingUp)
		{
			num++;
			num2 = teleportStartX + Main.rand.Next(teleportRangeX);
			num3 = teleportStartY + Main.rand.Next(teleportRangeY);
			int num5 = 5;
			num2 = (int)MathHelper.Clamp((float)num2, (float)num5, (float)(Main.maxTilesX - num5));
			num3 = (int)MathHelper.Clamp((float)num3, (float)num5, (float)(Main.maxTilesY - num5));
			val = new Vector2((float)num2, (float)num3) * 16f + new Vector2((float)(-num4 / 2 + 8), (float)(-height));
			if (Collision.SolidCollision(val, num4, height))
			{
				continue;
			}
			if (Main.tile[num2, num3] == null)
			{
				Main.tile[num2, num3] = default(Tile);
			}
			if ((settings.avoidWalls && Main.tile[num2, num3].wall > 0) || (Main.tile[num2, num3].wall == 87 && (double)num3 > Main.worldSurface && !NPC.downedPlantBoss) || (Main.wallDungeon[Main.tile[num2, num3].wall] && (double)num3 > Main.worldSurface && !NPC.downedBoss3))
			{
				continue;
			}
			int num6 = 0;
			while (num6 < settings.maximumFallDistanceFromOrignalPoint)
			{
				if (Main.tile[num2, num3 + num6] == null)
				{
					Main.tile[num2, num3 + num6] = default(Tile);
				}
				Tile tile = Main.tile[num2, num3 + num6];
				val = new Vector2((float)num2, (float)(num3 + num6)) * 16f + new Vector2((float)(-num4 / 2 + 8), (float)(-height));
				Collision.SlopeCollision(val, velocity, num4, height, gravDir);
				if (!Collision.SolidCollision(val, num4, height))
				{
					num6++;
					continue;
				}
				if (tile.active() && !tile.inActive() && Main.tileSolid[tile.type])
				{
					break;
				}
				num6++;
			}
			val.Y -= 16f;
			int i = (int)val.X / 16;
			int j = (int)val.Y / 16;
			int num7 = (int)(val.X + (float)num4 * 0.5f) / 16;
			int j2 = (int)(val.Y + (float)height) / 16;
			Tile tileSafely = Framing.GetTileSafely(i, j);
			Tile tileSafely2 = Framing.GetTileSafely(num7, j2);
			if (settings.avoidAnyLiquid && tileSafely2.liquid > 0)
			{
				continue;
			}
			if (settings.mostlySolidFloor)
			{
				Tile tileSafely3 = Framing.GetTileSafely(num7 - 1, j2);
				Tile tileSafely4 = Framing.GetTileSafely(num7 + 1, j2);
				if (!tileSafely3.active() || tileSafely3.inActive() || !Main.tileSolid[tileSafely3.type] || Main.tileSolidTop[tileSafely3.type] || !tileSafely4.active() || tileSafely4.inActive() || !Main.tileSolid[tileSafely4.type] || Main.tileSolidTop[tileSafely4.type])
				{
					continue;
				}
			}
			if ((settings.avoidWalls && tileSafely.wall > 0) || (settings.avoidAnyLiquid && Collision.WetCollision(val, num4, height)) || (settings.avoidLava && Collision.LavaCollision(val, num4, height)) || (settings.avoidHurtTiles && Collision.AnyHurtingTiles(val, num4, height)) || Collision.SolidCollision(val, num4, height) || num6 >= settings.maximumFallDistanceFromOrignalPoint - 1 || !CombinedHooks.CanBeTeleportedTo(this, val, i, j, "CheckForGoodTeleportationSpot"))
			{
				continue;
			}
			Vector2 val2 = Vector2.UnitX * 16f;
			if (Collision.TileCollision(val - val2, val2, width, height, fallThrough: false, fall2: false, (int)gravDir) != val2)
			{
				continue;
			}
			val2 = -Vector2.UnitX * 16f;
			if (Collision.TileCollision(val - val2, val2, width, height, fallThrough: false, fall2: false, (int)gravDir) != val2)
			{
				continue;
			}
			val2 = Vector2.UnitY * 16f;
			if (!(Collision.TileCollision(val - val2, val2, width, height, fallThrough: false, fall2: false, (int)gravDir) != val2))
			{
				val2 = -Vector2.UnitY * 16f;
				if (!(Collision.TileCollision(val - val2, val2, width, height, fallThrough: false, fall2: false, (int)gravDir) != val2))
				{
					canSpawn = true;
					num3 += num6;
					break;
				}
			}
		}
		return val;
	}

	public void GetAnglerReward(NPC angler, int questItemType)
	{
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		EntitySource_Gift source = new EntitySource_Gift(angler);
		int questsDone = anglerQuestsFinished;
		float anglerRewardRarityMultiplier = GetAnglerRewardRarityMultiplier(questsDone);
		anglerRewardRarityMultiplier *= (float)(currentShoppingSettings.PriceAdjustment + 1.0) / 2f;
		List<Item> list = new List<Item>();
		GetItemSettings anglerRewardSettings = GetItemSettings.NPCEntityToPlayerInventorySettings;
		GetAnglerReward_MainReward(list, source, questsDone, anglerRewardRarityMultiplier, questItemType, ref anglerRewardSettings);
		GetAnglerReward_Decoration(list, source, questsDone, anglerRewardRarityMultiplier, ref anglerRewardSettings);
		GetAnglerReward_Money(list, source, questsDone, anglerRewardRarityMultiplier, ref anglerRewardSettings);
		GetAnglerReward_Bait(list, source, questsDone, anglerRewardRarityMultiplier, ref anglerRewardSettings);
		PlayerLoader.AnglerQuestReward(this, anglerRewardRarityMultiplier, list);
		foreach (Item item2 in list)
		{
			item2.position = base.Center;
			Item item = GetItem(whoAmI, item2, GetItemSettings.NPCEntityToPlayerInventorySettings);
			if (item.stack > 0)
			{
				int number = Item.NewItem(source, (int)position.X, (int)position.Y, width, height, item.type, item.stack, noBroadcast: false, 0, noGrabDelay: true);
				if (Main.netMode == 1)
				{
					NetMessage.SendData(21, -1, -1, null, number, 1f);
				}
			}
		}
	}

	public static float GetAnglerRewardRarityMultiplier(int questsDone)
	{
		float num = 1f;
		num = ((questsDone <= 50) ? (num - (float)questsDone * 0.01f) : ((questsDone <= 100) ? (0.5f - (float)(questsDone - 50) * 0.005f) : ((questsDone > 150) ? 0.15f : (0.25f - (float)(questsDone - 100) * 0.002f))));
		return num * 0.9f;
	}

	private void GetAnglerReward_MainReward(List<Item> rewardItems, IEntitySource source, int questsDone, float rarityReduction, int questItemType, ref GetItemSettings anglerRewardSettings)
	{
		Item item = new Item();
		item.type = 0;
		switch (questsDone)
		{
		case 5:
			item.SetDefaults(2428);
			break;
		case 10:
			item.SetDefaults(2367);
			break;
		case 15:
			item.SetDefaults(2368);
			break;
		case 20:
			item.SetDefaults(2369);
			break;
		case 25:
			item.SetDefaults(3031);
			break;
		case 30:
			item.SetDefaults(2294);
			break;
		default:
		{
			if (questItemType == 2451 && Main.hardMode)
			{
				item.SetDefaults((Main.rand.Next(2) == 0) ? 5303 : 5302);
				break;
			}
			if (questItemType == 2451 && !Main.hardMode && Main.rand.Next(2) == 0)
			{
				item.SetDefaults((Main.rand.Next(2) == 0) ? 5303 : 5302);
				break;
			}
			List<int> list = new List<int> { 2373, 2374, 2375, 3120, 3037, 3096, 5139 };
			float num = 1f;
			for (int i = 0; i < 3; i++)
			{
				num *= 1f - 1f / (float)(int)(40f * rarityReduction);
			}
			for (int j = 0; j < 3; j++)
			{
				num *= 1f - 1f / (float)(int)(30f * rarityReduction);
			}
			num *= 1f - 1f / (float)(int)(25f * rarityReduction);
			float num2 = 1f - num;
			num2 *= 0.8f;
			if (questsDone > 75 && Main.rand.Next((int)(250f * rarityReduction)) == 0)
			{
				item.SetDefaults(2294);
				break;
			}
			if (Main.hardMode && questsDone > 25 && Main.rand.Next((int)(100f * rarityReduction)) == 0)
			{
				item.SetDefaults(2422);
				break;
			}
			if (Main.hardMode && questsDone > 10 && Main.rand.Next((int)(70f * rarityReduction)) == 0)
			{
				item.SetDefaults(2494);
				break;
			}
			if (questsDone > 10 && Main.rand.Next((int)(70f * rarityReduction)) == 0)
			{
				item.SetDefaults(3031);
				break;
			}
			if (questsDone > 10 && Main.rand.Next((int)(70f * rarityReduction)) == 0)
			{
				item.SetDefaults(3032);
				break;
			}
			if (Main.rand.Next((int)(80f * rarityReduction)) == 0)
			{
				item.SetDefaults(3183);
				break;
			}
			if (Main.rand.Next((int)(60f * rarityReduction)) == 0)
			{
				item.SetDefaults(2360);
				break;
			}
			if (Main.rand.Next((int)(60f * rarityReduction)) == 0)
			{
				item.SetDefaults(4067);
				break;
			}
			if (Main.rand.Next((int)(80f * rarityReduction)) == 0)
			{
				item.SetDefaults(2417);
				break;
			}
			if (Main.rand.Next((int)(80f * rarityReduction)) == 0)
			{
				item.SetDefaults(2498);
				break;
			}
			if (DropAnglerAccByMissing(list, num2, out var botheredRollingForADrop, out var itemIdToDrop))
			{
				item.SetDefaults(itemIdToDrop);
				break;
			}
			if (!botheredRollingForADrop && Main.rand.NextDouble() < (double)num2)
			{
				int defaults = Utils.SelectRandom(Main.rand, list.ToArray());
				item.SetDefaults(defaults);
				break;
			}
			switch (Main.rand.Next(3))
			{
			case 0:
				item.SetDefaults(2354);
				item.stack = Main.rand.Next(2, 6);
				break;
			case 1:
				item.SetDefaults(2355);
				item.stack = Main.rand.Next(2, 6);
				break;
			default:
				item.SetDefaults(2356);
				item.stack = Main.rand.Next(2, 6);
				break;
			}
			break;
		}
		}
		rewardItems.Add(item);
		if (item.type == 2417)
		{
			Item item2 = new Item();
			Item item3 = new Item();
			item2.SetDefaults(2418);
			rewardItems.Add(item2);
			item3.SetDefaults(2419);
			rewardItems.Add(item3);
		}
		else if (item.type == 2498)
		{
			Item item4 = new Item();
			Item item5 = new Item();
			item4.SetDefaults(2499);
			rewardItems.Add(item4);
			item5.SetDefaults(2500);
			rewardItems.Add(item5);
		}
	}

	private void GetAnglerReward_Decoration(List<Item> rewardItems, IEntitySource source, int questsDone, float rarityReduction, ref GetItemSettings anglerRewardSettings)
	{
		float num = 1f - rarityReduction;
		int num2 = 100;
		float num3 = MathHelper.Lerp(num, 1f, Math.Min(1f, (float)questsDone / (float)num2));
		if (num3 >= 1f || Main.rand.NextFloat() <= num3)
		{
			Item item = new Item();
			item.type = 0;
			item.SetDefaults(Main.rand.Next(19) switch
			{
				1 => 2443, 
				2 => 2444, 
				3 => 2445, 
				4 => 2497, 
				5 => 2495, 
				6 => 2446, 
				7 => 2447, 
				8 => 2448, 
				9 => 2449, 
				10 => 2490, 
				11 => 2496, 
				12 => 5235, 
				13 => 5252, 
				14 => 5256, 
				15 => 5259, 
				16 => 5263, 
				17 => 5264, 
				18 => 5265, 
				_ => 2442, 
			});
			rewardItems.Add(item);
		}
	}

	private void GetAnglerReward_Bait(List<Item> rewardItems, IEntitySource source, int questsDone, float rarityReduction, ref GetItemSettings anglerRewardSettings)
	{
		if (Main.rand.Next((int)(100f * rarityReduction)) <= 50)
		{
			Item item = new Item();
			if (Main.rand.Next((int)(15f * rarityReduction)) == 0)
			{
				item.SetDefaults(2676);
			}
			else if (Main.rand.Next((int)(5f * rarityReduction)) == 0)
			{
				item.SetDefaults(2675);
			}
			else
			{
				item.SetDefaults(2674);
			}
			if (Main.rand.Next(25) <= questsDone)
			{
				item.stack++;
			}
			if (Main.rand.Next(50) <= questsDone)
			{
				item.stack++;
			}
			if (Main.rand.Next(100) <= questsDone)
			{
				item.stack++;
			}
			if (Main.rand.Next(150) <= questsDone)
			{
				item.stack++;
			}
			if (Main.rand.Next(200) <= questsDone)
			{
				item.stack++;
			}
			if (Main.rand.Next(250) <= questsDone)
			{
				item.stack++;
			}
			rewardItems.Add(item);
		}
	}

	private void GetAnglerReward_Money(List<Item> rewardItems, IEntitySource source, int questsDone, float rarityReduction, ref GetItemSettings anglerRewardSettings)
	{
		Item item = new Item();
		int num = (questsDone + 50) / 2;
		num = (int)((float)(num * Main.rand.Next(50, 201)) * 0.015f);
		num = (int)((double)num * 1.5);
		if (Main.hardMode)
		{
			num *= 2;
		}
		if (Main.expertMode)
		{
			num *= 2;
		}
		if (num > 100)
		{
			num /= 100;
			if (num > 10)
			{
				num = 10;
			}
			if (num < 1)
			{
				num = 1;
			}
			item.SetDefaults(73);
			item.stack = num;
		}
		else
		{
			if (num > 99)
			{
				num = 99;
			}
			if (num < 1)
			{
				num = 1;
			}
			item.SetDefaults(72);
			item.stack = num;
		}
		rewardItems.Add(item);
	}

	public bool DropAnglerAccByMissing(List<int> itemIdsOfAccsWeWant, float totalChance, out bool botheredRollingForADrop, out int itemIdToDrop)
	{
		botheredRollingForADrop = false;
		itemIdToDrop = 0;
		List<int> list = new List<int>(itemIdsOfAccsWeWant);
		Item[] array = inventory;
		for (int i = 0; i < array.Length; i++)
		{
			RemoveAnglerAccOptionsFromRewardPool(list, array[i]);
		}
		array = armor;
		for (int j = 0; j < array.Length; j++)
		{
			RemoveAnglerAccOptionsFromRewardPool(list, array[j]);
		}
		array = bank.item;
		for (int k = 0; k < array.Length; k++)
		{
			RemoveAnglerAccOptionsFromRewardPool(list, array[k]);
		}
		array = bank2.item;
		for (int l = 0; l < array.Length; l++)
		{
			RemoveAnglerAccOptionsFromRewardPool(list, array[l]);
		}
		array = bank3.item;
		for (int m = 0; m < array.Length; m++)
		{
			RemoveAnglerAccOptionsFromRewardPool(list, array[m]);
		}
		array = bank4.item;
		for (int n = 0; n < array.Length; n++)
		{
			RemoveAnglerAccOptionsFromRewardPool(list, array[n]);
		}
		for (int num = 0; num < Loadouts.Length; num++)
		{
			array = Loadouts[num].Armor;
			for (int num2 = 0; num2 < array.Length; num2++)
			{
				RemoveAnglerAccOptionsFromRewardPool(list, array[num2]);
			}
		}
		if (list.Count == 0)
		{
			return false;
		}
		bool flag = false;
		if (Main.rand.NextDouble() < (double)totalChance)
		{
			flag = true;
		}
		botheredRollingForADrop = true;
		if (flag)
		{
			itemIdToDrop = Main.rand.NextFromList(list.ToArray());
			return true;
		}
		return false;
	}

	private void RemoveAnglerAccOptionsFromRewardPool(List<int> itemIdsOfAccsWeWant, Item itemToTestAgainst)
	{
		if (!itemToTestAgainst.IsAir)
		{
			switch (itemToTestAgainst.type)
			{
			default:
				itemIdsOfAccsWeWant.Remove(itemToTestAgainst.type);
				break;
			case 3721:
			case 5064:
				itemIdsOfAccsWeWant.Remove(2373);
				itemIdsOfAccsWeWant.Remove(2375);
				itemIdsOfAccsWeWant.Remove(2374);
				break;
			case 3036:
			case 3123:
			case 3124:
			case 5358:
			case 5359:
			case 5360:
			case 5361:
				itemIdsOfAccsWeWant.Remove(3120);
				itemIdsOfAccsWeWant.Remove(3037);
				itemIdsOfAccsWeWant.Remove(3096);
				break;
			case 5140:
			case 5141:
			case 5142:
			case 5143:
			case 5144:
			case 5145:
			case 5146:
				itemIdsOfAccsWeWant.Remove(5139);
				break;
			}
		}
	}

	public void GetDyeTraderReward(NPC dyeTrader)
	{
		//IL_01d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01da: Unknown result type (might be due to invalid IL or missing references)
		int num = -1;
		EntitySource_Gift source = new EntitySource_Gift(dyeTrader);
		List<int> list = new List<int>
		{
			3560, 3028, 3041, 3040, 3025, 3190, 3027, 3026, 3554, 3553,
			3555, 2872, 3534, 2871
		};
		if (Main.hardMode)
		{
			list.Add(3039);
			list.Add(3038);
			list.Add(3598);
			list.Add(3597);
			list.Add(3600);
			list.Add(3042);
			list.Add(3533);
			list.Add(3561);
			if (NPC.downedMechBossAny)
			{
				list.Add(2883);
				list.Add(2869);
				list.Add(2873);
				list.Add(2870);
			}
			if (NPC.downedPlantBoss)
			{
				list.Add(2878);
				list.Add(2879);
				list.Add(2884);
				list.Add(2885);
			}
			if (NPC.downedMartians)
			{
				list.Add(2864);
				list.Add(3556);
			}
			if (NPC.downedMoonlord)
			{
				list.Add(3024);
			}
		}
		PlayerLoader.GetDyeTraderReward(this, list);
		num = list[Main.rand.Next(list.Count)];
		Item item = new Item();
		item.SetDefaults(num);
		item.stack = 6;
		item.position = base.Center;
		Item item2 = GetItem(whoAmI, item, GetItemSettings.NPCEntityToPlayerInventorySettings);
		if (item2.stack > 0)
		{
			int number = Item.NewItem(source, (int)position.X, (int)position.Y, width, height, item2.type, item2.stack, noBroadcast: false, 0, noGrabDelay: true);
			if (Main.netMode == 1)
			{
				NetMessage.SendData(21, -1, -1, null, number, 1f);
			}
		}
	}

	public bool CheckMana(int amount, bool pay = false, bool blockQuickMana = false)
	{
		int num = (int)((float)amount * manaCost);
		if (statMana >= num)
		{
			if (pay)
			{
				statMana -= num;
			}
			return true;
		}
		if (manaFlower && !blockQuickMana)
		{
			QuickMana();
			if (statMana >= num)
			{
				if (pay)
				{
					statMana -= num;
				}
				return true;
			}
			return false;
		}
		return false;
	}

	public void TryPortalJumping()
	{
		if (!mount.Active && !dead && !isLockedToATile)
		{
			PortalHelper.TryGoingThroughPortals(this);
		}
	}

	public bool ConsumeSolarFlare()
	{
		if (setSolar && solarShields > 0)
		{
			solarShields--;
			for (int i = 0; i < maxBuffs; i++)
			{
				if (buffType[i] >= 170 && buffType[i] <= 172)
				{
					DelBuff(i);
				}
			}
			if (solarShields > 0 && whoAmI == Main.myPlayer)
			{
				AddBuff(170 + solarShields - 1, 5, quiet: false);
			}
			solarCounter = 0;
			return true;
		}
		return false;
	}

	public void KeyDoubleTap(int keyDir)
	{
		int num = 0;
		if (Main.ReversedUpDownArmorSetBonuses)
		{
			num = 1;
		}
		if (keyDir != num)
		{
			return;
		}
		PlayerLoader.ArmorSetBonusActivated(this);
		if (setVortex && !mount.Active)
		{
			vortexStealthActive = !vortexStealthActive;
		}
		if (setForbidden)
		{
			MinionRestTargetAim();
			if (!setForbiddenCooldownLocked)
			{
				CommandForbiddenStorm();
			}
		}
	}

	public void UpdateForbiddenSetLock()
	{
		List<int> list = new List<int>();
		for (int i = 0; i < 1000; i++)
		{
			Projectile projectile = Main.projectile[i];
			if (projectile.active && projectile.type == 656 && projectile.owner == whoAmI)
			{
				list.Add(i);
			}
		}
		setForbiddenCooldownLocked = list.Count > 1;
	}

	public void CommandForbiddenStorm()
	{
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_010f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_012a: Unknown result type (might be due to invalid IL or missing references)
		//IL_012f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_020b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0211: Unknown result type (might be due to invalid IL or missing references)
		//IL_021f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0221: Unknown result type (might be due to invalid IL or missing references)
		//IL_014e: Unknown result type (might be due to invalid IL or missing references)
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		//IL_015b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_0165: Unknown result type (might be due to invalid IL or missing references)
		//IL_016c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0182: Unknown result type (might be due to invalid IL or missing references)
		//IL_0188: Unknown result type (might be due to invalid IL or missing references)
		//IL_0196: Unknown result type (might be due to invalid IL or missing references)
		//IL_0198: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0325: Unknown result type (might be due to invalid IL or missing references)
		//IL_032a: Unknown result type (might be due to invalid IL or missing references)
		List<int> list = new List<int>();
		for (int i = 0; i < 1000; i++)
		{
			Projectile projectile = Main.projectile[i];
			if (projectile.active && projectile.type == 656 && projectile.owner == whoAmI)
			{
				list.Add(i);
			}
		}
		bool flag = StrayMethods.CanSpawnSandstormFriendly(MinionRestTargetPoint, 30, 30);
		bool num = MinionRestTargetPoint == Vector2.Zero;
		Vector2 center = base.Center;
		Vector2 endPoint = MinionRestTargetPoint;
		if (num)
		{
			endPoint = center;
		}
		int samplesToTake = 10;
		float samplingWidth = 60f;
		Collision.AimingLaserScan(center, endPoint, samplingWidth, samplesToTake, out var vectorTowardsTarget, out var samples);
		bool flag2 = false;
		float[] array = samples;
		for (int j = 0; j < array.Length; j++)
		{
			if (Math.Abs(array[j] - ((Vector2)(ref vectorTowardsTarget)).Length()) < 10f)
			{
				flag2 = true;
				break;
			}
		}
		float num2 = 0f;
		for (int k = 0; k < samples.Length; k++)
		{
			if (samples[k] > num2)
			{
				num2 = samples[k];
			}
		}
		if (list.Count <= 1)
		{
			Vector2 val = center + vectorTowardsTarget.SafeNormalize(Vector2.Zero) * num2;
			Vector2 val2 = val - center;
			if (((Vector2)(ref val2)).Length() > 0f)
			{
				for (float num3 = 0f; num3 < ((Vector2)(ref val2)).Length(); num3 += 15f)
				{
					Vector2 val3 = center + val2 * (num3 / ((Vector2)(ref val2)).Length());
					Dust obj = Main.dust[Dust.NewDust(val3, 0, 0, 269)];
					obj.position = val3;
					obj.fadeIn = 0.5f;
					obj.scale = 0.7f;
					obj.velocity *= 0.4f;
					obj.noLight = true;
				}
			}
			for (float num4 = 0f; num4 < (float)Math.PI * 2f; num4 += (float)Math.PI / 15f)
			{
				Dust obj2 = Main.dust[Dust.NewDust(val, 0, 0, 269)];
				obj2.position = val;
				obj2.fadeIn = 1f;
				obj2.scale = 0.3f;
				obj2.noLight = true;
			}
		}
		flag &= list.Count <= 1;
		flag = flag && flag2;
		if (flag)
		{
			flag = CheckMana(20, pay: true);
			if (flag)
			{
				manaRegenDelay = (int)maxRegenDelay;
			}
		}
		if (!flag)
		{
			return;
		}
		foreach (int item in list)
		{
			Projectile projectile2 = Main.projectile[item];
			if (!(projectile2.ai[0] >= 780f))
			{
				projectile2.ai[0] = 780f + projectile2.ai[0] % 60f;
				projectile2.netUpdate = true;
			}
		}
		int damage = (int)GetTotalDamage(DamageClass.MagicSummonHybrid).ApplyTo(20f);
		IEntitySource projectileSource_SetBonus = GetProjectileSource_SetBonus(3);
		_ = Main.projectile[Projectile.NewProjectile(projectileSource_SetBonus, MinionRestTargetPoint, Vector2.Zero, 656, damage, 0f, Main.myPlayer)];
	}

	public void KeyHoldDown(int keyDir, int holdTime)
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		int num = 0;
		if (Main.ReversedUpDownArmorSetBonuses)
		{
			num = 1;
		}
		if (keyDir == num)
		{
			PlayerLoader.ArmorSetBonusHeld(this, holdTime);
			if (setStardust && holdTime >= 60)
			{
				MinionRestTargetPoint = Vector2.Zero;
			}
			if (setForbidden && holdTime >= 60)
			{
				MinionRestTargetPoint = Vector2.Zero;
			}
		}
	}

	public void MinionNPCTargetAim(bool doNotDisableIfTheTargetIsTheSame)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		Vector2 mouseWorld = Main.MouseWorld;
		int num = -1;
		for (int i = 0; i < 200; i++)
		{
			if (Main.npc[i].CanBeChasedBy(this) && (num == -1 || Main.npc[i].Hitbox.Distance(mouseWorld) < Main.npc[num].Hitbox.Distance(mouseWorld)))
			{
				num = i;
			}
		}
		if (MinionAttackTargetNPC == num && !doNotDisableIfTheTargetIsTheSame)
		{
			MinionAttackTargetNPC = -1;
		}
		else
		{
			MinionAttackTargetNPC = num;
		}
	}

	public void MinionRestTargetAim()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0201: Unknown result type (might be due to invalid IL or missing references)
		//IL_0210: Unknown result type (might be due to invalid IL or missing references)
		//IL_0212: Unknown result type (might be due to invalid IL or missing references)
		Vector2 mouseWorld = Main.MouseWorld;
		float y = mouseWorld.Y;
		int num = (int)mouseWorld.X / 16;
		int num2 = (int)y / 16;
		int num3 = 0;
		if (Main.tile[num, num2].nactive() && Main.tileSolid[Main.tile[num, num2].type] && !Main.tileSolidTop[Main.tile[num, num2].type])
		{
			int num4 = 0;
			int num5 = 0;
			while (num5 > -20 && num2 + num5 > 1)
			{
				int y2 = num2 + num5;
				if (Main.tile[num, y2].nactive() && Main.tileSolid[Main.tile[num, y2].type] && !Main.tileSolidTop[Main.tile[num, y2].type])
				{
					num4 = num5;
					num5--;
					continue;
				}
				num4 = num5;
				break;
			}
			int num6 = 0;
			for (int i = 0; i < 20 && num2 + i < Main.maxTilesY; i++)
			{
				int y3 = num2 + i;
				if (Main.tile[num, y3].nactive() && Main.tileSolid[Main.tile[num, y3].type] && !Main.tileSolidTop[Main.tile[num, y3].type])
				{
					num6 = i;
					continue;
				}
				num6 = i;
				break;
			}
			num3 = ((num6 <= -num4) ? (num6 + 3) : (num4 - 2));
		}
		int num7 = num2 + num3;
		bool flag = false;
		for (int j = num7; j < num7 + 5; j++)
		{
			if (WorldGen.SolidTileAllowBottomSlope(num, j))
			{
				flag = true;
			}
		}
		while (!flag)
		{
			num7++;
			for (int k = num7; k < num7 + 5; k++)
			{
				if (WorldGen.SolidTileAllowBottomSlope(num, k))
				{
					flag = true;
				}
			}
		}
		Vector2 val = default(Vector2);
		((Vector2)(ref val))..ctor((float)(num * 16 + 8), (float)(num7 * 16));
		if (Distance(val) <= 1000f)
		{
			MinionRestTargetPoint = val;
		}
	}

	public void UpdateMinionTarget()
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		//IL_0128: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		if (whoAmI != Main.myPlayer)
		{
			return;
		}
		if (Distance(MinionRestTargetPoint) > 1000f)
		{
			MinionRestTargetPoint = Vector2.Zero;
		}
		if (MinionAttackTargetNPC != -1 && (!Main.npc[MinionAttackTargetNPC].CanBeChasedBy(this) || Main.npc[MinionAttackTargetNPC].Hitbox.Distance(base.Center) > 3000f))
		{
			MinionAttackTargetNPC = -1;
		}
		if (stardustGuardian && HasMinionRestTarget)
		{
			Vector2 minionRestTargetPoint = MinionRestTargetPoint;
			float num = (float)miscCounter / 150f;
			float num2 = (float)Math.PI * 2f / 3f;
			for (int i = 0; i < 3; i++)
			{
				int num3 = Dust.NewDust(minionRestTargetPoint, 0, 0, 135, 0f, 0f, 100, default(Color), 1.5f);
				Main.dust[num3].noGravity = true;
				Main.dust[num3].velocity = Vector2.Zero;
				Main.dust[num3].noLight = true;
				Main.dust[num3].position = minionRestTargetPoint + (num * ((float)Math.PI * 2f) + num2 * (float)i).ToRotationVector2() * 4f;
				Main.dust[num3].shader = GameShaders.Armor.GetSecondaryShader(cPet, this);
			}
		}
	}

	public void NebulaLevelup(int type)
	{
		if (whoAmI != Main.myPlayer)
		{
			return;
		}
		int timeToAdd = 480;
		for (int i = 0; i < maxBuffs; i++)
		{
			if (buffType[i] >= type && buffType[i] < type + 3)
			{
				DelBuff(i);
			}
		}
		switch (type)
		{
		case 173:
			nebulaLevelLife = (int)MathHelper.Clamp((float)(nebulaLevelLife + 1), 0f, 3f);
			AddBuff(type + nebulaLevelLife - 1, timeToAdd);
			break;
		case 176:
			nebulaLevelMana = (int)MathHelper.Clamp((float)(nebulaLevelMana + 1), 0f, 3f);
			AddBuff(type + nebulaLevelMana - 1, timeToAdd);
			break;
		case 179:
			nebulaLevelDamage = (int)MathHelper.Clamp((float)(nebulaLevelDamage + 1), 0f, 3f);
			AddBuff(type + nebulaLevelDamage - 1, timeToAdd);
			break;
		}
	}

	public void UpdateTouchingTiles()
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		TouchedTiles.Clear();
		List<Point> list = null;
		List<Point> list2 = null;
		if (!Collision.IsClearSpotTest(position + velocity, 16f, width, height, fallThrough: false, fall2: false, (int)gravDir, checkCardinals: true, checkSlopes: true))
		{
			list = Collision.FindCollisionTile((Math.Sign(velocity.Y) == 1) ? 2 : 3, position + velocity, 16f, width, height, fallThrough: false, fall2: false, (int)gravDir);
		}
		if (!Collision.IsClearSpotTest(position, Math.Abs(velocity.Y), width, height, fallThrough: false, fall2: false, (int)gravDir, checkCardinals: true, checkSlopes: true))
		{
			list2 = Collision.FindCollisionTile((Math.Sign(velocity.Y) == 1) ? 2 : 3, position, Math.Abs(velocity.Y), width, height, fallThrough: false, fall2: false, (int)gravDir, checkCardinals: true, checkSlopes: true);
		}
		if (list != null && list2 != null)
		{
			for (int i = 0; i < list2.Count; i++)
			{
				if (!list.Contains(list2[i]))
				{
					list.Add(list2[i]);
				}
			}
		}
		if (list == null && list2 != null)
		{
			list = list2;
		}
		if (list != null)
		{
			TouchedTiles = list;
		}
	}

	/// <summary> Gets the instance of the specified ModPlayer type. This will throw exceptions on failure. </summary>
	/// <exception cref="T:System.Collections.Generic.KeyNotFoundException" />
	/// <exception cref="T:System.IndexOutOfRangeException" />
	public T GetModPlayer<T>() where T : ModPlayer
	{
		return GetModPlayer(ModContent.GetInstance<T>());
	}

	/// <summary> Gets the local instance of the type of the specified ModPlayer instance. This will throw exceptions on failure. </summary>
	/// <exception cref="T:System.Collections.Generic.KeyNotFoundException" />
	/// <exception cref="T:System.IndexOutOfRangeException" />
	/// <exception cref="T:System.NullReferenceException" />
	public T GetModPlayer<T>(T baseInstance) where T : ModPlayer
	{
		return (modPlayers[baseInstance.Index] as T) ?? throw new KeyNotFoundException("Instance of '" + typeof(T).Name + "' does not exist on the current player.");
	}

	/// <summary> Gets the instance of the specified ModPlayer type. </summary>
	public bool TryGetModPlayer<T>(out T result) where T : ModPlayer
	{
		return TryGetModPlayer(ModContent.GetInstance<T>(), out result);
	}

	/// <summary> Safely attempts to get the local instance of the type of the specified ModPlayer instance. </summary>
	/// <returns> Whether or not the requested instance has been found. </returns>
	public bool TryGetModPlayer<T>(T baseInstance, out T result) where T : ModPlayer
	{
		if (baseInstance == null || baseInstance.Index < 0 || baseInstance.Index >= modPlayers.Length)
		{
			result = null;
			return false;
		}
		result = modPlayers[baseInstance.Index] as T;
		return result != null;
	}

	public void DropFromItem(int itemType)
	{
		DropAttemptInfo info = new DropAttemptInfo
		{
			player = this,
			item = itemType,
			IsExpertMode = Main.expertMode,
			IsMasterMode = Main.masterMode,
			IsInSimulation = false,
			rng = Main.rand
		};
		Main.ItemDropSolver.TryDropping(info);
	}

	/// <summary>
	/// Will spawn an item like <see cref="M:Terraria.Player.QuickSpawnItem(Terraria.DataStructures.IEntitySource,System.Int32,System.Int32)" />, but clones it (handy when you need to retain item infos)
	/// </summary>
	/// <param name="source">The spawn context</param>
	/// <param name="item">The item you want to be cloned</param>
	/// <param name="stack">The stack to give the item. Note that this will override maxStack if it's higher.</param>
	[Obsolete("Use Player.QuickSpawnItem(IEntitySource source, Item item, int stack) instead.")]
	public int QuickSpawnClonedItem(IEntitySource source, Item item, int stack = 1)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		int num = Item.NewItem(source, getRect(), item);
		Main.item[num].stack = stack;
		if (Main.netMode == 1)
		{
			NetMessage.SendData(21, -1, -1, null, num, 1f);
		}
		return num;
	}

	/// <inheritdoc cref="M:Terraria.Player.QuickSpawnClonedItem(Terraria.DataStructures.IEntitySource,Terraria.Item,System.Int32)" />
	public int QuickSpawnItem(IEntitySource source, Item item, int stack = 1)
	{
		return QuickSpawnClonedItem(source, item, stack);
	}

	/// <summary><inheritdoc cref="M:Terraria.Player.QuickSpawnClonedItem(Terraria.DataStructures.IEntitySource,Terraria.Item,System.Int32)" /></summary>
	/// <returns>Returns the Item instance</returns>
	public Item QuickSpawnClonedItemDirect(IEntitySource source, Item item, int stack = 1)
	{
		return Main.item[QuickSpawnClonedItem(source, item, stack)];
	}

	/// <summary><inheritdoc cref="M:Terraria.Player.QuickSpawnClonedItem(Terraria.DataStructures.IEntitySource,Terraria.Item,System.Int32)" /></summary>
	/// <returns>Returns the Item instance</returns>
	public Item QuickSpawnItemDirect(IEntitySource source, Item item, int stack = 1)
	{
		return Main.item[QuickSpawnClonedItem(source, item, stack)];
	}

	/// <summary><inheritdoc cref="M:Terraria.Player.QuickSpawnItem(Terraria.DataStructures.IEntitySource,System.Int32,System.Int32)" /></summary>
	/// <returns>Returns the Item instance</returns>
	public Item QuickSpawnItemDirect(IEntitySource source, int type, int stack = 1)
	{
		return Main.item[QuickSpawnItem(source, type, stack)];
	}

	/// <summary> Returns whether or not this Player currently has a (de)buff of the provided type. </summary>
	public bool HasBuff(int type)
	{
		return FindBuffIndex(type) != -1;
	}

	/// <inheritdoc cref="M:Terraria.Player.HasBuff(System.Int32)" />
	public bool HasBuff<T>() where T : ModBuff
	{
		return HasBuff(ModContent.BuffType<T>());
	}

	internal void ResetDamageClassData()
	{
		damageData = new DamageClassData[DamageClassLoader.DamageClassCount];
		for (int i = 0; i < damageData.Length; i++)
		{
			damageData[i] = new DamageClassData();
			DamageClassLoader.DamageClasses[i].SetDefaultStats(this);
		}
	}

	/// <summary>
	/// Gets the damage modifier for this damage type on this player.
	/// This returns a reference, and as such, you can freely modify this method's return value with operators.
	/// </summary>
	public ref StatModifier GetDamage<T>() where T : DamageClass
	{
		return ref GetDamage(ModContent.GetInstance<T>());
	}

	/// <summary>
	/// Gets the damage modifier for this damage type on this player.
	/// This returns a reference, and as such, you can freely modify this method's return value with operators.
	/// </summary>
	public ref StatModifier GetDamage(DamageClass damageClass)
	{
		return ref damageData[damageClass.Type].damage;
	}

	/// <summary>
	/// Gets the crit chance modifier for this damage type on this player.
	/// This returns a reference, and as such, you can freely modify this method's return value with operators.
	/// <para /> Note that crit values are percentage values ranging from 0 to 100, unlike damage multipliers. Adding 4, for example, would add 4% to the crit chance.
	/// </summary>
	public ref float GetCritChance<T>() where T : DamageClass
	{
		return ref GetCritChance(ModContent.GetInstance<T>());
	}

	/// <summary>
	/// Gets the crit chance modifier for this damage type on this player.
	/// This returns a reference, and as such, you can freely modify this method's return value with operators.
	/// <para /> Note that crit values are percentage values ranging from 0 to 100, unlike damage multipliers. Adding 4, for example, would add 4% to the crit chance.
	/// </summary>
	public ref float GetCritChance(DamageClass damageClass)
	{
		return ref damageData[damageClass.Type].critChance;
	}

	/// <summary>
	/// Gets the attack speed modifier for this damage type on this player.
	/// This returns a reference, and as such, you can freely modify this method's return values with operators.
	/// Setting this such that it results in zero or a negative value will throw an exception.
	/// NOTE: Due to the nature of attack speed modifiers, modifications to Flat will do nothing for this modifier.
	/// <para /> Note that attack speed is a multiplier. Adding 0.15f, for example, would add 15% to the attack speed stat.
	/// </summary>
	public ref float GetAttackSpeed<T>() where T : DamageClass
	{
		return ref GetAttackSpeed(ModContent.GetInstance<T>());
	}

	/// <summary>
	/// Gets the attack speed modifier for this damage type on this player.
	/// This returns a reference, and as such, you can freely modify this method's return values with operators.
	/// <para /> Note that attack speed is a multiplier. Adding 0.15f, for example, would add 15% to the attack speed stat.
	/// </summary>
	public ref float GetAttackSpeed(DamageClass damageClass)
	{
		return ref damageData[damageClass.Type].attackSpeed;
	}

	/// <summary>
	/// Gets the armor penetration modifier for this damage type on this player.
	/// This returns a reference, and as such, you can freely modify this method's return value with operators.
	/// <para /> Note that armor penetration value are typically whole numbers. Adding 5, for example, would add 5 to the armor penetration stat, similar to the Shark Tooth Necklace accessory.
	/// </summary>
	public ref float GetArmorPenetration<T>() where T : DamageClass
	{
		return ref GetArmorPenetration(ModContent.GetInstance<T>());
	}

	/// <summary>
	/// Gets the armor penetration modifier for this damage type on this player.
	/// This returns a reference, and as such, you can freely modify this method's return value with operators.
	/// <para /> Note that armor penetration value are typically whole numbers. Adding 5, for example, would add 5 to the armor penetration stat, similar to the Shark Tooth Necklace accessory.
	/// </summary>
	public ref float GetArmorPenetration(DamageClass damageClass)
	{
		return ref damageData[damageClass.Type].armorPen;
	}

	/// <summary>
	/// Gets the knockback modifier for this damage type on this player.
	/// This returns a reference, and as such, you can freely modify this method's return value with operators.
	/// <para /> Note that knockback values are multipliers. Adding 0.12f, for example, would add 12% to the knockback stat.
	/// </summary>
	public ref StatModifier GetKnockback<T>() where T : DamageClass
	{
		return ref GetKnockback(ModContent.GetInstance<T>());
	}

	/// <summary>
	/// Gets the knockback modifier for this damage type on this player.
	/// This returns a reference, and as such, you can freely modify this method's return value with operators.
	/// <para /> Note that knockback values are multipliers. Adding 0.12f, for example, would add 12% to the knockback stat.
	/// </summary>
	public ref StatModifier GetKnockback(DamageClass damageClass)
	{
		return ref damageData[damageClass.Type].knockback;
	}

	/// <inheritdoc cref="M:Terraria.Player.GetTotalDamage(Terraria.ModLoader.DamageClass)" />
	public StatModifier GetTotalDamage<T>() where T : DamageClass
	{
		return GetTotalDamage(ModContent.GetInstance<T>());
	}

	/// <summary>
	/// Calculates a total damage modifier for the player for the provided <see cref="T:Terraria.ModLoader.DamageClass" />.<br />
	/// Use in conjunction with <see cref="M:Terraria.ModLoader.StatModifier.ApplyTo(System.Single)" /> to calculate a final damage value for a given <see cref="T:Terraria.ModLoader.DamageClass" /> and base damage: <c>int finalDamage = (int)player.GetTotalDamage(item.DamageType).ApplyTo(30);</c>
	/// </summary>
	/// <remarks>The modifiers calculated here are important due to the possibility of
	/// damage classes inheriting modifiers from other damage classes. For instance, an attack
	/// can be classified as multiple damage types and each could have different modifiers to apply to the damage
	/// </remarks>
	/// <param name="damageClass">The <see cref="T:Terraria.ModLoader.DamageClass" /> to use for total damage calculation</param>
	/// <returns>All modifiers combined</returns>
	public StatModifier GetTotalDamage(DamageClass damageClass)
	{
		StatModifier result = damageData[damageClass.Type].damage;
		for (int i = 0; i < damageData.Length; i++)
		{
			if (i != damageClass.Type)
			{
				StatInheritanceData modifierInheritance = damageClass.GetModifierInheritance(DamageClassLoader.DamageClasses[i]);
				result = result.CombineWith(damageData[i].damage.Scale(modifierInheritance.damageInheritance));
			}
		}
		return result;
	}

	public float GetTotalCritChance<T>() where T : DamageClass
	{
		return GetTotalCritChance(ModContent.GetInstance<T>());
	}

	public float GetTotalCritChance(DamageClass damageClass)
	{
		float num = damageData[damageClass.Type].critChance;
		for (int i = 0; i < damageData.Length; i++)
		{
			if (i != damageClass.Type)
			{
				StatInheritanceData modifierInheritance = damageClass.GetModifierInheritance(DamageClassLoader.DamageClasses[i]);
				num += damageData[i].critChance * modifierInheritance.critChanceInheritance;
			}
		}
		return num;
	}

	public float GetTotalAttackSpeed<T>() where T : DamageClass
	{
		return GetTotalAttackSpeed(ModContent.GetInstance<T>());
	}

	public float GetTotalAttackSpeed(DamageClass damageClass)
	{
		float num = damageData[damageClass.Type].attackSpeed;
		for (int i = 0; i < damageData.Length; i++)
		{
			if (i != damageClass.Type)
			{
				StatInheritanceData modifierInheritance = damageClass.GetModifierInheritance(DamageClassLoader.DamageClasses[i]);
				num += (damageData[i].attackSpeed - 1f) * modifierInheritance.attackSpeedInheritance;
			}
		}
		return num;
	}

	public float GetTotalArmorPenetration<T>() where T : DamageClass
	{
		return GetTotalArmorPenetration(ModContent.GetInstance<T>());
	}

	public float GetTotalArmorPenetration(DamageClass damageClass)
	{
		float num = damageData[damageClass.Type].armorPen;
		for (int i = 0; i < damageData.Length; i++)
		{
			if (i != damageClass.Type)
			{
				StatInheritanceData modifierInheritance = damageClass.GetModifierInheritance(DamageClassLoader.DamageClasses[i]);
				num += damageData[i].armorPen * modifierInheritance.armorPenInheritance;
			}
		}
		return num;
	}

	public StatModifier GetTotalKnockback<T>() where T : DamageClass
	{
		return GetTotalKnockback(ModContent.GetInstance<T>());
	}

	public StatModifier GetTotalKnockback(DamageClass damageClass)
	{
		StatModifier result = damageData[damageClass.Type].knockback;
		for (int i = 0; i < damageData.Length; i++)
		{
			if (i != damageClass.Type)
			{
				StatInheritanceData modifierInheritance = damageClass.GetModifierInheritance(DamageClassLoader.DamageClasses[i]);
				result = result.CombineWith(damageData[i].knockback.Scale(modifierInheritance.knockbackInheritance));
			}
		}
		return result;
	}

	public int GetWeaponArmorPenetration(Item sItem)
	{
		return (int)((float)sItem.ArmorPenetration + GetTotalArmorPenetration(sItem.DamageType));
	}

	public float GetWeaponAttackSpeed(Item sItem)
	{
		float totalAttackSpeed = GetTotalAttackSpeed(sItem.DamageType);
		return 1f + (totalAttackSpeed - 1f) * ItemID.Sets.BonusAttackSpeedMultiplier[sItem.type];
	}

	/// <summary>
	/// Determines if the player is in specified ModBiome. This will throw exceptions on failure.
	/// </summary>
	/// <exception cref="T:System.IndexOutOfRangeException" />
	/// <exception cref="T:System.NullReferenceException" />
	public bool InModBiome(ModBiome baseInstance)
	{
		return modBiomeFlags[baseInstance.ZeroIndexType];
	}

	/// <inheritdoc cref="M:Terraria.Player.InModBiome(Terraria.ModLoader.ModBiome)" />
	public bool InModBiome<T>() where T : ModBiome
	{
		return InModBiome(ModContent.GetInstance<T>());
	}

	/// <summary>
	/// Calculates whether or not the player is in the purity/forest biome.
	/// </summary>
	public bool InZonePurity()
	{
		bool num = ZoneBeach || ZoneCorrupt || ZoneCrimson || ZoneDesert || ZoneDungeon || ZoneGemCave;
		bool flag = ZoneGlowshroom || ZoneGranite || ZoneGraveyard || ZoneHallow || ZoneHive || ZoneJungle;
		bool flag2 = ZoneLihzhardTemple || ZoneMarble || ZoneMeteor || ZoneSnow || ZoneUnderworldHeight;
		bool flag3 = modBiomeFlags.Cast<bool>().Contains(value: true);
		return !(num || flag || flag2 || flag3);
	}

	/// <summary>
	/// Invoked in UpdateVisibleAccessories. Runs common code for both modded slots and vanilla slots based on provided Items.
	/// </summary>
	public void UpdateVisibleAccessories(Item item, bool invisible, int slot = -1, bool modded = false)
	{
		if (eocDash > 0 && shield == -1 && item.shieldSlot != -1)
		{
			shield = item.shieldSlot;
			if (cShieldFallback != -1)
			{
				cShield = cShieldFallback;
			}
		}
		if (shieldRaised && shield == -1 && item.shieldSlot != -1)
		{
			shield = item.shieldSlot;
			if (cShieldFallback != -1)
			{
				cShield = cShieldFallback;
			}
		}
		if (ItemIsVisuallyIncompatible(item))
		{
			return;
		}
		if (item.wingSlot > 0)
		{
			if (invisible && (velocity.Y == 0f || mount.Active))
			{
				return;
			}
			wings = item.wingSlot;
		}
		if (!invisible)
		{
			UpdateVisibleAccessory(slot, item, modded);
		}
		else
		{
			ItemLoader.UpdateVisibleAccessory(item, this, hideVisual: true);
		}
	}

	[Obsolete("Removed in 1.4.5. Use Player.TryDroppingSingleItem instead.")]
	public void DropItem(IEntitySource source, Vector2 position, ref Item item)
	{
		TryDroppingSingleItem(source, item);
	}

	public int GetHealLife(Item item, bool quickHeal = false)
	{
		int healValue = item.healLife;
		ItemLoader.GetHealLife(item, this, quickHeal, ref healValue);
		PlayerLoader.GetHealLife(this, item, quickHeal, ref healValue);
		if (healValue <= 0)
		{
			return 0;
		}
		return healValue;
	}

	public int GetHealMana(Item item, bool quickHeal = false)
	{
		int healValue = item.healMana;
		ItemLoader.GetHealMana(item, this, quickHeal, ref healValue);
		PlayerLoader.GetHealMana(this, item, quickHeal, ref healValue);
		if (healValue <= 0)
		{
			return 0;
		}
		return healValue;
	}

	/// <summary>
	/// Calculates the mana needed to use the given item.
	/// </summary>
	/// <param name="item">The item to check.</param>
	/// <returns>The amount of mana needed to use <paramref name="item" />. Cannot be less than <c>0</c>.</returns>
	public int GetManaCost(Item item)
	{
		float reduce = manaCost;
		float mult = 1f;
		if (spaceGun && ItemID.Sets.IsSpaceGun[item.type])
		{
			mult = 0f;
		}
		if (item.type == 3852 && altFunctionUse == 2)
		{
			mult = 2f;
		}
		CombinedHooks.ModifyManaCost(this, item, ref reduce, ref mult);
		int num = (int)((float)item.mana * reduce * mult);
		if (num < 0)
		{
			return 0;
		}
		return num;
	}

	/// <summary>
	/// Determines if this player has enough mana to use an item.
	/// <br /> If the player doesn't have enough mana and <paramref name="blockQuickMana" /> is <see langword="false" />, the player will activate any missing mana effects they have and try again.
	/// <br /> The <paramref name="pay" /> parameter can be used to consume the mana amount.
	/// </summary>
	/// <param name="item">The item to use.</param>
	/// <param name="amount">The amount of mana needed. If <c>-1</c>, calculate using <see cref="M:Terraria.Player.GetManaCost(Terraria.Item)" />.</param>
	/// <param name="pay">If <see langword="true" />, actually use the mana requested.</param>
	/// <param name="blockQuickMana">If <see langword="true" />, prevent on missing mana effects like the Mana Flower from activating if the player doesn't have enough mana.</param>
	/// <returns><see langword="true" /> if the player has enough mana to use the item, <see langword="false" /> otherwise.</returns>
	public bool CheckMana(Item item, int amount = -1, bool pay = false, bool blockQuickMana = false)
	{
		if (amount <= -1)
		{
			amount = GetManaCost(item);
		}
		if (statMana >= amount)
		{
			if (pay)
			{
				CombinedHooks.OnConsumeMana(this, item, amount);
				statMana -= amount;
			}
			return true;
		}
		if (blockQuickMana)
		{
			return false;
		}
		CombinedHooks.OnMissingMana(this, item, amount);
		if (statMana < amount && manaFlower)
		{
			QuickMana();
		}
		if (statMana >= amount)
		{
			if (pay)
			{
				CombinedHooks.OnConsumeMana(this, item, amount);
				statMana -= amount;
			}
			return true;
		}
		return false;
	}

	/// <summary>
	/// Adds to either Player.immuneTime or Player.hurtCooldowns based on the cooldownCounterId
	/// </summary>
	/// <param name="cooldownCounterId">See <see cref="T:Terraria.ID.ImmunityCooldownID" /> for valid ids.</param>
	/// <param name="immuneTime">Extra immunity time to add</param>
	public void AddImmuneTime(int cooldownCounterId, int immuneTime)
	{
		if (cooldownCounterId < 0)
		{
			this.immuneTime += immuneTime;
		}
		else
		{
			hurtCooldowns[cooldownCounterId] += immuneTime;
		}
	}

	public ref ExtraJumpState GetJumpState<T>(T baseInstance) where T : ExtraJump
	{
		return ref extraJumps[baseInstance.Type];
	}

	public ref ExtraJumpState GetJumpState<T>() where T : ExtraJump
	{
		return ref GetJumpState(ModContent.GetInstance<T>());
	}

	/// <summary>
	/// Returns <see langword="true" /> if any extra jump is <see cref="P:Terraria.DataStructures.ExtraJumpState.Available" /> and <see cref="M:Terraria.ModLoader.ExtraJump.CanStart(Terraria.Player)" />.<br />
	/// Setting <see cref="F:Terraria.Player.blockExtraJumps" /> will cause this method to return <see langword="false" /> instead.
	/// </summary>
	public bool AnyExtraJumpUsable()
	{
		if (blockExtraJumps)
		{
			return false;
		}
		foreach (ExtraJump orderedJump in ExtraJumpLoader.OrderedJumps)
		{
			if (GetJumpState(orderedJump).Available && orderedJump.CanStart(this) && PlayerLoader.CanStartExtraJump(orderedJump, this))
			{
				return true;
			}
		}
		return false;
	}

	/// <summary>
	/// Cancels any extra jump in progress.<br />
	/// Sets all <see cref="P:Terraria.DataStructures.ExtraJumpState.Active" /> flags to <see langword="false" /> and calls OnExtraJumpEnded hooks.<br />
	/// Also sets <see cref="F:Terraria.Player.jump" /> to 0 if a an extra jump was active.<br /><br />
	///
	/// Used by vanilla when performing an action which would cancel jumping, such as grappling, grabbing a rope or getting frozen.<br /><br />
	///
	/// To prevent the use of remaining jumps, use <see cref="M:Terraria.Player.ConsumeAllExtraJumps" /> or <see cref="F:Terraria.Player.blockExtraJumps" />.<br />
	/// To cancel a regular jump as well, do <c>Player.jump = 0;</c>
	/// </summary>
	public void StopExtraJumpInProgress()
	{
		ExtraJumpLoader.StopActiveJump(this, out var anyJumpCancelled);
		if (anyJumpCancelled)
		{
			jump = 0;
		}
	}

	/// <summary>
	/// Checks if the player has any item in their <see cref="F:Terraria.Player.inventory" /> that appears in the provided Item ID set (<paramref name="itemSet" />).
	/// <br /><br /> For example <c>if (player.HasItem(ItemID.Sets.Glowsticks))</c> would return true if the player has any glowstick item.
	/// <br /><br /> Does not check Void Bag.
	/// </summary>
	/// <param name="itemSet">A set of length <see cref="P:Terraria.ModLoader.ItemLoader.ItemCount" /> to check against</param>
	/// <returns>True if the player has such an item</returns>
	public bool HasItem(bool[] itemSet)
	{
		for (int i = 0; i < 58; i++)
		{
			if (itemSet[inventory[i].type] && inventory[i].stack > 0)
			{
				return true;
			}
		}
		return false;
	}

	public IEntitySource GetSource_Accessory(Item item, string? context = null)
	{
		return new EntitySource_ItemUse(this, item, context);
	}

	public IEntitySource GetSource_Accessory_OnHurt(Item item, Entity? attacker, string? context = null)
	{
		return new EntitySource_ItemUse_OnHurt(this, item, attacker, context);
	}

	public IEntitySource GetSource_Accessory_OnHurt(Item item, PlayerDeathReason damageSource, string? context = null)
	{
		Entity entity;
		return GetSource_Accessory_OnHurt(item, (whoAmI == Main.myPlayer && damageSource.TryGetCausingEntity(out entity)) ? entity : null, context);
	}

	public IEntitySource GetSource_OnHurt(PlayerDeathReason damageSource, string? context = null)
	{
		Entity entity;
		return GetSource_OnHurt((whoAmI == Main.myPlayer && damageSource.TryGetCausingEntity(out entity)) ? entity : null, context);
	}

	public IEntitySource GetSource_OpenItem(int itemType, string? context = null)
	{
		return new EntitySource_ItemOpen(this, itemType, context);
	}

	public IEntitySource GetSource_ItemUse(Item item, string? context = null)
	{
		return new EntitySource_ItemUse(this, item, context);
	}

	public IEntitySource GetSource_ItemUse_WithPotentialAmmo(Item item, int ammoItemId, string? context = null)
	{
		return new EntitySource_ItemUse_WithAmmo(this, item, ammoItemId, context);
	}
}
